-- XPath constructor evaluation tests

   include 'xml'

-----------------------------------------------------------------------------------------------------------------------
-- Direct element constructors should evaluate expressions inside tags and attributes

function testDirectConstructorEvaluation()
   local xml = obj.new("xml", { statement = '<root price="10"><item>5</item></root>' })

   local err, attributeValue = xml.mtEvaluate('string((<result price="{/root/@price}">{/root/item/text()}</result>)/@price)')
   assert(attributeValue == '10', 'Attribute value template should resolve to 10, got ' .. nz(attributeValue, 'NIL'))

   local err, elementString = xml.mtEvaluate('string((<result>{/root/item/text()}</result>)[1])')
   assert(elementString == '5', 'Element content should expose inner text, got ' .. nz(elementString, 'NIL'))

   local err, doubled = xml.mtEvaluate('string((<result><double>{/root/@price * 2}</double></result>)/double)')
   assert(doubled == '20', 'Nested constructor should evaluate arithmetic content, got ' .. nz(doubled, 'NIL'))
end

-----------------------------------------------------------------------------------------------------------------------
-- Direct constructors should preserve literal whitespace inside element content

function testDirectConstructorWhitespace()
   local xml = obj.new("xml", { statement = '<root/>' })

   local err, singleSpace = xml.mtEvaluate('string(<a>hello world</a>)')
   assert(singleSpace == 'hello world', 'Direct constructor should preserve single spaces, got ' .. nz(singleSpace, 'NIL'))

   local err, leading = xml.mtEvaluate('string(<a>  padded  </a>)')
   assert(leading == '  padded  ', 'Direct constructor should retain leading and trailing spaces, got ' .. nz(leading, 'NIL'))

   local err, multiline = xml.mtEvaluate([[string(<a>line 1
   line 2</a>)]])
   assert(multiline == "line 1\n   line 2", 'Direct constructor should keep newline indentation, got ' .. nz(multiline, 'NIL'))
end

-----------------------------------------------------------------------------------------------------------------------
-- Computed constructors should honour dynamic names and content expressions

function testComputedConstructors()
   local xml = obj.new("xml", { statement = '<root price="10"/>' })

   local err, elementName = xml.mtEvaluate('local-name(element summary { /root/@price })')
   assert(elementName == 'summary', 'Computed element should adopt supplied lexical name, got ' .. nz(elementName, 'NIL'))

   local err, elementContent = xml.mtEvaluate('string(element summary { /root/@price * 3 })')
   assert(elementContent == '30', 'Computed element should evaluate numeric expressions, got ' .. nz(elementContent, 'NIL'))

   local err, attributeValue = xml.mtEvaluate('string(element wrapper { attribute cost { /root/@price } }/@cost)')
   assert(attributeValue == '10', 'Computed attribute should expose evaluated value, got ' .. nz(attributeValue, 'NIL'))
end

-----------------------------------------------------------------------------------------------------------------------
-- Text, comment, and processing-instruction constructors should produce textual nodes

function testNonElementConstructors()
   local xml = obj.new("xml", { statement = '<root price="10"/>' })

   local err, textValue = xml.mtEvaluate('string(text { /root/@price })')
   assert(textValue == '10', 'Text constructor should convert attribute content to text, got ' .. nz(textValue, 'NIL'))

   local err, commentValue = xml.mtEvaluate('string(comment { "note" })')
   assert(commentValue == 'note', 'Comment constructor should return its content, got ' .. nz(commentValue, 'NIL'))

   local err, piName = xml.mtEvaluate('name(processing-instruction target { "data" })')
   assert(piName == 'target', 'Processing-instruction should expose its target name, got ' .. nz(piName, 'NIL'))

   local err, piContent = xml.mtEvaluate('string(processing-instruction target { "data" })')
   assert(piContent == 'data', 'Processing-instruction should preserve its content, got ' .. nz(piContent, 'NIL'))

   local err = xml.mtFindTag('processing-instruction target { "bad?>data" }')
   assert(err != ERR_Okay, 'Processing-instruction content containing ?> should be rejected')
end

-----------------------------------------------------------------------------------------------------------------------
-- Document constructors should wrap sequences into a standalone document node

function testDocumentConstructor()
   local xml = obj.new("xml", { statement = '<root/>' })

   local err, temp_childCount = xml.mtEvaluate('count((document { <a/>, <b/> })/node())')
   local childCount = tonumber(temp_childCount)
   assert(childCount == 2, 'Document constructor should expose two child nodes, got ' .. tostring(childCount))

   local err, firstName = xml.mtEvaluate('name(((document { <root/> })/node())[1])')
   assert(firstName == 'root', 'Document constructor should retain child element names, got ' .. nz(firstName, 'NIL'))
end

-----------------------------------------------------------------------------------------------------------------------
-- Attribute and sequence content should merge correctly inside constructors

function testConstructorAttributeSequences()
   local xml = obj.new("xml", { statement = '<root/>' })

   local err, temp_mergedCount = xml.mtEvaluate('count(element wrapper { (attribute first { "1" }, attribute second { "2" }), element child { "value" } }/@*)')
   local mergedCount = tonumber(temp_mergedCount)
   assert(mergedCount == 2, 'Element constructor should merge attribute sequences into the result, got ' .. tostring(mergedCount))

   local err, mergedAttr = xml.mtEvaluate('string(element wrapper { (attribute first { "1" }, attribute second { "2" }), element child { "value" } }/@second)')
   assert(mergedAttr == '2', 'Element constructor should preserve attribute values from sequences, got ' .. nz(mergedAttr, 'NIL'))

   local err, firstChild = xml.mtEvaluate('name((element wrapper { (attribute first { "1" }, attribute second { "2" }), element child { "value" } }/node())[1])')
   assert(firstChild == 'child', 'Element constructor should retain subsequent child nodes after attributes, got ' .. nz(firstChild, 'NIL'))

   local err, dynamicAttr = xml.mtEvaluate('string((let $attrs := (attribute id { "main" }, attribute role { "admin" }) return element wrapper { $attrs, text { "ready" } })/@role)')
   assert(dynamicAttr == 'admin', 'Element constructor should append dynamic attribute sequences before content, got ' .. nz(dynamicAttr, 'NIL'))

   local err, firstText = xml.mtEvaluate('string((let $attrs := (attribute id { "main" }) return element wrapper { $attrs, text { "ready" }, "!" })/text()[1])')
   assert(firstText == 'ready', 'Element constructor should keep constructed text content before atomic values, got ' .. nz(firstText, 'NIL'))

   local err, secondText = xml.mtEvaluate('string((let $attrs := (attribute id { "main" }) return element wrapper { $attrs, text { "ready" }, "!" })/text()[2])')
   assert(secondText == '!', 'Element constructor should append atomic values as subsequent text nodes, got ' .. nz(secondText, 'NIL'))

   local err, combinedText = xml.mtEvaluate('concat((let $attrs := (attribute id { "main" }) return element wrapper { $attrs, text { "ready" }, "!" })/text()[1], (let $attrs := (attribute id { "main" }) return element wrapper { $attrs, text { "ready" }, "!" })/text()[2])')
   assert(combinedText == 'ready!', 'Element constructor should preserve text node ordering when combined explicitly, got ' .. nz(combinedText, 'NIL'))
end

-----------------------------------------------------------------------------------------------------------------------

return {
   tests = {
      'testDirectConstructorEvaluation', 'testDirectConstructorWhitespace', 'testComputedConstructors',
      'testNonElementConstructors', 'testDocumentConstructor',
      'testConstructorAttributeSequences'
   }
}
