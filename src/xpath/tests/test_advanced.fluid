-- Advanced XPath path lookup and edge case tests

   include 'xml'

-----------------------------------------------------------------------------------------------------------------------
-- Deeply nested path traversal combining multiple predicates and steps

function testDeeplyNestedPathTraversal()
   local xml = obj.new("xml", {
      statement = '<catalog><category name="fiction"><series name="modern"><book author="Smith"><chapter num="1"><section><paragraph>Intro</paragraph></section></chapter><chapter num="2"><section><paragraph>Body</paragraph><paragraph>Middle</paragraph></section></chapter><chapter num="3"><section><paragraph>Conclusion</paragraph></section></chapter></book></series></category></catalog>'
   })

   local err, tagId = xml.mtFindTag('/catalog/category[@name="fiction"]/series[@name="modern"]/book[@author="Smith"]/chapter[last()]/section/paragraph[position()=1]')
   assert(err == ERR_Okay, 'last() combined with position() should locate the first paragraph of the last chapter: ' .. mSys.GetErrorMsg(err))

   local err, content = xml.mtEvaluate('/catalog/category[@name="fiction"]/series[@name="modern"]/book[@author="Smith"]/chapter[last()]/section/paragraph[position()=1]')
   assert(content == 'Conclusion', 'Paragraph content should be "Conclusion", got ' .. nz(content, 'NIL'))
end

-----------------------------------------------------------------------------------------------------------------------
-- Edge case: sequential predicates mixing numeric and functional tests

function testSequentialPredicateEvaluation()
   local xml = obj.new("xml", {
      statement = '<data><entry type="record" priority="1"/><entry type="record" priority="2"/><entry type="log" priority="3"/><entry type="record" priority="4"/><entry type="record" priority="5"/></data>'
   })

   local err, tagId = xml.mtFindTag('/data/entry[@type="record"][position()=last()]')
   assert(err == ERR_Okay, 'Sequential predicates should allow position()=last() evaluation: ' .. mSys.GetErrorMsg(err))

   local errAttr, priority = xml.mtGetAttrib(tagId, 'priority')
   assert(errAttr == ERR_Okay and priority == '5', 'Expected the final record entry priority to be 5, got ' .. nz(priority, 'NIL'))
end

-----------------------------------------------------------------------------------------------------------------------
-- Edge case: navigating relative to the current node using .// patterns

function testRelativeCurrentNodeTraversal()
   local xml = obj.new("xml", {
      statement = '<root><section id="alpha"><item id="x"/><group><item id="y"/></group></section><section id="beta"><group><item id="z"/><item id="target"/></group></section></root>'
   })

   local err, sectionId = xml.mtFindTag('/root/section[./group/item[@id="target"]]')
   assert(err == ERR_Okay, 'Predicate using ./group should evaluate relative to the current node: ' .. mSys.GetErrorMsg(err))

   local errAttr, sectionName = xml.mtGetAttrib(sectionId, 'id')
   assert(errAttr == ERR_Okay and sectionName == 'beta', 'Expected the section containing the target item to be beta, got ' .. nz(sectionName, 'NIL'))

   local errItem, itemId = xml.mtFindTag('/root/section[@id="beta"]//item[@id="target"]')
   assert(errItem == ERR_Okay, '// should descend from the matched section to find the nested target item: ' .. mSys.GetErrorMsg(errItem))
end

-----------------------------------------------------------------------------------------------------------------------
-- Edge case: ensuring failed lookups return error codes cleanly

function testMissingPathError()
   local xml = obj.new("xml", {
      statement = '<root><item id="1"/><item id="2"/></root>'
   })

   local err, tagId = xml.mtFindTag('/root/item[@id="3"]')
   assert(err != ERR_Okay, 'Non-existent predicate matches should produce an error result, got ' .. mSys.GetErrorMsg(err))
   assert(tagId == nil or tagId == 0, 'No tag identifier should be returned when the lookup fails, got ' .. tagId)
end

-----------------------------------------------------------------------------------------------------------------------
-- Complex descendant traversal mixing attribute and element access

function testDescendantAxisAttributeAccess()
   local xml = obj.new("xml", {
      statement = '<root category="library"><branch name="east"><shelf code="A"><book id="1">Intro</book></shelf></branch><branch name="west"><shelf code="B"><book id="2">Advanced</book></shelf></branch></root>'
   })

   local err, category = xml.mtEvaluate('//branch[@name="west"]/../@category')
   assert(category == 'library', 'Using .. from a descendant selection should expose the ancestor attribute value, got ' .. nz(category, 'NIL'))

   local err, tagId = xml.mtFindTag('//branch[@name="west"]/shelf[@code="B"]/book[text()="Advanced"]')
   assert(err == ERR_Okay, 'Complex descendant traversal should locate the advanced book entry: ' .. mSys.GetErrorMsg(err))
end

-----------------------------------------------------------------------------------------------------------------------
-- Conditional expressions should select the correct branch

function testConditionalIfExpression()
   local xml = obj.new("xml", {
      statement = '<root><item id="a">Alpha</item><item id="b">Beta</item></root>'
   })

   local err, chosen = xml.mtEvaluate('if (/root/item[@id="a"]) then /root/item[@id="a"] else /root/item[@id="b"]')
   assert(chosen == 'Alpha', 'If expression should return Alpha branch when predicate succeeds, got ' .. nz(chosen, 'NIL'))

   local err, fallback = xml.mtEvaluate('if (/root/item[@id="missing"]) then /root/item[@id="a"] else /root/item[@id="b"]')
   assert(fallback == 'Beta', 'If expression should evaluate else branch when condition fails, got ' .. nz(fallback, 'NIL'))
end

-----------------------------------------------------------------------------------------------------------------------
-- For expressions should iterate sequences and aggregate node results

function testForExpressionNodeAggregation()
   local xml = obj.new("xml", {
      statement = '<root><group name="one"><item id="a">Alpha</item><item id="b">Beta</item></group><group name="two"><item id="c">Gamma</item></group></root>'
   })

   local collected = {}
   local err, index = xml.mtFindTag('for $g in /root/group return $g/item', function(XML, TagID, Attrib)
      local errAttr, idValue = xml.mtGetAttrib(TagID, 'id')
      assert(errAttr == ERR_Okay, 'For expression callback should resolve item id: ' .. mSys.GetErrorMsg(errAttr))
      table.insert(collected, idValue)
   end)

   assert(err == ERR_Okay, 'For expression evaluation should succeed: ' .. mSys.GetErrorMsg(err))
   assert(#collected == 3, 'For expression should yield three items, got ' .. #collected)

   table.sort(collected)
   assert(collected[1] == 'a' and collected[2] == 'b' and collected[3] == 'c', 'For expression should gather all item identifiers, got ' .. table.concat(collected, ','))
end

-----------------------------------------------------------------------------------------------------------------------
-- Quantified expressions should evaluate boolean logic correctly

function testQuantifiedExpressions()
   local xml = obj.new("xml", {
      statement = '<root><group name="alpha"><item id="a" class="one"/><item id="b" class="two"/></group><group name="beta"><item id="c" class="beta"/></group></root>'
   })

   local err, someResult = xml.mtEvaluate('if (some $g in /root/group satisfies $g/@name = "beta") then "yes" else "no"')
   assert(someResult == 'yes', 'Quantified some expression should detect the beta group, got ' .. nz(someResult, 'NIL'))

   local err, everyResult = xml.mtEvaluate('if (every $item in /root/group[@name="alpha"]/item satisfies @class = "one") then "all" else "mixed"')
   assert(everyResult == 'mixed', 'Quantified every expression should detect mixed class values, got ' .. nz(everyResult, 'NIL'))

   local err, nestedResult = xml.mtEvaluate('if (some $g in /root/group, $item in $g/item satisfies $item/@id = "c") then "found" else "missing"')
   assert(nestedResult == 'found', 'Nested quantified expression should locate item c, got ' .. nz(nestedResult, 'NIL'))
end

-----------------------------------------------------------------------------------------------------------------------
-- For expressions with multiple bindings should iterate nested sequences

function testForExpressionMultipleBindings()
   local xml = obj.new("xml", {
      statement = '<root><group name="one"><item id="a" class="one"/><item id="b" class="two"/></group><group name="two"><item id="c" class="two"/><item id="d" class="one"/></group></root>'
   })

   local matched = {}
   local err = xml.mtFindTag('for $group in /root/group, $item in $group/item[@class=$group/@name] return $item', function(XML, TagID)
      local errAttr, idValue = xml.mtGetAttrib(TagID, 'id')
      assert(errAttr == ERR_Okay, 'Multi-binding for expression callback should resolve item id: ' .. mSys.GetErrorMsg(errAttr))
      table.insert(matched, idValue)
   end)

   assert(err == ERR_Okay, 'Multi-binding for expression evaluation should succeed: ' .. mSys.GetErrorMsg(err))
   table.sort(matched)
   assert(#matched == 2 and matched[1] == 'a' and matched[2] == 'c', 'Multi-binding for expression should filter matching ids, got ' .. table.concat(matched, ','))
end

-----------------------------------------------------------------------------------------------------------------------
-- FLWOR expressions should allow mixing FOR and LET clauses with shared variables

function testFlworForLetCombination()
   local xml = obj.new("xml", {
      statement = '<library>' ..
                  '<book id="a" genre="fiction" price="39"/>' ..
                  '<book id="b" genre="reference" price="55"/>' ..
                  '<book id="c" genre="fiction" price="42"/>' ..
                  '</library>'
   })

   local collected = {}
   local err = xml.mtFindTag('for $book in /library/book let $genre := $book/@genre return $book[$genre = "fiction"]', function(XML, TagID)
      local errAttr, idValue = xml.mtGetAttrib(TagID, 'id')
      assert(errAttr == ERR_Okay, 'FLWOR for-let callback should resolve book id: ' .. mSys.GetErrorMsg(errAttr))
      table.insert(collected, idValue)
   end)

   assert(err == ERR_Okay, 'FLWOR for-let evaluation should succeed: ' .. mSys.GetErrorMsg(err))
   table.sort(collected)
   assert(#collected == 2 and collected[1] == 'a' and collected[2] == 'c', 'FLWOR for-let should filter fiction books, got ' .. table.concat(collected, ','))
end

-----------------------------------------------------------------------------------------------------------------------
-- LET clauses preceding FOR clauses should bind variables for subsequent iterations

function testFlworLetForCombination()
   local xml = obj.new("xml", {
      statement = '<library>' ..
                  '<book id="a" price="39"/>' ..
                  '<book id="b" price="55"/>' ..
                  '<book id="c" price="44"/>' ..
                  '</library>'
   })

   local expensive = {}
   local err = xml.mtFindTag('let $collection := /library/book for $book in $collection return $book[@price > 40]', function(XML, TagID)
      local errAttr, idValue = xml.mtGetAttrib(TagID, 'id')
      assert(errAttr == ERR_Okay, 'FLWOR let-for callback should resolve book id: ' .. mSys.GetErrorMsg(errAttr))
      table.insert(expensive, idValue)
   end)

   assert(err == ERR_Okay, 'FLWOR let-for evaluation should succeed: ' .. mSys.GetErrorMsg(err))
   table.sort(expensive)
   assert(#expensive == 2 and expensive[1] == 'b' and expensive[2] == 'c', 'FLWOR let-for should filter books above price 40, got ' .. table.concat(expensive, ','))
end

-----------------------------------------------------------------------------------------------------------------------
-- Sequence set operators should merge and filter node collections

function testSequenceSetOperators()
   local xml = obj.new("xml", {
      statement = '<root>' ..
                  '<item id="a" group="alpha"/>' ..
                  '<item id="b" group="beta"/>' ..
                  '<item id="c" group="gamma"/>' ..
                  '<item id="d" group="alpha"/>' ..
                  '</root>'
   })

   local unionOrder = {}
   local errUnion = xml.mtFindTag('(/root/item[@group="alpha"] union /root/item[@group="beta"])', function(XML, TagID)
      local errAttr, value = xml.mtGetAttrib(TagID, 'id')
      assert(errAttr == ERR_Okay, 'Union keyword should expose item identifiers: ' .. mSys.GetErrorMsg(errAttr))
      table.insert(unionOrder, value)
   end)

   assert(errUnion == ERR_Okay, 'Union keyword expression should evaluate successfully: ' .. mSys.GetErrorMsg(errUnion))
   assert(#unionOrder == 3, 'Union keyword should return three matching nodes, got ' .. #unionOrder)
   assert(unionOrder[1] == 'a' and unionOrder[2] == 'b' and unionOrder[3] == 'd',
      'Union keyword should preserve document order of a, b, d, got ' .. table.concat(unionOrder, ','))

   local xmlIntersect = obj.new("xml", {
      statement = '<root>' ..
                  '<item id="one" group="team" priority="high"/>' ..
                  '<item id="two" group="team" priority="low"/>' ..
                  '<item id="three" group="other" priority="high" exclude="yes"/>' ..
                  '<item id="four" group="team" priority="high" exclude="yes"/>' ..
                  '</root>'
   })

   local intersectIds = {}
   local errIntersect = xmlIntersect.mtFindTag('(/root/item[@group="team"] intersect /root/item[@priority="high"])', function(XML, TagID)
      local errAttr, value = xmlIntersect.mtGetAttrib(TagID, 'id')
      assert(errAttr == ERR_Okay, 'Intersect operator should expose item identifiers: ' .. mSys.GetErrorMsg(errAttr))
      table.insert(intersectIds, value)
   end)

   assert(errIntersect == ERR_Okay, 'Intersect operator should evaluate successfully: ' .. mSys.GetErrorMsg(errIntersect))
   assert(#intersectIds == 2 and intersectIds[1] == 'one' and intersectIds[2] == 'four',
      'Intersect operator should return ids one and four in document order, got ' .. table.concat(intersectIds, ','))

   local exceptIds = {}
   local errExcept = xmlIntersect.mtFindTag('(/root/item[@priority="high"]) except /root/item[@exclude="yes"]', function(XML, TagID)
      local errAttr, value = xmlIntersect.mtGetAttrib(TagID, 'id')
      assert(errAttr == ERR_Okay, 'Except operator should expose item identifiers: ' .. mSys.GetErrorMsg(errAttr))
      table.insert(exceptIds, value)
   end)

   assert(errExcept == ERR_Okay, 'Except operator should evaluate successfully: ' .. mSys.GetErrorMsg(errExcept))
   assert(#exceptIds == 1 and exceptIds[1] == 'one',
      'Except operator should filter excluded nodes leaving only id one, got ' .. table.concat(exceptIds, ','))
end

-----------------------------------------------------------------------------------------------------------------------
-- Node tests named after set operator keywords should continue to resolve

function testSetOperatorKeywordNameTests()
   local xml = obj.new("xml", {
      statement = '<root>' ..
                  '<union id="u"><leaf/></union>' ..
                  '<intersect id="i" value="keep"/>' ..
                  '<except id="e" flag="omit"/>' ..
                  '</root>'
   })

   local err, unionId = xml.mtEvaluate('/root/union/@id')
   assert(unionId == 'u', 'Selecting /root/union should expose id attribute, got ' .. nz(unionId, 'NIL'))

   local errUnionAxis, unionAxisTag = xml.mtFindTag('/root/child::union')
   assert(errUnionAxis == ERR_Okay, 'child::union axis form should resolve the union element: ' .. mSys.GetErrorMsg(errUnionAxis))
   assert(unionAxisTag != nil and unionAxisTag != 0, 'child::union should return a valid tag id, got ' .. nz(unionAxisTag, 'NIL'))

   local errIntersect, intersectTag = xml.mtFindTag('/root/intersect')
   assert(errIntersect == ERR_Okay, 'Path lookup should resolve intersect element: ' .. mSys.GetErrorMsg(errIntersect))
   local errIntersectAttrib, intersectValue = xml.mtGetAttrib(intersectTag, 'value')
   assert(errIntersectAttrib == ERR_Okay and intersectValue == 'keep',
       'Intersect element attribute should be retrievable, got ' .. nz(intersectValue, 'NIL'))

   local errExcept, exceptTag = xml.mtFindTag('/root/except')
   assert(errExcept == ERR_Okay, 'Path lookup should resolve except element: ' .. mSys.GetErrorMsg(errExcept))
   local errExceptAttrib, exceptFlag = xml.mtGetAttrib(exceptTag, 'flag')
   assert(errExceptAttrib == ERR_Okay and exceptFlag == 'omit',
      'Except element attribute should be retrievable, got ' .. nz(exceptFlag, 'NIL'))
end

-----------------------------------------------------------------------------------------------------------------------
return {
   tests = {
      'testDeeplyNestedPathTraversal', 'testSequentialPredicateEvaluation', 'testRelativeCurrentNodeTraversal',
      'testMissingPathError', 'testDescendantAxisAttributeAccess', 'testConditionalIfExpression', 'testForExpressionNodeAggregation',
      'testQuantifiedExpressions', 'testForExpressionMultipleBindings', 'testFlworForLetCombination', 'testFlworLetForCombination', 'testSequenceSetOperators',
      'testSetOperatorKeywordNameTests'
   }
}
