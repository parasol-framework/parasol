-- XQuery prolog integration tests

   include 'xml'

-----------------------------------------------------------------------------------------------------------------------
-- User-defined functions declared in the prolog should execute during evaluation

function testUserDefinedFunction()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err, result = xml.mtEvaluate('declare function local:square($x) { $x * $x }; local:square(5)')
   assert(tonumber(result) == 25, 'Prolog-defined function should return the squared result, got ' .. tostring(result))
   assert(xml.errorMsg == nil or xml.errorMsg == '', 'User-defined function should not record an error message, got ' .. tostring(xml.errorMsg))
end

-----------------------------------------------------------------------------------------------------------------------
-- Namespace declarations and prolog variables should participate in evaluation

function testNamespaceAndVariableDeclarations()
   local xml = obj.new('xml', {
      statement = '<root xmlns:ex="http://example.com/ns"><ex:item>Alpha</ex:item></root>'
   })

   local expr = 'declare namespace ex = "http://example.com/ns"; declare variable $ex:answer := 42; if ($ex:answer = 42 and string(/root/ex:item) = "Alpha") then "pass" else "fail"'
   local err, value = xml.mtEvaluate(expr)

   assert(value == 'pass', 'Prolog namespace and variable declarations should evaluate correctly, got ' .. tostring(value))
   assert(xml.errorMsg == nil or xml.errorMsg == '', 'Namespace and variable declarations should not record an error message, got ' .. tostring(xml.errorMsg))
end

-----------------------------------------------------------------------------------------------------------------------
-- Boundary-space preservation should retain lexical whitespace in direct element constructors

function testBoundarySpacePreservation()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err, value = xml.mtEvaluate('declare boundary-space preserve; string(<a>  padded  </a>)')
   assert(value == '  padded  ', 'Boundary-space preserve should retain surrounding whitespace, got ' .. tostring(value))
end

function testBoundarySpacePreserveComputedText()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local expr = table.concat({
      'declare boundary-space preserve;',
      'string(<a>{"  padded  "}</a>)'
   }, ' ')

   local err, value = xml.mtEvaluate(expr)
   assert(value == '  padded  ', 'Boundary-space preserve should retain whitespace from enclosed expressions, got ' .. tostring(value))
end

function testBoundarySpaceStripRemoval()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err, value = xml.mtEvaluate('string(<a>   </a>)')
   assert(value == '', 'Boundary-space strip should remove whitespace-only text, got ' .. tostring(value))
end

function testBoundarySpaceStripComputedText()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err, value = xml.mtEvaluate('string(<a>{"  padded  "}</a>)')
   assert(value == 'padded', 'Boundary-space strip should trim whitespace from enclosed expressions, got ' .. tostring(value))
end

function testConstructionStripComputedWhitespace()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local expr = table.concat({
      'declare construction strip;',
      'string(<a>{"   "}</a>)'
   }, ' ')

   local err, value = xml.mtEvaluate(expr)
   assert(value == '', 'Construction strip should remove whitespace-only computed text nodes, got ' .. tostring(value))
end

function testConstructionPreserveComputedWhitespace()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local expr = table.concat({
      'declare construction preserve;',
      'string(<a>{"   "}</a>)'
   }, ' ')

   local err, value = xml.mtEvaluate(expr)
   assert(value == '   ', 'Construction preserve should retain whitespace-only computed text nodes, got ' .. tostring(value))
end

function testConstructionStripTextConstructorWhitespace()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local expr = table.concat({
      'declare construction strip;',
      'string(element wrapper { text { "  padded  " } })'
   }, ' ')

   local err, value = xml.mtEvaluate(expr)
   assert(value == 'padded', 'Construction strip should trim text constructor content, got ' .. tostring(value))
end

function testConstructionPreserveTextConstructorWhitespace()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local expr = table.concat({
      'declare construction preserve;',
      'string(element wrapper { text { "  padded  " } })'
   }, ' ')

   local err, value = xml.mtEvaluate(expr)
   assert(value == '  padded  ', 'Construction preserve should retain text constructor whitespace, got ' .. tostring(value))
end

-----------------------------------------------------------------------------------------------------------------------
-- Recursive functions declared in the prolog should resolve correctly

function testRecursiveFunction()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err, temp_result = xml.mtEvaluate('declare function local:factorial($n) { if ($n le 1) then 1 else $n * local:factorial($n - 1) }; local:factorial(5)')
   local result = tonumber(temp_result)
   assert(result == 120, 'Recursive prolog function should compute factorial, got ' .. tostring(result))
   assert(xml.errorMsg == nil or xml.errorMsg == '', 'Recursive function evaluation should not record an error message, got ' .. tostring(xml.errorMsg))
end

-----------------------------------------------------------------------------------------------------------------------
-- Functions with the same QName but different arity should dispatch based on argument count

function testFunctionOverloadingByArity()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err, value = xml.mtEvaluate('declare function local:adder($a, $b) { $a + $b }; declare function local:adder($a, $b, $c) { $a + $b + $c }; concat(local:adder(2, 3), ":", local:adder(1, 2, 3))')
   assert(value == '5:6', 'Function overloading by arity should select the correct body, got ' .. tostring(value))
   assert(xml.errorMsg == nil or xml.errorMsg == '', 'Function overloading should not record an error message, got ' .. tostring(xml.errorMsg))
end

-----------------------------------------------------------------------------------------------------------------------
-- Namespace prefixes declared on the document should remain accessible when compiling queries

function testNamespaceFallbackFromDocument()
   local xml = obj.new('xml', {
      statement = '<root xmlns:ns="urn:fallback"><ns:item>Alpha</ns:item></root>'
   })

   local err, value = xml.mtEvaluate('/root/ns:item')
   assert(value == 'Alpha', 'Document namespace prefixes should be available during evaluation, got ' .. tostring(value))
   assert(xml.errorMsg == nil or xml.errorMsg == '', 'Namespace fallback should not record an error message, got ' .. tostring(xml.errorMsg))
end

-----------------------------------------------------------------------------------------------------------------------
-- Dynamic bindings should shadow prolog variables of the same QName

function testVariableShadowing()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err, value = xml.mtEvaluate('declare variable $local:value := "prolog"; let $local:value := "runtime" return $local:value')
   assert(value == 'runtime', 'Dynamic let binding should shadow prolog variable, got ' .. tostring(value))
   assert(xml.errorMsg == nil or xml.errorMsg == '', 'Variable shadowing should not record an error message, got ' .. tostring(xml.errorMsg))
end

-----------------------------------------------------------------------------------------------------------------------
-- External variable declarations should surface explicit diagnostics

function testExternalVariableErrorHandling()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err = xml.mtEvaluate('declare variable $local:missing external; $local:missing')
   local message = tostring(xml.errorMsg)
   assert(message == "External variable 'local:missing' is not supported.", 'External variable access should report a descriptive error, got ' .. message)
end

-----------------------------------------------------------------------------------------------------------------------
-- External function declarations should report missing implementation errors

function testExternalFunctionErrorHandling()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err = xml.mtEvaluate('declare function local:provided($x) external; local:provided(1)')
   local message = tostring(xml.errorMsg)
   assert(message == "External function 'local:provided' is not supported.", 'External function invocation should report a descriptive error, got ' .. message)
end

-----------------------------------------------------------------------------------------------------------------------
-- Module imports without loader support should emit a structural diagnostic
-- TODO: Module importing has been implemented, update test.

function testModuleImportDeclaration()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err = xml.mtEvaluate('import module namespace math = "urn:math"; math:square(2)')
   local message = tostring(xml.errorMsg)
   assert(message == "Module function resolution is not implemented for namespace 'urn:math'.", 'Module import should record structural diagnostic, got ' .. message)
end

-----------------------------------------------------------------------------------------------------------------------
-- Default function namespace should canonicalise prolog function names

function testDefaultFunctionNamespaceNormalisation()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local expr = table.concat({
      'declare namespace math = "urn:math";',
      'declare default function namespace "urn:math";',
      'declare function square($x) { $x * $x };',
      'concat(square(3), ":", math:square(4))'
   }, ' ')

   local err, value = xml.mtEvaluate(expr)
   assert(value == '9:16', 'Default function namespace should apply to prefixed and unprefixed calls, got ' .. tostring(value))
   assert(xml.errorMsg == nil or xml.errorMsg == '', 'Default function namespace should not record an error, got ' .. tostring(xml.errorMsg))
end

-----------------------------------------------------------------------------------------------------------------------
-- Module import namespaces should be normalised for cache lookups
-- TODO: Module importing has been implemented, update test.

function testModuleImportNamespaceNormalisation()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err = xml.mtEvaluate('import module namespace math = "urn:math\\library"; math:square(2)')
   local message = tostring(xml.errorMsg)
   assert(message == "Module function resolution is not implemented for namespace 'urn:math/library'.", 'Module import namespaces should be normalised, got ' .. message)
end

-----------------------------------------------------------------------------------------------------------------------
-- User-defined functions with type annotations should parse without errors

function testFunctionTypeAnnotations()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err, temp_result = xml.mtEvaluate('declare function local:add($a as xs:integer, $b as xs:integer) as xs:integer { $a + $b }; local:add(10, 20)')
   local result = tonumber(temp_result)
   assert(result == 30, 'Function with type annotations should execute correctly, got ' .. tostring(result))
   assert(xml.errorMsg == nil or xml.errorMsg == '', 'Function with type annotations should not record an error, got ' .. tostring(xml.errorMsg))
end

-----------------------------------------------------------------------------------------------------------------------
-- Multiple namespace declarations in prolog should be available during evaluation

function testMultipleNamespacesInProlog()
   local xml = obj.new('xml', {
      statement = '<root xmlns:a="urn:a" xmlns:b="urn:b"><a:item>A</a:item><b:item>B</b:item></root>'
   })

   local expr = 'declare namespace a = "urn:a"; declare namespace b = "urn:b"; concat(string(/root/a:item), ":", string(/root/b:item))'
   local err, value = xml.mtEvaluate(expr)
   assert(value == 'A:B', 'Multiple namespace declarations should work, got ' .. tostring(value))
   assert(xml.errorMsg == nil or xml.errorMsg == '', 'Multiple namespaces should not error, got ' .. tostring(xml.errorMsg))
end

-----------------------------------------------------------------------------------------------------------------------
-- Variable initialization expressions should evaluate correctly

function testVariableInitializerExpressions()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err, temp_value = xml.mtEvaluate('declare variable $x := 5; declare variable $y := $x * 2; $x + $y')
   local value = tonumber(temp_value)
   assert(value == 15, 'Variable initialiser expressions should evaluate, got ' .. tostring(value))
   assert(xml.errorMsg == nil or xml.errorMsg == '', 'Variable initialisers should not error, got ' .. tostring(xml.errorMsg))
end

-----------------------------------------------------------------------------------------------------------------------
-- Default collation declaration should parse without errors (stored for future use)

function testDefaultCollationDeclaration()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err, result = xml.mtEvaluate('declare default collation "http://www.w3.org/2005/xpath-functions/collation/codepoint"; "test"')
   assert(result == 'test', 'Default collation declaration should not affect evaluation, got ' .. tostring(result))
   assert(xml.errorMsg == nil or xml.errorMsg == '', 'Default collation should not error, got ' .. tostring(xml.errorMsg))
end

function testDefaultCollationFunctionUsesProlog()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err, result = xml.mtEvaluate('declare default collation "urn:custom"; default-collation()')
   assert(result == 'urn:custom', 'default-collation() should honour prolog declaration, got ' .. tostring(result))
end

function testDecimalFormatDeclaration()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err, result = xml.mtEvaluate('declare decimal-format local:df decimal-separator = "x"; "ok"')
   assert(result == 'ok', 'Decimal-format declaration should succeed, got ' .. tostring(result))
   assert(xml.errorMsg == nil or xml.errorMsg == '', 'Decimal-format declaration should not error, got ' .. tostring(xml.errorMsg))
end

-----------------------------------------------------------------------------------------------------------------------
-- Construction mode declaration should parse correctly

function testConstructionModeDeclaration()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err, value = xml.mtEvaluate('declare construction strip; string(<test>value</test>)')
   assert(value == 'value', 'Construction mode declaration should parse, got ' .. tostring(value))
   assert(xml.errorMsg == nil or xml.errorMsg == '', 'Construction mode should not error, got ' .. tostring(xml.errorMsg))
end

function testConstructionStripTrimsComputedContent()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err, value = xml.mtEvaluate('declare construction strip; string(<test>{ "  padded  " }</test>)')
   assert(value == 'padded', 'Construction strip should trim computed content, got ' .. tostring(value))
end

function testConstructionPreserveRetainsWhitespace()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err, value = xml.mtEvaluate('declare construction preserve; string(<test>{ "  padded  " }</test>)')
   assert(value == '  padded  ', 'Construction preserve should keep surrounding whitespace, got ' .. tostring(value))
end

-----------------------------------------------------------------------------------------------------------------------
-- Function with zero parameters should work

function testZeroParameterFunction()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err, result = xml.mtEvaluate('declare function local:getAnswer() { 42 }; local:getAnswer()')
   assert(tonumber(result) == 42, 'Zero-parameter function should work, got ' .. tostring(result))
   assert(xml.errorMsg == nil or xml.errorMsg == '', 'Zero-parameter function should not error, got ' .. tostring(xml.errorMsg))
end

-----------------------------------------------------------------------------------------------------------------------
-- Function with many parameters should work

function testMultiParameterFunction()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err, result = xml.mtEvaluate('declare function local:sum($a, $b, $c, $d, $e) { $a + $b + $c + $d + $e }; local:sum(1, 2, 3, 4, 5)')
   assert(tonumber(result) == 15, 'Multi-parameter function should work, got ' .. tostring(result))
   assert(xml.errorMsg == nil or xml.errorMsg == '', 'Multi-parameter function should not error, got ' .. tostring(xml.errorMsg))
end

-----------------------------------------------------------------------------------------------------------------------
-- Prolog variables should initialize before use in expression

function testPrologVariableAvailability()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err, temp_value = xml.mtEvaluate('declare variable $pi := 3.14159; $pi * 100')
   local value = tonumber(temp_value)
   assert(math.floor(value + 0.5) == 314, 'Prolog variable should be available, got ' .. tostring(value))
   assert(xml.errorMsg == nil or xml.errorMsg == '', 'Prolog variable should not error, got ' .. tostring(xml.errorMsg))
end

-----------------------------------------------------------------------------------------------------------------------
-- Function name collision with builtin should allow user-defined to be called with matching arity

function testFunctionNameCollisionResolution()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   -- Note: We cannot truly override built-in functions with single parameter since those exist
   -- So we test with a different arity where the user function should be selected
   local err, result = xml.mtEvaluate('declare function local:count($x, $y) { "custom" }; local:count(1, 2)')
   assert(result == 'custom', 'User-defined function with different arity should be called, got ' .. tostring(result))
   assert(xml.errorMsg == nil or xml.errorMsg == '', 'Function name resolution should work, got ' .. tostring(xml.errorMsg))
end

-----------------------------------------------------------------------------------------------------------------------
-- Prolog namespace should take precedence over document namespace with same prefix

function testNamespacePrecedence()
   local xml = obj.new('xml', {
      statement = '<root xmlns:ex="urn:document"><ex:item>doc-value</ex:item></root>'
   })

   -- Declare a prolog namespace that shadows the document namespace
   local expr = 'declare namespace ex = "urn:prolog"; string(/root/ex:item)'
   local err, value = xml.mtEvaluate(expr)
   -- This tests whether prolog namespace takes precedence
   assert(xml.errorMsg == nil or xml.errorMsg == '', 'Namespace precedence should be handled, got ' .. tostring(xml.errorMsg))
end

-----------------------------------------------------------------------------------------------------------------------
-- Multiple function declarations with same name but different arity should all be available

function testMultipleFunctionArities()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local expr = 'declare function local:f($a) { "one" }; declare function local:f($a, $b) { "two" }; declare function local:f($a, $b, $c) { "three" }; concat(local:f(1), ":", local:f(1, 2), ":", local:f(1, 2, 3))'
   local err, value = xml.mtEvaluate(expr)
   assert(value == 'one:two:three', 'Multiple function arities should be available, got ' .. tostring(value))
   assert(xml.errorMsg == nil or xml.errorMsg == '', 'Multiple function arities should not error, got ' .. tostring(xml.errorMsg))
end

-----------------------------------------------------------------------------------------------------------------------
-- Base URI declaration should parse (stored for future use)

function testBaseUriDeclaration()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err, result = xml.mtEvaluate('declare base-uri "http://example.com/"; "ok"')
   assert(result == 'ok', 'Base URI declaration should parse, got ' .. tostring(result))
   assert(xml.errorMsg == nil or xml.errorMsg == '', 'Base URI declaration should not error, got ' .. tostring(xml.errorMsg))
end

-----------------------------------------------------------------------------------------------------------------------
-- Ordering declaration should parse

function testOrderingDeclaration()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err, result = xml.mtEvaluate('declare ordering ordered; (3, 1, 2)')
   assert(result ~= nil, 'Ordering declaration should parse')
   assert(xml.errorMsg == nil or xml.errorMsg == '', 'Ordering declaration should not error, got ' .. tostring(xml.errorMsg))
end

function testOrderingModeUnorderedSequence()
   local xml = obj.new('xml', {
      statement = '<root><a>Alpha</a><b>Beta</b></root>'
   })

   local expr = table.concat({
      'declare ordering unordered;',
      'let $seq := (/root/b, /root/a)',
      'return concat(string($seq[1]), ":", string($seq[2]))'
   }, ' ')

   local err, value = xml.mtEvaluate(expr)
   assert(value == 'Beta:Alpha', 'Ordering unordered should preserve evaluation sequence, got ' .. tostring(value))
end

function testOrderingModeUnorderedUnion()
   local xml = obj.new('xml', {
      statement = '<root><a>Alpha</a><b>Beta</b></root>'
   })

   local expr = table.concat({
      'declare ordering unordered;',
      'let $u := ((/root/b) union (/root/a))',
      'return concat(string($u[1]), ":", string($u[2]))'
   }, ' ')

   local err, value = xml.mtEvaluate(expr)
   assert(value == 'Beta:Alpha', 'Ordering unordered should preserve union branch order, got ' .. tostring(value))
end

function testOrderingModeUnorderedIntersect()
   local xml = obj.new('xml', {
      statement = '<root><a>Alpha</a><b>Beta</b></root>'
   })

   local expr = table.concat({
      'declare ordering unordered;',
      'let $inter := ((/root/b, /root/a) intersect (/root/a | /root/b))',
      'return concat(string($inter[1]), ":", string($inter[2]))'
   }, ' ')

   local err, value = xml.mtEvaluate(expr)
   assert(value == 'Beta:Alpha', 'Ordering unordered should retain left operand order for intersect, got ' .. tostring(value))
end

function testOrderingModeUnorderedExcept()
   local xml = obj.new('xml', {
      statement = '<root><a>Alpha</a><b>Beta</b><c>Gamma</c></root>'
   })

   local expr = table.concat({
      'declare ordering unordered;',
      'let $exc := ((/root/c, /root/a, /root/b) except (/root/a))',
      'return concat(string($exc[1]), ":", string($exc[2]))'
   }, ' ')

   local err, value = xml.mtEvaluate(expr)
   assert(value == 'Gamma:Beta', 'Ordering unordered should respect operand order for except, got ' .. tostring(value))
end

function testDefaultEmptyOrderGreatest()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local expr = table.concat({
      'let $seq := (for $x in ("b", "", "a")',
      'order by if ($x = "") then () else $x',
      'return if ($x = "") then "empty" else $x)',
      'return concat($seq[1], ":", $seq[2], ":", $seq[3])'
   }, ' ')

   local err, value = xml.mtEvaluate(expr)
   assert(value == 'a:b:empty', 'Default empty order should treat empties as greatest, got ' .. tostring(value))
end

function testEmptyOrderLeastPlacement()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local expr = table.concat({
      'declare default order empty least;',
      'let $seq := (for $x in ("b", "", "a")',
      'order by if ($x = "") then () else $x',
      'return if ($x = "") then "empty" else $x)',
      'return concat($seq[1], ":", $seq[2], ":", $seq[3])'
   }, ' ')

   local err, value = xml.mtEvaluate(expr)
   assert(value == 'empty:a:b', 'Empty least should place empties first, got ' .. tostring(value))
end

-----------------------------------------------------------------------------------------------------------------------
-- Copy-namespaces declaration should parse

function testCopyNamespacesDeclaration()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err, result = xml.mtEvaluate('declare copy-namespaces preserve, inherit; "ok"')
   assert(result == 'ok', 'Copy-namespaces declaration should parse, got ' .. tostring(result))
   assert(xml.errorMsg == nil or xml.errorMsg == '', 'Copy-namespaces should not error, got ' .. tostring(xml.errorMsg))
end

-----------------------------------------------------------------------------------------------------------------------
-- Queries without prolog should still work

function testQueryWithoutProlog()
   local xml = obj.new('xml', {
      statement = '<root><item>test</item></root>'
   })

   local err, value = xml.mtEvaluate('string(/root/item)')
   assert(value == 'test', 'Query without prolog should work, got ' .. tostring(value))
   assert(xml.errorMsg == nil or xml.errorMsg == '', 'Query without prolog should not error, got ' .. tostring(xml.errorMsg))
end

-----------------------------------------------------------------------------------------------------------------------
-- ERROR HANDLING TESTS
-- These tests enforce W3C XQuery 3.0 specification rules for duplicate declarations
-----------------------------------------------------------------------------------------------------------------------

-- W3C XQuery 3.0 XQST0033: Duplicate namespace prefix declarations must raise static error

function testDuplicateNamespaceDeclaration()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err = xml.mtEvaluate('declare namespace ex = "urn:first"; declare namespace ex = "urn:second"; "test"')
   local message = tostring(xml.errorMsg)
   assert(xml.errorMsg and xml.errorMsg != '',
      'W3C XQuery 3.0 XQST0033: Duplicate namespace prefix declaration must raise static error, got ' .. message)
end

-----------------------------------------------------------------------------------------------------------------------
-- W3C XQuery 3.0 XQST0049: Duplicate variable declarations must raise static error

function testDuplicateVariableDeclaration()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err = xml.mtEvaluate('declare variable $x := 1; declare variable $x := 2; $x')
   local message = tostring(xml.errorMsg)
   assert(xml.errorMsg and xml.errorMsg != '',
      'W3C XQuery 3.0 XQST0049: Duplicate variable declaration must raise static error, got ' .. message)
end

-----------------------------------------------------------------------------------------------------------------------
-- W3C XQuery 3.0 XQST0034: Duplicate function declarations with same signature must raise static error

function testDuplicateFunctionDeclaration()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err = xml.mtEvaluate('declare function local:f($x) { $x }; declare function local:f($y) { $y * 2 }; local:f(5)')
   local message = tostring(xml.errorMsg)
   assert(xml.errorMsg and xml.errorMsg != '',
      'W3C XQuery 3.0 XQST0034: Duplicate function declaration must raise static error, got ' .. message)
end

-----------------------------------------------------------------------------------------------------------------------
-- W3C XQuery 3.0 XQST0032: Duplicate base-uri declarations must raise static error

function testDuplicateBaseUriDeclaration()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err = xml.mtEvaluate('declare base-uri "http://example.com/"; declare base-uri "http://other.com/"; "test"')
   local message = tostring(xml.errorMsg)
   assert(xml.errorMsg and xml.errorMsg != '',
      'W3C XQuery 3.0 XQST0032: Duplicate base-uri declaration must raise static error, got ' .. message)
end

-----------------------------------------------------------------------------------------------------------------------
-- W3C XQuery 3.0 XQST0038: Duplicate default collation declarations must raise static error

function testDuplicateDefaultCollationDeclaration()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err = xml.mtEvaluate('declare default collation "http://example.com/collation1"; declare default collation "http://example.com/collation2"; "test"')
   local message = tostring(xml.errorMsg)
   assert(xml.errorMsg and xml.errorMsg != '',
      'W3C XQuery 3.0 XQST0038: Duplicate default collation declaration must raise static error, got ' .. message)
end

-----------------------------------------------------------------------------------------------------------------------
-- W3C XQuery 3.0 XQST0068: Duplicate boundary-space declarations must raise static error

function testDuplicateBoundarySpaceDeclaration()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err = xml.mtEvaluate('declare boundary-space preserve; declare boundary-space strip; "test"')
   local message = tostring(xml.errorMsg)
   assert(xml.errorMsg and xml.errorMsg != '',
      'W3C XQuery 3.0 XQST0068: Duplicate boundary-space declaration must raise static error, got ' .. message)
end

-----------------------------------------------------------------------------------------------------------------------
-- W3C XQuery 3.0 XQST0067: Duplicate construction mode declarations must raise static error

function testDuplicateConstructionModeDeclaration()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err = xml.mtEvaluate('declare construction preserve; declare construction strip; "test"')
   local message = tostring(xml.errorMsg)
   assert(xml.errorMsg and xml.errorMsg != '',
      'W3C XQuery 3.0 XQST0067: Duplicate construction mode declaration must raise static error, got ' .. message)
end

-----------------------------------------------------------------------------------------------------------------------
-- W3C XQuery 3.0 XQST0065: Duplicate ordering mode declarations must raise static error

function testDuplicateOrderingModeDeclaration()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err = xml.mtEvaluate('declare ordering ordered; declare ordering unordered; "test"')
   local message = tostring(xml.errorMsg)
   assert(xml.errorMsg and xml.errorMsg != '',
      'W3C XQuery 3.0 XQST0065: Duplicate ordering mode declaration must raise static error, got ' .. message)
end

-----------------------------------------------------------------------------------------------------------------------
-- W3C XQuery 3.0 XQST0069: Duplicate default empty order declarations must raise static error

function testDuplicateEmptyOrderDeclaration()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err = xml.mtEvaluate('declare default order empty greatest; declare default order empty least; "test"')
   local message = tostring(xml.errorMsg)
   assert(xml.errorMsg and xml.errorMsg != '',
      'W3C XQuery 3.0 XQST0069: Duplicate default empty order declaration must raise static error, got ' .. message)
end

-----------------------------------------------------------------------------------------------------------------------
-- W3C XQuery 3.0 XQST0055: Duplicate copy-namespaces declarations must raise static error

function testDuplicateCopyNamespacesDeclaration()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err = xml.mtEvaluate('declare copy-namespaces preserve, inherit; declare copy-namespaces no-preserve, no-inherit; "test"')
   local message = tostring(xml.errorMsg)
   assert(xml.errorMsg and xml.errorMsg != '',
      'W3C XQuery 3.0 XQST0055: Duplicate copy-namespaces declaration must raise static error, got ' .. message)
end

-----------------------------------------------------------------------------------------------------------------------
-- W3C XQuery 3.0 XQST0111: Duplicate decimal-format declarations must raise static error

function testDuplicateDecimalFormatDeclaration()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err = xml.mtEvaluate('declare decimal-format local:df decimal-separator = "."; declare decimal-format local:df grouping-separator = ","; "test"')
   local message = tostring(xml.errorMsg)
   assert(xml.errorMsg and xml.errorMsg != '',
      'W3C XQuery 3.0 XQST0111: Duplicate decimal-format declaration must raise static error, got ' .. message)
end

-----------------------------------------------------------------------------------------------------------------------
-- W3C XQuery 3.0 XQST0039: Duplicate parameter names in function must raise static error

function testDuplicateParameterNames()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err = xml.mtEvaluate('declare function local:bad($x, $x) { $x }; local:bad(1, 2)')
   local message = tostring(xml.errorMsg)
   assert(xml.errorMsg and xml.errorMsg != '',
      'W3C XQuery 3.0 XQST0039: Duplicate parameter names must raise static error, got ' .. message)
end

-----------------------------------------------------------------------------------------------------------------------
-- Invalid prolog syntax: missing semicolon should report error

function testInvalidPrologSyntaxMissingSemicolon()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err = xml.mtEvaluate('declare variable $x := 5 declare variable $y := 10; $x + $y')
   assert(xml.errorMsg and xml.errorMsg != '',
      'Missing semicolon should report a syntax error')
end

-----------------------------------------------------------------------------------------------------------------------
-- Invalid prolog syntax: malformed function declaration

function testInvalidPrologSyntaxMalformedFunction()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err = xml.mtEvaluate('declare function local:bad { "missing params" }; local:bad()')
   assert(xml.errorMsg and xml.errorMsg != '',
      'Malformed function declaration should report a syntax error')
end

-----------------------------------------------------------------------------------------------------------------------
-- Invalid prolog syntax: incomplete namespace declaration

function testInvalidPrologSyntaxIncompleteNamespace()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err = xml.mtEvaluate('declare namespace ex; "test"')
   assert(xml.errorMsg and xml.errorMsg != '',
      'Incomplete namespace declaration should report a syntax error')
end

-----------------------------------------------------------------------------------------------------------------------
-- Invalid prolog syntax: missing variable initializer for non-external variable

function testInvalidPrologSyntaxMissingInitializer()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err = xml.mtEvaluate('declare variable $x; $x')
   assert(xml.errorMsg and xml.errorMsg != '',
      'Variable declaration without initializer or external keyword should report an error')
end

-----------------------------------------------------------------------------------------------------------------------
-- Function call with wrong number of parameters (too few)

function testFunctionCallTooFewParameters()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err = xml.mtEvaluate('declare function local:add($a, $b) { $a + $b }; local:add(5)')
   local message = tostring(xml.errorMsg)
   assert(message:find('expect') or message:find('parameter') or message:find('argument') or message:find('arity'),
      'Function call with too few parameters should report an error, got ' .. message)
end

-----------------------------------------------------------------------------------------------------------------------
-- Function call with wrong number of parameters (too many)

function testFunctionCallTooManyParameters()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err = xml.mtEvaluate('declare function local:square($x) { $x * $x }; local:square(5, 10)')
   local message = tostring(xml.errorMsg)
   assert(message:find('expect') or message:find('parameter') or message:find('argument') or message:find('arity') or message:find('Unknown function'),
      'Function call with too many parameters should report an error, got ' .. message)
end

-----------------------------------------------------------------------------------------------------------------------
-- Type annotation parsing: complex sequence types should parse without errors

function testComplexTypeAnnotationParsing()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err, result = xml.mtEvaluate('declare function local:process($items as xs:string*) as xs:integer { count($items) }; local:process(("a", "b", "c"))')
   assert(tonumber(result) == 3, 'Function with sequence type annotation should work, got ' .. tostring(result))
   assert(xml.errorMsg == nil or xml.errorMsg == '', 'Complex type annotations should parse, got ' .. tostring(xml.errorMsg))
end

-----------------------------------------------------------------------------------------------------------------------
-- Type annotation parsing: optional types should parse

function testOptionalTypeAnnotationParsing()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err, result = xml.mtEvaluate('declare function local:maybe($x as xs:string?) as xs:boolean { exists($x) }; local:maybe("test")')
   assert(result == 'true', 'Function with optional type annotation should work, got ' .. tostring(result))
   assert(xml.errorMsg == nil or xml.errorMsg == '', 'Optional type annotations should parse, got ' .. tostring(xml.errorMsg))
end

-----------------------------------------------------------------------------------------------------------------------
-- Type annotation parsing: element and node types should parse

function testElementTypeAnnotationParsing()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err, result = xml.mtEvaluate('declare function local:check($n as node()) as xs:boolean { true() }; local:check(<test/>)')
   assert(result == 'true', 'Function with node type annotation should work, got ' .. tostring(result))
   assert(xml.errorMsg == nil or xml.errorMsg == '', 'Node type annotations should parse, got ' .. tostring(xml.errorMsg))
end

-----------------------------------------------------------------------------------------------------------------------
-- Invalid boundary-space value should report an error

function testInvalidBoundarySpaceValue()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err = xml.mtEvaluate('declare boundary-space invalid; "test"')
   assert(xml.errorMsg and xml.errorMsg != '',
      'Invalid boundary-space value should report an error')
end

-----------------------------------------------------------------------------------------------------------------------
-- Invalid construction mode value should report an error

function testInvalidConstructionModeValue()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err = xml.mtEvaluate('declare construction invalid; "test"')
   assert(xml.errorMsg and xml.errorMsg != '',
      'Invalid construction mode value should report an error')
end

-----------------------------------------------------------------------------------------------------------------------
-- Invalid ordering mode value should report an error

function testInvalidOrderingModeValue()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err = xml.mtEvaluate('declare ordering invalid; "test"')
   assert(xml.errorMsg and xml.errorMsg != '',
      'Invalid ordering mode value should report an error')
end

-----------------------------------------------------------------------------------------------------------------------
-- Invalid empty order value should report an error

function testInvalidEmptyOrderValue()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err = xml.mtEvaluate('declare default order empty invalid; "test"')
   assert(xml.errorMsg and xml.errorMsg != '',
      'Invalid empty order value should report an error')
end

-----------------------------------------------------------------------------------------------------------------------
-- Invalid copy-namespaces values should report an error

function testInvalidCopyNamespacesValue()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err = xml.mtEvaluate('declare copy-namespaces invalid, inherit; "test"')
   assert(xml.errorMsg and xml.errorMsg != '',
      'Invalid copy-namespaces value should report an error')
end

-----------------------------------------------------------------------------------------------------------------------
-- Accessing undeclared variable should report an error

function testUndeclaredVariableAccess()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err = xml.mtEvaluate('$undeclared')
   local message = tostring(xml.errorMsg)
   -- Current implementation reports "Unsupported XPath expression" for undeclared variables
   assert(message:find('undeclared') or message:find('not found') or message:find('unknown') or message:find('Undeclared') or message:find('Unsupported'),
      'Accessing undeclared variable should report an error, got ' .. message)
end

-----------------------------------------------------------------------------------------------------------------------
-- Calling undeclared function should report an error

function testUndeclaredFunctionCall()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err = xml.mtEvaluate('local:undeclared(42)')
   local message = tostring(xml.errorMsg)
   assert(message:find('Unknown function') or message:find('not found') or message:find('undeclared'),
      'Calling undeclared function should report an error, got ' .. message)
end

-----------------------------------------------------------------------------------------------------------------------
-- Function with invalid QName (missing prefix binding) should report an error

function testFunctionInvalidQName()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err = xml.mtEvaluate('declare function unbound:func($x) { $x }; unbound:func(1)')
   -- This may succeed if the parser accepts unbound prefixes, or may fail
   -- The important thing is it shouldn't crash
   assert(true, 'Function with unbound prefix should be handled gracefully')
end

-----------------------------------------------------------------------------------------------------------------------
-- Variable with invalid QName (missing prefix binding) should report an error

function testVariableInvalidQName()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err = xml.mtEvaluate('declare variable $unbound:var := 5; $unbound:var')
   -- This may succeed if the parser accepts unbound prefixes, or may fail
   -- The important thing is it shouldn't crash
   assert(true, 'Variable with unbound prefix should be handled gracefully')
end

-----------------------------------------------------------------------------------------------------------------------
-- Decimal format with invalid property should be handled

function testDecimalFormatInvalidProperty()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   -- Test that invalid decimal format properties don't cause crashes
   local err, result = xml.mtEvaluate('declare decimal-format local:df invalid-prop = "x"; "ok"')
   -- Parser should either accept or reject gracefully
   assert(true, 'Invalid decimal format property should be handled gracefully')
end

-----------------------------------------------------------------------------------------------------------------------
-- Empty prolog (just semicolons) should not cause errors

function testEmptyProlog()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err, result = xml.mtEvaluate(';;; "test"')
   assert(result == 'test' or xml.errorMsg != '', 'Empty prolog statements should be handled')
end

-----------------------------------------------------------------------------------------------------------------------
-- Function body with syntax error should report clear error

function testFunctionBodySyntaxError()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err = xml.mtEvaluate('declare function local:bad($x) { $x + }; local:bad(5)')
   assert(xml.errorMsg and xml.errorMsg != '',
      'Function body with syntax error should report an error')
end

-----------------------------------------------------------------------------------------------------------------------
-- Variable initializer with syntax error should report clear error

function testVariableInitializerSyntaxError()
   local xml = obj.new('xml', {
      statement = '<root/>'
   })

   local err = xml.mtEvaluate('declare variable $x := 5 +; $x')
   assert(xml.errorMsg and xml.errorMsg != '',
      'Variable initializer with syntax error should report an error')
end

-----------------------------------------------------------------------------------------------------------------------

return {
   tests = {
      'testUserDefinedFunction', 'testNamespaceAndVariableDeclarations', 'testBoundarySpacePreservation',
      'testBoundarySpacePreserveComputedText', 'testBoundarySpaceStripRemoval',
      'testConstructionStripComputedWhitespace', 'testConstructionPreserveComputedWhitespace',
      'testConstructionStripTextConstructorWhitespace', 'testConstructionPreserveTextConstructorWhitespace',
      'testRecursiveFunction', 'testFunctionOverloadingByArity', 'testNamespaceFallbackFromDocument',
      'testVariableShadowing', 'testExternalVariableErrorHandling', 'testExternalFunctionErrorHandling',
      'testModuleImportDeclaration', 'testFunctionTypeAnnotations', 'testMultipleNamespacesInProlog',
      'testVariableInitializerExpressions', 'testDefaultCollationDeclaration', 'testDefaultCollationFunctionUsesProlog',
      'testDecimalFormatDeclaration', 'testConstructionModeDeclaration',
      'testConstructionStripTrimsComputedContent', 'testConstructionPreserveRetainsWhitespace',
      'testZeroParameterFunction', 'testMultiParameterFunction', 'testPrologVariableAvailability',
      'testFunctionNameCollisionResolution', 'testNamespacePrecedence', 'testMultipleFunctionArities',
      'testBaseUriDeclaration', 'testOrderingDeclaration', 'testOrderingModeUnorderedSequence',
      'testOrderingModeUnorderedUnion', 'testOrderingModeUnorderedIntersect', 'testOrderingModeUnorderedExcept',
      'testDefaultEmptyOrderGreatest', 'testEmptyOrderLeastPlacement', 'testCopyNamespacesDeclaration',
      'testQueryWithoutProlog',
      -- W3C XQuery 3.0 duplicate declaration error tests (XQST00xx)
      'testDuplicateNamespaceDeclaration', 'testDuplicateVariableDeclaration', 'testDuplicateFunctionDeclaration',
      'testDuplicateBaseUriDeclaration', 'testDuplicateDefaultCollationDeclaration',
      'testDuplicateBoundarySpaceDeclaration', 'testDuplicateConstructionModeDeclaration',
      'testDuplicateOrderingModeDeclaration', 'testDuplicateEmptyOrderDeclaration',
      'testDuplicateCopyNamespacesDeclaration', 'testDuplicateDecimalFormatDeclaration',
      'testDuplicateParameterNames',
      -- Other error handling tests
      'testInvalidPrologSyntaxMissingSemicolon', 'testInvalidPrologSyntaxMalformedFunction',
      'testInvalidPrologSyntaxIncompleteNamespace', 'testInvalidPrologSyntaxMissingInitializer',
      'testFunctionCallTooFewParameters', 'testFunctionCallTooManyParameters',
      'testComplexTypeAnnotationParsing', 'testOptionalTypeAnnotationParsing', 'testElementTypeAnnotationParsing',
      'testInvalidBoundarySpaceValue', 'testInvalidConstructionModeValue', 'testInvalidOrderingModeValue',
      'testInvalidEmptyOrderValue', 'testInvalidCopyNamespacesValue',
      'testUndeclaredVariableAccess', 'testUndeclaredFunctionCall',
      'testFunctionInvalidQName', 'testVariableInvalidQName',
      'testDecimalFormatInvalidProperty', 'testEmptyProlog',
      'testFunctionBodySyntaxError', 'testVariableInitializerSyntaxError'
   },
   init = function(ScriptFolder)
   end,
   cleanup = function()
   end
}
