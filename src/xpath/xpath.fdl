--$FLUID:Include

module({ name="XPath", copyright="Paul Manias Â© 2025", version=1.0, timestamp=20240611 }, function()
  c_include("<parasol/modules/xml.h>")
  cpp_include("<functional>", "<optional>", "<sstream>", "<parasol/strings.hpp>")

-- XPath AST Node Structure

enum('XPathNodeType', { type='int', start=0 },
   -- Location path components
   'LOCATION_PATH',
   'STEP',
   'NODE_TEST',
   'PREDICATE',
   'ROOT',

   -- Expressions
   'EXPRESSION',
   'FILTER',
   'BINARY_OP',
   'UNARY_OP',
   'CONDITIONAL',
   'FOR_EXPRESSION',
   'FOR_BINDING',
   'LET_EXPRESSION',
   'LET_BINDING',
   'FLWOR_EXPRESSION',
   'QUANTIFIED_EXPRESSION',
   'QUANTIFIED_BINDING',
   'FUNCTION_CALL',
   'LITERAL',
   'VARIABLE_REFERENCE',

   -- Node tests
   'NAME_TEST',
   'NODE_TYPE_TEST',
   'PROCESSING_INSTRUCTION_TEST',
   'WILDCARD',

   -- Axes
   'AXIS_SPECIFIER',

   -- Union / set expressions
   'UNION',

   -- Primary expressions
   'NUMBER',
   'STRING',
   'PATH',

   -- Constructor expressions
   'DIRECT_ELEMENT_CONSTRUCTOR',
   'DIRECT_ATTRIBUTE_CONSTRUCTOR',
   'DIRECT_TEXT_CONSTRUCTOR',
   'COMPUTED_ELEMENT_CONSTRUCTOR',
   'COMPUTED_ATTRIBUTE_CONSTRUCTOR',
   'TEXT_CONSTRUCTOR',
   'COMMENT_CONSTRUCTOR',
   'PI_CONSTRUCTOR',
   'DOCUMENT_CONSTRUCTOR',
   'CONSTRUCTOR_CONTENT',
   'ATTRIBUTE_VALUE_TEMPLATE')

  struct("XPathNode", { type="XPathNode" }, [[
  ]],
  [==[
   struct XPathAttributeValuePart
   {
      bool is_expression = false;
      std::string text;
   };

   struct XPathConstructorAttribute
   {
      std::string prefix;
      std::string name;
      std::string namespace_uri;
      bool is_namespace_declaration = false;
      std::vector<XPathAttributeValuePart> value_parts;
      std::vector<std::unique_ptr<XPathNode>> expression_parts;

      void set_expression_for_part(size_t index, std::unique_ptr<XPathNode> expr)
      {
         if (expression_parts.size() <= index) expression_parts.resize(index + 1);
         expression_parts[index] = std::move(expr);
      }

      [[nodiscard]] XPathNode * get_expression_for_part(size_t index) const
      {
         return index < expression_parts.size() ? expression_parts[index].get() : nullptr;
      }
   };

   struct XPathConstructorInfo
   {
      std::string prefix;
      std::string name;
      std::string namespace_uri;
      bool is_empty_element = false;
      bool is_direct = false;
      std::vector<XPathConstructorAttribute> attributes;
   };

   XPathNodeType type;
   std::string value;
   std::vector<std::unique_ptr<XPathNode>> children;
   std::optional<XPathConstructorInfo> constructor_info;
   std::vector<XPathAttributeValuePart> attribute_value_parts;
   bool attribute_value_has_expressions = false;
   std::unique_ptr<XPathNode> name_expression;

   XPathNode(XPathNodeType t, std::string v = "") : type(t), value(std::move(v)) {}

   void add_child(std::unique_ptr<XPathNode> child) { children.push_back(std::move(child)); }
   [[nodiscard]] XPathNode * get_child(size_t index) const { return index < children.size() ? children[index].get() : nullptr; }
   [[nodiscard]] size_t child_count() const { return children.size(); }

   void set_constructor_info(XPathConstructorInfo info)
   {
      constructor_info = std::move(info);
   }

   [[nodiscard]] bool has_constructor_info() const
   {
      return constructor_info.has_value();
   }

   void set_attribute_value_parts(std::vector<XPathAttributeValuePart> parts)
   {
      attribute_value_has_expressions = false;
      for (const auto &part : parts)
      {
         if (part.is_expression)
         {
            attribute_value_has_expressions = true;
            break;
         }
      }
      attribute_value_parts = std::move(parts);
   }

   void set_name_expression(std::unique_ptr<XPathNode> expr)
   {
      name_expression = std::move(expr);
   }

   [[nodiscard]] XPathNode * get_name_expression() const
   {
      return name_expression.get();
   }

   [[nodiscard]] bool has_name_expression() const
   {
      return name_expression != nullptr;
   }
  ]==])
  
  functionNames("xp",
     "Compile",
     "Evaluate",
     "Query")
end)
