--$FLUID:Include

module({ name="Core", copyright="Paul Manias 1996-2022" }, function()
  c_include("<stdarg.h>")
  cpp_include("<list>", "<map>", "<string>", "<vector>", "<unordered_map>")

  platform("Windows", function()
     enum("NETMSG", {}, "START", "END")
  end)

  privateNames({ "ScriptArg", "CoreBase", "ModuleMaster", "KeyPair" })

  loadFile(glPath .. 'common.fdl')
  loadFile(glPath .. 'common-graphics.fdl')

  flags("SCF", { comment="Script flags" },
    "EXIT_ON_ERROR: The script will automatically terminate its execution process if an error is detected.",
    "DEBUG: Enables execution debugging.  More information will be printed to the console in this mode.")

  flags("STR", { bits=16 },
     "MATCH_CASE|CASE: Perform a case-sensitive match.",
     "MATCH_LEN: The strings must be of equal length to be matched.",
     "WILDCARD: Allow the use of wildcard characters '|', '?' and '*'.")

  flags("MSF", { comment="Message flags." },
     "WAIT: Wait before inserting the message if the queue is at maximum capacity.",
     "UPDATE: If the Type parameter matches a message already inside the queue, the data for that message will be deleted, then the new message will be added to the end of the queue.",
     "NO_DUPLICATE: If the Type parameter matches a message already inside the queue, the new message will not be added and the function will immediately return with ERR_Okay.",
     "ADD: The default behaviour - this will add the message to the end of the queue.",
     "ADDRESS: Internal flag that changes the behaviour of the input parameters so that queues can be processed by address rather than ID.",
     "MESSAGE_ID: The Type parameter refers to a unique message ID rather than a message type for this call.")

  flags("PMF", { comment="Flags for ProcessMessages" },
     "SYSTEM_NO_BREAK: Private.  For system calls that need to avoid early termination.")

  flags("ALF", { bits=16 },
     "SHARED: The lock will be shared between foreign processes.",
     "RECURSIVE: Set if support for recursive locking within the same thread is required.")

  flags("NSF", { comment="Flags for NotifySubscribers" },
     "EXCLUSIVE: Instead of messaging each object, the function will attempt to gain exclusive access to each of the subscribed objects and send the notification directly.",
     "LOCAL|LOCAL_TASK: Only send messages to objects that are owned by the current process.",
     "OTHER_TASKS: Only send messages to objects that are owned by other processes.",
     "DELAY|FORCE_DELAY: Place all notifications on the message queue.")

  flags("SMF", { comment="Flags for semaphores" },
     "NO_BLOCKING|NON_BLOCKING: Do not block when locking the semaphore unless its counter has reached zero.",
     "EXISTS: When allocating a semaphore, declares that the named semaphore already exists and should not be recreated.")

  flags("RFD", { bits=16, comment="Flags for RegisterFD()" },
     "WRITE: Activate the callback if there is room to write to the FD's buffer.",
     "EXCEPT: Activate the callback if error conditions are pending.",
     "READ: Activate the callback if there is data available to read.",
     "REMOVE: Stop monitoring this file descriptor.",
     "STOP_RECURSE: Internal flag to prevent recursion.",
     "ALLOW_RECURSION: Internal flag to allow recursion.",
     "SOCKET: Identifies the file descriptor as a socket (Linux systems only).",
     "RECALL: Set if the subscriber needs to manually check for incoming/outgoing data.  This is supported as a one-off check, so the flag will be disabled automatically when the subscriber is called.",
     "ALWAYS_CALL: Always call this FD's handler prior to the process going to sleep.")

  flags("SBF", { comment="Flags for StrBuildArray()" },
    "NO_DUPLICATES: Sort the resulting list and remove duplicated strings.",
    "SORT: Sort the resulting list.",
    "CASE: Use case-sensitivity when comparing strings in the list.",
    "DESC: Sort in descending order.",
    "CSV: The list is in CSV format and the Size and Total parameters should be ignored. Note that the source string will be modified in this mode.")

  flags("TSF", { comment="Task flags" },
    "FOREIGN: Set this flag when using the task object to execute a foreign process - that is an executable that does not use the Parasol API.",
    "DUMMY: Private. Marks the object as being for temporary use only.",
    "WAIT: This flag will cause the parent process to halt when the task is activated.  Control is returned to the parent process once the child process terminates.",
    "RESET_PATH: If set, the executed process will start in its own folder rather than the folder of the parent process.",
    "PRIVILEGED: During a normal execution process, any privileges of the parent process will be dropped so that the child process runs unprivileged.  This behaviour can be reversed if he PRIVILEGED flag is set, in which case the child process has the same privileges as the parent.",
    "SHELL: Enables shell mode.  On Unix systems, this means that a shell (usually BASH) will be used to launch the process.",
    "DEBUG: Additional debug messages will be printed during normal usage of the task class when this flag is set.",
    "QUIET: Setting this flag will divert all process output to /dev/null or the nearest equivalent for non-Unix systems.",
    "DETACHED: Forces new task to be detached from the parent.",
    "ATTACHED: Forces new task to be attached to the parent (child will close when parent closes).",
    "PIPE: Enable the output pipe to the launched process so that it can read data.")

  hash("AHASH", "0x%s",
    "ACTIONNOTIFY", "ACTIVATE",      "ACCESSOBJECT", "CLEAR",    "FREEWARNING",  "OWNERDESTROYED", "COPYDATA",
    "DATAFEED",     "DEACTIVATE",    "DRAW",         "FLUSH",    "FOCUS",        "FREE",         "RELEASEOBJECT",
    "GETVAR",       "DRAGDROP",      "HIDE",         "INIT",     "LOCK",         "LOSTFOCUS",    "MOVE",
    "MOVETOBACK",   "MOVETOFRONT",   "NEWCHILD",     "NEWOWNER", "NEWOBJECT",    "REDO",         "QUERY",
    "READ",         "RENAME",        "RESET",        "RESIZE",   "SAVEIMAGE",    "SAVETOOBJECT", "SCROLL",
    "SEEK",         "SETVAR",        "SHOW",         "TIMER",    "UNLOCK",       "NEXT",         "PREV",
    "WRITE",        "SETFIELD",      "CLIPBOARD",    "REFRESH",  "DISABLE",      "ENABLE",       "REDIMENSION",
    "MOVETOPOINT",  "SCROLLTOPOINT", "CUSTOM",       "SORT",     "SAVESETTINGS", "SELECTAREA",   "SIGNAL",
    "UNDO")

  enum("STYLE", { start=1, comment="Internal style notifications" },
     "ENABLED", "DISABLED", "FOCUS", "LOST_FOCUS", "RESIZE", "CONTENT")

  flags("MHF", { comment="Internal options for requesting function tables from modules." },
    "NULL",
    "STRUCTURE|DEFAULT: Use structures to group exported functions (Linux, C/C++ standard)",
    "STATIC: Keep the module code in memory")

  enum("CPU", { start=1, comment="Registered CPU ID's", restrict="c" },
    "M68K", "I486", "I586", "I686", "X64", "ARMEABI")

  flags("STP", { comment="ScrollToPoint flags" }, "X", "Y", "Z", "ANIM")

  flags("MTF", { comment="MoveToPoint flags" }, "X", "Y", "Z", "ANIM", "RELATIVE")

  flags("VLF", { comment="VlogF flags" }, "BRANCH", "ERROR", "WARNING", "CRITICAL", "INFO", "API", "EXTAPI", "DEBUG", "TRACE", "FUNCTION")

  flags("MOF", { comment="Module flags" },
    "LINK_LIBRARY: Module refers to a symbolic link library (e.g. libz DLL or SO)",
    "STATIC: This flag prevents the loaded module code from being unloaded when the module object is freed.  This may be needed in cases where a module is designed with the presumption that it will remain in memory after being loaded by the developer.",
    "SYSTEM_PROBE: Indicates that the module is being probed.  Do not use outside of the core library.")

  flags("THF", { comment="Thread flags" },
    "AUTO_FREE: Automatically destroy the Thread object when the user routine has completed.",
    "MSG_HANDLER: Allow the thread to handle messages that target objects that it has created.")

  enum("FDT", { start=0, comment="Flags for the SetDate() file method." },
    "MODIFIED: The date on which the file was last modified.",
    "CREATED: The date on which the file was created.  On some host platforms this datestamp may be read-only.",
    "ACCESSED: The date on which the file was last accessed by a user or application.",
    "ARCHIVED: The date on which the file was most recently archived.  Not supported by most filesystems.")

  flags("VOLUME", { },
    "REPLACE: If the volume already exists, all paths that are attached to it will be replaced with the new path setting.",
    "PRIORITY: If the volume already exists, the path will be inserted at the beginning of the path list so that it has priority over the others.",
    "HIDDEN: Hides the volume so that it will not show up when reading the root folder.",
    "SAVE: The volume will be saved to user:config/volumes.cfg if this flag is set.  This allows the volume to be automatically restored on the next reboot.  See also VOLUME_SYSTEM.",
    "SYSTEM: If the VOLUME_SAVE option is used in conjunction with VOLUME_SYSTEM, the volume is saved to config:volumes.cfg as opposed to the user's home folder.  This means that the change is global to all users.  On secure platforms the current process may need administrative rights to write to the file.")

  flags("FDL", { comment="Options for the File Delete() method." },
    "FEEDBACK: Automatically manage user feedback for deleting files by presenting dialog boxes.")

  flags("CMF", { comment="Compression flags" },
    "PASSWORD: A password has been set on the object.",
    "NEW: Force the creation of a new file archive.  Any existing file data at the target location will be destroyed.",
    "CREATE_FILE: Create a new archive only if the source file does not already exist.",
    "READ_ONLY: Forces read-only access, which is strongly recommended if an existing archive is being opened with no modifications intended.  If this flag is not set, initialisation can fail if the user does not have write access to the source file.",
    "NO_LINKS: Treat symbolic links as normal files/folders.",
    "APPLY_SECURITY: When decompressing, apply individual file permissions if they are available in the compression file.")

  flags("RSF", { comment="Flags for ResolvePath()"},
    "NO_FILE_CHECK: Do not test for the existence of the targeted file or folder during the resolution process.",
    "CHECK_VIRTUAL: If the volume referenced by Path is traced to another volume that is reserved by a virtual file system driver, ERR_VirtualVolume is returned. The volume is still resolved as far as possible and the resulting path will be returned by this function.",
    "APPROXIMATE: Ignores file extensions for the purpose of file name matching.",
    "NO_DEEP_SCAN: Do not perform more than one iteration when resolving the source file path.",
    "PATH: Use the PATH environment variable to resolve the file name in the Path parameter.",
    "CASE_SENSITIVE: For use on host systems that use case-insensitive file systems such as Windows; this option checks that the discovered file is a case-sensitive match to the Path.")

  -- NB: The MFF flags are duplicated in the FileSystem's Win32 code if you're going to change these

  flags("MFF", { comment="Flags for the File Watch() method." },
    "READ: File was accessed (read).",
    "MODIFY|WRITE: File modified via write or truncation.",
    "CREATE: New file/link created or renamed in folder.",
    "DELETE: Existing file deleted",
    "MOVED|RENAME: Existing file moved or renamed.",
    "ATTRIB: File permissions or datestamp changed.",
    "OPENED: Existing file was opened.",
    "CLOSED: An opened file has been closed.",
    "UNMOUNT: Host filesystem was unmounted.",
    "FOLDER: Folder identifier; if passed to Watch() then indicates a preference for folder events only.",
    "FILE: File identifier; if passed to Watch() then indicates a preference for file events only.",
    "SELF: Event applies to the monitored folder and not a contained item",
    "DEEP: Receive notifications from sub-folders (Windows only).")

  enum("STT", { start=1, comment="Types for StrDatatype()." },
    "NUMBER: The string represents a whole number.",
    "FLOAT: The string represents a floating point number.",
    "HEX: The string represents a hexadecimal number.",
    "STRING: The string represents plain-text.")

  flags("OPF", { },
    "NAME",
    "COPYRIGHT",
    "DATE",
    "AUTHOR",
    "CORE_VERSION",
    "JUMPTABLE",
    "MAX_DEPTH",
    "DETAIL",
    "SHOW_MEMORY",
    "SHOW_IO",
    "SHOW_ERRORS",
    "ARGS",
    "ERROR",
    "COMPILED_AGAINST",
    "PRIVILEGED",
    "SYSTEM_PATH",
    "MODULE_PATH",
    "ROOT_PATH",
    "SCAN_MODULES",
    "GLOBAL_INSTANCE",
    "OPTIONS",
    "SHOW_PUBLIC_MEM") -- Show shared memory allocations only (ignore private).

  enum("TOI", { },
    "LOCAL_CACHE",        -- For Android.  Defines the path of the local cache for assignment to localcache:
    "LOCAL_STORAGE",      -- For Android.  Defines the path of the local storage for assignment to localstorage:
    "ANDROID_ENV",        -- For Android.
    "ANDROID_CLASS",      -- For Android.
    "ANDROID_ASSETMGR")   -- For Android.  Permanent pointer to the AssetManager

  flags("STF", { comment="Universal flag values used for searching text" },
    "CASE: Case sensitive search",
    "MOVE_CURSOR: The cursor is moved to the text.  If not set, the text is auto-selected",
    "SCAN_SELECTION: Limit search to within the user's current selection",
    "BACKWARDS: Search backwards",
    "EXPRESSION: Search text is a regular expression",
    "WRAP: Wrap search at the end of the document")

  flags("RDF", { comment="Flags for the OpenDir() function." },
    "SIZE: Retrieve the byte size of each file.",
    "DATE|TIME: Retrieve the date stamp of each file.",
    "PERMISSIONS: Get permission/security information.",
    "FILES|FILE: Read all files in the folder.",
    "FOLDERS|FOLDER: Read all folders/volumes in the folder.",
    "VOLUME: Feedback only - indicates a volume.",
    "LINK: Feedback only - file/folder is actually a link to another location.",
    "TAGS: Receive additional information for each file, such as comments, author and copyright.  The results are stored in the Tags field of each file.",
    "HIDDEN: Feedback only - file/folder is hidden.",
    "QUALIFY|QUALIFIED: Return fully qualified folder names (i.e. trailing slash or colon for each name).",
    "VIRTUAL: Path is to a virtual device.",
    "STREAM: Path is connected via a stream, e.g. network connection.",
    "READ_ONLY: Read-only (not permissions related and might indicate read-only media).",
    "ARCHIVE: Feedback only - archive bit is set.",
    "OPENDIR: Internal option.",
    { READ_ALL = "SIZE|DATE|PERMISSIONS|FILES|FOLDERS" })

  flags("FL", { comment="File flags" },
    "WRITE: Prepares a file for writing data, starting at byte position 0.  To start writing from the end of a file, use the Seek action after the file has been initialised.",
    "NEW: Required when creating a new file.  If a file with the same name exists, its contents will be destroyed. If however the existing file is locked, the initalisation process will fail.",
    "READ: Required if the file needs to be opened for read access.",
    "FOLDER|DIRECTORY: The file object represents a folder.",
    "APPROXIMATE: Allows fuzzy matching of the file path when opening an existing file.  This means that the file extension will be ignored; for instance attempting to open a file of 'screenshot.png' when only a file name of 'screenshot.jpg' exists in the same folder, the 'screenshot.jpg' file will be opened instead.  If multiple files could potentially match to the file name, the file object will select the first match that is encountered.",
    "LINK: Read-Only.  Indicates that the file is a symbolic link or shortcut to another file.",
    "BUFFER: Activates a special mode in which the file data is stored in a memory buffer rather than a disk file.  Set the Size field to a value of at least 1 so that the initial buffer size is configured.  In this mode many of the available file operations are meaningless except for the Read, Write and Seek actions.",
    "LOOP: In loop mode, the file object's position marker for read/write operations is allowed to extend past the actual file size.  Any read/write operation beyond the file size will loop back to the file at a corrected offset - for example, reading position 330 of a 100 byte file will start the operation from the 30th byte.  Loop mode does not affect any other area besides the read, write and seek operations.  The loop feature is typically used to create multimedia data streams with minimal effort.",
    "FILE: Explicitly declares the file object as an entity that stores content (as opposed to a device or folder for example).",
    "RESET_DATE: For internal use only",
    "DEVICE: The file is a system device (must set if opening a device for read/write operations)",
    "STREAM: File data is streamed (e.g. PIPE, FIFO, socket) and may be accessed locally or via a network.",
    "EXCLUDE_FILES: Exclude files when scanning this folder.",
    "EXCLUDE_FOLDERS: Exclude folders when scanning this folder.")

  enum("LOC", { start=1, comment="AnalysePath() values" },
    "DIRECTORY|FOLDER: The path refers to a folder.",
    "VOLUME: The path refers to a volume name.",
    "FILE: The path refers to a file.")

  flags("IDF", { comment="IdentifyFile() values" },
    "SECTION: Return the name of the Config group that supports the file association, rather than an executable command.",
    "HOST: Query the host platform's file associations only.",
    "IGNORE_HOST: Ignore the host platform's file assocations.")

  flags("LDF", { comment="Flags for LoadFile()" },
    "CHECK_EXISTS: Limits the routine to checking the file cache for the existence of the file.  If found, the relevant cache entry is returned. The open count is not incremented by this action (it is therefore unnecessary to follow-up with a call to UnloadFile()).  If no up-to-date cache entry is available, ERR_Search is returned.")

  enum("FBK", { start=1, comment="Flags for file feedback." },
    "MOVE_FILE: A file is to be, or has been moved.",
    "COPY_FILE: A file is to be, or has been copied.",
    "DELETE_FILE: A file is to be, or has been deleted.")

  enum("FFR", { start=0, comment="Return codes available to the feedback routine" },
    "OKAY|CONTINUE: Continue processing uninterrupted.",
    "SKIP: Skip processing of this entity.",
    "ABORT: Abort the entire operation.")

  enum("VAS", { start=1, comment="For use by VirtualVolume()" },
    "DEREGISTER: Remove the virtual volume from the system.",
    "SCAN_DIR",
    "DELETE",
    "RENAME",
    "OPEN_DIR",
    "CLOSE_DIR",
    "TEST_PATH",
    "WATCH_PATH",
    "IGNORE_FILE",
    "GET_INFO",
    "GET_DEVICE_INFO",
    "IDENTIFY_FILE",
    "MAKE_DIR",
    "SAME_FILE",
    "CASE_SENSITIVE: Set to true if the volume's paths are case-sensitive.",
    "READ_LINK",
    "CREATE_LINK")

  enum("AST", { start=1, bits=64, comment="Tags for SetVolume()" }, -- Note: Tag names are not normally capitalised.
    "Path|PATH: Required.  Follow this tag with the path to be set against the volume.  If setting multiple paths, separate each path with a semi-colon character.  Each path must terminate with a forward slash to denote a folder.",
    "Name|NAME: Required.  Follow this tag with the string name of the volume.",
    "Flags|FLAGS: Optional VOLUME flags.",
    "Icon|ICON: An icon can be associated with the volume so that it has graphical representation when viewed in the UI.  The required icon string format is 'category/name'.",
    "Comment|COMMENT: A user comment string may be set against the volume with this tag.",
    "Label|LABEL: An optional label or short comment may be applied to the volume.  This may be useful if the volume name has little meaning to the user (e.g. drive1, drive2 ...).",
    "Device|DEVICE: If the volume references the root of a device, it's code name should be specified here, e.g. 'disk', 'cd', 'hd', 'network'.",
    "DevicePath|DEVICE_PATH: For Unix systems, set this to the device path under '/dev/' if this is a root volume and a device path is applicable.",
    "ID: A unique ID string can be specified against the volume.  This is useful for programs that want to identify volumes that they have created.")

  enum("FDB", { start=1, comment="Feedback event indicators." },
    "DECOMPRESS_FILE",
    "COMPRESS_FILE",
    "REMOVE_FILE",
    "DECOMPRESS_OBJECT")

  enum("CF", { start=1, comment="Compression stream formats" },
    "GZIP: The 'gzip' format",
    "ZLIB: The 'zlib' format",
    "DEFLATE: The 'deflate' format")

  flags("FOF", { comment="Flags that can be passed to FindObject()" },
    "SMART_NAMES: Parse numeric object names as ID references and support use of the 'Owner' reserved keyword.",
    "INCLUDE_SHARED: Include shared objects when searching.")

  flags("NF", { comment="Flags that can be passed to NewObject().  If a flag needs to be stored with the object, it must be specified in the lower word." },
    "NO_TRACK|UNTRACKED: An object created with this flag will not be tracked back to the object that created it.  If combined with the NF_PUBLIC flag, the object can also remain in memory when the object's related task is terminated.",
    "PUBLIC|SHARED: Allocates a shared object using shareable resources, allowing it to be accessed directly by any process.  Access is granted via exclusive access locks  - refer to the AccessObject() and ReleaseObject() functions.",
    "FOREIGN_OWNER: Read-only indicator for when an object's parent is in a foreign process.",
    "INITIALISED: Read-only indicator if the object has been initialised.",
    "INTEGRAL: Integral objects can only be allocated by classes that need to adopt the functionality of said object.  Integral objects do not appear in the object tree, effectively making them hidden from view.",
    "UNLOCK_FREE: Read-only indicator for when the object is marked for deletion.",
    "FREE: Read-only indicator for when the object is being freed.",
    "TIMER_SUB: Indicates that the object is subscribed to a timer Zinterval.",
    "CREATE_OBJECT: Private. Called from CreateObject().",
    "COLLECT: Marked for garbage collection.",
    "NEW_OBJECT: Private. The object is in the process of being created.",
    "RECLASSED: The object switched from the base-class to a sub-class during initialisation.",
    "MESSAGE: Action has been called against the object through the message system (managed by ProcessMessages()).",
    "SIGNALLED: The object has been signalled and is awaiting processing.",
    "HAS_SHARED_RESOURCES: Private. The object owns a shared object or memory resource.",
    { UNIQUE = "0x40000000: Use to allocate an object that has a guaranteed unique name.  This will prevent code from shadowing any object that exists with the same name, which can be imperative when creating shared objects.  If it is discovered that an identically named object exists, NewObject() will return ERR_ObjectExists.  This flag works in conjunction with the Name argument.",
      NAME   = "0x80000000: Use the Name parameter to name the created object.  This flag is not required if using NF_UNIQUE.",
      PRIVATE = 0
    }
  )

  const("RPM", { comment="Reserved Public Memory identifiers.", restrict="c" }, {
    SharedObjects  = "-1000: Shared object list (struct SharedObject *).",
    Audio          = "-1001: Global audio settings.",
    Clipboard      = "-1002: Clipboard array.",
    X11            = "-1003: X11 global variables.",
    AlphaBlend     = "-1004: Alpha blending lookup table (Bitmap module).",
    XWindowLookup  = "-1005: X Window to Surface lookup table (Display/Surface modules).",
    FocusList      = "-1006: The Surface class uses this to store the focus hierarchy.",
    InputEvents    = "-1007: Input message cyclic array.",
    DisplayInfo    = "-1008: DisplayInfo structure, managed by the Display module"
  })

  const("MAX", { }, { FILENAME = 256 })  -- Maximum length for file names (not necessarily including path)

  const("COPY", { comment="Flags for StrCopy()" }, {
     ALL = "0x7fffffff: Copy all characters from the source string."
  })

  const("MODULE", { comment="Module file header constants", restrict="c" }, {
    HEADER_V1 = 0x4D4F4401,
    HEADER_V2 = 0x4D4F4402,
    HEADER_VERSION = 0x4D4F4402, -- Always set to the latest version number of the module header.
    HEADER = "EXPORT struct ModHeader ModHeader"
  })

  const("MAX", nil, { NAME_LEN = 32 })

  const("MSGID", { comment="Reserved message ID's that are handled internally." }, {
     QUIT             = 1000,     -- Note that IDs >= 100 may be handled by non-Core code (external modules and applications)
     BREAK            = 102,
     COMMAND          = 101,
     EXPOSE           = 100,
     CORE_END         = 100,  -- End marker for Core generated messages
     ACTION           = 99,     -- Start from 99 descending (lower risk of accidental ID matches)
     SET_FIELD        = 98,
     GET_FIELD        = 97,
     ACTION_RESULT    = 96,
     DEBUG            = 95,
     EVENT            = 94,
     VALIDATE_PROCESS = 93,
     THREAD_CALLBACK  = 92,
     THREAD_ACTION    = 91,
     WAIT_FOR_OBJECTS = 90
  })

  const("LTF", { comment="Flags for ListTasks()" }, {
     CURRENT_PROCESS = 0x0000001
  })

  const("SUB", { comment="Special tags for SubscribeActionTags()" }, {
    WARN_EXISTS = "0x7fffffff: An error of ERR_Exists will be returned if there was an existing match for the subscriber and at least one of the following actions.",
    FAIL_EXISTS = "0x7ffffffe: As for WARN_EXISTS, but aborts immediately when a conflict is discovered."
  })

  enum("IDTYPE", { start=1, comment="Types for AllocateID()" },
    "MESSAGE: Message ID's are allocated for the purpose of sending uniquely identifiable messages between tasks.",
    "GLOBAL: Global ID's have no specific association with anything.",
    "FUNCTION: Function ID's are used to track FUNCTION types and are assigned to the function ID field."
  )

  enum("SEM", { start=1 },
    "GET_VAL: Get the maximum value for the counter, as originally set in AllocSemaphore.  Associated tag must be a pointer to a 32-bit integer.",
    "GET_COUNTER: Get the current counter value (affected by AccessSemaphore and ReleaseSemaphore).  Associated tag must be a pointer to a 32-bit integer.",
    "GET_DATA_PTR: Get the user customisable data value associated with the semaphore.  The subsequent tag must be a pointer to an address pointer.",
    "GET_DATA_LONG: Get the user customisable data value associated with the semaphore.  The subsequent tag must be a pointer to a 32-bit integer.",
    "GET_DATA_LARGE: Get the user customisable data value associated with the semaphore.  The subsequent tag must be a pointer to a 64-bit integer.",
    "GET_DATA_DOUBLE: Get the user customisable data value associated with the semaphore.  The subsequent tag must be a pointer to a 64-bit float point number.",
    "SET_DATA_PTR: Set the user customisable data value associated with the semaphore.  The subsequent tag must be an address pointer.",
    "SET_DATA_LONG: Set the user customisable data value associated with the semaphore.  The subsequent tag must be a 32-bit integer.",
    "SET_DATA_LARGE: Set the user customisable data value associated with the semaphore.  The subsequent tag must be a 64-bit integer.",
    "SET_DATA_DOUBLE: Set the user customisable data value associated with the semaphore.  The subsequent tag must be a 64-bit floating point number.")

  enum("TSTATE", { comment="Indicates the state of a process." },
    "RUNNING: The process is currently executing code.",
    "PAUSED: The process is asleep.",
    "STOPPING: The process is in its termination phase.",
    "TERMINATED: The process has closed.")

  enum("RES", { start=1 },
    "MESSAGE_QUEUE: Use this resource to retrieve the message queue ID of the current task.",
    "CONSOLE_FD: Internal reference to the FD of the console.",
    "GLOBAL_INSTANCE: If a global instance is active, this resource holds the instance ID.  Otherwise the value is 0.",
    "SHARED_CONTROL: Internal pointer to the SharedControl structure.",
    "USER_ID: Internal",
    "DISPLAY_DRIVER: Internal.  Passes the name of the preferred display driver to the display module.",
    "PRIVILEGED_USER: If this value is set to 1, the process will operate in privileged mode (typically this enables full administrator rights).  This feature will only work for Unix processes that are granted admin rights when launched.  Setting the Value to 0 reverts to the user's permission settings.  SetResource() will return an error code indicating the level of success.",
    "PRIVILEGED: This is set to TRUE if the process has elevated privileges (such as superuser or administrative rights).",
    "CORE_IDL: Refers to the Core module's compressed IDL string.",
    "PARENT_CONTEXT: Read-only pointer to the parent object of the current context.",
    "LOG_LEVEL: The current level of log detail (larger numbers indicate more detail).",
    "TOTAL_SHARED_MEMORY: The total amount of shared memory in use.",
    "TASK_CONTROL: Internal",
    "TASK_LIST: Internal",
    "MAX_PROCESSES: The maximum number of processes that can be supported at any time.",
    "LOG_DEPTH: The current depth of log messages.",
    "JNI_ENV: Return the current JNI environment string.",
    "THREAD_ID: Return the ID of the current thread.",
    "CURRENT_MSG: Returns a Message structure if the program is currently processing a message - otherwise returns NULL.  This resource type is meaningful only during a ProcessMessages call.",
    "OPEN_INFO: Pointer to the OpenInfo structure originally used to initialise the system.",
    "EXCEPTION_HANDLER: Internal",
    "NET_PROCESSING: Internal windows resource for Network module",
    "PROCESS_STATE: Life-cycle stage of the running process",
    "TOTAL_MEMORY: The total amount of installed memory.",
    "TOTAL_SWAP: The total amount of available swap space.",
    "CPU_SPEED: The average top-speed of all CPU cores in Mhz.",
    "SHARED_BLOCKS: Internal",
    "FREE_MEMORY: The total amount of free memory.",
    "FREE_SWAP: The total amount of free swap memory.",
    "KEY_STATE: Maintains the state of key qualifiers such as caps-lock and the shift keys."
  )

  enum("RP", { start=1, comment="Path types for SetResourcePath()" },
    "MODULE_PATH: An alternative path leading to the system modules (normally 'system:modules/').  Introduced for platforms such as Android, where modules are stored in asset folders.",
    "SYSTEM_PATH: The path of the 'system:' volume, which otherwise defaults to '[root]:system/'.",
    "ROOT_PATH: Overrides the root path, which defaults to the location at which Parasol is installed.")

  flags("CLF", { comment="Flags for the MetaClass." },
    "SHARED_ONLY|SHARED_OBJECTS: Forces all objects of this class to be shared.",
    "PRIVATE_ONLY: Do not allow shared-memory instances of the class (private-shared objects will still be possible).",
    "PROMOTE_INTEGRAL: Promote class support for any integral object defined in the class definition structure.",
    "PUBLIC_OBJECTS: Forces all class objects to be allocated in shared memory.",
    "XML_CONTENT: Script processing should treat any object content as XML.",
    "NO_OWNERSHIP: Objects created will not be tracked to the creating process, nor any parent object (SetOwner() will not work either).")

  flags("CNF", { comment="Flags for the Config class." },
    "STRIP_QUOTES: Removes quotes from key values that are quote-encapsulated.",
    "AUTO_SAVE: When the configuration object is freed, automatically save the configuration data back to the original file source.",
    "OPTIONAL_FILES: Files are optional (do not fail if a requested file does not exist).",
    "NEW: On initialisation, do not load any data from the referenced configuration file.")

  flags("KSF", { comment="Flags for VarNew()" },
    "CASE: Enable case-sensitive keys.",
    "THREAD_SAFE: Enable thread safety for a small performance penalty.",
    "UNTRACKED: Do not track the key-store to the object with the current context.",
    "AUTO_REMOVE: Automatically call FreeResource() on remaining key values when FreeResource() is called for the key-store.",
    "INTERNAL: Private.")

-- Please note that when the user is using an international keyboard, the name of the key will not
-- actually match what the symbol represents for some key types.

  const("K", { comment="Raw key codes" }, {
    A = 1,
    B = 2,
    C = 3,
    D = 4,
    E = 5,
    F = 6,
    G = 7,
    H = 8,
    I = 9,
    J = 10,
    K = 11,
    L = 12,
    M = 13,
    N = 14,
    O = 15,
    P = 16,
    Q = 17,
    R = 18,
    S = 19,
    T = 20,
    U = 21,
    V = 22,
    W = 23,
    X = 24,
    Y = 25,
    Z = 26,
    ONE   = 27,
    TWO   = 28,
    THREE = 29,
    FOUR  = 30,
    FIVE  = 31,
    SIX   = 32,
    SEVEN = 33,
    EIGHT = 34,
    NINE  = 35,
    ZERO  = 36,
    REVERSE_QUOTE = 37,
    MINUS         = 38,
    EQUALS        = 39,
    L_SQUARE      = 40,
    R_SQUARE      = 41,
    SEMI_COLON    = 42,
    APOSTROPHE    = 43,
    COMMA         = 44,
    PERIOD        = 45,
    DOT           = 45, -- Synonym
    SLASH         = 46,
    BACK_SLASH    = 47,
    SPACE         = 48,
    -- Keypad keys
    NP_0        = 49,
    NP_1        = 50,
    NP_2        = 51,
    NP_3        = 52,
    NP_4        = 53,
    NP_5        = 54,
    NP_6        = 55,
    NP_7        = 56,
    NP_8        = 57,
    NP_9        = 58,
    NP_MULTIPLY = 59,
    NP_PLUS     = 60,
    NP_SEPARATOR = 61,
    NP_BAR      = 61, -- Synonym
    NP_MINUS    = 62,
    NP_DECIMAL  = 63,
    NP_DOT      = 63,   -- Synonym
    NP_DIVIDE   = 64,
    L_CONTROL   = 65,   -- Left Control
    R_CONTROL   = 66,   -- Right Control
    HELP        = 67,   -- Help
    L_SHIFT     = 68,   -- Left Shift
    R_SHIFT     = 69,   -- Right Shift
    CAPS_LOCK   = 70,   -- Caps Lock
    PRINT       = 71,   -- Print (not print-screen!)
    L_ALT       = 72,   -- Left Alt
    R_ALT       = 73,   -- Right Alt
    L_COMMAND   = 74,   -- Left Amiga/Win/Special
    R_COMMAND   = 75,   -- Right Amiga/Win/Special
    F1          = 76,   -- Function Key 1
    F2          = 77,   -- Function Key 2
    F3          = 78,   -- Function Key 3
    F4          = 79,   -- Function Key 4
    F5          = 80,   -- Function Key 5
    F6          = 81,   -- Function Key 6
    F7          = 82,   -- Function Key 7
    F8          = 83,   -- Function Key 8
    F9          = 84,   -- Function Key 9
    F10         = 85,   -- Function Key 10
    F11         = 86,   -- Function Key 11
    F12         = 87,   -- Function Key 12
    F13         = 88,   -- Function Key 13
    F14         = 89,   -- Function Key 14
    F15         = 90,   -- Function Key 15
    F16         = 91,   -- Function Key 16
    F17         = 92,   -- Function Key 17
    MACRO       = 93,
    NP_PLUS_MINUS = 94,  -- Plus/Minus on some numeric keypads
    LESS_GREATER  = 95,  -- Less/Greater key on foreign keyboards (no US equivalent?)
    UP          = 96,    -- Cursor Up
    DOWN        = 97,    -- Cursor Down
    RIGHT       = 98,    -- Cursor Right
    LEFT        = 99,    -- Cursor Left
    SCR_LOCK    = 100,   -- Scroll Lock
    PAUSE       = 101,   -- Pause
    WAKE        = 102,   -- Wake
    SLEEP       = 103,   -- Sleep
    POWER       = 104,   -- Power
    BACKSPACE   = 105,   -- Backspace
    TAB         = 106,   -- Tabulation
    ENTER       = 107,   -- Enter/Return
    ESCAPE      = 108,   -- Escape
    DELETE      = 109,   -- Delete
    CLEAR       = 110,   -- Clear
    HOME        = 111,   -- Home
    PAGE_UP     = 112,   -- Page Up
    PAGE_DOWN   = 113,   -- Page Down
    END         = 114,   -- End
    SELECT      = 115,   -- Select
    EXECUTE     = 116,   -- Execute
    INSERT      = 117,   -- Insert
    UNDO        = 118,   -- Undo
    REDO        = 119,   -- Redo
    MENU        = 120,   -- Menu / Shortcut / Application key
    FIND        = 121,   -- Find
    CANCEL      = 122,   -- Cancel
    BREAK       = 123,   -- Break
    NUM_LOCK    = 124,   -- Number lock
    PRT_SCR     = 125,   -- Print Screen
    NP_ENTER    = 126,   -- Numeric keypad enter
    SYSRQ       = 127,
    F18         = 128,
    F19         = 129,
    F20         = 130,
    WIN_CONTROL = 131,   -- Special MS internal control key, doesn't map to a real key
    -- A lot of the following are derived from Android
    VOLUME_UP   = 132,
    VOLUME_DOWN = 133,
    BACK        = 134, -- Not the same as backspace!
    CALL        = 135,
    END_CALL    = 136,
    CAMERA      = 137,
    AT          = 138,
    PLUS        = 139,
    LENS_FOCUS  = 140,
    STOP        = 141,
    NEXT        = 142,
    PREVIOUS    = 143,
    FORWARD     = 144,
    REWIND      = 145,
    MUTE        = 146,
    STAR        = 147, -- As seen on phone keypads
    POUND       = 148, -- As seen on phone keypads
    PLAY        = 149,
    -- End marker
    LIST_END    = 150
  })

  c_insert([[

#ifndef __GNUC__
#define __attribute__(a)
#endif

#define VER_CORE (1.0f)  // Core version + revision
#define REV_CORE (0)     // Core revision as a whole number

#ifdef  __cplusplus
extern "C" {
#endif

#define MODULE_COREBASE struct CoreBase *CoreBase = 0;

#ifndef STRINGIFY
#define STRINGIFY(x) #x
#define TOSTRING(x) STRINGIFY(x)
#endif

#define MOD_IDL NULL

#ifdef MOD_NAME
#define PARASOL_MOD(init,close,open,expunge,version) MODULE_HEADER = { MODULE_HEADER_VERSION, MHF_DEFAULT, version, VER_CORE, MOD_IDL, init, close, open, expunge, NULL, TOSTRING(MOD_NAME), NULL };
#define MOD_PATH ("modules:" TOSTRING(MOD_NAME))
#endif

#ifdef DEBUG
#define MSG(...)  LogF(0,__VA_ARGS__)
#define FMSG(...) LogF(__VA_ARGS__)
#define LOGRETURN()    LogReturn()
#else
#define MSG(...)
#define FMSG(...)
#define LOGRETURN()
#endif
#define LOG FMSG
#define LOGBACK LOGRETURN

#define PRIVATE_FIELDS

#undef  NULL    // Turn off any previous definition of NULL
#define NULL 0  // NULL is a value of 0

#define skipwhitespace(a) while ((*(a) > 0) && (*(a) <= 0x20)) (a)++;

#define ARRAYSIZE(a) ((LONG)(sizeof(a)/sizeof(a[0])))

#define ROUNDUP(a,b) (((a) + (b)) - ((a) % (b))) // ROUNDUP(Number, Alignment) e.g. (14,8) = 16

#define ALIGN64(a) (((a) + 7) & (~7))
#define ALIGN32(a) (((a) + 3) & (~3))
#define ALIGN16(a) (((a) + 1) & (~1))

#define CODE_MEMH 0x4D454D48L
#define CODE_MEMT 0x4D454D54L

#ifdef PRINTF64I
  #define PF64() "%I64d"
#else
  #define PF64() "%lld"
#endif

// Use DEBUG_BREAK in critical areas where you would want to break in gdb.  This feature will only be compiled
// in to debug builds.

#ifdef DEBUG
 #define DEBUG_BREAK asm("int $3");
#else
 #define DEBUG_BREAK
#endif

#ifdef  __cplusplus
}
#endif

//****************************************************************************
// Endian management routines.

#ifdef REVERSE_BYTEORDER

// CPU is little endian (Intel, ARM)

#define wrb_long(a,b) ((LONG *)(b))[0] = (a)
#define wrb_word(a,b) ((WORD *)(b))[0] = (a)

INLINE ULONG cpu_be32(ULONG x) {
   return ((((UBYTE)x)<<24)|(((UBYTE)(x>>8))<<16)|((x>>8) & 0xff00)|(x>>24));
}

#define be32_cpu(x) ((x<<24)|((x<<8) & 0xff0000)|((x>>8) & 0xff00)|(x>>24))
#define cpu_be16(x) ((x<<8)|(x>>8))
#define be16_cpu(x) ((x<<8)|(x>>8))

#else

// CPU is big endian (Motorola)

#define wrb_long(a,b) (b)[0] = (UBYTE)(a); (b)[1] = (UBYTE)((a)>>8); (b)[2] = (UBYTE)((a)>>16); (b)[3] = (UBYTE)((a)>>24)
#define wrb_word(a,b) (b)[0] = (UBYTE)(a); (b)[1] = (UBYTE)((a)>>8)

#define cpu_be32(x) (x)
#define be32_cpu(x) (x)
#define cpu_be16(x) (x)
#define be16_cpu(x) (x)
#endif

// Fast float-2-int conversion, with rounding to the nearest integer (F2I) and truncation (F2T)

#if defined(__GNUC__) && defined(__x86__)

INLINE LONG F2I(DOUBLE val) {
   // This will round if the CPU is kept in its default rounding mode
   LONG ret;
   asm ("fistpl %0" : "=m" (ret) : "t" (val) : "st");
   return(ret);
}

#else

INLINE LONG F2I(DOUBLE val) {
   DOUBLE t = val + 6755399441055744.0;
   return *((int *)(&t));
}

#endif

INLINE LONG F2T(DOUBLE val) // For numbers no larger than 16 bit, standard (LONG) is faster than F2T().
{
   if ((val > 32767.0) OR (val < -32767.0)) return((LONG)val);
   else {
      val = val + (68719476736.0 * 1.5);
#ifdef REVERSE_BYTEORDER
      return ((LONG *)(APTR)&val)[0]>>16;
#else
      return ((LONG *)&val)[1]>>16;
#endif
   }
}

//#define F2T(a) LONG(a)

// Structures to pass to OpenCore()

struct OpenTag {
   LONG Tag;
   union {
      LONG Long;
      LARGE Large;
      APTR Pointer;
      CSTRING String;
   } Value;
};

struct OpenInfo {
   LONG    Flags;           // OPF flags need to be set for fields that have been defined in this structure.
   CSTRING Name;            // OPF_NAME
   CSTRING Copyright;       // OPF_COPYRIGHT
   CSTRING Date;            // OPF_DATE
   CSTRING Author;          // OPF_AUTHOR
   FLOAT   CoreVersion;     // OPF_CORE_VERSION
   LONG    JumpTable;       // OPF_JUMPTABLE
   LONG    MaxDepth;        // OPF_MAX_DEPTH
   LONG    Detail;          // OPF_DETAIL
   CSTRING *Args;           // OPF_ARGS
   LONG    ArgCount;        // OPF_ARGS
   ERROR   Error;           // OPF_ERROR
   FLOAT   CompiledAgainst; // OPF_COMPILED_AGAINST
   CSTRING SystemPath;      // OPF_SYSTEM_PATH
   CSTRING ModulePath;      // OPF_MODULE_PATH
   CSTRING RootPath;        // OPF_ROOT_PATH
   struct OpenTag *Options; // OPF_OPTIONS Typecast to va_list (defined in stdarg.h)
};

// Flags for defining fields, methods, actions and functions.  CLASSDEF's can only be used in field definitions for
// classes.  FUNCDEF's can only be used in argument definitions for methods, actions and functions.

#ifdef _LP64
#define FD_PTR64 FD_POINTER
#else
#define FD_PTR64 0
#endif

// Field flags for classes.  These are intended to simplify field definitions, e.g. using FDF_BYTEARRAY combines
// FD_ARRAY with FD_BYTE.  DO NOT use these for function definitions, they are not intended to be compatible.

// Sizes/Types

#define FT_POINTER  FD_POINTER
#define FT_FLOAT    FD_FLOAT
#define FT_LONG     FD_LONG
#define FT_DOUBLE   FD_DOUBLE
#define FT_LARGE    FD_LARGE
#define FT_STRING   (FD_POINTER|FD_STRING)
#define FT_UNLISTED FD_UNLISTED
#define FT_VARIABLE FD_VARIABLE

// Class field definitions.  See core.h for all FD definitions.

#define FDF_BYTE       FD_BYTE
#define FDF_WORD       FD_WORD     // Field is word sized (16-bit)
#define FDF_LONG       FD_LONG     // Field is long sized (32-bit)
#define FDF_DOUBLE     FD_DOUBLE   // Field is double floating point sized (64-bit)
#define FDF_LARGE      FD_LARGE    // Field is large sized (64-bit)
#define FDF_POINTER    FD_POINTER  // Field is an address pointer (typically 32-bit)
#define FDF_ARRAY      FD_ARRAY    // Field is a pointer to an array
#define FDF_PTR        FD_POINTER
#define FDF_VARIABLE   FD_VARIABLE
#define FDF_SYNONYM    FD_SYNONYM

#define FDF_UNSIGNED    (FD_UNSIGNED)
#define FDF_FUNCTION    (FD_FUNCTION)           // sizeof(struct rkFunction) - use FDF_FUNCTIONPTR for sizeof(APTR)
#define FDF_FUNCTIONPTR (FD_FUNCTION|FD_POINTER)
#define FDF_STRUCT      (FD_STRUCT)
#define FDF_RESOURCE    (FD_RESOURCE)
#define FDF_OBJECT      (FD_POINTER|FD_OBJECT)   // Field refers to another object
#define FDF_OBJECTID    (FD_LONG|FD_OBJECT)      // Field refers to another object by ID
#define FDF_INTEGRAL    (FD_POINTER|FD_INTEGRAL) // Field refers to an integral object
#define FDF_STRING      (FD_POINTER|FD_STRING)   // Field points to a string.  NB: Ideally want to remove the FD_POINTER as it should be redundant
#define FDF_STR         (FDF_STRING)
#define FDF_PERCENTAGE  FD_PERCENTAGE
#define FDF_FLAGS       FD_FLAGS                // Field contains flags
#define FDF_ALLOC       FD_ALLOC                // Field is a dynamic allocation - either a memory block or object
#define FDF_LOOKUP      FD_LOOKUP               // Lookup names for values in this field
#define FDF_READ        FD_READ                 // Field is readable
#define FDF_WRITE       FD_WRITE                // Field is writeable
#define FDF_INIT        FD_INIT                 // Field can only be written prior to Init()
#define FDF_SYSTEM      FD_SYSTEM
#define FDF_ERROR       (FD_LONG|FD_ERROR)
#define FDF_REQUIRED    FD_REQUIRED
#define FDF_RGB         (FD_RGB|FD_BYTE|FD_ARRAY)
#define FDF_R           (FD_READ)
#define FDF_W           (FD_WRITE)
#define FDF_RW          (FD_READ|FD_WRITE)
#define FDF_RI          (FD_READ|FD_INIT)
#define FDF_I           (FD_INIT)
#define FDF_VIRTUAL     FD_VIRTUAL
#define FDF_LONGFLAGS   (FDF_LONG|FDF_FLAGS)
#define FDF_FIELDTYPES  (FD_LONG|FD_DOUBLE|FD_LARGE|FD_POINTER|FD_VARIABLE|FD_BYTE|FD_ARRAY|FD_FUNCTION)

// These constants have to match the FD* constants << 32

#define TDOUBLE   0x8000000000000000LL
#define TLONG     0x4000000000000000LL
#define TVAR      0x2000000000000000LL
#define TFLOAT    0x1000000000000000LL // NB: Floats are upscaled to doubles when passed as v-args.
#define TPTR      0x0800000000000000LL
#define TLARGE    0x0400000000000000LL
#define TFUNCTION 0x0200000000000000LL
#define TSTR      0x0080000000000000LL
#define TRELATIVE 0x0020000000000000LL
#define TARRAY    0x0000100000000000LL
#define TPERCENT  TRELATIVE
#define TAGEND    0LL
#define TAGDIVERT -1LL
#define TSTRING   TSTR
#define TREL      TRELATIVE

#define ResolveAddress(a,b)  ((APTR)(((BYTE *)(a)) + (b)))

#define FreeFromLL(a,b,c) if ((a)->Prev) (a)->Prev->Next = (a)->Next; \
                          if ((a)->Next) (a)->Next->Prev = (a)->Prev; \
                          if ((a) == (b)) { \
                             (c) = (void *)((a)->Next); \
                             if ((a)->Next) (a)->Next->Prev = 0; \
                          } \
                          (a)->Prev = 0; \
                          (a)->Next = 0;

#define nextutf8(str) if (*(str)) for (++(str); (*(str) & 0xc0) IS 0x80; (str)++);

//********************************************************************************************************************
// FieldValue is used to simplify the initialisation of new objects.

namespace parasol {
struct FieldValue {
   ULONG FieldID;
   LONG Type;
   union {
      CSTRING String;
      APTR    Pointer;
      CPTR    CPointer;
      DOUBLE  Double;
      LARGE   Large;
      LONG    Long;
   };

   constexpr FieldValue(ULONG pFID, CSTRING pValue) : FieldID(pFID), Type(FD_STRING), String(pValue) { };
   constexpr FieldValue(ULONG pFID, LONG pValue)    : FieldID(pFID), Type(FD_LONG), Long(pValue) { };
   constexpr FieldValue(ULONG pFID, LARGE pValue)   : FieldID(pFID), Type(FD_LARGE), Large(pValue) { };
   constexpr FieldValue(ULONG pFID, DOUBLE pValue)  : FieldID(pFID), Type(FD_DOUBLE), Double(pValue) { };
   constexpr FieldValue(ULONG pFID, APTR pValue)    : FieldID(pFID), Type(FD_POINTER), Pointer(pValue) { };
   constexpr FieldValue(ULONG pFID, CPTR pValue)    : FieldID(pFID), Type(FD_POINTER), CPointer(pValue) { };
};
}

#include <string.h> // memset()
#include <stdlib.h> // strtol(), strtod()
]])

  struct("ObjectSignal", { comment="Required in calls to WaitForObjects()." }, [[
     obj Object
  ]])

  struct("ResourceManager", { comment="This structure must be placed at the start of any memory block allocated with the MEM_MANAGED flag.", restrict="c" }, [[
     cstr Name            # The name of the resource.
     fptr(void ptr) Free  # A function that will remove the resource's content when terminated.
  ]])

  struct("rkBase64Decode", { type="base64decode", comment="Private structure for the Base64Decode() function." }, [[
    uchar Step                # Internal
    uchar PlainChar           # Internal
    bit(uchar) Initialised    # Internal
  ]])

  struct("rkBase64Encode", { type="base64encode", comment="Private structure for the Base64Encode() function." }, [[
    uchar Step             # Internal
    uchar Result           # Internal
    int StepCount          # Internal
  ]])

  struct("FeedSubscription", { }, [[
    oid SubscriberID    # Subscriber ID
    mem MessagePortMID  # Message port for the subscriber
    cid ClassID         # Class of the subscriber
  ]])

  struct("FunctionField", { comment="Used by ActionTable and Function structures to declare lists of parameters." }, [[
    cstr Name   # Name of the field
    uint Type   # Type of the field
  ]])

  struct("Function", { comment="Function list array structure" }, [[
    ptr Address     # Pointer to the function entry point
    cstr Name       # Name of the function
    cstruct(*FunctionField) Args  # A list of parameters accepted by the function
  ]])

  struct("ModHeader", { comment="Module file header", restrict="c" }, [[
    int HeaderVersion              # The version of this structure.
    int Flags                      # Special flags, type of function table wanted from the Core
    float ModVersion               # Version of this module
    float CoreVersion              # Core version compiled against
    cstr Definitions               # Module definition string, usable by run-time languages such as Fluid
    fptr(error obj struct(*CoreBase)) Init # A one-off initialisation routine for when the module is first opened.
    fptr(void obj) Close           # A function that will be called each time the module is closed.
    fptr(error obj) Open           # A function that will be called each time the module is opened.
    fptr(error) Expunge            # Reference to an expunge function to terminate the module.
    cstruct(*Function) DefaultList # Pointer to default function list
    cstr Name                      # Name of the module
    struct(*ModuleMaster) Master   # Private, must be set to zero
  ]])

  struct("FieldArray", { comment="Used to construct class blueprints for the MetaClass." }, [[
    cstr   Name      # The name of the field, e.g. "Width"
    uint   Flags     # Special flags that describe the field
    maxint Arg       # Can be a pointer or an integer value
    ptr    GetField  # void GetField(*Object, APTR Result);
    ptr    SetField  # ERROR SetField(*Object, APTR Value);
  ]])

  struct("FieldDef", { comment="Used to define constants for field references." }, [[
    cstr Name  # The name of the constant.
    int Value  # The value of the constant.
  ]])

  struct("SystemState", { comment="Returned by the GetSystemState() function." }, [[
    array(cstr) ErrorMessages  # A sorted array of all error codes, translated into human readable strings.
    cstr RootPath              # The current root path, which defaults to the location of the installation folder.
    cstr SystemPath            # The current path of the 'system:' volume.
    cstr ModulePath            # The current path to the system modules, normally 'system:modules/'
    cstr Platform              # String-based field indicating the user's platform.  Currently returns 'Native', 'Windows', 'OSX' or 'Linux'.
    hhandle ConsoleFD          # Internal
    int  CoreVersion           # Reflects the Core version number.
    int  CoreRevision          # Reflects the Core revision number.
    int  InstanceID            # This is the ID of the instance that the calling process resides in.
    int  TotalErrorMessages    # The total number of error codes listed in the ErrorMessages array.
    int  Stage                 # The current operating stage.  -1 = Initialising, 0 indicates normal operating status; 1 means that the program is shutting down; 2 indicates a program restart; 3 is for mode switches.
  ]])

  struct("Variable", { }, [[
    uint   Type     # Field definition flags
    int    Unused   # Unused 32-bit value for 64-bit alignment
    large  Large    # The value as a 64-bit integer.
    double Double   # The value as a 64-bit float-point number.
    ptr    Pointer  # The value as an address pointer.
  ]])

------------------------------------------------------------------------------

  -- Structures for defining method and action invocations.

  struct("ActionArray", { }, [[
    int ActionCode  # Action identifier
    ptr Routine     # Pointer to the function entry point
  ]])

  struct("MethodArray", { restrict="c" }, [[
    int  MethodID   # Unique method identifier
    ptr  Routine    # The method entry point, defined as ERROR (*Routine)(OBJECTPTR, APTR);
    cstr Name       # Name of the method
    cstruct(*FunctionField) Args  # List of parameters accepted by the method
    int  Size       # Total byte-size of all accepted parameters when they are assembled as a C structure.
  ]])

  struct("MemoryLocks", { comment="A supplement structure for ListTasks." }, [[
    mem  MemoryID  # Reference to a memory ID.
    short Locks    # The total number of locks on the memory block.
  ]])

  struct("ActionTable", { comment="Structure for ActionList" }, [[
    uint Hash   # Hash of the action name.
    int  Size   # Byte-size of the structure for this action.
    cstr Name   # Name of the action.
    cstruct(*FunctionField) Args  # List of fields that are passed to this action.
  ]])

  struct("ChildEntry", { comment="Structure for ListChildren() function" }, [[
    oid ObjectID  # Object ID
    cid ClassID   # The class ID of the referenced object.
  ]])

  struct("ListTasks", { comment="Structure for ListTasks()" }, [[
     int     ProcessID         # Core process ID
     oid     TaskID            # Task ID for this array entry
     int     WaitingProcessID  # If the task is waiting, this field reflects the other task's ID
     mem     WaitingMemoryID   # If the task is waiting, this field reflects the memory ID
     int     WaitingTime       # If the task is waiting, the time at which the sleep started (msec)
     mem     MessageID         # Message queue ID
     oid     OutputID          # The object that the task should output information to
     hhandle Semaphore         # Semaphore for IPC
     int     InstanceID        # Instance that the task belongs to
     int     TotalMemoryLocks  # Total number of held memory locks
     oid     ModalID           # Refers to any surface that currently holds a modal lock.
     struct(*MemoryLocks) MemoryLocks # An array of memory locks currently held by the process.
  ]])

  struct("FDTable", { comment="Internal record for processing FD activity." }, [[
     hhandle FD           # The file descriptor that is managed by this record.
     fptr(void hhandle ptr) Routine  # The routine that will process read/write messages for the FD.
     ptr  Data            # A user specific data pointer.
     int Flags            # Set to RFD_READ, RFD_WRITE or RFD_EXCEPT.
  ]])

  struct("Message", { comment="Messaging structures.  Note: This structure is utilised by NextMsg" }, [[
     large Time    # A timestamp acquired from PreciseTime() when the message was first passed to SendMessage().
     int UniqueID  # A unique identifier automatically created by SendMessage().
     int Type      # A message type identifier as defined by the client.
     int Size      # The size of the message data, in bytes.  If there is no data associated with the message, the Size will be set to zero.</>
  ]])

  struct("ExposeMessage", { comment="Internal Core message structures.", restrict="c" }, [[
     oid ObjectID # Target surface
     int X        # Horizontal starting coordinate
     int Y        # Vertical starting coordinate
     int Width    # Width of exposed area
     int Height   # Height of exposed area
     int Flags    # Optional flags
  ]])

  struct("DebugMessage", { restrict="c" }, [[ int DebugID # Internal ]])

  struct("ThreadMessage", { restrict="c" }, [[ oid ThreadID # Internal ]])

  struct("ThreadActionMessage", { restrict="c", comment="An internal structure for managing actions executed via threads." }, [[
     obj   Object    # Direct pointer to a target object.
     int   ActionID  # The action to execute.
     int   Key       # Internal
     error Error     # The error code resulting from the action's execution.
     func  Callback  # Callback function to execute on action completion.
  ]])

  struct("MemInfo", { type="meminfo" }, [[
    ptr  Start         # The starting address of the memory block (does not apply to shared blocks).
    oid  ObjectID      # The object that owns the memory block.
    int  Size          # The size of the memory block.
    short AccessCount  # Total number of active locks on this block.
    short Flags        # The type of memory.
    mem  MemoryID      # The unique ID for this block.
    oid  LockID        # Reference to the task that currently has a lock on the block.
    oid  TaskID        # The Task that owns the memory block
    int  Handle        # Native system handle (e.g. the shmid in Linux)
  ]])

  struct("ActionEntry", { restrict="c" }, [[ fptr(error obj ptr) PerformAction # Internal ]])

  struct("MsgHandler", { restrict="c" }, [[
    ptr(struct(MsgHandler)) Prev  # Previous message handler in the chain
    ptr(struct(MsgHandler)) Next  # Next message handler in the chain
    ptr Custom                    # Custom pointer to send to the message handler
    func Function                 # Call this function
    int MsgType                   # Type of message being filtered
  ]])

  struct("KeyStore", { comment="Key-pair storage created by VarNew()" }, [[
    ptr Mutex                   # Internal mutex for managing thread-safety.
    ptr(struct(*KeyPair)) Data  # Key-pairs are stored here.
    int TableSize               # The size of the available storage area.
    int Total                   # Total number of currently stored key-pairs, including dead keys.
    int(KSF) Flags              # Optional flags used for VarNew()
  ]])

  struct("CacheFile", { restrict="c", comment="Internal structure for managing files cached by LoadFile()." }, [[
    large TimeStamp   # The file's last-modified timestamp.
    large Size        # Byte size of the cached data.
    large LastUse     # The last time that this file was requested.
    str Path          # Pointer to the resolved file path.
    ptr Data          # Pointer to the cached data.
    short Locks       # Internal count of active locks for this element.
    short PathLength  # Length of the Path string, including trailing zero.
  ]])

  struct("CompressionFeedback", { }, [[
    int(FDB) FeedbackID     # Set to one of the FDB event indicators
    int   Index             # Index of the current file
    cstr  Path              # Name of the current file/path in the archive
    cstr  Dest              # Destination file/path during decompression
    large Progress          # Progress indicator (byte position for the file being de/compressed).
    large OriginalSize      # Original size of the file
    large CompressedSize    # Compressed size of the file
    short Year              # Year of the original file's datestamp.
    short Month             # Month of the original file's datestamp.
    short Day               # Day of the original file's datestamp.
    short Hour              # Hour of the original file's datestamp.
    short Minute            # Minute of the original file's datestamp.
    short Second            # Second of the original file's datestamp.
  ]])

  struct("CompressedItem", { }, [[
    large OriginalSize            # Original size of the file
    large CompressedSize          # Compressed size of the file
    struct(*CompressedItem) Next  # Used only if this is a linked-list.
    cstr Path                     # Path to the file (includes folder prefixes).  Archived folders will include the trailing slash.
    struct(*KeyStore) Tags        # Any archive specific information is expressed here as key value pairs.
    int(PERMIT) Permissions       # Original permissions - see PERMIT flags.
    int  UserID                   # Original user ID
    int  GroupID                  # Original group ID
    int  OthersID                 # Original others ID
    int(FL) Flags                 # FL flags
    struct(DateTime) Created      # Date and time of the file's creation.
    struct(DateTime) Modified     # Date and time last modified.
  ]])

  struct("FileInfo", { comment="Returned by GetFileInfo()" }, [[
    large Size                 # The size of the file's content.
    large TimeStamp            # 64-bit time stamp - usable only for comparison (e.g. sorting).
    struct(*FileInfo) Next     # Next structure in the list, or NULL.
    str Name                   # The name of the file.  This string remains valid until the next call to GetFileInfo().
    struct(*KeyStore) Tags     # A store of special tag strings that are file-specific.
    int(FL) Flags              # Additional flags to describe the file.
    int(PERMIT) Permissions    # Standard permission flags.
    int UserID                 # User  ID (Unix systems only).
    int GroupID                # Group ID (Unix systems only).
    struct(DateTime) Created   # The date/time of the file's creation.
    struct(DateTime) Modified  # The date/time of the last file modification.
  ]]) -- NB: Private fields can follow this structure.

  struct("DirInfo", { comment="Used by OpenDir() only" }, [[
    struct(*FileInfo) Info # Pointer to a FileInfo structure
  ]],
  [[
   #ifdef PRV_FILE
   APTR   prvHandle;        // Directory handle.  If virtual, may store a private data address
   STRING prvPath;          // Original folder location string
   STRING prvResolvedPath;  // Resolved folder location
   LONG   prvFlags;         // OpenFolder() RDF flags
   LONG   prvTotal;         // Total number of items in the folder
   ULONG  prvVirtualID;     // Unique ID (name hash) for a virtual device
   union {
      LONG prvIndex;        // Current index within the folder when scanning
      APTR prvIndexPtr;
   };
   WORD   prvResolveLen;    // Byte length of ResolvedPath
   #endif
  ]])

  -- NB: Duplicated to windows.c
  struct("FileFeedback", { }, [[
    large Size          # Size of the file
    large Position      # Current seek position within the file if moving or copying
    str Path            # Path to the file
    str Dest            # Destination file/path if moving or copying
    int(FDB) FeedbackID # Set to one of the FDB integers
    char(32) Reserved   # Reserved in case of future expansion
  ]])

  struct("Field", { comment="Used to describe the public fields of a class." }, [[
    maxint Arg         # An option to complement the field type.  Can be a pointer or an integer value
    fptr(error ptr ptr) GetValue # A virtual function that will retrieve the value for this field.
    ptr SetValue       # A virtual function that will set the value for this field.
    fptr(error obj struct(*Field) int cptr int) WriteValue # An internal function for writing to this field.
    cstr Name          # The English name for the field, e.g. "Width"
    uint FieldID       # Provides a fast way of finding fields, e.g. FID_WIDTH
    ushort Offset      # Field offset within the object
    ushort Index       # Field array index
    uint Flags         # Special flags that describe the field
  ]]) -- [32/52]

  c_insert([[
struct ScriptArg { // For use with scExec
   CSTRING Name;
   ULONG Type;
   union {
      APTR   Address;
      LONG   Long;
      LARGE  Large;
      DOUBLE Double;
   };
};
]])

  functionNames(nil,
    "AccessMemory",
    "Action",
    "ActionList",
    "ActionMsg",
    "KeyGet",
    "ResolveClassID",
    "AllocateID",
    "AllocMemory",
    "AccessObject",
    "ListTasks",
    "CheckAction",
    "CheckMemoryExists",
    "CheckObjectExists",
    "DeleteFile",
    "CreateObject",
    "CurrentContext",
    "GetFieldArray",
    "AdjustLogLevel",
    "LogF",
    "FindObject",
    "FindClass",
    "ReleaseObject",
    "FreeResource",
    "FreeResourceID",
    "GetClassID",
    "GetOwnerID",
    "GetField",
    "GetFieldVariable",
    "GetFields",
    "GetName",
    "ListChildren",
    "Base64Decode",
    "RegisterFD",
    "ManageAction",
    "MemoryIDInfo",
    "MemoryPtrInfo",
    "NewObject",
    "NotifySubscribers",
    "StrReadLocale",
    "GetMemAddress",
    "ProcessMessages",
    "IdentifyFile",
    "ReallocMemory",
    "GetMessage",
    "ReleaseMemory",
    "ResolveClassName",
    "KeySet",
    "SendMessage",
    "SetOwner",
    "SetContext",
    "SetField",
    "SetFields",
    "ScanDir",
    "SetName",
    "LogReturn",
    "StrCompare",
    "SubscribeAction",
    "VarGet",
    "SubscribeEvent",
    "SubscribeTimer",
    "UpdateTimer",
    "UnsubscribeAction",
    "VarSet",
    "UnsubscribeEvent",
    "BroadcastEvent",
    "WaitTime",
    "GetEventID",
    "GenCRC32",
    "GetResource",
    "SetResource",
    "ScanMessages",
    "SysLock",
    "SysUnlock",
    "CopyMemory",
    "LoadFile",
    "SubscribeActionTags",
    "PrintDiagnosis",
    "NewLockedObject",
    "UpdateMessage",
    "AddMsgHandler",
    "FindPrivateObject",
    "PreciseTime",
    "OpenDir",
    "GetObjectPtr",
    "FindField",
    "VarIterate",
    "GetErrorMsg",
    "GetActionMsg",
    "FuncError",
    "SetArray",
    "ReleaseMemoryID",
    "AccessPrivateObject",
    "ReleasePrivateObject",
    "AllocMutex",
    "FreeMutex",
    "LockMutex",
    "UnlockMutex",
    "ActionThread",
    "VarNew",
    "AllocSharedMutex",
    "FreeSharedMutex",
    "LockSharedMutex",
    "UnlockSharedMutex",
    "VLogF",
    "StrSearch",
    "VarSetSized",
    "VarLock",
    "WakeProcess",
    "SetResourcePath",
    "CurrentTask",
    "KeyIterate",
    "ResolveGroupID",
    "StrCopy",
    "StrClone",
    "VarUnlock",
    "ResolveUserID",
    "CreateLink",
    "StrBuildArray",
    "UTF8CharOffset",
    "UTF8Length",
    "UTF8OffsetToChar",
    "UTF8PrevLength",
    "UTF8CharLength",
    "UTF8ReadValue",
    "UTF8WriteValue",
    "StrFormat",
    "WaitForObjects",
    "ReadFileToBuffer",
    "StrDatatype",
    "UnloadFile",
    "SetDefaultPermissions",
    "CompareFilePaths",
    "GetSystemState",
    "TranslateCmdRef",
    "AddInfoTag",
    "UTF8Copy",
    "Base64Encode",
    "VarSetString",
    "VarGetString",
    "VarCopy",
    "StrHash",
    "UTF8ValidEncoding",
    "AnalysePath",
    "CreateFolder",
    "MoveFile",
    "ResolvePath",
    "SetVolume",
    "DeleteVolume",
    "VirtualVolume",
    "CopyFile")

  c_insert([[

#define PRIME_HASH 2654435761UL
#define END_FIELD { NULL, 0, 0, NULL, NULL }
#define FDEF static const struct FunctionField

//****************************************************************************

#ifndef PRV_CORE_MODULE
#undef ActionMsg
#define ActionMsg(a,b,c)          (CoreBase->_ActionMsg(a,b,c,0,0))

#undef Action
#define Action(a,b,c) (CoreBase->_Action(a,b,c))

#define ActionMsgPort(a,b,c,d,e)  (CoreBase->_ActionMsg(a,b,c,d,e))
#define DeregisterFD(a)           (CoreBase->_RegisterFD((a), RFD_REMOVE|RFD_READ|RFD_WRITE|RFD_EXCEPT|RFD_ALWAYS_CALL, 0, 0))
#define DelayAction(a,b,c)        (CoreBase->_ActionMsg(a,b,c,0,(CLASSID)-1))
#define DelayMsg(a,b,c)           (CoreBase->_ActionMsg(a,b,c,0,(CLASSID)-1))
#define DeleteMsg(a,b)            (CoreBase->_UpdateMessage(a,b,(APTR)-1,0,0))
#define GetObjectAddress          (CoreBase->_GetMemAddress)

#undef NewLockedObject
#define NewLockedObject(a,b,c,d)  (CoreBase->_NewLockedObject(a,b,c,d,0))

#undef PrintDiagnosis
#define PrintDiagnosis()          (CoreBase->_PrintDiagnosis(NULL,NULL))

#define SendAction(a,b,c,d)       (CoreBase->_ActionMsg(a,b,c,d,0))

#define WaitMsg(a,b,c)            (CoreBase->_ActionMsg(a,b,c,0,-2))
#endif // PRV_CORE_MODULE

// Macros

#define GetParentContext()        ((OBJECTPTR)(MAXINT)GetResource(RES_PARENT_CONTEXT))
#define GetResourcePtr(a)         ((APTR)(MAXINT)GetResource((a)))
#define AllocPublicMemory(a,b,c)  (AllocMemory((a),(b)|MEM_PUBLIC,0,(c)))
#define AllocPrivateMemory(a,b,c) (AllocMemory((a),(b),(c),0))
#define NewPrivateObject(a,b,c)   (NewObject(a,b,c))
#define NewPublicObject(a,b,c)    (NewLockedObject(a,(b)|NF_PUBLIC,0,c))
#define NewNamedObject(a,b,c,d,e) (CoreBase->_NewLockedObject(a,(b)|NF_NAME,c,d,e))
#define StrMatch(a,b)             (StrCompare((a),(b),0,STR_MATCH_LEN))

extern struct CoreBase *CoreBase;

typedef std::map<std::string, std::string> ConfigKeys;
typedef std::pair<std::string, ConfigKeys> ConfigGroup;
typedef std::vector<ConfigGroup> ConfigGroups;

inline LONG StrLength(CSTRING String)
{
   if (String) return strlen(String);
   else return 0;
}

inline LARGE StrToInt(CSTRING String)
{
   if (!String) return 0;

   while ((*String < '0') or (*String > '9')) { // Ignore any leading characters
      if (!String[0]) return 0;
      else if (*String IS '-') break;
      else if (*String IS '+') break;
      else String++;
   }

   return strtoll(String, NULL, 0);
}

inline DOUBLE StrToFloat(CSTRING String)
{
   if (!String) return 0;

   // Ignore any leading characters

   while ((*String != '-') and (*String != '.') and ((*String < '0') or (*String > '9'))) {
      if (!*String) return 0;
      String++;
   }

   return strtod(String, NULL);
}

inline LONG IntToStr(LARGE Integer, STRING String, LONG StringSize) {
   return StrFormat(String, StringSize, PF64(), Integer);
}

inline ERROR ClearMemory(APTR Memory, LONG Length)
{
   if (!Memory) return ERR_NullArgs;
   memset(Memory, 0, Length); // memset() is assumed to be optimised by the compiler.
   return ERR_Okay;
}

// If AUTO_OBJECT_LOCK is enabled, objects will be automatically locked to prevent thread-clashes.
// NB: Turning this off will cause issues between threads unless they call the necessary locking functions.

//#define AUTO_OBJECT_LOCK 1

//********************************************************************************************************************
// Header used for all objects.

struct BaseClass { // Must be 64-bit aligned
   union {
      objMetaClass *Class;          // Class pointer, resolved on AccessObject()
      class extMetaClass *ExtClass; // Internal class reference
   };
   struct Stats *Stats;         // Stats pointer, resolved on AccessObject() [Private]
   APTR     ChildPrivate;       // Address for the ChildPrivate structure, if allocated
   APTR     CreatorMeta;        // The creator (via NewObject) is permitted to store a custom data pointer here.
   CLASSID  ClassID;            // Reference to the object's class, used to resolve the Class pointer
   CLASSID  SubID;              // Reference to the object's sub-class, used to resolve the Class pointer
   OBJECTID UID;                // Unique object identifier
   OBJECTID OwnerID;            // Refers to the owner of this object
   WORD     Flags;              // Object flags
   WORD     MemFlags;           // Recommended memory allocation flags
   OBJECTID TaskID;             // The process that this object belongs to
   volatile LONG  ThreadID;     // Managed by locking functions
   #ifdef _WIN32
      WINHANDLE ThreadMsg;      // Pipe for sending messages to the owner thread.
   #else
      LONG ThreadMsg;
   #endif
   UBYTE ThreadPending;         // ActionThread() increments this.
   volatile BYTE Queue;         // Managed by locking functions
   volatile BYTE SleepQueue;    //
   volatile bool Locked;        // Set if locked by AccessObject()/AccessPrivateObject()
   BYTE ActionDepth;            // Incremented each time an action or method is called on the object

   inline bool initialised() { return Flags & NF_INITIALISED; }
   inline bool isPublic() { return Flags & NF_PUBLIC; }
   inline OBJECTID ownerTask() { return TaskID; }
   inline OBJECTID ownerID() { return OwnerID; }
   inline LONG memflags() { return MemFlags; }
   inline LONG flags() { return Flags; }

   CSTRING className();

   inline bool collecting() { // Is object being freed or marked for collection?
      return Flags & (NF_FREE|NF_COLLECT);
   }

   inline bool terminating() { // Is object currently being freed?
      return Flags & NF_FREE;
   }

   inline ERROR threadLock() {
      #ifdef AUTO_OBJECT_LOCK
         if (INC_QUEUE(this) IS 1) {
            ThreadID = get_thread_id();
            return ERR_Okay;
         }
         else {
            if (ThreadID IS get_thread_id()) return ERR_Okay; // If this is for the same thread then it's a nested lock, so there's no issue.
            SUB_QUEUE(this); // Put the lock count back to normal before AccessPrivateObject()
            return AccessPrivateObject(this, -1); // Can fail if object is marked for deletion.
         }
      #else
         return ERR_Okay;
      #endif
   }

   inline void threadRelease() {
      #ifdef AUTO_OBJECT_LOCK
         if (SleepQueue > 0) ReleasePrivateObject(this);
         else SUB_QUEUE(this);
      #endif
   }

   // These are fast in-line calls for object locking.  They attempt to quickly 'steal' the
   // object lock if the queue value was at zero.

   inline LONG incQueue() {
      return __sync_add_and_fetch(&Queue, 1);
   }

   inline LONG subQueue() {
      return __sync_sub_and_fetch(&Queue, 1);
   }

   inline LONG incSleep() {
      return __sync_add_and_fetch(&SleepQueue, 1);
   }

   inline LONG subSleep() {
      return __sync_sub_and_fetch(&SleepQueue, 1);
   }

   inline bool hasOwner(OBJECTID ID) { // Return true if ID has ownership.
      auto oid = this->OwnerID;
      while ((oid) and (oid != ID)) oid = GetOwnerID(oid);
      return oid ? true : false;
   }

   inline ERROR set(ULONG FieldID, int Value)             { return SetField(this, (FIELD)FieldID|TLONG, Value); }
   inline ERROR set(ULONG FieldID, unsigned int Value)    { return SetField(this, (FIELD)FieldID|TLONG, Value); }
   inline ERROR set(ULONG FieldID, LARGE Value)           { return SetField(this, (FIELD)FieldID|TLARGE, Value); }
   inline ERROR set(ULONG FieldID, DOUBLE Value)          { return SetField(this, (FIELD)FieldID|TDOUBLE, Value); }
   inline ERROR set(ULONG FieldID, const FUNCTION *Value) { return SetField(this, (FIELD)FieldID|TFUNCTION, Value); }
   inline ERROR set(ULONG FieldID, const char *Value)     { return SetField(this, (FIELD)FieldID|TSTRING, Value); }
   inline ERROR set(ULONG FieldID, const unsigned char *Value) { return SetField(this, (FIELD)FieldID|TSTRING, Value); }
   inline ERROR set(ULONG FieldID, std::string &Value)    { return SetField(this, (FIELD)FieldID|TSTRING, Value.c_str()); }
   inline ERROR set(ULONG FieldID, const Variable *Value) { return SetField(this, (FIELD)FieldID|TVAR, Value); }
   // Works both for regular data pointers and function pointers if field is defined correctly.
   inline ERROR set(ULONG FieldID, const void *Value) { return SetField(this, (FIELD)FieldID|TPTR, Value); }

   inline ERROR setPercentage(ULONG FieldID, DOUBLE Value) { return SetField(this, (FIELD)FieldID|TDOUBLE|TPERCENT, Value); }

   inline ERROR get(ULONG FieldID, LONG *Value) { return GetField(this, (FIELD)FieldID|TLONG, Value); }
   inline ERROR get(ULONG FieldID, LARGE *Value) { return GetField(this, (FIELD)FieldID|TLARGE, Value); }
   inline ERROR get(ULONG FieldID, DOUBLE *Value) { return GetField(this, (FIELD)FieldID|TDOUBLE, Value); }
   inline ERROR get(ULONG FieldID, STRING *Value) { return GetField(this, (FIELD)FieldID|TSTRING, Value); }
   inline ERROR get(ULONG FieldID, CSTRING *Value) { return GetField(this, (FIELD)FieldID|TSTRING, Value); }
   inline ERROR get(ULONG FieldID, Variable *Value) { return GetField(this, (FIELD)FieldID|TVAR, Value); }
   inline ERROR getPtr(ULONG FieldID, APTR Value) { return GetField(this, (FIELD)FieldID|TPTR, Value); }
   inline ERROR getPercentage(ULONG FieldID, DOUBLE *Value) { return GetField(this, (FIELD)FieldID|TDOUBLE|TPERCENT, Value); }

} __attribute__ ((aligned (8)));

namespace parasol {

class Log { // C++ wrapper for Parasol's log functionality
   private:
      LONG branches = 0;

   public:
      CSTRING header;

      Log() {
         header = NULL;
      }

      Log(CSTRING Header) {
         header = Header;
      }

      ~Log() {
         while (branches > 0) { branches--; LogReturn(); }
      }

      void branch(CSTRING Message = "", ...) __attribute__((format(printf, 2, 3))) {
         va_list arg;
         va_start(arg, Message);
         VLogF(VLF_API|VLF_BRANCH, header, Message, arg);
         va_end(arg);
         branches++;
      }

      #ifdef DEBUG
      void traceBranch(CSTRING Message = "", ...) __attribute__((format(printf, 2, 3))) {
         va_list arg;
         va_start(arg, Message);
         VLogF(VLF_TRACE|VLF_BRANCH, header, Message, arg);
         va_end(arg);
         branches++;
      }
      #else
      void traceBranch(CSTRING Message = "", ...) __attribute__((format(printf, 2, 3))) { }
      #endif

      void debranch() {
         branches--;
         LogReturn();
      }

      void app(CSTRING Message, ...) { // Info level, recommended for applications only
         va_list arg;
         va_start(arg, Message);
         VLogF(VLF_INFO, header, Message, arg);
         va_end(arg);
      }

      void msg(CSTRING Message, ...) __attribute__((format(printf, 2, 3))) { // Defaults to API level, recommended for modules
         va_list arg;
         va_start(arg, Message);
         VLogF(VLF_API, header, Message, arg);
         va_end(arg);
      }

      void msg(LONG Flags, CSTRING Message, ...) __attribute__((format(printf, 3, 4))) { // Defaults to API level, recommended for modules
         va_list arg;
         va_start(arg, Message);
         VLogF(Flags, header, Message, arg);
         va_end(arg);
         if (Flags & VLF_BRANCH) branches++;
      }

      void extmsg(CSTRING Message, ...) __attribute__((format(printf, 2, 3))) { // Extended API message
         va_list arg;
         va_start(arg, Message);
         VLogF(VLF_EXTAPI, header, Message, arg);
         va_end(arg);
      }

      void pmsg(CSTRING Message, ...) __attribute__((format(printf, 2, 3))) { // "Parent message", uses the scope of the caller
         va_list arg;
         va_start(arg, Message);
         VLogF(VLF_API, NULL, Message, arg);
         va_end(arg);
      }

      void warning(CSTRING Message, ...) __attribute__((format(printf, 2, 3))) {
         va_list arg;
         va_start(arg, Message);
         VLogF(VLF_WARNING, header, Message, arg);
         va_end(arg);
      }

      void error(CSTRING Message, ...) __attribute__((format(printf, 2, 3))) { // NB: Use for messages intended for the user, not the developer
         va_list arg;
         va_start(arg, Message);
         VLogF(VLF_ERROR, header, Message, arg);
         va_end(arg);
      }

      void debug(CSTRING Message, ...) __attribute__((format(printf, 2, 3))) {
         va_list arg;
         va_start(arg, Message);
         VLogF(VLF_DEBUG, header, Message, arg);
         va_end(arg);
      }

      void function(CSTRING Message, ...) __attribute__((format(printf, 2, 3))) { // Equivalent to branch() but without a new branch being created
         va_list arg;
         va_start(arg, Message);
         VLogF(VLF_API|VLF_FUNCTION, header, Message, arg);
         va_end(arg);
      }

      ERROR error(ERROR Code) { // Technically a warning
         FuncError(header, Code);
         return Code;
      }

      ERROR warning(ERROR Code) {
         FuncError(header, Code);
         return Code;
      }

      void trace(CSTRING Message, ...) {
         #ifdef DEBUG
            va_list arg;
            va_start(arg, Message);
            VLogF(VLF_TRACE, header, Message, arg);
            va_end(arg);
         #endif
      }

      void traceWarning(CSTRING Message, ...) {
         #ifdef DEBUG
            va_list arg;
            va_start(arg, Message);
            VLogF(VLF_WARNING, header, Message, arg);
            va_end(arg);
         #endif
      }
};

template<class T = BaseClass>
class Create {
   private:
      T *obj;

   public:
      ERROR error;

      // Create a scoped object

      Create(std::initializer_list<FieldValue> Fields) : obj(NULL) {
         parasol::Log log("CreateObject");
         log.branch(T::CLASS_NAME);

         if (!NewObject(T::CLASS_ID, NF_CREATE_OBJECT, (BaseClass **)&obj)) {
            for (auto &f : Fields) {
               OBJECTPTR target;
               if (auto field = FindField(obj, f.FieldID, &target)) {
                  if ((!(field->Flags & (FD_INIT|FD_WRITE))) and (CurrentContext() != target)) {
                     error = log.warning(ERR_NoFieldAccess);
                     return;
                  }
                  else if ((field->Flags & FD_INIT) and (target->initialised()) and (CurrentContext() != target)) {
                     error = log.warning(ERR_NoFieldAccess);
                     return;
                  }
                  else {
                     target->threadLock();

                     if (f.Type & (FD_POINTER|FD_STRING|FD_FUNCTION|FD_VARIABLE)) {
                        error = field->WriteValue(target, field, f.Type, f.Pointer, 0);
                     }
                     else if (f.Type & (FD_DOUBLE|FD_FLOAT)) {
                        error = field->WriteValue(target, field, f.Type, &f.Double, 1);
                     }
                     else if (f.Type & FD_LARGE) {
                        error = field->WriteValue(target, field, f.Type, &f.Large, 1);
                     }
                     else {
                        error = field->WriteValue(target, field, f.Type, &f.Long, 1);
                     }

                     target->threadRelease();

                     if (error) return;
                  }
               }
               else { error = log.warning(ERR_UnsupportedField); return; }
            }

            if (!(error = acInit(obj))) return;
         }
         else error = ERR_NewObject;
      }

      ~Create() {
         if (obj) { acFree(obj); obj = NULL; }
      }

      T * operator->() { return obj; }; // Promotes underlying methods and fields
      T * & operator*() { return obj; }; // To allow object pointer referencing when calling functions

      inline bool ok() { return error == ERR_Okay; }
};
}

#define ClassName(a) ((a)->Class->Name)

inline OBJECTID CurrentTaskID() { return ((OBJECTPTR)CurrentTask())->UID; }
inline APTR SetResourcePtr(LONG Res, APTR Value) { return (APTR)(MAXINT)(CoreBase->_SetResource(Res, (MAXINT)Value)); }
#define CONV_TIME_DATETIME(a) ((DateTime *)(&(a)->Year))

inline BYTE CMP_DATETIME(DateTime *one, DateTime *two)
{
   if (one->Year < two->Year) return -1;
   if (one->Year > two->Year) return 1;
   if (one->Month < two->Month) return -1;
   if (one->Month > two->Month) return 1;
   if (one->Day < two->Day) return -1;
   if (one->Day > two->Day) return 1;
   if (one->Minute < two->Minute) return -1;
   if (one->Minute > two->Minute) return 1;
   if (one->Hour < two->Hour) return -1;
   if (one->Hour > two->Hour) return 1;
   if (one->Second < two->Second) return -1;
   if (one->Second > two->Second) return 1;
   return 0;
}

// Macro based actions.

#define SetRead(a,b,c)  a.Buffer=(b);   a.Length=(c);
#define SetSeek(a,b,c)  a.Position=(b); a.Offset=(c);
#define SetWrite(a,b,c) a.Buffer=(b);   a.Length=(c);

// Action and Notification Structures

struct acActionNotify  { union { ACTIONID ActionID; ACTIONID Action; }; union { OBJECTID ObjectID; OBJECTID Object; }; APTR Args; LONG Size; ERROR Error; LONG Time; };
struct acClipboard     { LONG Mode; };
struct acCopyData      { union { OBJECTID DestID; OBJECTID Dest; }; };
struct acCustom        { LONG Number; CSTRING String; };
struct acDataFeed      { union { OBJECTID ObjectID; OBJECTID Object; }; union { LONG DataType; LONG Datatype; }; const void *Buffer; LONG Size; };
struct acDragDrop      { union { OBJECTID SourceID; OBJECTID Source; }; LONG Item; CSTRING Datatype; };
struct acDraw          { LONG X; LONG Y; LONG Width; LONG Height; };
struct acGetVar        { CSTRING Field; STRING Buffer; LONG Size; };
struct acMove          { DOUBLE DeltaX; DOUBLE DeltaY; DOUBLE DeltaZ; };
struct acMoveToPoint   { DOUBLE X; DOUBLE Y; DOUBLE Z; LONG Flags; };
struct acNewChild      { OBJECTPTR Object; };
struct acNewOwner      { union { OBJECTID NewOwnerID; OBJECTID NewOwner; }; CLASSID ClassID; };
struct acRead          { APTR Buffer; LONG Length; LONG Result; };
struct acRedimension   { DOUBLE X; DOUBLE Y; DOUBLE Z; DOUBLE Width; DOUBLE Height; DOUBLE Depth; };
struct acRedo          { LONG Steps; };
struct acRename        { CSTRING Name; };
struct acResize        { DOUBLE Width; DOUBLE Height; DOUBLE Depth; };
struct acSaveImage     { union { OBJECTID DestID; OBJECTID Dest; }; union { CLASSID ClassID; CLASSID Class; }; };
struct acSaveToObject  { union { OBJECTID DestID; OBJECTID Dest; }; union { CLASSID ClassID; CLASSID Class; }; };
struct acScroll        { DOUBLE DeltaX; DOUBLE DeltaY; DOUBLE DeltaZ; };
struct acScrollToPoint { DOUBLE X; DOUBLE Y; DOUBLE Z; LONG Flags; };
struct acSeek          { DOUBLE Offset; LONG Position; };
struct acSelectArea    { DOUBLE X; DOUBLE Y; DOUBLE Width; DOUBLE Height; };
struct acSetVar        { CSTRING Field; CSTRING Value; };
struct acUndo          { LONG Steps; };
struct acWrite         { CPTR Buffer; LONG Length; LONG Result; };

// Action Macros

inline ERROR acActivate(OBJECTPTR Object) { return Action(AC_Activate,Object,NULL); }
inline ERROR acClear(OBJECTPTR Object) { return Action(AC_Clear,Object,NULL); }
inline ERROR acDeactivate(OBJECTPTR Object) { return Action(AC_Deactivate,Object,NULL); }
inline ERROR acDisable(OBJECTPTR Object) { return Action(AC_Disable,Object,NULL); }
inline ERROR acDraw(OBJECTPTR Object) { return Action(AC_Draw,Object,NULL); }
inline ERROR acEnable(OBJECTPTR Object) { return Action(AC_Enable,Object,NULL); }
inline ERROR acFlush(OBJECTPTR Object) { return Action(AC_Flush,Object,NULL); }
inline ERROR acFocus(OBJECTPTR Object) { return Action(AC_Focus,Object,NULL); }
inline ERROR acFree(OBJECTPTR Object) { return Action(AC_Free,Object,NULL); }
inline ERROR acHide(OBJECTPTR Object) { return Action(AC_Hide,Object,NULL); }
inline ERROR acInit(OBJECTPTR Object) { return Action(AC_Init,Object,NULL); }
inline ERROR acLock(OBJECTPTR Object) { return Action(AC_Lock,Object,NULL); }
inline ERROR acLostFocus(OBJECTPTR Object) { return Action(AC_LostFocus,Object,NULL); }
inline ERROR acMoveToBack(OBJECTPTR Object) { return Action(AC_MoveToBack,Object,NULL); }
inline ERROR acMoveToFront(OBJECTPTR Object) { return Action(AC_MoveToFront,Object,NULL); }
inline ERROR acNext(OBJECTPTR Object) { return Action(AC_Next,Object,NULL); }
inline ERROR acPrev(OBJECTPTR Object) { return Action(AC_Prev,Object,NULL); }
inline ERROR acQuery(OBJECTPTR Object) { return Action(AC_Query,Object,NULL); }
inline ERROR acRefresh(OBJECTPTR Object) { return Action(AC_Refresh, Object, NULL); }
inline ERROR acReset(OBJECTPTR Object) { return Action(AC_Reset,Object,NULL); }
inline ERROR acSaveSettings(OBJECTPTR Object) { return Action(AC_SaveSettings,Object,NULL); }
inline ERROR acShow(OBJECTPTR Object) { return Action(AC_Show,Object,NULL); }
inline ERROR acSort(OBJECTPTR Object) { return Action(AC_Sort,Object,NULL); }
inline ERROR acUnlock(OBJECTPTR Object) { return Action(AC_Unlock,Object,NULL); }

inline ERROR acClipboard(OBJECTPTR Object, LONG Mode) {
   struct acClipboard args = { Mode };
   return Action(AC_Clipboard, Object, &args);
}

inline ERROR acDragDrop(OBJECTPTR Object, OBJECTID Source, LONG Item, CSTRING Datatype) {
   struct acDragDrop args = { Source, Item, Datatype };
   return Action(AC_DragDrop, Object, &args);
}

inline ERROR acDrawArea(OBJECTPTR Object, LONG X, LONG Y, LONG Width, LONG Height) {
   struct acDraw args = { X, Y, Width, Height };
   return Action(AC_Draw, Object, &args);
}

inline ERROR acDataFeed(OBJECTPTR Object, OBJECTID ObjectID, LONG Datatype, const void *Buffer, LONG Size) {
   struct acDataFeed args = { { ObjectID }, { Datatype }, Buffer, Size };
   return Action(AC_DataFeed, Object, &args);
}

inline ERROR acMove(OBJECTPTR Object, DOUBLE X, DOUBLE Y, DOUBLE Z) {
   struct acMove args = { X, Y, Z };
   return Action(AC_Move, Object, &args);
}

inline ERROR acRead(OBJECTPTR Object, APTR Buffer, LONG Bytes, LONG *Read) {
   ERROR error;
   struct acRead read = { (BYTE *)Buffer, Bytes };
   if (!(error = Action(AC_Read, Object, &read))) {
      if (Read) *Read = read.Result;
      return ERR_Okay;
   }
   else {
      if (Read) *Read = 0;
      return error;
   }
}

inline ERROR acRedo(OBJECTPTR Object, LONG Steps) {
   struct acRedo args = { Steps };
   return Action(AC_Redo, Object, &args);
}

inline ERROR acRedimension(OBJECTPTR Object, DOUBLE X, DOUBLE Y, DOUBLE Z, DOUBLE Width, DOUBLE Height, DOUBLE Depth) {
   struct acRedimension args = { X, Y, Z, Width, Height, Depth };
   return Action(AC_Redimension, Object, &args);
}

inline ERROR acRename(OBJECTPTR Object, CSTRING Name) {
   struct acRename args = { Name };
   return Action(AC_Rename, Object, &args);
}

inline ERROR acResize(OBJECTPTR Object, DOUBLE Width, DOUBLE Height, DOUBLE Depth) {
   struct acResize args = { Width, Height, Depth };
   return Action(AC_Resize, Object, &args);
}

inline ERROR acScroll(OBJECTPTR Object, DOUBLE X, DOUBLE Y, DOUBLE Z) {
   struct acScroll args = { X, Y, Z };
   return Action(AC_Scroll, Object, &args);
}

inline ERROR acScrollToPoint(OBJECTPTR Object, DOUBLE X, DOUBLE Y, DOUBLE Z, LONG Flags) {
   struct acScrollToPoint args = { X, Y, Z, Flags };
   return Action(AC_ScrollToPoint, Object, &args);
}

inline ERROR acUndo(OBJECTPTR Object, LONG Steps) {
   struct acUndo args = { Steps };
   return Action(AC_Undo, Object, &args);
}

inline ERROR acGetVar(OBJECTPTR Object, CSTRING FieldName, STRING Buffer, LONG Size) {
   struct acGetVar args = { FieldName, Buffer, Size };
   ERROR error = Action(AC_GetVar, Object, &args);
   if ((error) and (Buffer)) Buffer[0] = 0;
   return error;
}

inline ERROR acMoveToPoint(OBJECTPTR Object, DOUBLE X, DOUBLE Y, DOUBLE Z, LONG Flags) {
   struct acMoveToPoint moveto = { X, Y, Z, Flags };
   return Action(AC_MoveToPoint, Object, &moveto);
}

inline ERROR acSaveImage(OBJECTPTR Object, OBJECTID DestID, CLASSID ClassID) {
   struct acSaveImage args = { { DestID }, { ClassID } };
   return Action(AC_SaveImage, Object, &args);
}

inline ERROR acSaveToObject(OBJECTPTR Object, OBJECTID DestID, CLASSID ClassID) {
   struct acSaveToObject args = { { DestID }, { ClassID } };
   return Action(AC_SaveToObject, Object, &args);
}

inline ERROR acSeek(OBJECTPTR Object, DOUBLE Offset, LONG Position) {
   struct acSeek args = { Offset, Position };
   return Action(AC_Seek, Object, &args);
}

inline ERROR acSetVars(OBJECTPTR Object, CSTRING tags, ...) {
   struct acSetVar args;
   va_list list;

   va_start(list, tags);
   while ((args.Field = va_arg(list, STRING)) != TAGEND) {
      args.Value = va_arg(list, STRING);
      if (Action(AC_SetVar, Object, &args) != ERR_Okay) {
         va_end(list);
         return ERR_Failed;
      }
   }
   va_end(list);
   return ERR_Okay;
}

inline ERROR acWrite(OBJECTPTR Object, CPTR Buffer, LONG Bytes, LONG *Result) {
   ERROR error;
   struct acWrite write = { (BYTE *)Buffer, Bytes };
   if (!(error = Action(AC_Write, Object, &write))) {
      if (Result) *Result = write.Result;
   }
   else if (Result) *Result = 0;
   return error;
}

inline LONG acWriteResult(OBJECTPTR Object, CPTR Buffer, LONG Bytes) {
   struct acWrite write = { (BYTE *)Buffer, Bytes };
   if (!Action(AC_Write, Object, &write)) return write.Result;
   else return 0;
}

#define acSeekStart(a,b)    acSeek((a),(b),SEEK_START)
#define acSeekEnd(a,b)      acSeek((a),(b),SEEK_END)
#define acSeekCurrent(a,b)  acSeek((a),(b),SEEK_CURRENT)

inline ERROR acSelectArea(OBJECTPTR Object, DOUBLE X, DOUBLE Y, DOUBLE Width, DOUBLE Height) {
   struct acSelectArea area = { X, Y, Width, Height };
   return Action(AC_SelectArea, Object, &area);
}

inline ERROR acSetVar(OBJECTPTR Object, CSTRING FieldName, CSTRING Value) {
   struct acSetVar args = { FieldName, Value };
   return Action(AC_SetVar, Object, &args);
}

#define GetVar(a,b,c,d)  acGetVar(a,b,c,d)
#define SetVar(a,b,c)    acSetVar(a,b,c)
]])

  class("StorageDevice", { src="../classes/class_storagedevice.cpp" }, [[
    large(DEVICE) DeviceFlags  # Flags identifying the type of media
    large DeviceSize           # Size of the device
    large BytesFree            # Bytes available to the user
    large BytesUsed            # Bytes already used
  ]])

  methods("File", "Fl", {
    { id=1,  name="StartStream" },
    { id=2,  name="StopStream" },
    { id=3,  name="Delete" },
    { id=4,  name="Move" },
    { id=5,  name="Copy" },
    { id=6,  name="SetDate" },
    { id=7,  name="ReadLine", inline=false },
    { id=8,  name="BufferContent" },
    { id=9,  name="Next" },
    { id=10, name="Watch" }
  })

  class("File", { version=1.2, src="../classes/class_file.cpp", output="../classes/class_file_def.c" }, [[
    large     Position  # The current read/write byte position in a file.
    int(FL)   Flags     # File flags and options.
    int       Static    # Set to TRUE if a file object should be static.
    oid       Target    # Specifies a surface ID to target for user feedback and dialog boxes.
    ptr(char) Buffer    # Points to the internal data buffer if the file content is held in memory.
  ]])

  methods("config", "Cfg", {
    { id=1,  name="ReadValue" },
    { id=2,  name="ReadIValue" },
    { id=3,  name="WriteValue" },
    { id=4,  name="DeleteKey" },
    { id=5,  name="DeleteGroup" },
    { id=6,  name="GetGroupFromIndex" },
    { id=7,  name="SortByKey" },
    { id=9,  name="MergeFile" },
    { id=10, name="Merge" },
    { id=11, name="Set" }
  })

  class("Config", { src="../classes/class_config.cpp", output="../classes/class_config_def.c" }, [[
    str Path          # The location pointer
    str KeyFilter     # Enables key filtering, removing any unwanted keys on load.
    str GroupFilter   # Enables group filtering, removing any unwanted groups on load.
    int(CNF) Flags    # Not currently in use
  ]])

  c_insert([[
inline ERROR cfgWrite(OBJECTPTR Self, CSTRING Group, CSTRING Key, LONG Integer)
{
   if (!Self) return ERR_NullArgs;
   char buffer[32];
   StrFormat(buffer, sizeof(buffer), "%d", Integer);
   struct cfgWriteValue write = { Group, Key, buffer };
   return Action(MT_CfgWriteValue, Self, &write);
}

inline ERROR cfgRead(OBJECTPTR Self, CSTRING Group, CSTRING Key, DOUBLE *Value)
{
   ERROR error;
   struct cfgReadValue read = { .Group = Group, .Key = Key };
   if (!(error = Action(MT_CfgReadValue, Self, &read))) {
      *Value = StrToFloat(read.Data);
      return ERR_Okay;
   }
   else { *Value = 0; return error; }
}

inline ERROR cfgRead(OBJECTPTR Self, CSTRING Group, CSTRING Key, LONG *Value)
{
   ERROR error;
   struct cfgReadValue read = { .Group = Group, .Key = Key };
   if (!(error = Action(MT_CfgReadValue, Self, &read))) {
      *Value = StrToInt(read.Data);
      return ERR_Okay;
   }
   else { *Value = 0; return error; }
}
  ]])

  methods("Script", "Sc", {
    { id=1, name="Exec" },
    { id=2, name="DerefProcedure" },
    { id=3, name="Callback" },
    { id=4, name="GetProcedureID" }
  })

  class("Script", { src={ "../classes/class_script.cpp" }, output="../classes/class_script_def.c" }, [[
    oid Target           # The object that script objects must be initialised to, e.g. for obj.new()
    int(SCF) Flags       # Optional flags
    error Error          # If an error occurred, this field will indicate the error number
    int CurrentLine      # Current line being executed, or failed line if script execution terminated
    int LineOffset       # An optional offset to use when reporting line numbers
  ]],
  [[
   LARGE    ProcedureID;          // For callbacks
   KeyStore *Vars;                // Global parameters
   STRING   *Results;
   char     Language[4];          // 3-character language code, null-terminated
   const ScriptArg *ProcArgs;     // Procedure args - applies during Exec
   STRING   Path;                 // File location of the script
   STRING   String;
   STRING   WorkingPath;
   STRING   ErrorString;
   CSTRING  Procedure;
   STRING   CacheFile;
   LONG     ActivationCount;      // Incremented every time the script is activated.
   LONG     ResultsTotal;
   LONG     TotalArgs;            // Total number of ProcArgs
   char     LanguageDir[32];      // Directory to use for language files
   OBJECTID ScriptOwnerID;
  ]])

  methods("MetaClass", "mc", {
    { id=1, name="FindField" }
  })

  class("MetaClass", { src="../classes/class_metaclass.cpp" }, [[
    double ClassVersion    # Version of the class
    struct(*MethodArray) Methods # Original method array supplied by the module.
    cstruct(*FieldArray) Fields  # Original field array supplied by the module.
    cstr ClassName         # Name of the class
    cstr FileExtension     # File extension that is supported by this class.
    cstr FileDescription   # File description
    cstr FileHeader        # Internal file header for identifying the file
    cstr Path              # Module path to the class
    int Size               # Byte-size of the class when produced as an object
    int(CLF) Flags         # Special flags
    cid SubClassID         # Sub-class ID
    cid BaseClassID        # Base-class ID
    int OpenCount          # Number of objects allocated to this class
    int TotalMethods       # Total number of methods
    int TotalFields        # Total number of fields, including any additional standard fields like 'Name'
    int(CCF) Category      # Assigned category
  ]])

  methods("Task", "Task", {
    { id=1, name="Expunge" },
    { id=2, name="AddArgument" },
    { id=3, name="Quit" },
    { id=4, name="GetEnv" },
    { id=5, name="SetEnv" },
    { id=6, name="CloseInstance" }
  })

  class("Task", { src="../classes/class_task.cpp", output="../classes/class_task_def.c" }, [[
    double TimeOut
    int Flags
    int ReturnCode
    int ProcessID    # Native process ID of the activated task
  ]])

  methods("Thread", "Th", {
    { id=1, name="SetData" },
    { id=2, name="Wait" }
  })

  class("Thread", { src="../classes/class_thread.cpp", output="../classes/class_thread_def.c" }, [[
   ptr   Data         # User data pointer.
   int   DataSize     # Size of user data.
   int   StackSize    # Pre-set stack size
   error Error        # Error code returned by the thread on completion.
   int   Flags        # Optional flags.
  ]])

  c_insert([[
// Private task list control structure.

#define MAX_MEMLOCKS 64  // Maximum number of non-blocking memory locks allowed per task

struct TaskList {
   LARGE    CreationTime;  // Time at which the task slot was created
   LONG     ProcessID;     // Core process ID
   OBJECTID TaskID;        // Task ID for this array entry.  Also see the ParentID field
   MEMORYID MessageID;     // Message queue ID
   OBJECTID OutputID;      // The object that the task should output information to
   LONG     InstanceID;    // Instance that the task belongs to
   LONG     ReturnCode;    // Return code
   OBJECTID ParentID;      // The task responsible for creating this task slot
   OBJECTID ModalID;       // Set if a modal surface is to have the user's attention
   LONG     EventMask;     // The events that this task is listening to
   WORD     Returned:1;    // Process has finished (the ReturnCode is set)
   WORD     Index;         // Index in the shTasks array
   #ifdef _WIN32
      WINHANDLE Lock;      // The semaphore to signal when a message is sent to the task
   #endif
   struct   {
      MEMORYID MemoryID;
      WORD     AccessCount;
   } NoBlockLocks[MAX_MEMLOCKS+1]; // Allow for a NULL entry at the end of the array
};
  ]])

  methods("Module", "Mod", {
    { id=1,  name="ResolveSymbol" },
  })

  class("Module", { src="../classes/class_module.cpp" }, [[
    double Version                  # Minimum required version of the module
    cstruct(*Function) FunctionList # Array of functions
    ptr ModBase                     # Ptr to function jump table
    struct(*ModuleMaster) Master    # Shared details on the module
    struct(*ModHeader) Header       # For creating in-memory modules only.
    int(MOF) Flags                  # Optional flags
  ]])

  -- Note that the fields following SystemTime are identical to struct DateTime

  methods("Time", "Tm", {
    { id=1, name="SetTime" },
  })

  class("Time", { src="../classes/class_time.cpp" }, [[
    large SystemTime  # Total number of microseconds passed since the system base time
    int Year          # Year   (-ve for BC, +ve for AD)
    int Month         # Month  (1 - 12)
    int Day           # Day    (1 - 31)
    int Hour          # Hour   (0 - 23)
    int Minute        # Minute (0 - 59)
    int Second        # Second (0 - 59)
    int TimeZone      # 0 is GMT, range is +1300 or -1300
    int DayOfWeek     # Day of week (0 = Sunday ..)
    int MilliSecond   # Millisecond (0 - 999)
    int MicroSecond   # Microsecond  (0 - 999999)
  ]])

  methods("Compression", "Cmp", {
    { id=1, name="CompressBuffer" },
    { id=2, name="CompressFile" },
    { id=3, name="DecompressBuffer" },
    { id=4, name="DecompressFile" },
    { id=5, name="RemoveFile" },
    { id=6, name="CompressStream" },
    { id=7, name="DecompressStream" },
    { id=8, name="CompressStreamStart" },
    { id=9, name="CompressStreamEnd" },
    { id=10, name="DecompressStreamEnd" },
    { id=11, name="DecompressStreamStart" },
    { id=12, name="DecompressObject" },
    { id=13, name="Scan" },
    { id=14, name="Find" }
  })

  class("Compression", { src={ "../compression/class_compression.cpp", "../compression/compression_fields.cpp" }, output="../compression/class_compression_def.c" }, [[
    large TotalOutput       # Total number of bytes output (e.g. during compression of a stream)
    oid Output              # Reference to output object for user messages
    int CompressionLevel    # Compression level (percentage - 0% none, 100% high)
    int(CMF) Flags          # Optional flags
    int SegmentSize         # Splits the compressed file if it surpasses a set byte limit (e.g. 1.44MB)
    int(PERMIT) Permissions # Default permissions to use for decompressed files
    int MinOutputSize       # Minimum recommended output buffer size
    int WindowBits          # Window bits, currently applicable to the default (zlib) compression
  ]])

  class("CompressedStream", { src="../compression/class_compressed_stream.cpp", output="../compression/class_compressed_stream_def.c" }, [[
    large TotalOutput  # Count of the total bytes that have been output.
    obj Input          # The object that is the source of the compressed data.
    obj Output         # The object that is the destination for the compressed data.
    int(CF) Format     # CF_GZIP, CF_ZLIB, CF_DEFLATE
  ]])

  c_insert([[
#ifndef PRV_CORE

// Note that the length of the data is only needed when messaging between processes, so we can skip it for these
// direct-access data channel macros.

#define acDataContent(a,b)  acDataFeed((a),0,DATA_CONTENT,(b),0)
#define acDataXML(a,b)      acDataFeed((a),0,DATA_XML,(b),0)
#define acDataText(a,b)     acDataFeed((a),0,DATA_TEXT,(b),0)

inline ERROR acCustom(OBJECTID ObjectID, LONG Number, CSTRING String) {
   struct acCustom args = { Number, String };
   return ActionMsg(AC_Custom, ObjectID, &args);
}

inline ERROR acDataFeed(OBJECTID ObjectID, OBJECTID SenderID, LONG Datatype, const APTR Data, LONG Size) {
   struct acDataFeed channel = { { SenderID }, { Datatype }, Data, Size };
   return ActionMsg(AC_DataFeed, ObjectID, &channel);
}

inline ERROR acDragDrop(OBJECTID ObjectID, OBJECTID Source, LONG Item, CSTRING Datatype) {
   struct acDragDrop args = { { Source }, Item, Datatype };
   return ActionMsg(AC_DragDrop, ObjectID, &args);
}

inline ERROR acDrawArea(OBJECTID ObjectID, LONG X, LONG Y, LONG Width, LONG Height) {
   struct acDraw draw = { X, Y, Width, Height };
   return ActionMsg(AC_Draw, ObjectID, &draw);
}

inline ERROR acMove(OBJECTID ObjectID, DOUBLE X, DOUBLE Y, DOUBLE Z = 0) {
   struct acMove move = { X, Y, Z };
   return ActionMsg(AC_Move, ObjectID, &move);
}

inline ERROR acMoveToPoint(OBJECTID ObjectID, DOUBLE X, DOUBLE Y, DOUBLE Z = 0, LONG Flags = MTF_X|MTF_Y) {
   struct acMoveToPoint moveto = { X, Y, Z, Flags };
   return ActionMsg(AC_MoveToPoint, ObjectID, &moveto);
}

inline ERROR acRedimension(OBJECTID ObjectID, DOUBLE X, DOUBLE Y, DOUBLE Z, DOUBLE Width, DOUBLE Height, DOUBLE Depth) {
   struct acRedimension resize = { X, Y, Z, Width, Height, Depth };
   return ActionMsg(AC_Redimension, ObjectID, &resize);
}

inline ERROR acResize(OBJECTID ObjectID, DOUBLE Width, DOUBLE Height, DOUBLE Depth) {
   struct acResize resize = { Width, Height, Depth };
   return ActionMsg(AC_Resize, ObjectID, &resize);
}

inline ERROR acScrollToPoint(OBJECTID ObjectID, DOUBLE X, DOUBLE Y, DOUBLE Z = 0, LONG Flags = STP_X|STP_Y) {
   struct acScrollToPoint scroll = { X, Y, Z, Flags };
   return ActionMsg(AC_ScrollToPoint, ObjectID, &scroll);
}

inline ERROR acScroll(OBJECTID ObjectID, DOUBLE X, DOUBLE Y, DOUBLE Z = 0) {
   struct acScroll scroll = { X, Y, Z };
   return ActionMsg(AC_Scroll, ObjectID, &scroll);
}

inline ERROR acSelectArea(OBJECTID ObjectID, DOUBLE X, DOUBLE Y, DOUBLE Width, DOUBLE Height) {
   struct acSelectArea area = { X, Y, Width, Height };
   return ActionMsg(AC_SelectArea, ObjectID, &area);
}

inline ERROR acActivate(OBJECTID ObjectID) { return ActionMsg(AC_Activate, ObjectID, NULL); }
inline ERROR acClear(OBJECTID ObjectID) { return ActionMsg(AC_Clear, ObjectID, NULL); }
inline ERROR acDisable(OBJECTID ObjectID) { return ActionMsg(AC_Disable, ObjectID, NULL); }
inline ERROR acDraw(OBJECTID ObjectID) { return ActionMsg(AC_Draw, ObjectID, NULL); }
inline ERROR acEnable(OBJECTID ObjectID) { return ActionMsg(AC_Enable, ObjectID, NULL); }
inline ERROR acFlush(OBJECTID ObjectID) { return ActionMsg(AC_Flush, ObjectID, NULL); }
inline ERROR acFocus(OBJECTID ObjectID) { return ActionMsg(AC_Focus, ObjectID, NULL); }
inline ERROR acFree(OBJECTID ObjectID) { return ActionMsg(AC_Free, ObjectID, NULL); }
inline ERROR acHide(OBJECTID ObjectID) { return ActionMsg(AC_Hide, ObjectID, NULL); }
inline ERROR acInit(OBJECTID ObjectID) { return ActionMsg(AC_Init, ObjectID, NULL); }
inline ERROR acLostFocus(OBJECTID ObjectID) { return ActionMsg(AC_LostFocus, ObjectID, NULL); }
inline ERROR acMoveToBack(OBJECTID ObjectID) { return ActionMsg(AC_MoveToBack, ObjectID, NULL); }
inline ERROR acMoveToFront(OBJECTID ObjectID) { return ActionMsg(AC_MoveToFront, ObjectID, NULL); }
inline ERROR acQuery(OBJECTID ObjectID) { return ActionMsg(AC_Query, ObjectID, NULL); }
inline ERROR acRefresh(OBJECTID ObjectID) { return ActionMsg(AC_Refresh, ObjectID, NULL); }
inline ERROR acSaveSettings(OBJECTID ObjectID) { return ActionMsg(AC_SaveSettings, ObjectID, NULL); }
inline ERROR acShow(OBJECTID ObjectID) { return ActionMsg(AC_Show, ObjectID, NULL); }

// The number of bytes written is not returned (you would need to use DelayMsg() for that).

inline ERROR acWrite(OBJECTID ObjectID, CPTR Buffer, LONG Bytes) {
   struct acWrite write = { (BYTE *)Buffer, Bytes };
   return ActionMsg(AC_Write, ObjectID, &write);
}

inline ERROR LoadModule(CSTRING Name, FLOAT Version, OBJECTPTR *Module, APTR Functions) {
   OBJECTPTR module;
   if (!CreateObject(ID_MODULE, 0, &module,
         FID_Name|TSTR,   Name,
         FID_Version|TFLOAT, Version,
         TAGEND)) {
      APTR functionbase;
      if (!GetField(module, FID_ModBase|TPTR, &functionbase)) {
         if (Module) *Module = module;
         if (Functions) ((APTR *)Functions)[0] = functionbase;
         return ERR_Okay;
      }
      else return ERR_GetField;
   }
   else return ERR_CreateObject;
}

inline FIELD ResolveField(CSTRING Field) {
   return StrHash(Field, FALSE);
}

#endif // PRV_CORE

#ifdef __unix__
#include <pthread.h>
#endif

#ifdef __system__

// Public memory management structures.

struct PublicAddress {
   LARGE    AccessTime;        // The time at which the block was accessed
   MEMORYID MemoryID;          // Unique memory ID
   LONG     Size;              // Size of the memory block
   LONG     Offset;            // Offset of the memory block within the page file
   OBJECTID ObjectID;          // Object that the address belongs to
   OBJECTID TaskID;            // The task that the block is tracked back to
   OBJECTID ContextID;         // Context that locked the memory block (for debugging purposes only)
   LONG     InstanceID;        // Reference to the instance that this memory block is restricted to
   WORD     ActionID;          // Action that locked the memory block (for debugging purposes only)
   WORD     Flags;             // Special MEM_ address flags
   volatile UBYTE AccessCount;  // Count of locks on this address
   volatile UBYTE ExternalLock; // Incremented when a third party requires access during a lock
   #ifdef __unix__
      volatile LONG ThreadLockID;      // Globally unique ID from get_thread_id()
      volatile LONG ProcessLockID;     // If locked, this field refers to the ID of the semaphore that locked the block
   #endif
   #ifdef _WIN32
      LONG      OwnerProcess;   // The process ID of the task that created the block as referred to by Offset
      WINHANDLE Handle;         // Memory handle, if block does not belong to the core memory pool
      volatile OBJECTID ProcessLockID;  // If locked, refers to the ID of the process that locked it
      volatile LONG     ThreadLockID;   // If locked, the global thread ID of the locker.
   #endif
};

struct SortedAddress {
   MEMORYID MemoryID;
   LONG Index;
};

// Semaphore management structure.

#define MAX_SEMAPHORES  40  // Maximum number of semaphores that can be allocated in the system

struct SemaphoreEntry {   // The index of each semaphore in the array indicates their IDs
   ULONG NameID;          // Hashed name of the semaphore
   LONG  InstanceID;      // Reference to the instance that this semaphore is restricted to
   LONG  BlockingProcess; // Process ID of the blocker
   LONG  BlockingThread;  // Global thread ID of the blocker
   LARGE Data;            // User configurable 64-bit data
   WORD  Flags;           // Status flags
   WORD  BlockingValue;   // Value used for blocking access
   WORD  MaxValue;        // Semaphore maximum value
   WORD  Counter;         // When the counter reaches zero, the semaphore is blocked
   struct SemProcess {
      LONG ProcessID;
      UBYTE AllocCount;      // Number of times that this process has allocated the semaphore with AllocSemaphore()
      UBYTE BlockCount;      // Count of blocking locks currently recorded
      UBYTE AccessCount;     // Count of access locks currently recorded
      UBYTE BufferCount;     // Buffered accesses (this value increases instead of AccessCount when the BlockCount is set)
   } Processes[20];
   //LONG     FIFO[10];       // List of processes currently queued for access
};

// Message structure and internal ID's for standard Task-to-Task messages.

struct ActionMessage {
   WORD ActionID;            // ID of the action or method to execute
   UWORD SendArgs:1;         //
   UWORD ReturnResult:1;     // Set to TRUE if a result is required
   UWORD Delayed:1;          // TRUE if the message was intentionally delayed
   MEMORYID ReturnMessage;   // If ReturnResult is TRUE, the message queue for the result message must be set here
   OBJECTID ObjectID;        // The object that is to receive the action
   ERROR Error;              // If a result is required, the action's error code is returned here by MSGID_ACTIONRESULT
   LONG  Time;
   // Action arguments follow this structure in a buffer
};

#endif

enum { // For SysLock()
   PL_WAITLOCKS=1,
   PL_PUBLICMEM,
   PL_FORBID,
   PL_PROCESSES,
   PL_SEMAPHORES,
   #ifdef _WIN32
      CN_PUBLICMEM,
      CN_SEMAPHORES,
   #endif
   PL_END
};

struct SharedControl {
   LONG PoolSize;                   // Amount of allocated page space (starts at zero and expands)
   volatile LONG BlocksUsed;        // Total amount of shared memory blocks currently allocated
   LONG MaxBlocks;                  // Maximum amount of available blocks
   volatile LONG NextBlock;         // Next empty position in the blocks table
   volatile LONG IDCounter;         // ID counter
   volatile LONG PrivateIDCounter;  // ID counter for private memory blocks
   volatile LONG MessageIDCount;    // Counter of message ID's
   volatile LONG ClassIDCount;      // Counter of class ID's
   volatile LONG GlobalIDCount;     // Counter for general ID's
   volatile LONG ThreadIDCount;
   volatile LONG InputTotal;        // Total number of subscribers in InputMID
   volatile LONG ValidateProcess;
   volatile LONG InputIDCounter;    // Counter for input event subscriptions
   WORD SystemState;
   volatile WORD WLIndex;           // Current insertion point for the wait-lock array.
   LONG MagicKey;                   // This magic key is set to the semaphore key (used only as an indicator for initialisation)
   LONG BlocksOffset;               // Array of available shared memory pages
   LONG SortedBlocksOffset;         // Array of shared memory blocks sorted by MemoryID
   LONG SemaphoreOffset;            // Offset to the semaphore control array
   LONG TaskOffset;                 // Offset to the task control array
   LONG MemoryOffset;               // Offset to the shared memory allocations
   LONG WLOffset;                   // Offset to the wait-lock array
   LONG GlobalInstance;             // If glSharedControl belongs to a global instance, this is the PID of the creator.
   LONG SurfaceSemaphore;
   LONG InputSize;                  // Maximum number of subscribers allowed in InputMID
   LONG InstanceMsgPort;            // The message port of the process that created the instance.
   MEMORYID SurfacesMID;
   MEMORYID ClassesMID;             // Class database
   MEMORYID ModulesMID;             // Module database
   MEMORYID InputMID;
   LONG ClassSemaphore;             // Semaphore for controlling access to the class database
   #ifdef __unix__
      struct {
         pthread_mutex_t Mutex;
         pthread_cond_t Cond;
         LONG PID;               // Resource tracking: Process that has the current lock.
         WORD Count;             // Resource tracking: Count of all locks (nesting)
      } PublicLocks[PL_END];
   #elif _WIN32
      // In windows, the shared memory controls are controlled by mutexes that have local handles.
   #endif
};

// Class database.

#define CL_ITEMS(c)        (ClassItem *)((BYTE *)(c) + sizeof(ClassHeader) + ((c)->Total<<2) )
#define CL_OFFSETS(c)      ((LONG *)((c) + 1))
#define CL_SIZE_OFFSETS(c) (sizeof(LONG) * (c)->Total)
#define CL_ITEM(c,i)       ((ClassItem *)((BYTE *)(c) + offsets[(i)]))

struct ClassHeader {
   LONG Total;          // Total number of registered classes
   LONG Size;           // Size of the entire memory block
   // Followed by lookup table with offsets to each ClassItem, sorted by hash
};

struct ClassItem {
   CLASSID ClassID;
   CLASSID ParentID;    // Parent class reference.
   LONG  Category;
   WORD  Size;          // Size of the item structure, all accompanying strings and byte alignment
   WORD  PathOffset;
   WORD  MatchOffset;
   WORD  HeaderOffset;
   char Name[24];
   // Followed by [path, match, header] strings
};

// X11 Variables

struct X11Globals {
   UBYTE DGAInitialised;
   UBYTE InitCount;
   UBYTE DGACount;
   UBYTE RRInitialised;
   UBYTE Manager;
   UBYTE FailMsg;
   LONG PixelsPerLine;
   LONG BankSize;
};

// Event support

typedef struct rkEvent {
   EVENTID EventID;
   // Data follows
} rkEvent;

#define EVID_DISPLAY_RESOLUTION_CHANGE  GetEventID(EVG_DISPLAY, "resolution", "change")

#define EVID_GUI_SURFACE_FOCUS          GetEventID(EVG_GUI, "surface", "focus")

#define EVID_FILESYSTEM_VOLUME_CREATED  GetEventID(EVG_FILESYSTEM, "volume", "created")
#define EVID_FILESYSTEM_VOLUME_DELETED  GetEventID(EVG_FILESYSTEM, "volume", "deleted")

#define EVID_USER_STATUS_LOGIN          GetEventID(EVG_USER, "status", "login")
#define EVID_USER_STATUS_LOGOUT         GetEventID(EVG_USER, "status", "logout")
#define EVID_USER_STATUS_LOGGEDOUT      GetEventID(EVG_USER, "status", "loggedout")

#define EVID_SYSTEM_TASK_CREATED        GetEventID(EVG_SYSTEM, "task", "created")
#define EVID_SYSTEM_TASK_REMOVED        GetEventID(EVG_SYSTEM, "task", "removed")

#define EVID_POWER_STATE_SUSPENDING     GetEventID(EVG_POWER, "state", "suspending")
#define EVID_POWER_STATE_RESUMED        GetEventID(EVG_POWER, "state", "resumed")
#define EVID_POWER_DISPLAY_STANDBY      GetEventID(EVG_POWER, "display", "standby")
#define EVID_POWER_BATTERY_LOW          GetEventID(EVG_POWER, "battery", "low")
#define EVID_POWER_BATTERY_CRITICAL     GetEventID(EVG_POWER, "battery", "critical")
#define EVID_POWER_CPUTEMP_HIGH         GetEventID(EVG_POWER, "cputemp", "high")
#define EVID_POWER_CPUTEMP_CRITICAL     GetEventID(EVG_POWER, "cputemp", "critical")
#define EVID_POWER_SCREENSAVER_ON       GetEventID(EVG_POWER, "screensaver", "on")
#define EVID_POWER_SCREENSAVER_OFF      GetEventID(EVG_POWER, "screensaver", "off")

#define EVID_HARDWARE_DRIVERS_STARTING  GetEventID(EVG_HARDWARE, "drivers", "starting")
#define EVID_HARDWARE_DRIVERS_STARTED   GetEventID(EVG_HARDWARE, "drivers", "started")
#define EVID_HARDWARE_DRIVERS_CLOSING   GetEventID(EVG_HARDWARE, "drivers", "closing")

#define EVID_IO_KEYMAP_CHANGE           GetEventID(EVG_IO, "keymap", "change")
#define EVID_IO_KEYBOARD_KEYPRESS       GetEventID(EVG_IO, "keyboard", "keypress")

#define EVID_AUDIO_VOLUME_MASTER        GetEventID(EVG_AUDIO, "volume", "master")
#define EVID_AUDIO_VOLUME_LINEIN        GetEventID(EVG_AUDIO, "volume", "linein")
#define EVID_AUDIO_VOLUME_MIC           GetEventID(EVG_AUDIO, "volume", "mic")
#define EVID_AUDIO_VOLUME_MUTED         GetEventID(EVG_AUDIO, "volume", "muted") // All volumes have been muted
#define EVID_AUDIO_VOLUME_UNMUTED       GetEventID(EVG_AUDIO, "volume", "unmuted") // All volumes have been unmuted

// Event structures.

typedef struct { EVENTID EventID; char Name[1]; } evVolumeCreated;
typedef struct { EVENTID EventID; char Name[1]; } evVolumeDeleted;
typedef struct { EVENTID EventID; OBJECTID TaskID; } evTaskCreated;
typedef struct { EVENTID EventID; OBJECTID TaskID; OBJECTID ProcessID; } evTaskRemoved;
typedef struct { EVENTID EventID; } evPowerSuspending;
typedef struct { EVENTID EventID; } evPowerResumed;
typedef struct { EVENTID EventID; } evUserLogin;
typedef struct { EVENTID EventID; } evKeymapChange;
typedef struct { EVENTID EventID; } evScreensaverOn;
typedef struct { EVENTID EventID; } evScreensaverOff;
typedef struct { EVENTID EventID; DOUBLE Volume; LONG Muted; } evVolume;
typedef struct { EVENTID EventID; LONG Qualifiers; LONG Code; LONG Unicode; } evKey;
typedef struct { EVENTID EventID; WORD TotalWithFocus; WORD TotalLostFocus; OBJECTID FocusList[1]; } evFocus;

// Hotplug event structure.  The hotlpug event is sent whenever a new hardware device is inserted by the user.

struct evHotplug {
   EVENTID EventID;
   WORD Type;            // HT ID
   WORD Action;          // HTA_INSERTED, HTA_REMOVED
   LONG VendorID;        // USB vendor ID
   union {
      LONG ProductID;    // USB product or device ID
      LONG DeviceID;
   };
   char  ID[20];         // Typically the PCI bus ID or USB bus ID, serial number or unique identifier
   char  Group[32];    // Group name in the config file
   char  Class[32];      // Class identifier (USB)
   union {
      char Product[40]; // Name of product or the hardware device
      char Device[40];
   };
   char Vendor[40];     // Name of vendor
};

inline void SET_DEVICE(struct dcDeviceInput *Input, WORD Type, WORD Flags, DOUBLE Value, LARGE Timestamp)
{
   Input->Type  = Type;
   Input->Flags = Flags;
   Input->Value = Value;
   Input->Timestamp = Timestamp;
}

//****************************************************************************
// File Methods.

inline CSTRING flReadLine(OBJECTPTR Object) {
   struct flReadLine args;
   if (!Action(MT_FlReadLine, Object, &args)) return args.Result;
   else return NULL;
}

//****************************************************************************
// Little endian read functions.

inline ERROR flReadLE(OBJECTPTR Object, WORD *Result)
{
   UBYTE data[2];
   struct acRead read = { .Buffer = data, .Length = 2 };
   if (!Action(AC_Read, Object, &read)) {
      if (read.Result IS 2) {
         #ifdef LITTLE_ENDIAN
            *Result = ((WORD *)data)[0];
         #else
            *Result = (data[1]<<8) | data[0];
         #endif
         return ERR_Okay;
      }
      else return ERR_Read;
   }
   else return ERR_Read;
}

inline ERROR flReadLE(OBJECTPTR Object, LONG *Result)
{
   UBYTE data[4];
   struct acRead read = { data, sizeof(data) };
   if (!Action(AC_Read, Object, &read)) {
      if (read.Result IS sizeof(data)) {
         #ifdef LITTLE_ENDIAN
            *Result = ((LONG *)data)[0];
         #else
            *Result = (data[0]<<24)|(data[1]<<16)|(data[2]<<8)|(data[3])
         #endif
         return ERR_Okay;
      }
      else return ERR_Read;
   }
   else return ERR_Read;
}

inline ERROR flReadLE(OBJECTPTR Object, LARGE *Result)
{
   UBYTE data[8];
   struct acRead read = { data, sizeof(data) };
   if (!Action(AC_Read, Object, &read)) {
      if (read.Result IS sizeof(data)) {
         #ifdef LITTLE_ENDIAN
            *Result = ((LARGE *)data)[0];
         #else
            *Result = ((LARGE)data[0]<<56)|((LARGE)data[1]<<48)|((LARGE)data[2]<<40)|((LARGE)data[3]<<32)|(data[4]<<24)|(data[5]<<16)|(data[6]<<8)|(data[7])
         #endif
         return ERR_Okay;
      }
      else return ERR_Read;
   }
   else return ERR_Read;
}

#ifdef __cplusplus
template <class R>
constexpr FUNCTION make_function_stdc(R Routine, OBJECTPTR Context = CurrentContext()) {
   FUNCTION func = { .Type = CALL_STDC, .StdC = { .Context = Context, .Routine = (APTR)Routine } };
   return func;
}

inline FUNCTION make_function_script(OBJECTPTR Script, LARGE Procedure) {
   FUNCTION func = { .Type = CALL_SCRIPT, .Script = { .Script = (OBJECTPTR)Script, .ProcedureID = Procedure } };
   return func;
}
#endif

inline CSTRING BaseClass::className() { return Class->ClassName; }

  ]])

  if (glProgram == "idl-def") then
     loadFile("defs/errors.fdl")
  end
end)
