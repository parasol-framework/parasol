--$FLUID:Include

module({ name="Core", copyright="Paul Manias 1996-2025", timestamp=20241015 }, function()
  c_include("<stdarg.h>", "<inttypes.h>")
  cpp_include("<list>", "<map>", "<string>", "<vector>", "<unordered_map>", "<bit>", "<atomic>", "<array>", "<charconv>", "<sstream>", "<cmath>", "<type_traits>", "ankerl/unordered_dense.h")

  platform("Windows", function()
     enum("NETMSG", {}, "START", "END")
  end)

  privateNames({ "ScriptArg", "CoreBase", "RootModule" })

  priority([[
#if defined(_DEBUG)
 #ifndef _MSC_VER
  #include <signal.h>
 #endif
#endif

// For use in requires statements
template <typename T> concept pcPointer = std::is_pointer_v<T>;
template <typename T> concept pcObject = std::is_base_of_v<Object, T>;

#ifndef DEFINE_ENUM_FLAG_OPERATORS
template <size_t S> struct _ENUM_FLAG_INTEGER_FOR_SIZE;
template <> struct _ENUM_FLAG_INTEGER_FOR_SIZE<1> { typedef int8_t type; };
template <> struct _ENUM_FLAG_INTEGER_FOR_SIZE<2> { typedef int16_t type; };
template <> struct _ENUM_FLAG_INTEGER_FOR_SIZE<4> { typedef int type; };
template <> struct _ENUM_FLAG_INTEGER_FOR_SIZE<8> { typedef int64_t type; };
// used as an approximation of std::underlying_type<T>
template <class T> struct _ENUM_FLAG_SIZED_INTEGER { typedef typename _ENUM_FLAG_INTEGER_FOR_SIZE<sizeof(T)>::type type; };

#define DEFINE_ENUM_FLAG_OPERATORS(ENUMTYPE) \
constexpr ENUMTYPE operator | (ENUMTYPE a, ENUMTYPE b) noexcept { return ENUMTYPE(((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)a) | ((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)b)); } \
constexpr ENUMTYPE operator & (ENUMTYPE a, ENUMTYPE b) noexcept { return ENUMTYPE(((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)a) & ((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)b)); } \
constexpr ENUMTYPE operator ~ (ENUMTYPE a) noexcept { return ENUMTYPE(~((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)a)); } \
constexpr ENUMTYPE operator ^ (ENUMTYPE a, ENUMTYPE b) noexcept { return ENUMTYPE(((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)a) ^ ((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)b)); } \
constexpr ENUMTYPE &operator |= (ENUMTYPE &a, ENUMTYPE b) noexcept { return (ENUMTYPE &)(((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type &)a) |= ((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)b)); } \
constexpr ENUMTYPE &operator &= (ENUMTYPE &a, ENUMTYPE b) noexcept { return (ENUMTYPE &)(((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type &)a) &= ((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)b)); }
#endif

template<typename T>
constexpr bool defined(T flags, T test_flag) noexcept {
   static_assert(std::is_enum_v<T>, "Type must be an enum");
   using underlying = std::underlying_type_t<T>;
   return (static_cast<underlying>(flags) & static_cast<underlying>(test_flag)) != 0;
}

  ]])

  loadFile(glPath .. 'common.fdl')
  loadFile(glPath .. 'common-graphics.fdl')

  flags("SCF", { comment="Script flags" },
     "EXIT_ON_ERROR: The script will automatically terminate its execution process if an error is detected.",
     "LOG_ALL: Enables execution debugging.  More information will be printed to the console in this mode.")

  flags("STR", { bits=32 },
     "MATCH_CASE|CASE: Perform a case-sensitive match.",
     "MATCH_LEN: The strings must be of equal length to be matched.")

  flags("MSF", { comment="Message flags." },
     "UPDATE: If the `Type` parameter matches a message already inside the queue, the data for that message will be deleted, then the new message will be added to the end of the queue.",
     "NO_DUPLICATE: If the `Type` parameter matches a message already inside the queue, the new message will not be added and the function will immediately return with `ERR::Okay`.")

  flags("PMF", { comment="Flags for ProcessMessages" },
     "SYSTEM_NO_BREAK: Private.  For system calls that need to avoid early termination.")

  flags("RFD", { bits=32, comment="Flags for RegisterFD()" },
     "WRITE: Activate the callback if there is room to write to the FD's buffer.",
     "EXCEPT: Activate the callback if error conditions are pending.",
     "READ: Activate the callback if there is data available to read.",
     "REMOVE: Stop monitoring this file descriptor.",
     "STOP_RECURSE: Internal flag to prevent recursion.",
     "ALLOW_RECURSION: Internal flag to allow recursion.",
     "SOCKET: Identifies the file descriptor as a socket (Linux systems only).",
     "RECALL: Set if the subscriber needs to manually check for incoming/outgoing data.  This is supported as a one-off check, so the flag will be disabled automatically when the subscriber is called.",
     "ALWAYS_CALL: Always call this FD's handler prior to the process going to sleep.")

  flags("TSF", { comment="Task flags" },
    "WAIT: The parent process will halt when the task is running.  Control is returned to the parent process once the child process terminates.",
    "RESET_PATH: The new process will start in its own folder and not the folder of the parent process.",
    "PRIVILEGED: The child process will inherit the system privileges of its parent.",
    "SHELL: Enables shell mode.  On Unix systems, this means that a shell (usually BASH) will be used to launch the process.",
    "VERBOSE: Enable verbose logging.",
    "QUIET: Divert all process output to `/dev/null` or the nearest equivalent for non-Unix systems.",
    "DETACHED: Forces the new process to be detached from the parent.",
    "ATTACHED: Forces the new process to be attached to the parent (child will close when parent closes).",
    "PIPE: Enable the output pipe to the launched process so that it can read data.")

  hash("AHASH", "0x%s",
    "ACTIVATE",     "CLEAR",         "FREEWARNING",  "COPYDATA",
    "DATAFEED",     "DEACTIVATE",    "DRAW",         "FLUSH",       "FOCUS",        "FREE",
    "GETKEY",       "DRAGDROP",      "HIDE",         "INIT",        "LOCK",         "LOSTFOCUS",    "MOVE",
    "MOVETOBACK",   "MOVETOFRONT",   "NEWCHILD",     "NEWOWNER",    "NEWOBJECT",    "REDO",         "QUERY",
    "READ",         "RENAME",        "RESET",        "RESIZE",      "SAVEIMAGE",    "SAVETOOBJECT",
    "SEEK",         "SETKEY",        "SHOW",         "TIMER",       "UNLOCK",       "NEXT",         "PREV",
    "WRITE",        "SETFIELD",      "CLIPBOARD",    "REFRESH",     "DISABLE",      "ENABLE",       "REDIMENSION",
    "MOVETOPOINT",  "SORT",          "SAVESETTINGS", "SIGNAL",      "NEWPLACEMENT", "UNDO")

  flags("MHF", { comment="Internal options for requesting function tables from modules." },
    "STATIC: Keep the module code in memory",
    "STRUCTURE|DEFAULT: Use structures to group exported functions (Linux, C/C++ standard)")

  flags("MTF", { comment="MoveToPoint flags" }, "X", "Y", "Z", "ANIM", "RELATIVE")

  flags("VLF", { comment="VlogF flags" }, "BRANCH", "ERROR", "WARNING", "CRITICAL", "INFO", "API", "DETAIL", "TRACE", "FUNCTION")

  flags("MOF", { comment="Module flags" },
    "LINK_LIBRARY: Module refers to a symbolic link library (e.g. libz DLL or SO)",
    "STATIC: This flag prevents the loaded module code from being unloaded when the module object is freed.  This may be needed in cases where a module is designed with the presumption that it will remain in memory after being loaded by the developer.",
    "SYSTEM_PROBE: Indicates that the module is being probed.  Do not use outside of the core library.")

  flags("THF", { comment="Thread flags" },
    "AUTO_FREE: Automatically destroy the Thread object when the user routine has completed.")

  enum("FDT", { type="int", start=0, comment="Flags for the SetDate() file method." },
    "MODIFIED: The date on which the file was last modified.",
    "CREATED: The date on which the file was created.  On some host platforms this datestamp may be read-only.",
    "ACCESSED: The date on which the file was last accessed by a user or application.",
    "ARCHIVED: The date on which the file was most recently archived.  Not supported by most filesystems.")

  flags("VOLUME", { comment="Options for SetVolume()" },
    "REPLACE: If the volume already exists, all paths that are attached to it will be replaced with the new path setting.",
    "PRIORITY: If the volume already exists, the path will be inserted at the beginning of the path list so that it has priority over the others.",
    "HIDDEN: Hides the volume so that it will not show up when reading volumes from the root path `:`.",
    "SYSTEM: Identifies the volume as being created by the system (this flag is not for client use).")

  flags("FDL", { comment="Options for the File Delete() method." },
    "FEEDBACK: Automatically manage user feedback for deleting files by presenting dialog boxes.")

  flags("CMF", { comment="Compression flags" },
    "PASSWORD: A password has been set on the object.",
    "NEW: Force the creation of a new file archive.  Any existing file data at the target location will be destroyed.",
    "CREATE_FILE: Create a new archive only if the source file does not already exist.",
    "READ_ONLY: Forces read-only access, which is strongly recommended if an existing archive is being opened with no modifications intended.  If this flag is not set, initialisation can fail if the user does not have write access to the source file.",
    "NO_LINKS: Treat symbolic links as normal files/folders.",
    "APPLY_SECURITY: When decompressing, apply individual file permissions if they are available in the compression file.")

  flags("RSF", { comment="Flags for ResolvePath()"},
    "NO_FILE_CHECK: Do not test for the existence of the targeted file or folder during the resolution process.",
    "CHECK_VIRTUAL: If the volume referenced by Path is traced to another volume that is reserved by a virtual file system driver, `ERR::VirtualVolume` is returned. The volume is still resolved as far as possible and the resulting path will be returned by this function.",
    "APPROXIMATE: Ignores file extensions for the purpose of file name matching.",
    "NO_DEEP_SCAN: Do not perform more than one iteration when resolving the source file path.",
    "PATH: Use the `PATH` environment variable to resolve the file name in the `Path` parameter.",
    "CASE_SENSITIVE: For use on host systems that use case-insensitive file systems such as Windows; this option checks that the discovered file is a case-sensitive match to the Path.")

  -- NB: The MFF flags are duplicated in the FileSystem's Win32 code if you're going to change these

  flags("MFF", { comment="Flags for the File Watch() method." },
    "READ: File was accessed (read).",
    "MODIFY|WRITE: File modified via write or truncation.",
    "CREATE: New file/link created or renamed in folder.",
    "DELETE: Existing file deleted",
    "MOVED|RENAME: Existing file moved or renamed.",
    "ATTRIB: File permissions or datestamp changed.",
    "OPENED: Existing file was opened.",
    "CLOSED: An opened file has been closed.",
    "UNMOUNT: Host filesystem was unmounted.",
    "FOLDER: Folder identifier; if passed to @File.Watch() then indicates a preference for folder events only.",
    "FILE: File identifier; if passed to @File.Watch() then indicates a preference for file events only.",
    "SELF: Event applies to the monitored folder and not a contained item",
    "DEEP: Receive notifications from sub-folders (Windows only).")

  enum("STT", { type="int", start=1, comment="Types for StrDatatype()." },
    "NUMBER: The string represents a whole number.",
    "FLOAT: The string represents a floating point number.",
    "HEX: The string represents a hexadecimal number.",
    "STRING: The string represents plain-text.")

  flags("OPF", { },
    "OPTIONS",
    "MAX_DEPTH",
    "DETAIL",
    "SHOW_MEMORY",
    "SHOW_IO",
    "SHOW_ERRORS",
    "ARGS",
    "ERROR",
    "PRIVILEGED",
    "SYSTEM_PATH",
    "MODULE_PATH",
    "ROOT_PATH",
    "SCAN_MODULES")

  enum("TOI", { type="int" },
    "LOCAL_CACHE",        -- For Android.  Defines the path of the local cache for assignment to localcache:
    "LOCAL_STORAGE",      -- For Android.  Defines the path of the local storage for assignment to localstorage:
    "ANDROID_ENV",        -- For Android.
    "ANDROID_CLASS",      -- For Android.
    "ANDROID_ASSETMGR")   -- For Android.  Permanent pointer to the AssetManager

  flags("RDF", { comment="Flags for the OpenDir() function." },
    "SIZE: Retrieve the byte size of each file.",
    "DATE|TIME: Retrieve the date stamp of each file.",
    "PERMISSIONS: Get permission/security information.",
    "FILES|FILE: Read all files in the folder.",
    "FOLDERS|FOLDER: Read all folders/volumes in the folder.",
    "VOLUME: Feedback only - indicates a volume.",
    "LINK: Feedback only - file/folder is actually a link to another location.",
    "TAGS: Receive additional information for each file, such as comments, author and copyright.  The results are stored in the `Tags` field of each file.",
    "HIDDEN: Feedback only - file/folder is hidden.",
    "QUALIFY|QUALIFIED: Return fully qualified folder names (i.e. trailing slash or colon for each name).",
    "VIRTUAL: Path is to a virtual device.",
    "STREAM: Path is connected via a stream, e.g. network connection.",
    "READ_ONLY: Read-only (not permissions related and might indicate read-only media).",
    "ARCHIVE: Feedback only - archive bit is set.",
    "OPENDIR: Internal option.",
    { READ_ALL = "SIZE|DATE|PERMISSIONS|FILES|FOLDERS" })

  flags("FL", { comment="File flags" },
    "WRITE: Prepares a file for writing data, starting at byte position 0.  To start writing from the end of a file, use the Seek action after the file has been initialised.",
    "NEW: Required when creating a new file.  If a file with the same name exists, its contents will be destroyed. If however the existing file is locked, the initalisation process will fail.",
    "READ: Required if the file needs to be opened for read access.",
    "FOLDER|DIRECTORY: The file object represents a folder.",
    "APPROXIMATE: Allows fuzzy matching of the file path when opening an existing file.  This means that the file extension will be ignored; for instance attempting to open a file of 'screenshot.png' when only a file name of 'screenshot.jpg' exists in the same folder, the 'screenshot.jpg' file will be opened instead.  If multiple files could potentially match to the file name, the file object will select the first match that is encountered.",
    "LINK: Read-Only.  Indicates that the file is a symbolic link or shortcut to another file.",
    "BUFFER: Activates a special mode in which the file data is stored in a memory buffer rather than a disk file.  Set the Size field to a value of at least 1 so that the initial buffer size is configured.  In this mode many of the available file operations are meaningless except for the Read, Write and Seek actions.",
    "LOOP: In loop mode, the file object's position marker for read/write operations is allowed to extend past the actual file size.  Any read/write operation beyond the file size will loop back to the file at a corrected offset - for example, reading position 330 of a 100 byte file will start the operation from the 30th byte.  Loop mode does not affect any other area besides the read, write and seek operations.  The loop feature is typically used to create multimedia data streams with minimal effort.",
    "FILE: Explicitly declares the file object as an entity that stores content (as opposed to a device or folder for example).",
    "RESET_DATE: For internal use only",
    "DEVICE: The file is a system device (must set if opening a device for read/write operations)",
    "STREAM: File data is streamed (e.g. PIPE, FIFO, socket) and may be accessed locally or via a network.",
    "EXCLUDE_FILES: Exclude files when scanning this folder.",
    "EXCLUDE_FOLDERS: Exclude folders when scanning this folder.")

  enum("LOC", { type="int", start=1, comment="AnalysePath() values" },
    "DIRECTORY|FOLDER: The path refers to a folder.",
    "VOLUME: The path refers to a volume name.",
    "FILE: The path refers to a file.")

  flags("LDF", { comment="Flags for LoadFile()" },
    "CHECK_EXISTS: Limits the routine to checking the file cache for the existence of the file.  If found, the relevant cache entry is returned. The open count is not incremented by this action (it is therefore unnecessary to follow-up with a call to UnloadFile()).  If no up-to-date cache entry is available, `ERR::Search` is returned.")

  enum("FBK", { type="int", start=1, comment="Flags for file feedback." },
    "MOVE_FILE: A file is to be, or has been moved.",
    "COPY_FILE: A file is to be, or has been copied.",
    "DELETE_FILE: A file is to be, or has been deleted.")

  enum("FFR", { type="int", start=0, comment="Return codes available to the feedback routine" },
    "OKAY|CONTINUE: Continue processing uninterrupted.",
    "SKIP: Skip processing of this entity.",
    "ABORT: Abort the entire operation.")

  enum("VAS", { type="int", start=1, comment="For use by VirtualVolume()" },
    "DEREGISTER: Remove the virtual volume from the system.",
    "SCAN_DIR",
    "DELETE",
    "RENAME",
    "OPEN_DIR",
    "CLOSE_DIR",
    "TEST_PATH",
    "WATCH_PATH",
    "IGNORE_FILE",
    "GET_INFO",
    "GET_DEVICE_INFO",
    "IDENTIFY_FILE",
    "MAKE_DIR",
    "SAME_FILE",
    "CASE_SENSITIVE: Set to true if the volume's paths are case-sensitive.",
    "READ_LINK",
    "CREATE_LINK",
    "DRIVER_SIZE")

  enum("FDB", { type="int", start=1, comment="Feedback event indicators." },
    "DECOMPRESS_FILE",
    "COMPRESS_FILE",
    "REMOVE_FILE",
    "DECOMPRESS_OBJECT")

  enum("CF", { type="int", start=1, comment="Compression stream formats" },
    "GZIP: The 'gzip' format",
    "ZLIB: The 'zlib' format",
    "DEFLATE: The 'deflate' format")

  flags("FOF", { comment="Flags that can be passed to FindObject()" },
    "SMART_NAMES: Parse numeric object names as ID references and support use of the 'Owner' reserved keyword.")

  flags("NF", { comment="Flags that can be passed to NewObject().  If a flag needs to be stored with the object, it must be specified in the lower word." },
    "UNTRACKED: An object created with this flag will not be tracked back to the object that created it.",
    "INITIALISED: Read-only indicator if the object has been initialised.",
    "LOCAL: Classes can allocate local objects to stop them from being associated with the client.",
    "FREE_ON_UNLOCK: Read-only indicator for when the object is marked for deletion.",
    "FREE: Read-only indicator for when the object is being freed.",
    "TIMER_SUB: The object is subscribed to a timer interval.",
    "SUPPRESS_LOG: Private.  Turns off the initial log message.",
    "COLLECT: Marked for garbage collection.",
    "RECLASSED: The object switched from the base-class to a sub-class during initialisation.",
    "MESSAGE: Action has been called against the object through the message system (managed by ~Core.ProcessMessages()).",
    "SIGNALLED: The object has been signalled and is awaiting processing.",
    "PERMIT_TERMINATE: Private.  Permits termination when a lock is held on the object.",
    { UNIQUE = "0x40000000: Use to allocate an object that has a guaranteed unique name.  This will prevent code from shadowing any object that exists with the same name, which can be imperative when creating shared objects.  If it is discovered that an identically named object exists, ~Core.NewObject() will return `ERR::ObjectExists`.  This flag works in conjunction with the `Name` parameter.",
      NAME   = "0x80000000: Use the Name parameter to name the created object.  This flag is not required if using `UNIQUE`.",
      PRIVATE = 0
    }
  )

  const("MAX", { }, {
     FILENAME = 256, -- Maximum length for file names (not necessarily including path)
     NAME_LEN = 31   -- Refer to the 'Object' struct for more info on the NAME_LEN value
  })

  const("MSGID", { type="int", comment="Reserved message ID's that are handled internally." }, {
     QUIT             = 1000,   -- Note that IDs >= 100 may be handled by non-Core code (external modules and applications)
     COMMAND          = 101,
     BREAK            = 100,
     CORE_END         = 100,    -- End marker for Core generated messages
     ACTION           = 99,     -- Start from 99 descending (lower risk of accidental ID matches)
     FREE             = 98,
     DEBUG            = 97,
     EVENT            = 96,
     VALIDATE_PROCESS = 95,
     THREAD_CALLBACK  = 94,
     THREAD_ACTION    = 93,
     FLUID_THREAD_CALLBACK = 92,
     WAIT_FOR_OBJECTS = 91
  })

  enum("IDTYPE", { type="int", start=1, comment="Types for AllocateID()" },
    "MESSAGE: Message ID's are allocated for the purpose of sending uniquely identifiable messages between tasks.",
    "GLOBAL: Global ID's have no specific association with anything.",
    "FUNCTION: Function ID's are used to track `FUNCTION` types and are assigned to the function ID field."
  )

  enum("TSTATE", { type="char", comment="Indicates the state of a process." },
    "RUNNING: The process is currently executing code.",
    "PAUSED: The process is asleep.",
    "STOPPING: The process is in its termination phase.",
    "TERMINATED: The process has closed.")

  enum("RES", { type="int", start=1 },
    "FREE_SWAP: The total amount of free swap memory.",
    "CONSOLE_FD: Internal reference to the FD of the console.",
    "KEY_STATE: Maintains the state of key qualifiers such as caps-lock and the shift keys.",
    "USER_ID: Internal",
    "DISPLAY_DRIVER: Internal.  Passes the name of the preferred display driver to the display module.",
    "PRIVILEGED_USER: If this value is set to 1, the process will operate in privileged mode (typically this enables full administrator rights).  This feature will only work for Unix processes that are granted admin rights when launched.  Setting the Value to 0 reverts to the user's permission settings.  SetResource() will return an error code indicating the level of success.",
    "PRIVILEGED: This is set to `true` if the process has elevated privileges (such as superuser or administrative rights).",
    "CORE_IDL: Refers to the Core module's compressed IDL string.",
    "STATIC_BUILD: Returns true if the runtime is a statically linked build.",
    "LOG_LEVEL: The current level of log detail (larger numbers indicate more detail).",
    "TOTAL_SHARED_MEMORY: The total amount of shared memory in use (system wide).",
    "LOG_DEPTH: The current depth of log messages.",
    "JNI_ENV: Return the current JNI environment string.",
    "THREAD_ID: Return the ID of the current thread.",
    "OPEN_INFO: Pointer to the OpenInfo structure originally used to initialise the system.",
    "EXCEPTION_HANDLER: Internal",
    "NET_PROCESSING: Internal windows resource for Network module",
    "PROCESS_STATE: Life-cycle stage of the running process",
    "TOTAL_MEMORY: The total amount of installed memory.",
    "TOTAL_SWAP: The total amount of available swap space.",
    "CPU_SPEED: The average top-speed of all CPU cores in Mhz.",
    "FREE_MEMORY: The total amount of free memory.",
    "MEMORY_USAGE: The total amount of memory used by the current process, in bytes."
  )

  enum("RP", { type="int", start=1, comment="Path types for SetResourcePath()" },
    "MODULE_PATH: An alternative path leading to the system modules (normally `system:modules/`).  Introduced for platforms such as Android, where modules are stored in asset folders.",
    "SYSTEM_PATH: The path of the `system:` volume, which otherwise defaults to `[root]:system/`.",
    "ROOT_PATH: Overrides the root path, which defaults to the location at which Parasol is installed.")

  flags("CLF", { comment="Flags for the MetaClass." },
    "INHERIT_LOCAL: Inherit the functionality of local objects defined in the class spec.",
    "NO_OWNERSHIP: Objects created will not be tracked to the creating process, nor any parent object (~Core.SetOwner() will not work either).")

  flags("CNF", { comment="Flags for the Config class." },
    "STRIP_QUOTES: Removes quotes from key values that are quote-encapsulated.",
    "AUTO_SAVE: When the configuration object is freed, automatically save the configuration data back to the original file source.",
    "OPTIONAL_FILES: Files are optional (do not fail if a requested file does not exist).",
    "NEW: On initialisation, do not load any data from the referenced configuration file.")

-- Please note that when the user is using an international keyboard, the name of the key will not
-- actually match what the symbol represents for some key types.

  const("KEY", { type="int", comment="Raw key codes" }, {
    A = 1,
    B = 2,
    C = 3,
    D = 4,
    E = 5,
    F = 6,
    G = 7,
    H = 8,
    I = 9,
    J = 10,
    K = 11,
    L = 12,
    M = 13,
    N = 14,
    O = 15,
    P = 16,
    Q = 17,
    R = 18,
    S = 19,
    T = 20,
    U = 21,
    V = 22,
    W = 23,
    X = 24,
    Y = 25,
    Z = 26,
    ONE   = 27,
    TWO   = 28,
    THREE = 29,
    FOUR  = 30,
    FIVE  = 31,
    SIX   = 32,
    SEVEN = 33,
    EIGHT = 34,
    NINE  = 35,
    ZERO  = 36,
    REVERSE_QUOTE = 37,
    MINUS         = 38,
    EQUALS        = 39,
    L_SQUARE      = 40,
    R_SQUARE      = 41,
    SEMI_COLON    = 42,
    APOSTROPHE    = 43,
    COMMA         = 44,
    PERIOD        = 45,
    DOT           = 45, -- Synonym
    SLASH         = 46,
    BACK_SLASH    = 47,
    SPACE         = 48,
    -- Keypad keys
    NP_0        = 49,
    NP_1        = 50,
    NP_2        = 51,
    NP_3        = 52,
    NP_4        = 53,
    NP_5        = 54,
    NP_6        = 55,
    NP_7        = 56,
    NP_8        = 57,
    NP_9        = 58,
    NP_MULTIPLY = 59,
    NP_PLUS     = 60,
    NP_SEPARATOR = 61,
    NP_BAR      = 61, -- Synonym
    NP_MINUS    = 62,
    NP_DECIMAL  = 63,
    NP_DOT      = 63,   -- Synonym
    NP_DIVIDE   = 64,
    L_CONTROL   = 65,   -- Left Control
    R_CONTROL   = 66,   -- Right Control
    HELP        = 67,   -- Help
    L_SHIFT     = 68,   -- Left Shift
    R_SHIFT     = 69,   -- Right Shift
    CAPS_LOCK   = 70,   -- Caps Lock
    PRINT       = 71,   -- Print (not print-screen!)
    L_ALT       = 72,   -- Left Alt
    R_ALT       = 73,   -- Right Alt
    L_COMMAND   = 74,   -- Left Amiga/Win/Special
    R_COMMAND   = 75,   -- Right Amiga/Win/Special
    F1          = 76,   -- Function Key 1
    F2          = 77,   -- Function Key 2
    F3          = 78,   -- Function Key 3
    F4          = 79,   -- Function Key 4
    F5          = 80,   -- Function Key 5
    F6          = 81,   -- Function Key 6
    F7          = 82,   -- Function Key 7
    F8          = 83,   -- Function Key 8
    F9          = 84,   -- Function Key 9
    F10         = 85,   -- Function Key 10
    F11         = 86,   -- Function Key 11
    F12         = 87,   -- Function Key 12
    F13         = 88,   -- Function Key 13
    F14         = 89,   -- Function Key 14
    F15         = 90,   -- Function Key 15
    F16         = 91,   -- Function Key 16
    F17         = 92,   -- Function Key 17
    MACRO       = 93,
    NP_PLUS_MINUS = 94,  -- Plus/Minus on some numeric keypads
    LESS_GREATER  = 95,  -- Less/Greater key on foreign keyboards (no US equivalent?)
    UP          = 96,    -- Cursor Up
    DOWN        = 97,    -- Cursor Down
    RIGHT       = 98,    -- Cursor Right
    LEFT        = 99,    -- Cursor Left
    SCR_LOCK    = 100,   -- Scroll Lock
    PAUSE       = 101,   -- Pause
    WAKE        = 102,   -- Wake
    SLEEP       = 103,   -- Sleep
    POWER       = 104,   -- Power
    BACKSPACE   = 105,   -- Backspace
    TAB         = 106,   -- Tabulation
    ENTER       = 107,   -- Enter/Return
    ESCAPE      = 108,   -- Escape
    DELETE      = 109,   -- Delete
    CLEAR       = 110,   -- Clear
    HOME        = 111,   -- Home
    PAGE_UP     = 112,   -- Page Up
    PAGE_DOWN   = 113,   -- Page Down
    END         = 114,   -- End
    SELECT      = 115,   -- Select
    EXECUTE     = 116,   -- Execute
    INSERT      = 117,   -- Insert
    UNDO        = 118,   -- Undo
    REDO        = 119,   -- Redo
    MENU        = 120,   -- Menu / Shortcut / Application key
    FIND        = 121,   -- Find
    CANCEL      = 122,   -- Cancel
    BREAK       = 123,   -- Break
    NUM_LOCK    = 124,   -- Number lock
    PRT_SCR     = 125,   -- Print Screen
    NP_ENTER    = 126,   -- Numeric keypad enter
    SYSRQ       = 127,
    F18         = 128,
    F19         = 129,
    F20         = 130,
    WIN_CONTROL = 131,   -- Special MS internal control key, doesn't map to a real key
    -- A lot of the following are derived from Android
    VOLUME_UP   = 132,
    VOLUME_DOWN = 133,
    BACK        = 134, -- Not the same as backspace!
    CALL        = 135,
    END_CALL    = 136,
    CAMERA      = 137,
    AT          = 138,
    PLUS        = 139,
    LENS_FOCUS  = 140,
    STOP        = 141,
    NEXT        = 142,
    PREVIOUS    = 143,
    FORWARD     = 144,
    REWIND      = 145,
    MUTE        = 146,
    STAR        = 147, -- As seen on phone keypads
    POUND       = 148, -- As seen on phone keypads
    PLAY        = 149,
    -- End marker
    LIST_END    = 150
  })

  c_insert([[

typedef AC ACTIONID;

#ifndef __GNUC__
#define __attribute__(a)
#endif

typedef const std::vector<std::pair<std::string, uint32_t>> STRUCTS;
typedef std::map<std::string, std::string, std::less<>> KEYVALUE;

#ifndef STRINGIFY
#define STRINGIFY(x) #x
#define TOSTRING(x) STRINGIFY(x)
#endif

#define MOD_IDL nullptr

#ifdef PARASOL_STATIC
__export void CloseCore(void);
__export ERR OpenCore(struct OpenInfo *, struct CoreBase **);
#else
__export struct ModHeader ModHeader;
#endif

#ifdef MOD_NAME
#ifdef PARASOL_STATIC
#define PARASOL_MOD(init,close,open,expunge,IDL,Structures) static struct ModHeader ModHeader(init, close, open, expunge, IDL, Structures, TOSTRING(MOD_NAME), TOSTRING(MOD_NAMESPACE));
#else
#define PARASOL_MOD(init,close,open,expunge,IDL,Structures) struct ModHeader ModHeader(init, close, open, expunge, IDL, Structures, TOSTRING(MOD_NAME), TOSTRING(MOD_NAMESPACE));
#endif
#define MOD_PATH ("modules:" TOSTRING(MOD_NAME))
#else
#define MOD_NAME nullptr
#endif

namespace pf {

template <class T> T roundup(T Num, int Alignment) {
   return (Num + Alignment) - (Num % Alignment); // Round up to Alignment value, e.g. (14,8) = 16
}

#ifdef PRINTF64I
  #define PF64 "I64d"
#elif PRINTF64_PRID
  #define PF64 PRId64
#else
  #define PF64 "lld"
#endif

// Use DEBUG_BREAK in critical areas where you would want to break in gdb.  This feature will only be compiled
// in to debug builds.

#ifdef _DEBUG
 #ifdef _MSC_VER
  #define DEBUG_BREAK __debugbreak();
 #elif __linux__
  #define DEBUG_BREAK raise(SIGTRAP);
 #else
  #define DEBUG_BREAK
 #endif
#else
 #define DEBUG_BREAK
#endif

// Fast float-2-int conversion, with rounding to the nearest integer (F2I) and truncation (F2T)

#if defined(__GNUC__) && defined(__x86__)

constexpr int F2I(double val) noexcept {
   if (std::is_constant_evaluated()) {
      return (int)std::round(val);
   }
   // This will round if the CPU is kept in its default rounding mode
   int ret;
   asm ("fistpl %0" : "=m" (ret) : "t" (val) : "st");
   return(ret);
}

#else

inline int F2I(double val) {
   double t = val + 6755399441055744.0;
   return *((int *)(&t));
}

#endif

constexpr int F2T(double val) noexcept // For numbers no larger than 16 bit, standard (int) is faster than F2T().
{
   if ((val > 32767.0) or (val < -32767.0)) return((int)val);
   else {
      val = val + (68719476736.0 * 1.5);
      if constexpr (std::endian::native == std::endian::little) {
         return ((int *)(APTR)&val)[0]>>16;
      }
      else return ((int *)&val)[1]>>16;
   }
}

} // namespace

// Structures to pass to OpenCore()

struct OpenTag {
   TOI Tag;
   union {
      int Int;
      int64_t Int64;
      APTR Pointer;
      CSTRING String;
   } Value;
};

struct OpenInfo {
   CSTRING Name;            // OPF::NAME
   CSTRING *Args;           // OPF::ARGS
   CSTRING SystemPath;      // OPF::SYSTEM_PATH
   CSTRING ModulePath;      // OPF::MODULE_PATH
   CSTRING RootPath;        // OPF::ROOT_PATH
   OpenTag *Options;        // OPF::OPTIONS Typecast to va_list (defined in stdarg.h)
   OPF     Flags;           // OPF::flags need to be set for fields that have been defined in this structure.
   int     MaxDepth;        // OPF::MAX_DEPTH
   int     Detail;          // OPF::DETAIL
   int     ArgCount;        // OPF::ARGS
   ERR     Error;           // OPF::ERROR
};

// Flags for defining fields, methods, actions and functions.  CLASSDEF's can only be used in field definitions for
// classes.  FUNCDEF's can only be used in argument definitions for methods, actions and functions.

#ifdef _LP64
#define FD_PTR64 FD_POINTER
#else
#define FD_PTR64 0
#endif

// Field flags for classes.  These are intended to simplify field definitions, e.g. using FDF_BYTEARRAY combines
// FD_ARRAY with FD_BYTE.  DO NOT use these for function definitions, they are not intended to be compatible.

// Sizes/Types

#define FT_POINTER  FD_POINTER
#define FT_FLOAT    FD_FLOAT
#define FT_INT      FD_INT
#define FT_DOUBLE   FD_DOUBLE
#define FT_INT64    FD_INT64
#define FT_STRING   (FD_POINTER|FD_STRING)
#define FT_UNLISTED FD_UNLISTED
#define FT_UNIT     FD_UNIT

// Class field definitions.  See core.h for all FD definitions.

#define FDF_BYTE       FD_BYTE
#define FDF_WORD       FD_WORD     // Field is word sized (16-bit)
#define FDF_INT        FD_INT      // Field is int sized (32-bit)
#define FDF_DOUBLE     FD_DOUBLE   // Field is double floating point sized (64-bit)
#define FDF_INT64      FD_INT64    // Field is large sized (64-bit)
#define FDF_POINTER    FD_POINTER  // Field is an address pointer (typically 32-bit)
#define FDF_ARRAY      FD_ARRAY    // Field is a pointer to an array
#define FDF_CPP        FD_CPP      // Field is a C++ type variant
#define FDF_PTR        FD_POINTER
#define FDF_UNIT       FD_UNIT
#define FDF_SYNONYM    FD_SYNONYM

#define FDF_UNSIGNED    FD_UNSIGNED
#define FDF_FUNCTION    FD_FUNCTION           // sizeof(FUNCTION) - use FDF_FUNCTIONPTR for sizeof(APTR)
#define FDF_FUNCTIONPTR (FD_FUNCTION|FD_POINTER)
#define FDF_STRUCT      FD_STRUCT
#define FDF_RESOURCE    FD_RESOURCE
#define FDF_OBJECT      (FD_POINTER|FD_OBJECT)   // Field refers to another object
#define FDF_OBJECTID    (FD_INT|FD_OBJECT)      // Field refers to another object by ID
#define FDF_LOCAL       (FD_POINTER|FD_LOCAL)    // Field refers to a local object
#define FDF_STRING      (FD_POINTER|FD_STRING)   // Field points to a string.  NB: Ideally want to remove the FD_POINTER as it should be redundant
#define FDF_STR         FDF_STRING
#define FDF_SCALED      FD_SCALED
#define FDF_FLAGS       FD_FLAGS                // Field contains flags
#define FDF_ALLOC       FD_ALLOC                // Field is a dynamic allocation - either a memory block or object
#define FDF_LOOKUP      FD_LOOKUP               // Lookup names for values in this field
#define FDF_READ        FD_READ                 // Field is readable
#define FDF_WRITE       FD_WRITE                // Field is writeable
#define FDF_INIT        FD_INIT                 // Field can only be written prior to Init()
#define FDF_SYSTEM      FD_SYSTEM
#define FDF_ERROR       (FD_INT|FD_ERROR)
#define FDF_RGB         (FD_RGB|FD_BYTE|FD_ARRAY)
#define FDF_R           FD_READ
#define FDF_W           FD_WRITE
#define FDF_RW          (FD_READ|FD_WRITE)
#define FDF_RI          (FD_READ|FD_INIT)
#define FDF_I           FD_INIT
#define FDF_VIRTUAL     FD_VIRTUAL
#define FDF_INTFLAGS    (FDF_INT|FDF_FLAGS)
#define FDF_FIELDTYPES  (FD_INT|FD_DOUBLE|FD_INT64|FD_POINTER|FD_UNIT|FD_BYTE|FD_ARRAY|FD_FUNCTION)

// These constants have to match the FD* constants << 32

#define TDOUBLE   0x8000000000000000LL
#define TINT      0x4000000000000000LL
#define TUNIT     0x2000000000000000LL
#define TFLOAT    0x1000000000000000LL // NB: Floats are upscaled to doubles when passed as v-args.
#define TPTR      0x0800000000000000LL
#define TINT64    0x0400000000000000LL
#define TFUNCTION 0x0200000000000000LL
#define TSTR      0x0080000000000000LL
#define TARRAY    0x0000100000000000LL
#define TSCALE    0x0020000000000000LL
#define TAGEND    0LL
#define TAGDIVERT -1LL
#define TSTRING   TSTR

#define nextutf8(str) if (*(str)) for (++(str); (*(str) & 0xc0) IS 0x80; (str)++);

//********************************************************************************************************************
// FieldValue is used to simplify the initialisation of new objects.

namespace pf {

struct FieldValue {
   uint32_t FieldID;
   int Type;
   union {
      CSTRING String;
      APTR    Pointer;
      CPTR    CPointer;
      double  Double;
      SCALE   Percent;
      int64_t Int64;
      int     Int;
   };

   //std::string not included as not compatible with constexpr
   constexpr FieldValue(uint32_t pFID, CSTRING pValue)  : FieldID(pFID), Type(FD_STRING), String(pValue) { };
   constexpr FieldValue(uint32_t pFID, int pValue)      : FieldID(pFID), Type(FD_INT), Int(pValue) { };
   constexpr FieldValue(uint32_t pFID, int64_t pValue)  : FieldID(pFID), Type(FD_INT64), Int64(pValue) { };
   constexpr FieldValue(uint32_t pFID, size_t pValue)   : FieldID(pFID), Type(FD_INT64), Int64(pValue) { };
   constexpr FieldValue(uint32_t pFID, double pValue)   : FieldID(pFID), Type(FD_DOUBLE), Double(pValue) { };
   constexpr FieldValue(uint32_t pFID, SCALE pValue)    : FieldID(pFID), Type(FD_DOUBLE|FD_SCALED), Percent(pValue) { };
   constexpr FieldValue(uint32_t pFID, const FUNCTION &pValue) : FieldID(pFID), Type(FDF_FUNCTIONPTR), CPointer(&pValue) { };
   constexpr FieldValue(uint32_t pFID, const FUNCTION *pValue) : FieldID(pFID), Type(FDF_FUNCTIONPTR), CPointer(pValue) { };
   constexpr FieldValue(uint32_t pFID, APTR pValue)     : FieldID(pFID), Type(FD_POINTER), Pointer(pValue) { };
   constexpr FieldValue(uint32_t pFID, CPTR pValue)     : FieldID(pFID), Type(FD_POINTER), CPointer(pValue) { };
   constexpr FieldValue(uint32_t pFID, CPTR pValue, int pCustom) : FieldID(pFID), Type(pCustom), CPointer(pValue) { };
};


class FloatRect {
   public:
   double X, Y, Width, Height;
   constexpr FloatRect() noexcept = default;
   constexpr FloatRect(double Value) noexcept : X(Value), Y(Value), Width(Value), Height(Value) { }
   constexpr FloatRect(double pX, double pY, double pWidth, double pHeight) noexcept : X(pX), Y(pY), Width(pWidth), Height(pHeight) { }
   constexpr double left() const noexcept { return X; }
   constexpr double top() const noexcept { return Y; }
   constexpr double right() const noexcept { return X + Width; }
   constexpr double bottom() const noexcept { return Y + Height; }
};

}

#include <string.h> // memset()
#include <stdlib.h> // strtol(), strtod()

namespace dmf { // Helper functions for DMF flags
inline bool has(DMF Value, DMF Flags) { return (Value & Flags) != DMF::NIL; }

inline bool hasX(DMF Value) { return (Value & DMF::FIXED_X) != DMF::NIL; }
inline bool hasY(DMF Value) { return (Value & DMF::FIXED_Y) != DMF::NIL; }
inline bool hasWidth(DMF Value) { return (Value & DMF::FIXED_WIDTH) != DMF::NIL; }
inline bool hasHeight(DMF Value) { return (Value & DMF::FIXED_HEIGHT) != DMF::NIL; }
inline bool hasXOffset(DMF Value) { return (Value & DMF::FIXED_X_OFFSET) != DMF::NIL; }
inline bool hasYOffset(DMF Value) { return (Value & DMF::FIXED_Y_OFFSET) != DMF::NIL; }
inline bool hasRadiusX(DMF Value) { return (Value & DMF::FIXED_RADIUS_X) != DMF::NIL; }
inline bool hasRadiusY(DMF Value) { return (Value & DMF::FIXED_RADIUS_Y) != DMF::NIL; }
inline bool hasScaledX(DMF Value) { return (Value & DMF::SCALED_X) != DMF::NIL; }
inline bool hasScaledY(DMF Value) { return (Value & DMF::SCALED_Y) != DMF::NIL; }
inline bool hasScaledWidth(DMF Value) { return (Value & DMF::SCALED_WIDTH) != DMF::NIL; }
inline bool hasScaledHeight(DMF Value) { return (Value & DMF::SCALED_HEIGHT) != DMF::NIL; }
inline bool hasScaledXOffset(DMF Value) { return (Value & DMF::SCALED_X_OFFSET) != DMF::NIL; }
inline bool hasScaledYOffset(DMF Value) { return (Value & DMF::SCALED_Y_OFFSET) != DMF::NIL; }
inline bool hasScaledCenterX(DMF Value) { return (Value & DMF::SCALED_CENTER_X) != DMF::NIL; }
inline bool hasScaledCenterY(DMF Value) { return (Value & DMF::SCALED_CENTER_Y) != DMF::NIL; }
inline bool hasScaledRadiusX(DMF Value) { return (Value & DMF::SCALED_RADIUS_X) != DMF::NIL; }
inline bool hasScaledRadiusY(DMF Value) { return (Value & DMF::SCALED_RADIUS_Y) != DMF::NIL; }

inline bool hasAnyHorizontalPosition(DMF Value) { return (Value & (DMF::FIXED_X|DMF::SCALED_X|DMF::FIXED_X_OFFSET|DMF::SCALED_X_OFFSET)) != DMF::NIL; }
inline bool hasAnyVerticalPosition(DMF Value) { return (Value & (DMF::FIXED_Y|DMF::SCALED_Y|DMF::FIXED_Y_OFFSET|DMF::SCALED_Y_OFFSET)) != DMF::NIL; }
inline bool hasAnyScaledRadius(DMF Value) { return (Value & (DMF::SCALED_RADIUS_X|DMF::SCALED_RADIUS_Y)) != DMF::NIL; }
inline bool hasAnyX(DMF Value) { return (Value & (DMF::SCALED_X|DMF::FIXED_X)) != DMF::NIL; }
inline bool hasAnyY(DMF Value) { return (Value & (DMF::SCALED_Y|DMF::FIXED_Y)) != DMF::NIL; }
inline bool hasAnyWidth(DMF Value) { return (Value & (DMF::SCALED_WIDTH|DMF::FIXED_WIDTH)) != DMF::NIL; }
inline bool hasAnyHeight(DMF Value) { return (Value & (DMF::SCALED_HEIGHT|DMF::FIXED_HEIGHT)) != DMF::NIL; }
inline bool hasAnyXOffset(DMF Value) { return (Value & (DMF::SCALED_X_OFFSET|DMF::FIXED_X_OFFSET)) != DMF::NIL; }
inline bool hasAnyYOffset(DMF Value) { return (Value & (DMF::SCALED_Y_OFFSET|DMF::FIXED_Y_OFFSET)) != DMF::NIL; }
}

]])

  struct("ObjectSignal", { comment="Required in calls to WaitForObjects()." }, [[
     obj Object # Reference to an object to monitor.
  ]])

  struct("ResourceManager", { comment="This structure must be placed at the start of any memory block allocated with the MEM::MANAGED flag.", restrict="c" }, [[
     cstr Name             # The name of the resource.
     fptr(error ptr) Free  # A function that will remove the resource's content when terminated.
  ]])

  struct("FunctionField", { comment="Used by ActionTable and Function structures to declare lists of parameters." }, [[
    cstr Name   # Name of the field
    uint Type   # Type of the field
  ]])

  struct("Function", { comment="Function list array structure" }, [[
    ptr Address     # Pointer to the function entry point
    cstr Name       # Name of the function
    cstruct(*FunctionField) Args  # A list of parameters accepted by the function
  ]])

  struct("ModHeader", { comment="Module file header", restrict="c" }, [[
    int(MHF) Flags                 # Special flags, type of function table wanted from the Core
    cstr Definitions               # Module definition string, usable by run-time languages such as Fluid
    fptr(error obj struct(*CoreBase)) Init # A one-off initialisation routine for when the module is first opened.
    fptr(void obj) Close           # A function that will be called each time the module is closed.
    fptr(error obj) Open           # A function that will be called each time the module is opened.
    fptr(error) Expunge            # Reference to an expunge function to terminate the module.
    cstr Name                      # Name of the module
    cstr Namespace                 # A reserved system-wide namespace for function names.
  ]],
  [[
   STRUCTS *StructDefs;
   class RootModule *Root;
   ModHeader(ERR (*pInit)(OBJECTPTR, struct CoreBase *),
      void  (*pClose)(OBJECTPTR),
      ERR (*pOpen)(OBJECTPTR),
      ERR (*pExpunge)(void),
      CSTRING pDef,
      STRUCTS *pStructs,
      CSTRING pName,
      CSTRING pNamespace) {
      Flags         = MHF::DEFAULT;
      Definitions   = pDef;
      StructDefs    = pStructs;
      Init          = pInit;
      Close         = pClose;
      Open          = pOpen;
      Expunge       = pExpunge;
      Name          = pName;
      Namespace     = pNamespace;
      Root          = nullptr;
   }
  ]])

  struct("FieldArray", { comment="Used to construct class blueprints for the MetaClass." }, [[
    cstr   Name      # The name of the field, e.g. `Width`
    ptr    GetField  # `void GetField(*Object, APTR Result);`
    ptr    SetField  # `ERR SetField(*Object, APTR Value);`
    maxint Arg       # Can be a pointer or an integer value
    uint   Flags     # Special flags that describe the field
  ]],
  [[
  template <class G = APTR, class S = APTR, class T = MAXINT> FieldArray(CSTRING pName, uint32_t pFlags, G pGetField = nullptr, S pSetField = nullptr, T pArg = 0) :
     Name(pName), GetField((APTR)pGetField), SetField((APTR)pSetField), Arg((MAXINT)pArg), Flags(pFlags)
     { }
  ]])

  struct("FieldDef", { comment="Used to define constants for field references." }, [[
    cstr Name  # The name of the constant.
    int Value  # The value of the constant.
  ]],
  [[
   template <class T> FieldDef(CSTRING pName, T pValue) : Name(pName), Value(int(pValue)) { }
  ]])

  struct("SystemState", { comment="Returned by the GetSystemState() function." }, [[
    cstr Platform      # String-based field indicating the user's platform.  Currently returns `Native`, `Windows`, `OSX` or `Linux`.
    hhandle ConsoleFD  # Internal
    int  Stage         # The current operating stage.  `-1` = Initialising, `0` indicates normal operating status; `1` means that the program is shutting down; `2` indicates a program restart; `3` is for mode switches.
  ]])

  struct("Unit", { }, [[
    double Value  # The unit value.
    uint   Type   # Additional type information
  ]],
  [[
   constexpr Unit(double pValue, int pType = FD_DOUBLE) : Value(pValue), Type(pType) { }
   constexpr Unit() : Value(0), Type(0) { }
   explicit Unit(std::string_view String) { read(String); }
   constexpr operator double() const { return Value; }
   constexpr void set(const double pValue) { Value = pValue; }
   bool scaled() { return (Type & FD_SCALED) ? true : false; }
   inline void read(std::string_view String) {
      const auto start = String.find_first_not_of(" \n\r\t");
      if (start != std::string::npos) String.remove_prefix(start);
      if (String.starts_with('+')) String.remove_prefix(1);
      auto [ end, error ] = std::from_chars(String.data(), String.data() + String.size(), Value);
      if (error != std::errc()) { Value = 0; return; }

      String = String.substr(end - String.data());
      if (String.starts_with("%")) { Value *= 0.01; Type = FD_DOUBLE|FD_SCALED; }
      else Type = FD_DOUBLE;
   }
   ]])

  -- Structures for defining method and action invocations.

  struct("ActionArray", { }, [[
    ptr Routine     # Pointer to the function entry point
    int(AC) ActionCode  # Action identifier
  ]],
  [[
  template <class T> ActionArray(AC pID, T pRoutine) : Routine((APTR)pRoutine), ActionCode(pID) { }
  ]])

  struct("MethodEntry", { restrict="c" }, [[
    int(AC) MethodID  # Unique method identifier
    ptr  Routine      # The method entry point, defined as `ERR (*Routine)(OBJECTPTR, APTR);`
    cstr Name         # Name of the method
    cstruct(*FunctionField) Args  # List of parameters accepted by the method
    int  Size         # Total byte-size of all accepted parameters when they are assembled as a C structure.
  ]],
  [[
   MethodEntry() : MethodID(AC::NIL), Routine(nullptr), Name(nullptr) { }
   MethodEntry(AC pID, APTR pRoutine, CSTRING pName, const struct FunctionField *pArgs, int pSize) :
      MethodID(pID), Routine(pRoutine), Name(pName), Args(pArgs), Size(pSize) { }
  ]])

  struct("ActionTable", { comment="Structure for ActionList" }, [[
    uint Hash   # Hash of the action name.
    int  Size   # Byte-size of the structure for this action.
    cstr Name   # Name of the action.
    cstruct(*FunctionField) Args  # List of fields that are passed to this action.
  ]])

  struct("ChildEntry", { comment="Structure for ListChildren() function" }, [[
    oid ObjectID  # Object ID
    cid ClassID   # The class ID of the referenced object.
  ]])

  struct("Message", { comment="Message header." }, [[
     large Time  # A timestamp acquired from ~Core.PreciseTime() when the message was first passed to ~Core.SendMessage().
     int UID     # A unique identifier automatically created by ~Core.SendMessage().
     int(MSGID) Type # A message type identifier as defined by the client.
     int Size    # The byte-size of the message data, or zero if no data is provided.
  ]])

  struct("MemInfo", { type="meminfo" }, [[
    ptr  Start         # The starting address of the memory block (does not apply to shared blocks).
    oid  ObjectID      # The object that owns the memory block.
    uint Size          # The size of the memory block.
    int(MEM) Flags     # The type of memory.
    mem   MemoryID     # The unique ID for this block.
    short AccessCount  # Total number of active locks on this block.
  ]])

  struct("MsgHandler", { restrict="c" }, [[
    ptr(struct(MsgHandler)) Prev  # Previous message handler in the chain.
    ptr(struct(MsgHandler)) Next  # Next message handler in the chain.
    func Function                 # Call this function to handle the message.
    int(MSGID) MsgType            # Type of message being filtered.
  ]])

  struct("CacheFile", { restrict="c", comment="Internal structure for managing files cached by LoadFile()." }, [[
    large TimeStamp   # The file's last-modified timestamp.
    large Size        # Byte size of the cached data.
    large LastUse     # The last time that this file was requested.
    cstr Path         # Pointer to the resolved file path.
    ptr Data          # Pointer to the cached data.
  ]])

  struct("CompressionFeedback", { }, [[
    int(FDB) FeedbackID     # Set to one of the FDB event indicators
    int   Index             # Index of the current file
    cstr  Path              # Name of the current file/path in the archive
    cstr  Dest              # Destination file/path during decompression
    large Progress          # Progress indicator (byte position for the file being de/compressed).
    large OriginalSize      # Original size of the file
    large CompressedSize    # Compressed size of the file
    short Year              # Year of the original file's datestamp.
    short Month             # Month of the original file's datestamp.
    short Day               # Day of the original file's datestamp.
    short Hour              # Hour of the original file's datestamp.
    short Minute            # Minute of the original file's datestamp.
    short Second            # Second of the original file's datestamp.
  ]],
  [[
   CompressionFeedback() : FeedbackID(FDB::NIL), Index(0), Path(nullptr), Dest(nullptr),
      Progress(0), OriginalSize(0), CompressedSize(0),
      Year(0), Month(0), Day(0), Hour(0), Minute(0), Second(0) { }

   CompressionFeedback(FDB pFeedback, int pIndex, CSTRING pPath, CSTRING pDest) :
      FeedbackID(pFeedback), Index(pIndex), Path(pPath), Dest(pDest),
      Progress(0), OriginalSize(0), CompressedSize(0),
      Year(0), Month(0), Day(0), Hour(0), Minute(0), Second(0) { }
  ]])

  struct("CompressedItem", { }, [[
    large OriginalSize            # Original size of the file
    large CompressedSize          # Compressed size of the file
    struct(*CompressedItem) Next  # Used only if this is a linked-list.
    cstr Path                     # Path to the file (includes folder prefixes).  Archived folders will include the trailing slash.
    int(PERMIT) Permissions       # Original permissions - see `PERMIT` flags.
    int  UserID                   # Original user ID
    int  GroupID                  # Original group ID
    int  OthersID                 # Original others ID
    int(FL) Flags                 # `FL` flags
    struct(DateTime) Created      # Date and time of the file's creation.
    struct(DateTime) Modified     # Date and time last modified.
  ]],
  [[
    ankerl::unordered_dense::map<std::string, std::string> *Tags;
  ]])

  struct("FileInfo", { comment="Metadata for describing a file." }, [[
    large Size                 # The size of the file's content.
    large TimeStamp            # 64-bit time stamp - usable only for comparison (e.g. sorting).
    struct(*FileInfo) Next     # Next structure in the list, or `NULL`.
    str Name                   # The name of the file.
    int(RDF) Flags             # Additional flags to describe the file.
    int(PERMIT) Permissions    # Standard permission flags.
    int UserID                 # User  ID (Unix systems only).
    int GroupID                # Group ID (Unix systems only).
    struct(DateTime) Created   # The date/time of the file's creation.
    struct(DateTime) Modified  # The date/time of the last file modification.
  ]],
  [[
    ankerl::unordered_dense::map<std::string, std::string> *Tags;
  ]]) -- NB: Private fields can follow this structure.

  struct("DirInfo", { comment="Used by OpenDir() only" }, [[
    struct(*FileInfo) Info # Pointer to a !FileInfo structure
  ]],
  [[
   #ifdef PRV_FILE
   APTR   Driver;
   APTR   prvHandle;        // Directory handle.  If virtual, may store a private data address
   STRING prvPath;          // Original folder location string
   STRING prvResolvedPath;  // Resolved folder location
   RDF    prvFlags;         // OpenFolder() RDF flags
   int    prvTotal;         // Total number of items in the folder
   uint32_t prvVirtualID;   // Unique ID (name hash) for a virtual device
   union {
      int prvIndex;         // Current index within the folder when scanning
      APTR prvIndexPtr;
   };
   int16_t   prvResolveLen;    // Byte length of ResolvedPath
   #endif
  ]])

  -- NB: Duplicated to windows.c
  struct("FileFeedback", { }, [[
    large Size          # Size of the file
    large Position      # Current seek position within the file if moving or copying
    str Path            # Path to the file
    str Dest            # Destination file/path if moving or copying
    int(FBK) FeedbackID # Set to one of the `FBK` values
    char(32) Reserved   # Reserved in case of future expansion
  ]],
  [[
  FileFeedback() : Size(0), Position(0), Path(nullptr), Dest(nullptr), FeedbackID(FBK::NIL) { }
  ]])

  struct("Field", { comment="Used to describe the public fields of a class." }, [[
    maxint Arg         # An option to complement the field type.  Can be a pointer or an integer value
    fptr(error ptr ptr) GetValue # A virtual function that will retrieve the value for this field.
    ptr SetValue       # A virtual function that will set the value for this field.
    fptr(error obj struct(*Field) int cptr int) WriteValue # An internal function for writing to this field.
    cstr Name          # The English name for the field, e.g. `Width`
    uint FieldID       # Provides a fast way of finding fields, e.g. `FID_Width`
    ushort Offset      # Field offset within the object
    ushort Index       # Field array index
    uint Flags         # Special flags that describe the field
  ]],
  [[
   bool readable() {
      return (Flags & FD_READ) ? true : false;
   }
   bool writeable() {
      return (Flags & (FD_WRITE|FD_INIT)) ? true : false;
   }
  ]]) -- [32/52]

  c_insert([[
struct ScriptArg { // For use with sc::Exec
   CSTRING Name;
   uint32_t Type;
   union {
      APTR    Address;
      int     Int;
      int64_t Int64;
      double  Double;
   };

   ScriptArg(CSTRING pName, OBJECTPTR pValue, uint32_t pType = FD_OBJECTPTR) : Name(pName), Type(pType), Address((APTR)pValue) { }
   ScriptArg(CSTRING pName, std::string &pValue, uint32_t pType = FD_STRING) : Name(pName), Type(pType), Address((APTR)pValue.data()) { }
   ScriptArg(CSTRING pName, const std::string &pValue, uint32_t pType = FD_STRING) : Name(pName), Type(pType), Address((APTR)pValue.data()) { }
   ScriptArg(CSTRING pName, CSTRING pValue, uint32_t pType = FD_STRING) : Name(pName), Type(pType), Address((APTR)pValue) { }
   ScriptArg(CSTRING pName, APTR pValue, uint32_t pType = FD_PTR) : Name(pName), Type(pType), Address(pValue) { }
   ScriptArg(CSTRING pName, int pValue, uint32_t pType = FD_INT) : Name(pName), Type(pType), Int(pValue) { }
   ScriptArg(CSTRING pName, uint32_t pValue, uint32_t pType = FD_INT) : Name(pName), Type(pType), Int(pValue) { }
   ScriptArg(CSTRING pName, int64_t pValue, uint32_t pType = FD_INT64) : Name(pName), Type(pType), Int64(pValue) { }
   ScriptArg(CSTRING pName, double pValue, uint32_t pType = FD_DOUBLE) : Name(pName), Type(pType), Double(pValue) { }
};
]])

  functionNames(nil,
    "AccessMemory",
    "Action",
    "ActionList",
    "DeleteFile",
    "ResolveClassID",
    "AllocateID",
    "AllocMemory",
    "AccessObject",
    "CheckAction",
    "CheckMemoryExists",
    "CheckObjectExists",
    "InitObject",
    "VirtualVolume",
    "CurrentContext",
    "AdjustLogLevel",
    "ReadFileToBuffer",
    "FindObject",
    "FindClass",
    "AnalysePath",
    "FreeResource",
    "GetClassID",
    "GetOwnerID",
    "CompareFilePaths",
    "GetSystemState",
    "ListChildren",
    "RegisterFD",
    "ResolvePath",
    "MemoryIDInfo",
    "MemoryPtrInfo",
    "NewObject",
    "NotifySubscribers",
    "CopyFile",
    "ProcessMessages",
    "IdentifyFile",
    "ReallocMemory",
    "ReleaseMemory",
    "ResolveClassName",
    "SendMessage",
    "SetOwner",
    "SetContext",
    "SetObjectContext",
    "FieldName",
    "ScanDir",
    "SetName",
    "LogReturn",
    "SubscribeAction",
    "SubscribeEvent",
    "SubscribeTimer",
    "UpdateTimer",
    "UnsubscribeAction",
    "UnsubscribeEvent",
    "BroadcastEvent",
    "WaitTime",
    "GetEventID",
    "GenCRC32",
    "GetResource",
    "SetResource",
    "ScanMessages",
    "WaitForObjects",
    "UnloadFile",
    "CreateFolder",
    "LoadFile",
    "SetVolume",
    "DeleteVolume",
    "MoveFile",
    "UpdateMessage",
    "AddMsgHandler",
    "QueueAction",
    "PreciseTime",
    "OpenDir",
    "GetObjectPtr",
    "FindField",
    "GetErrorMsg",
    "GetActionMsg",
    "FuncError",
    "LockObject",
    "ReleaseObject",
    "AsyncAction",
    "AddInfoTag",
    "SetDefaultPermissions",
    "VLogF",
    "ReadInfoTag",
    "SetResourcePath",
    "CurrentTask",
    "ResolveGroupID",
    "ResolveUserID",
    "CreateLink",
    "ParentContext",
    "SetResourceMgr",
    "ProtectMemory")

  c_insert([=[

//********************************************************************************************************************

#define END_FIELD FieldArray(nullptr, 0)
#define FDEF static const struct FunctionField

template <class T> inline MEMORYID GetMemoryID(T &&A) {
   return ((MEMORYID *)A)[-2];
}

inline ERR DeregisterFD(HOSTHANDLE Handle) {
   return RegisterFD(Handle, RFD::REMOVE|RFD::READ|RFD::WRITE|RFD::EXCEPT|RFD::ALWAYS_CALL, 0, 0);
}

inline APTR GetResourcePtr(RES ID) { return (APTR)(MAXINT)GetResource(ID); }

inline CSTRING to_cstring(const std::string &A) { return A.c_str(); }
constexpr inline CSTRING to_cstring(CSTRING A) { return A; }
#ifndef PRV_CORE_DATA
// These overloaded functions can't be used in the Core as they will confuse the compiler in key areas.

inline ERR SubscribeAction(OBJECTPTR Object, AC Action, FUNCTION Callback) {
   return SubscribeAction(Object,Action,&Callback);
}

inline ERR SubscribeEvent(int64_t Event, FUNCTION Callback, APTR *Handle) {
   return SubscribeEvent(Event,&Callback,Handle);
}

inline ERR SubscribeTimer(double Interval, FUNCTION Callback, APTR *Subscription) {
   return SubscribeTimer(Interval,&Callback,Subscription);
}

inline ERR ReleaseMemory(const void *Address) {
   if (!Address) return ERR::NullArgs;
   return ReleaseMemory(((MEMORYID *)Address)[-2]);
}

inline ERR FreeResource(const void *Address) {
   if (!Address) return ERR::NullArgs;
   return FreeResource(((int *)Address)[-2]);
}

inline ERR AllocMemory(int Size, MEM Flags, APTR Address) {
   return AllocMemory(Size, Flags, (APTR *)Address, nullptr);
}

template<class T> inline ERR NewObject(CLASSID ClassID, T **Result) {
   return NewObject(ClassID, NF::NIL, (OBJECTPTR *)Result);
}

template<class T> inline ERR NewLocalObject(CLASSID ClassID, T **Result) {
   return NewObject(ClassID, NF::LOCAL, (OBJECTPTR *)Result);
}

inline ERR MemoryIDInfo(MEMORYID ID, struct MemInfo * MemInfo) {
   return MemoryIDInfo(ID,MemInfo,sizeof(struct MemInfo));
}

inline ERR MemoryPtrInfo(APTR Address, struct MemInfo * MemInfo) {
   return MemoryPtrInfo(Address,MemInfo,sizeof(struct MemInfo));
}

inline ERR QueueAction(AC Action, OBJECTID ObjectID) {
   return QueueAction(Action, ObjectID, nullptr);
}
#endif

typedef KEYVALUE ConfigKeys;
typedef std::pair<std::string, ConfigKeys> ConfigGroup;
typedef std::vector<ConfigGroup> ConfigGroups;

namespace pf {

inline void copymem(const void *Src, APTR Dest, std::size_t Length) {
   memmove(Dest, Src, Length);
}

inline void clearmem(APTR Memory, std::size_t Length) {
   if (Memory) memset(Memory, 0, Length);
}

static thread_local int _tlUniqueThreadID = 0;

[[nodiscard]] inline int _get_thread_id(void) {
   if (_tlUniqueThreadID) return _tlUniqueThreadID;
   _tlUniqueThreadID = GetResource(RES::THREAD_ID);
   return _tlUniqueThreadID;
}

// For extremely verbose debug logs, run cmake with -DPARASOL_VLOG=ON

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wformat-zero-length"

class Log { // C++ wrapper for Parasol's log functionality
   private:
      int branches;
      CSTRING header;

   public:
      Log() : branches(0), header(nullptr) { }
      Log(CSTRING Header) : branches(0), header(Header) { }

      ~Log() {
         while (branches > 0) { branches--; LogReturn(); }
      }

      void branch(CSTRING Message = "", ...) __attribute__((format(printf, 2, 3))) {
         va_list arg;
         va_start(arg, Message);
         VLogF(VLF::API|VLF::BRANCH, header, Message, arg);
         va_end(arg);
         branches++;
      }

      #ifdef _DEBUG
      void traceBranch(CSTRING Message = "", ...) __attribute__((format(printf, 2, 3))) {
         va_list arg;
         va_start(arg, Message);
         VLogF(VLF::TRACE|VLF::BRANCH, header, Message, arg);
         va_end(arg);
         branches++;
      }
      #else
      void traceBranch(CSTRING Message = "", ...) __attribute__((format(printf, 2, 3))) { }
      #endif

      inline void debranch() {
         branches--;
         LogReturn();
      }

      void app(CSTRING Message, ...) { // Info level, recommended for applications only
         va_list arg;
         va_start(arg, Message);
         VLogF(VLF::INFO, header, Message, arg);
         va_end(arg);
      }

      void msg(CSTRING Message, ...) __attribute__((format(printf, 2, 3))) { // Defaults to API level, recommended for modules
         va_list arg;
         va_start(arg, Message);
         VLogF(VLF::API, header, Message, arg);
         va_end(arg);
      }

      void msg(VLF Flags, CSTRING Message, ...) __attribute__((format(printf, 3, 4))) { // Defaults to API level, recommended for modules
         va_list arg;
         va_start(arg, Message);
         VLogF(Flags, header, Message, arg);
         va_end(arg);
         if ((Flags & VLF::BRANCH) != VLF::NIL) branches++;
      }

      void detail(CSTRING Message, ...) __attribute__((format(printf, 2, 3))) { // Detailed API message
         va_list arg;
         va_start(arg, Message);
         VLogF(VLF::DETAIL, header, Message, arg);
         va_end(arg);
      }

      void pmsg(CSTRING Message, ...) __attribute__((format(printf, 2, 3))) { // "Parent message", uses the scope of the caller
         va_list arg;
         va_start(arg, Message);
         VLogF(VLF::API, nullptr, Message, arg);
         va_end(arg);
      }

      void warning(CSTRING Message, ...) __attribute__((format(printf, 2, 3))) {
         va_list arg;
         va_start(arg, Message);
         VLogF(VLF::WARNING, header, Message, arg);
         va_end(arg);
      }

      void error(CSTRING Message, ...) __attribute__((format(printf, 2, 3))) { // NB: Use for messages intended for the user, not the developer
         va_list arg;
         va_start(arg, Message);
         VLogF(VLF::ERROR, header, Message, arg);
         va_end(arg);
      }

      void function(CSTRING Message = "", ...) __attribute__((format(printf, 2, 3))) { // Equivalent to branch() but without a new branch being created
         va_list arg;
         va_start(arg, Message);
         VLogF(VLF::API|VLF::FUNCTION, header, Message, arg);
         va_end(arg);
      }

      inline ERR error(ERR Code) { // Technically a warning
         FuncError(header, Code);
         return Code;
      }

      inline ERR warning(ERR Code) {
         FuncError(header, Code);
         return Code;
      }

      void trace(CSTRING Message, ...) {
         #ifdef _DEBUG
            va_list arg;
            va_start(arg, Message);
            VLogF(VLF::TRACE, header, Message, arg);
            va_end(arg);
         #endif
      }

      void traceWarning(CSTRING Message, ...) {
         #ifdef _DEBUG
            va_list arg;
            va_start(arg, Message);
            VLogF(VLF::WARNING, header, Message, arg);
            va_end(arg);
         #endif
      }

      inline ERR traceWarning(ERR Code) {
         #ifdef _DEBUG
            FuncError(header, Code);
         #endif
         return Code;
      }
};

#pragma GCC diagnostic pop

class LogLevel {
   private:
      int level;
   public:
      LogLevel(int Level) : level(Level) {
         AdjustLogLevel(Level);
      }

      ~LogLevel() {
         AdjustLogLevel(-level);
      }
};

} // namespace

class ScopedObjectAccess {
   private:
      OBJECTPTR obj;

   public:
      ERR error;

      inline ScopedObjectAccess(OBJECTPTR Object);

      inline ~ScopedObjectAccess();

      inline bool granted() { return error == ERR::Okay; }

      inline void release();
};

//********************************************************************************************************************
// Refer to Object->get() to see what this is about...

template <class T> inline int64_t FIELD_TAG()     { return 0; }
template <> inline int64_t FIELD_TAG<double>()    { return TDOUBLE; }
template <> inline int64_t FIELD_TAG<bool>()      { return TINT; }
template <> inline int64_t FIELD_TAG<int>()       { return TINT; }
template <> inline int64_t FIELD_TAG<int64_t>()   { return TINT64; }
template <> inline int64_t FIELD_TAG<uint64_t>()  { return TINT64; }
template <> inline int64_t FIELD_TAG<float>()     { return TFLOAT; }
template <> inline int64_t FIELD_TAG<OBJECTPTR>() { return TPTR; }
template <> inline int64_t FIELD_TAG<APTR>()      { return TPTR; }
template <> inline int64_t FIELD_TAG<CSTRING>()   { return TSTRING; }
template <> inline int64_t FIELD_TAG<STRING>()    { return TSTRING; }
template <> inline int64_t FIELD_TAG<SCALE>()     { return TDOUBLE|TSCALE; }

// For testing if type T can be matched to an FD flag.

template <class T> inline int FIELD_TYPECHECK()     { return FD_PTR|FD_STRUCT|FD_STRING; }
template <> inline int FIELD_TYPECHECK<double>()    { return FD_DOUBLE; }
template <> inline int FIELD_TYPECHECK<bool>()      { return FD_INT; }
template <> inline int FIELD_TYPECHECK<int>()       { return FD_INT; }
template <> inline int FIELD_TYPECHECK<int64_t>()   { return FD_INT64; }
template <> inline int FIELD_TYPECHECK<uint64_t>()  { return FD_INT64; }
template <> inline int FIELD_TYPECHECK<float>()     { return FD_FLOAT; }
template <> inline int FIELD_TYPECHECK<OBJECTPTR>() { return FD_PTR; }
template <> inline int FIELD_TYPECHECK<APTR>()      { return FD_PTR; }
template <> inline int FIELD_TYPECHECK<CSTRING>()   { return FD_STRING; }
template <> inline int FIELD_TYPECHECK<STRING>()    { return FD_STRING; }
template <> inline int FIELD_TYPECHECK<std::string>() { return FD_STRING|FD_CPP; }

//********************************************************************************************************************

class ObjectContext {
public:
   OBJECTPTR obj = nullptr;                 // The object that currently has the operating context.
   struct Field *field = nullptr;           // Set if the context is linked to a get/set field operation.  For logging purposes only.
   class extObjectContext *stack = nullptr; // Call stack.
   AC action = AC::NIL;                     // Set if the context enters an action or method routine.
};

//********************************************************************************************************************
// Header used for all objects.

struct Object { // Must be 64-bit aligned
   union {
      objMetaClass *Class;          // [Public] Class pointer
      class extMetaClass *ExtClass; // [Private] Internal version of the class pointer
   };
   APTR     ChildPrivate;        // Address for the ChildPrivate structure, if allocated
   APTR     CreatorMeta;         // The creator of the object is permitted to store a custom data pointer here.
   struct Object *Owner;         // The owner of this object
   std::atomic_uint64_t NotifyFlags; // Action subscription flags - space for 64 actions max
   std::atomic_uchar ThreadPending; // AsyncAction() increments this.
   std::atomic_char Queue;       // Counter of locks attained by LockObject(); decremented by ReleaseObject()
   std::atomic_char SleepQueue;  // For the use of LockObject() only
   int8_t   ActionDepth;         // Incremented each time an action or method is called on the object
   OBJECTID UID;                 // Unique object identifier
   NF       Flags;               // Object flags
   std::atomic_int ThreadID;     // Managed by locking functions.  Atomic due to volatility.
   char Name[MAX_NAME_LEN];      // The name of the object.  NOTE: This value can be adjusted to ensure that the struct is always 8-bit aligned.

   // NB: This constructor is called by NewObject(), no need to call it manually from client code.

   Object() : NotifyFlags(0), ThreadPending(0), Queue(0), SleepQueue(0), ThreadID(0) {
      Class = nullptr;
      ChildPrivate = nullptr;
      CreatorMeta = nullptr;
      Owner = nullptr;
      NotifyFlags = 0;
      ThreadPending = 0;
      Queue = 0;
      SleepQueue = 0;
      ActionDepth = 0;
      UID = 0;
      Flags = NF::NIL;
      Name[0] = '\0';
   }

   inline bool initialised() { return (Flags & NF::INITIALISED) != NF::NIL; }
   inline bool defined(NF pFlags) { return (Flags & pFlags) != NF::NIL; }
   inline bool isSubClass();
   inline OBJECTID ownerID() { return Owner ? Owner->UID : 0; }
   inline CLASSID classID();
   inline CLASSID baseClassID();
   inline NF flags() { return Flags; }

   CSTRING className();

   inline bool collecting() { // Is object being freed or marked for collection?
      return (Flags & (NF::FREE|NF::COLLECT|NF::FREE_ON_UNLOCK)) != NF::NIL;
   }

   inline bool terminating() { // Is object currently being freed?
      return (Flags & NF::FREE) != NF::NIL;
   }

   // Use lock() to quickly obtain an object lock without a call to LockObject().  Can fail if the object is being collected.

   inline ERR lock(int Timeout = -1) {
      if (++Queue IS 1) {
         ThreadID = pf::_get_thread_id();
         return ERR::Okay;
      }
      else {
         if (ThreadID IS pf::_get_thread_id()) return ERR::Okay; // If this is for the same thread then it's a nested lock, so there's no issue.
         --Queue; // Restore the lock count
         return LockObject(this, Timeout); // Can fail if object is marked for collection.
      }
   }

   inline void unlock() {
      // Prefer to use ReleaseObject() if there are threads that need to be woken
      if ((SleepQueue > 0) or defined(NF::FREE_ON_UNLOCK)) ReleaseObject(this);
      else --Queue;
   }

   inline bool locked() {
      return Queue > 0;
   }

   inline bool hasOwner(OBJECTID ID) { // Return true if ID has ownership.
      auto obj = this->Owner;
      while ((obj) and (obj->UID != ID)) obj = obj->Owner;
      return obj ? true : false;
   }

   // set() support for array fields

   template <class T> ERR set(FIELD FieldID, const T *Data, size_t Elements, int Type = FIELD_TYPECHECK<T>()) {
      Object *target;
      if (auto field = FindField(this, FieldID, &target)) {
         if (!(field->Flags & FD_ARRAY)) return ERR::FieldTypeMismatch;
         if ((!field->writeable()) and (CurrentContext() != target)) return ERR::NoFieldAccess;
         if ((field->Flags & FD_INIT) and (target->initialised()) and (CurrentContext() != target)) return ERR::NoFieldAccess;
         return field->WriteValue(target, field, FD_ARRAY|Type, Data, Elements);
      }
      else return ERR::UnsupportedField;
   }

   template <class T, std::size_t SIZE> ERR set(FIELD FieldID, const std::array<T, SIZE> &Value, int Type = FIELD_TYPECHECK<T>()) {
      Object *target;
      if (auto field = FindField(this, FieldID, &target)) {
         if (!(field->Flags & FD_ARRAY)) return ERR::FieldTypeMismatch;
         if ((!field->writeable()) and (CurrentContext() != target)) return ERR::NoFieldAccess;
         if ((field->Flags & FD_INIT) and (target->initialised()) and (CurrentContext() != target)) return ERR::NoFieldAccess;

         return field->WriteValue(target, field, FD_ARRAY|Type, Value.data(), SIZE);
      }
      else return ERR::UnsupportedField;
   }

   template <class T> ERR set(FIELD FieldID, const std::vector<T> &Value, int Type = FIELD_TYPECHECK<T>()) {
      Object *target;
      if (auto field = FindField(this, FieldID, &target)) {
         if (!(field->Flags & FD_ARRAY)) return ERR::FieldTypeMismatch;
         if ((!field->writeable()) and (CurrentContext() != target)) return ERR::NoFieldAccess;
         if ((field->Flags & FD_INIT) and (target->initialised()) and (CurrentContext() != target)) return ERR::NoFieldAccess;

         return field->WriteValue(target, field, FD_ARRAY|Type, const_cast<T *>(Value.data()), std::ssize(Value));
      }
      else return ERR::UnsupportedField;
   }

   template <class T> ERR set(FIELD FieldID, const pf::vector<T> &Value, int Type = FIELD_TYPECHECK<T>()) {
      Object *target;
      if (auto field = FindField(this, FieldID, &target)) {
         if (!(field->Flags & FD_ARRAY)) return ERR::FieldTypeMismatch;
         if ((!field->writeable()) and (CurrentContext() != target)) return ERR::NoFieldAccess;
         if ((field->Flags & FD_INIT) and (target->initialised()) and (CurrentContext() != target)) return ERR::NoFieldAccess;

         if (field->Flags & FD_CPP) return field->WriteValue(target, field, FD_ARRAY|Type, &Value, std::ssize(Value));
         else return field->WriteValue(target, field, FD_ARRAY|Type, const_cast<T *>(Value.data()), std::ssize(Value));
      }
      else return ERR::UnsupportedField;
   }

   inline ERR set(FIELD FieldID, const FRGB &Value) {
      Object *target;
      if (auto field = FindField(this, FieldID, &target)) {
         if (!(field->Flags & FD_ARRAY)) return ERR::FieldTypeMismatch;
         if ((!field->writeable()) and (CurrentContext() != target)) return ERR::NoFieldAccess;
         if ((field->Flags & FD_INIT) and (target->initialised()) and (CurrentContext() != target)) return ERR::NoFieldAccess;
         return field->WriteValue(target, field, FD_ARRAY|FD_FLOAT, &Value, 4);
      }
      else return ERR::UnsupportedField;
   }

   // set() support for numeric types

   template <class T> ERR set(FIELD FieldID, const T Value) requires std::integral<T> || std::floating_point<T> {
      Object *target;
      if (auto field = FindField(this, FieldID, &target)) {
         if ((!field->writeable()) and (CurrentContext() != target)) return ERR::NoFieldAccess;
         if ((field->Flags & FD_INIT) and (target->initialised()) and (CurrentContext() != target)) return ERR::NoFieldAccess;
         return field->WriteValue(target, field, FIELD_TYPECHECK<T>(), &Value, 1);
      }
      else return ERR::UnsupportedField;
   }

   inline ERR set(FIELD FieldID, const FUNCTION *Value) {
      Object *target;
      if (auto field = FindField(this, FieldID, &target)) {
         if ((!field->writeable()) and (CurrentContext() != target)) return ERR::NoFieldAccess;
         if ((field->Flags & FD_INIT) and (target->initialised()) and (CurrentContext() != target)) return ERR::NoFieldAccess;
         return field->WriteValue(target, field, FD_FUNCTION, Value, 1);
      }
      else return ERR::UnsupportedField;
   }

   inline ERR set(FIELD FieldID, const char *Value) {
      Object *target;
      if (auto field = FindField(this, FieldID, &target)) {
         if ((!field->writeable()) and (CurrentContext() != target)) return ERR::NoFieldAccess;
         if ((field->Flags & FD_INIT) and (target->initialised()) and (CurrentContext() != target)) return ERR::NoFieldAccess;
         return field->WriteValue(target, field, FD_STRING, Value, 1);
      }
      else return ERR::UnsupportedField;
   }

   inline ERR set(FIELD FieldID, const unsigned char *Value) {
      Object *target;
      if (auto field = FindField(this, FieldID, &target)) {
         if ((!field->writeable()) and (CurrentContext() != target)) return ERR::NoFieldAccess;
         if ((field->Flags & FD_INIT) and (target->initialised()) and (CurrentContext() != target)) return ERR::NoFieldAccess;
         return field->WriteValue(target, field, FD_STRING, Value, 1);
      }
      else return ERR::UnsupportedField;
   }

   inline ERR set(FIELD FieldID, const std::string &Value) {
      Object *target;
      if (auto field = FindField(this, FieldID, &target)) {
         if ((!field->writeable()) and (CurrentContext() != target)) return ERR::NoFieldAccess;
         if ((field->Flags & FD_INIT) and (target->initialised()) and (CurrentContext() != target)) return ERR::NoFieldAccess;
         return field->WriteValue(target, field, FD_STRING, Value.c_str(), 1);
      }
      else return ERR::UnsupportedField;
   }

   inline ERR set(FIELD FieldID, const Unit *Value) {
      Object *target;
      if (auto field = FindField(this, FieldID, &target)) {
         if ((!field->writeable()) and (CurrentContext() != target)) return ERR::NoFieldAccess;
         if ((field->Flags & FD_INIT) and (target->initialised()) and (CurrentContext() != target)) return ERR::NoFieldAccess;
         return field->WriteValue(target, field, FD_UNIT, Value, 1);
      }
      else return ERR::UnsupportedField;
   }

   inline ERR set(FIELD FieldID, const Unit &Value) {
      return set(FieldID, &Value);
   }

   // Works both for regular data pointers and function pointers if the field is defined correctly.

   inline ERR set(FIELD FieldID, const void *Value) {
      Object *target;
      if (auto field = FindField(this, FieldID, &target)) {
         if ((!field->writeable()) and (CurrentContext() != target)) return ERR::NoFieldAccess;
         if ((field->Flags & FD_INIT) and (target->initialised()) and (CurrentContext() != target)) return ERR::NoFieldAccess;
         return field->WriteValue(target, field, FD_POINTER, Value, 1);
      }
      else return ERR::UnsupportedField;
   }

   // There are two mechanisms for retrieving object values; the first allows the value to be retrieved with an error
   // code and the value itself; the second ignores the error code and returns a value that could potentially be invalid.

   private:
   template <class T> ERR get_unit(Object *Object, struct Field &Field, T &Value) {
      auto new_context = ObjectContext{ Object, &Field };
      auto ctx = SetObjectContext(&new_context);

      ERR error = ERR::Okay;
      if (Field.Flags & (FD_DOUBLE|FD_INT64|FD_INT)) {
          Unit var(0, FD_DOUBLE);
          error = Field.GetValue(Object, &var);
          if (error IS ERR::Okay) Value = var.Value;
      }
      else error = ERR::FieldTypeMismatch;

      SetObjectContext(ctx);
      return error;
   }

   inline std::pair<ERR, APTR> get_field_value(Object *Object, struct Field &Field, int8_t Buffer[8], int &ArraySize) {
      if (Field.GetValue) {
         auto new_context = ObjectContext{ Object, &Field };
         auto ctx = SetObjectContext(&new_context);
         auto get_field = (ERR (*)(APTR, APTR, int &))Field.GetValue;
         SetObjectContext(ctx);
         return std::make_pair(get_field(Object, Buffer, ArraySize), Buffer);
      }
      else return std::make_pair(ERR::Okay, ((int8_t *)Object) + Field.Offset);
   }

   public:

   template <class T> ERR get(FIELD FieldID, T &Value) requires std::integral<T> || std::floating_point<T> {
      Value = 0;
      Object *target;
      if (auto field = FindField(this, FieldID, &target)) {
         if (!field->readable()) return ERR::NoFieldAccess;

         ScopedObjectAccess objlock(target);

         auto flags = field->Flags;

         if (flags & FD_UNIT) return get_unit<T>(target, *field, Value);

         int8_t field_value[8];
         int array_size;
         auto fv = get_field_value(target, *field, field_value, array_size);

         if (flags & FD_INT)         Value = *((int *)fv.second);
         else if (flags & FD_INT64)  Value = *((int64_t *)fv.second);
         else if (flags & FD_DOUBLE) Value = *((double *)fv.second);
         else {
            if ((fv.first IS ERR::Okay) and (flags & FD_ALLOC)) FreeResource(GetMemoryID(*((APTR *)fv.second)));
            return ERR::FieldTypeMismatch;
         }
         return fv.first;
      }
      else return ERR::UnsupportedField;
   }

   inline ERR get(FIELD FieldID, std::string &Value) { // Retrieve field as a string, supports type conversion.
      Object *target;
      if (auto field = FindField(this, FieldID, &target)) {
         if (!field->readable()) return ERR::NoFieldAccess;

         auto flags = field->Flags;
         if (flags & FD_UNIT) {
            double num;

            if (auto error = get_unit<double>(target, *field, num); error IS ERR::Okay) {
               char buffer[64];
               snprintf(buffer, sizeof(buffer), "%f", num);
               Value.assign(buffer);
            }
            else return error;
         }

         int8_t field_value[8];
         int array_size = -1;
         auto fv = get_field_value(target, *field, field_value, array_size);
         APTR data = fv.second;

         if (fv.first != ERR::Okay) return fv.first;

         if (flags & FD_ARRAY) {
            if (flags & FD_CPP) {
               array_size = ((pf::vector<int> *)data)->size();
               data = ((pf::vector<int> *)data)->data();
            }

            std::stringstream buffer;
            if (array_size IS -1) return ERR::Failed; // Array sizing not supported by this field.

            if (flags & FD_INT) {
               auto array = (int *)data;
               for (int i=0; i < array_size; i++) buffer << *array++ << ',';
            }
            else if (flags & FD_BYTE) {
               auto array = (uint8_t *)data;
               for (int i=0; i < array_size; i++) buffer << *array++ << ',';
            }
            else if (flags & FD_DOUBLE) {
               auto array = (double *)data;
               for (int i=0; i < array_size; i++) buffer << *array++ << ',';
            }

            Value = buffer.str();
            if (!Value.empty()) Value.pop_back(); // Remove trailing comma
            return ERR::Okay;
         }

         if (flags & FD_INT) {
            if (flags & FD_LOOKUP) {
               // Reading a lookup field as a string is permissible, we just return the string registered in the lookup table
               if (auto lookup = (FieldDef *)field->Arg) {
                  int v = ((int *)data)[0];
                  while (lookup->Name) {
                     if (v IS lookup->Value) {
                        Value = lookup->Name;
                        return ERR::Okay;
                     }
                     lookup++;
                  }
               }
               Value.clear();
            }
            else if (flags & FD_FLAGS) {
               if (auto lookup = (FieldDef *)field->Arg) {
                  std::stringstream buffer;
                  int v = ((int *)data)[0];
                  while (lookup->Name) {
                     if (v & lookup->Value) buffer << lookup->Name << '|';
                     lookup++;
                  }
                  Value = buffer.str();
                  if (!Value.empty()) Value.pop_back(); // Remove trailing pipe
                  return ERR::Okay;
               }
            }
            else Value = std::to_string(*((int *)data));
         }
         else if (flags & FD_INT64) {
            Value = std::to_string(*((int64_t *)data));
         }
         else if (flags & FD_DOUBLE) {
            char buffer[64];
            auto written = snprintf(buffer, sizeof(buffer), "%f", *((double *)data));
            Value.assign(buffer, written);
         }
         else if (flags & (FD_POINTER|FD_STRING)) {
            Value.assign(*((CSTRING *)data));
            if (flags & FD_ALLOC) FreeResource(GetMemoryID(*((CSTRING *)data)));
         }
         else return ERR::UnrecognisedFieldType;

         return ERR::Okay;
      }
      else return ERR::UnsupportedField;
   }

   // Retrieve a direct pointer to a string field, no-copy operation.  Result will require deallocation by the client if the field is marked with ALLOC.

   inline ERR get(FIELD FieldID, CSTRING &Value) {
      Object *target;
      Value = nullptr;
      if (auto field = FindField(this, FieldID, &target)) {
         if (!field->readable()) return ERR::NoFieldAccess;

         int8_t field_value[8];
         int array_size;
         auto fv = get_field_value(target, *field, field_value, array_size);
         if (fv.first != ERR::Okay) return fv.first;

         if ((field->Flags & FD_INT) and (field->Flags & FD_LOOKUP)) {
            // Reading a lookup field as a string is permissible, we just return the string registered in the lookup table
            if (auto lookup = (FieldDef *)field->Arg) {
               int value = ((int *)fv.second)[0];
               while (lookup->Name) {
                  if (value IS lookup->Value) {
                     Value = lookup->Name;
                     return ERR::Okay;
                  }
                  lookup++;
               }
            }
            return ERR::Okay;
         }
         else if (field->Flags & (FD_POINTER|FD_STRING)) {
            Value = *((CSTRING *)fv.second);
            return ERR::Okay;
         }
         else return ERR::FieldTypeMismatch;
      }
      else return ERR::UnsupportedField;
   }

   template <class T> ERR get(FIELD FieldID, T &Value) requires pcPointer<T> {
      Object *target;
      Value = nullptr;
      if (auto field = FindField(this, FieldID, &target)) {
         if (!field->readable()) return ERR::NoFieldAccess;

         int8_t field_value[8];
         int array_size;
         auto fv = get_field_value(target, *field, field_value, array_size);
         if (fv.first != ERR::Okay) return fv.first;

         if (field->Flags & (FD_POINTER|FD_STRING)) {
            Value = *((T *)fv.second);
            return ERR::Okay;
         }
         return ERR::FieldTypeMismatch;
      }
      else return ERR::UnsupportedField;
   }

   inline ERR get(FIELD FieldID, Unit &Value) {
      Object *target;
      if (auto field = FindField(this, FieldID, &target)) {
         if (!field->readable()) return ERR::NoFieldAccess;

         if (field->Flags & FD_UNIT) {
            auto new_context = ObjectContext{ target, field };
            auto ctx = SetObjectContext(&new_context);
            auto get_field = (ERR (*)(APTR, Unit &))field->GetValue;
            auto error = get_field(target, Value);
            SetObjectContext(ctx);
            return error;
         }
         else return ERR::FieldTypeMismatch;
      }
      else return ERR::UnsupportedField;
   }

   inline ERR get(FIELD FieldID, DMF &Value) {
      uint32_t result;
      auto error = get<uint32_t>(FieldID, result);
      Value = DMF(result);
      return error;
   }

   template <class T> T get(FIELD FieldID)
   requires pcPointer<T> || std::integral<T> || std::floating_point<T> {
      T result(0);
      get(FieldID, result);
      return result;
   };

   template <class T> T get(FIELD FieldID) requires std::is_same_v<T, DMF> {
      DMF result(DMF::NIL);
      get(FieldID, result);
      return result;
   };

   // Fetch an array field.  Result is a direct pointer to the data, do not free it.  Elements is set to the number of elements

   template <class T> ERR get(FIELD FieldID, T * &Result, int &Elements, bool TypeCheck = true) {
      Object *target;
      Result = nullptr;
      if (auto field = FindField(this, FieldID, &target)) {
         if ((!field->readable()) or (!(field->Flags & FD_ARRAY))) return ERR::NoFieldAccess;

         if ((TypeCheck) and (!(field->Flags & FIELD_TYPECHECK<T>()))) return ERR::FieldTypeMismatch;

         ScopedObjectAccess objlock(target);

         T *data;
         Elements = -1;

         if (field->GetValue) {
            auto new_context = ObjectContext{ target, field };
            auto ctx = SetObjectContext(&new_context);
            auto get_field = (ERR (*)(APTR, T * &, int &))field->GetValue;
            auto error = get_field(target, data, Elements);
            SetObjectContext(ctx);
            if (error != ERR::Okay) return error;
         }
         else if (field->Arg) { // Fixed-size array (embedded)
            Elements = field->Arg;
            data = (T *)(((int8_t *)target) + field->Offset);
         }
         else data = *((T **)((int8_t *)target) + field->Offset);

         if (field->Flags & FD_CPP) {
            auto vec = (pf::vector<APTR> *)data; // Data type doesn't matter, we just need the size().
            Result = data; // Return a generic pf::vector<>, the caller must cast to the correct type.
            Elements = vec->size();
         }
         else {
            if (Elements IS -1) return ERR::Failed;
            Result = data;
         }

         return ERR::Okay;
      }
      else return ERR::UnsupportedField;
   }

   template <typename... Args> ERR setFields(Args&&... pFields) {
      pf::Log log("setFields");

      std::initializer_list<pf::FieldValue> Fields = { std::forward<Args>(pFields)... };

      auto ctx = CurrentContext();
      for (auto &f : Fields) {
         OBJECTPTR target;
         if (auto field = FindField(this, f.FieldID, &target)) {
            if ((!(field->Flags & (FD_INIT|FD_WRITE))) and (ctx != target)) {
               log.warning("%s.%s is immutable.", className(), field->Name);
            }
            else if ((field->Flags & FD_INIT) and (target->initialised()) and (ctx != target)) {
               log.warning("%s.%s is init-only.", className(), field->Name);
            }
            else {
               if (target != this) target->lock();

               ERR error;
               if (f.Type & (FD_POINTER|FD_STRING|FD_ARRAY|FD_FUNCTION|FD_UNIT)) {
                  error = field->WriteValue(target, field, f.Type, f.Pointer, 0);
               }
               else if (f.Type & (FD_DOUBLE|FD_FLOAT)) {
                  error = field->WriteValue(target, field, f.Type, &f.Double, 1);
               }
               else if (f.Type & FD_INT64) {
                  error = field->WriteValue(target, field, f.Type, &f.Int64, 1);
               }
               else error = field->WriteValue(target, field, f.Type, &f.Int, 1);

               if (target != this) target->unlock();

               // NB: NoSupport is considered a 'soft' error that does not warrant failure.

               if ((error != ERR::Okay) and (error != ERR::NoSupport)) {
                  log.warning("%s.%s: %s", target->className(), field->Name, GetErrorMsg(error));
                  return error;
               }
            }
         }
         else return log.warning(ERR::UnsupportedField);
      }

      return ERR::Okay;
   }

} __attribute__ ((aligned (8)));

namespace pf {

// Object creation helper class.  Usage examples:
//
//   objFile::create file { fl::Path(URI), fl::Flags(FL::READ) };
//   if (file.ok()) { ... }

template<class T = Object>
class Create {
   private:
      T *obj;

   public:
      ERR error;

      // Return an unscoped direct object pointer.  NB: Globals are still tracked to their owner; use untracked() if
      // you don't want this.

      template <typename... Args> static T * global(Args&&... Fields) {
         pf::Create<T> object = { std::forward<Args>(Fields)... };
         if (object.ok()) {
            auto result = *object;
            object.obj = nullptr;
            return result;
         }
         else return nullptr;
      }

      inline static T * global(const std::initializer_list<FieldValue> Fields) {
         pf::Create<T> object(Fields);
         if (object.ok()) {
            auto result = *object;
            object.obj = nullptr;
            return result;
         }
         else return nullptr;
      }

      // Return an unscoped local object (suitable for class allocations only).

      template <typename... Args> static T * local(Args&&... Fields) {
         pf::Create<T> object({ std::forward<Args>(Fields)... }, NF::LOCAL);
         if (object.ok()) return *object;
         else return nullptr;
      }

      inline static T * local(const std::initializer_list<FieldValue> Fields) {
         pf::Create<T> object(Fields, NF::LOCAL);
         if (object.ok()) return *object;
         else return nullptr;
      }

      // Return an unscoped and untracked object pointer.

      template <typename... Args> static T * untracked(Args&&... Fields) {
         pf::Create<T> object({ std::forward<Args>(Fields)... }, NF::UNTRACKED);
         if (object.ok()) return *object;
         else return nullptr;
      }

      inline static T * untracked(const std::initializer_list<FieldValue> Fields) {
         pf::Create<T> object(Fields, NF::UNTRACKED);
         if (object.ok()) return *object;
         else return nullptr;
      }

      // Create a scoped object that is not initialised.

      Create(NF Flags = NF::NIL) : obj(nullptr), error(ERR::NewObject) {
         if (NewObject(T::CLASS_ID, Flags, (Object **)&obj) IS ERR::Okay) {
            error = ERR::Okay;
         }
      }

      // Create a scoped object that is fully initialised.

      Create(const std::initializer_list<FieldValue> Fields, NF Flags = NF::NIL) : obj(nullptr), error(ERR::Failed) {
         pf::Log log("CreateObject");
         log.branch(T::CLASS_NAME);

         if (NewObject(T::CLASS_ID, NF::SUPPRESS_LOG|Flags, (Object **)&obj) IS ERR::Okay) {
            for (auto &f : Fields) {
               OBJECTPTR target;
               if (auto field = FindField(obj, f.FieldID, &target)) {
                  if (!(field->Flags & (FD_WRITE|FD_INIT))) {
                     error = log.warning(ERR::NoFieldAccess);
                     return;
                  }
                  else {
                     target->lock();

                     if (f.Type & (FD_POINTER|FD_STRING|FD_ARRAY|FD_FUNCTION|FD_UNIT)) {
                        error = field->WriteValue(target, field, f.Type, f.Pointer, 0);
                     }
                     else if (f.Type & (FD_DOUBLE|FD_FLOAT)) {
                        error = field->WriteValue(target, field, f.Type, &f.Double, 1);
                     }
                     else if (f.Type & FD_INT64) {
                        error = field->WriteValue(target, field, f.Type, &f.Int64, 1);
                     }
                     else error = field->WriteValue(target, field, f.Type, &f.Int, 1);

                     target->unlock();

                     // NB: NoSupport is considered a 'soft' error that does not warrant failure.

                     if ((error != ERR::Okay) and (error != ERR::NoSupport)) return;
                  }
               }
               else {
                  log.warning("%s.%s field not supported.", T::CLASS_NAME, FieldName(f.FieldID));
                  error = log.warning(ERR::UnsupportedField);
                  return;
               }
            }

            if ((error = InitObject(obj)) != ERR::Okay) {
               FreeResource(obj->UID);
               obj = nullptr;
            }
         }
         else error = ERR::NewObject;
      }

      ~Create() {
         if (obj) {
            if (obj->initialised()) {
               if ((obj->Object::Flags & (NF::UNTRACKED|NF::LOCAL)) != NF::NIL)  {
                  return; // Detected a successfully created unscoped object
               }
            }
            FreeResource(obj->UID);
            obj = nullptr;
         }
      }

      T * operator->() { return obj; }; // Promotes underlying methods and fields
      T * & operator*() { return obj; }; // To allow object pointer referencing when calling functions

      inline bool ok() { return error == ERR::Okay; }
};
}

inline OBJECTID CurrentTaskID() { return ((OBJECTPTR)CurrentTask())->UID; }
inline APTR SetResourcePtr(RES Res, APTR Value) { return (APTR)(MAXINT)(SetResource(Res, (MAXINT)Value)); }

//********************************************************************************************************************

inline ScopedObjectAccess::ScopedObjectAccess(OBJECTPTR Object) {
   error = Object->lock();
   obj = Object;
}

inline ScopedObjectAccess::~ScopedObjectAccess() {
   if (error IS ERR::Okay) obj->unlock();
}

inline void ScopedObjectAccess::release() {
   if (error IS ERR::Okay) {
      obj->unlock();
      error = ERR::ResourceNotLocked;
   }
}

// Action and Notification Structures

struct acClipboard     { static const AC id = AC::Clipboard; CLIPMODE Mode; };
struct acCopyData      { static const AC id = AC::CopyData; OBJECTPTR Dest; };
struct acDataFeed      { static const AC id = AC::DataFeed; OBJECTPTR Object; DATA Datatype; const void *Buffer; int Size; };
struct acDragDrop      { static const AC id = AC::DragDrop; OBJECTPTR Source; int Item; CSTRING Datatype; };
struct acDraw          { static const AC id = AC::Draw; int X; int Y; int Width; int Height; };
struct acGetKey        { static const AC id = AC::GetKey; CSTRING Key; STRING Value; int Size; };
struct acMove          { static const AC id = AC::Move; double DeltaX; double DeltaY; double DeltaZ; };
struct acMoveToPoint   { static const AC id = AC::MoveToPoint; double X; double Y; double Z; MTF Flags; };
struct acNewChild      { static const AC id = AC::NewChild; OBJECTPTR Object; };
struct acNewOwner      { static const AC id = AC::NewOwner; OBJECTPTR NewOwner; };
struct acRead          { static const AC id = AC::Read; APTR Buffer; int Length; int Result; };
struct acRedimension   { static const AC id = AC::Redimension; double X; double Y; double Z; double Width; double Height; double Depth; };
struct acRedo          { static const AC id = AC::Redo; int Steps; };
struct acRename        { static const AC id = AC::Rename; CSTRING Name; };
struct acResize        { static const AC id = AC::Resize; double Width; double Height; double Depth; };
struct acSaveImage     { static const AC id = AC::SaveImage; OBJECTPTR Dest; union { CLASSID ClassID; CLASSID Class; }; };
struct acSaveToObject  { static const AC id = AC::SaveToObject; OBJECTPTR Dest; union { CLASSID ClassID; CLASSID Class; }; };
struct acSeek          { static const AC id = AC::Seek; double Offset; SEEK Position; };
struct acSetKey        { static const AC id = AC::SetKey; CSTRING Key; CSTRING Value; };
struct acUndo          { static const AC id = AC::Undo; int Steps; };
struct acWrite         { static const AC id = AC::Write; CPTR Buffer; int Length; int Result; };

// Action Macros

inline ERR acActivate(OBJECTPTR Object) { return Action(AC::Activate,Object,nullptr); }
inline ERR acClear(OBJECTPTR Object) { return Action(AC::Clear,Object,nullptr); }
inline ERR acDeactivate(OBJECTPTR Object) { return Action(AC::Deactivate,Object,nullptr); }
inline ERR acDisable(OBJECTPTR Object) { return Action(AC::Disable,Object,nullptr); }
inline ERR acDraw(OBJECTPTR Object) { return Action(AC::Draw,Object,nullptr); }
inline ERR acEnable(OBJECTPTR Object) { return Action(AC::Enable,Object,nullptr); }
inline ERR acFlush(OBJECTPTR Object) { return Action(AC::Flush,Object,nullptr); }
inline ERR acFocus(OBJECTPTR Object) { return Action(AC::Focus,Object,nullptr); }
inline ERR acHide(OBJECTPTR Object) { return Action(AC::Hide,Object,nullptr); }
inline ERR acLock(OBJECTPTR Object) { return Action(AC::Lock,Object,nullptr); }
inline ERR acLostFocus(OBJECTPTR Object) { return Action(AC::LostFocus,Object,nullptr); }
inline ERR acMoveToBack(OBJECTPTR Object) { return Action(AC::MoveToBack,Object,nullptr); }
inline ERR acMoveToFront(OBJECTPTR Object) { return Action(AC::MoveToFront,Object,nullptr); }
inline ERR acNext(OBJECTPTR Object) { return Action(AC::Next,Object,nullptr); }
inline ERR acPrev(OBJECTPTR Object) { return Action(AC::Prev,Object,nullptr); }
inline ERR acQuery(OBJECTPTR Object) { return Action(AC::Query,Object,nullptr); }
inline ERR acRefresh(OBJECTPTR Object) { return Action(AC::Refresh, Object, nullptr); }
inline ERR acReset(OBJECTPTR Object) { return Action(AC::Reset,Object,nullptr); }
inline ERR acSaveSettings(OBJECTPTR Object) { return Action(AC::SaveSettings,Object,nullptr); }
inline ERR acShow(OBJECTPTR Object) { return Action(AC::Show,Object,nullptr); }
inline ERR acSignal(OBJECTPTR Object) { return Action(AC::Signal,Object,nullptr); }
inline ERR acUnlock(OBJECTPTR Object) { return Action(AC::Unlock,Object,nullptr); }

inline ERR acClipboard(OBJECTPTR Object, CLIPMODE Mode) {
   struct acClipboard args = { Mode };
   return Action(AC::Clipboard, Object, &args);
}

inline ERR acDragDrop(OBJECTPTR Object, OBJECTPTR Source, int Item, CSTRING Datatype) {
   struct acDragDrop args = { Source, Item, Datatype };
   return Action(AC::DragDrop, Object, &args);
}

inline ERR acDrawArea(OBJECTPTR Object, int X, int Y, int Width, int Height) {
   struct acDraw args = { X, Y, Width, Height };
   return Action(AC::Draw, Object, &args);
}

inline ERR acDataFeed(OBJECTPTR Object, OBJECTPTR Sender, DATA Datatype, const void *Buffer, int Size) {
   struct acDataFeed args = { Sender, Datatype, Buffer, Size };
   return Action(AC::DataFeed, Object, &args);
}

inline ERR acGetKey(OBJECTPTR Object, CSTRING Key, STRING Value, int Size) {
   struct acGetKey args = { Key, Value, Size };
   ERR error = Action(AC::GetKey, Object, &args);
   if ((error != ERR::Okay) and (Value)) Value[0] = 0;
   return error;
}

inline ERR acMove(OBJECTPTR Object, double X, double Y, double Z) {
   struct acMove args = { X, Y, Z };
   return Action(AC::Move, Object, &args);
}

inline ERR acRead(OBJECTPTR Object, APTR Buffer, int Bytes, int *Read) {
   struct acRead read = { (int8_t *)Buffer, Bytes };
   if (auto error = Action(AC::Read, Object, &read); error IS ERR::Okay) {
      if (Read) *Read = read.Result;
      return ERR::Okay;
   }
   else {
      if (Read) *Read = 0;
      return error;
   }
}

inline ERR acRedo(OBJECTPTR Object, int Steps = 1) {
   struct acRedo args = { Steps };
   return Action(AC::Redo, Object, &args);
}

inline ERR acRedimension(OBJECTPTR Object, double X, double Y, double Z, double Width, double Height, double Depth) {
   struct acRedimension args = { X, Y, Z, Width, Height, Depth };
   return Action(AC::Redimension, Object, &args);
}

inline ERR acRename(OBJECTPTR Object, CSTRING Name) {
   struct acRename args = { Name };
   return Action(AC::Rename, Object, &args);
}

inline ERR acResize(OBJECTPTR Object, double Width, double Height, double Depth) {
   struct acResize args = { Width, Height, Depth };
   return Action(AC::Resize, Object, &args);
}

inline ERR acMoveToPoint(OBJECTPTR Object, double X, double Y, double Z, MTF Flags) {
   struct acMoveToPoint moveto = { X, Y, Z, Flags };
   return Action(AC::MoveToPoint, Object, &moveto);
}

inline ERR acSaveImage(OBJECTPTR Object, OBJECTPTR Dest, CLASSID ClassID = CLASSID::NIL) {
   struct acSaveImage args = { Dest, { ClassID } };
   return Action(AC::SaveImage, Object, &args);
}

inline ERR acSaveToObject(OBJECTPTR Object, OBJECTPTR Dest, CLASSID ClassID = CLASSID::NIL) {
   struct acSaveToObject args = { Dest, { ClassID } };
   return Action(AC::SaveToObject, Object, &args);
}

inline ERR acSeek(OBJECTPTR Object, double Offset, SEEK Position) {
   struct acSeek args = { Offset, Position };
   return Action(AC::Seek, Object, &args);
}

inline ERR acSetKeys(OBJECTPTR Object, CSTRING tags, ...) {
   struct acSetKey args;
   va_list list;

   va_start(list, tags);
   while ((args.Key = va_arg(list, STRING)) != TAGEND) {
      args.Value = va_arg(list, STRING);
      if (auto error = Action(AC::SetKey, Object, &args); error != ERR::Okay) {
         va_end(list);
         return error;
      }
   }
   va_end(list);
   return ERR::Okay;
}

inline ERR acUndo(OBJECTPTR Object, int Steps) {
   struct acUndo args = { Steps };
   return Action(AC::Undo, Object, &args);
}

inline ERR acWrite(OBJECTPTR Object, CPTR Buffer, int Bytes, int *Result = nullptr) {
   struct acWrite write = { (int8_t *)Buffer, Bytes };
   if (auto error = Action(AC::Write, Object, &write); error IS ERR::Okay) {
      if (Result) *Result = write.Result;
      return error;
   }
   else {
      if (Result) *Result = 0;
      return error;
   }
}

inline int acWriteResult(OBJECTPTR Object, CPTR Buffer, int Bytes) {
   struct acWrite write = { (int8_t *)Buffer, Bytes };
   if (Action(AC::Write, Object, &write) IS ERR::Okay) return write.Result;
   else return 0;
}

#define acSeekStart(a,b)    acSeek((a),(b),SEEK::START)
#define acSeekEnd(a,b)      acSeek((a),(b),SEEK::END)
#define acSeekCurrent(a,b)  acSeek((a),(b),SEEK::CURRENT)

inline ERR acSetKey(OBJECTPTR Object, CSTRING Key, CSTRING Value) {
   struct acSetKey args = { Key, Value };
   return Action(AC::SetKey, Object, &args);
}

]=])

  methods("MetaClass", "mc", {
    { id=1, name="FindField" }
  })

  class("MetaClass", { src="../classes/class_metaclass.cpp" }, [[
    double ClassVersion    # Version of the class
    cstruct(*FieldArray) Fields  # Original field array supplied by the module.
    array(struct(Field)) Dictionary # Field lookup by ID
    cstr ClassName         # Name of the class
    cstr FileExtension     # File extension that is supported by this class.
    cstr FileDescription   # File description
    cstr FileHeader        # Internal file header for identifying the file
    cstr Path              # Module path to the class
    cstr Icon              # An icon that can be used to represent class data.
    int Size               # Byte-size of the class when produced as an object
    int(CLF) Flags         # Special flags
    cid ClassID            # ID of this class
    cid BaseClassID        # Base-class ID
    int OpenCount          # Number of objects allocated to this class
    int(CCF) Category      # Assigned category
  ]])

c_insert([[
inline bool Object::isSubClass() { return Class->ClassID != Class->BaseClassID; }
inline CLASSID Object::classID() { return Class->ClassID; }
inline CLASSID Object::baseClassID() { return Class->BaseClassID; }
]])

  class("StorageDevice", { src="../classes/class_storagedevice.cpp" }, [[
    large(DEVICE) DeviceFlags  # Flags identifying the type of media
    large DeviceSize           # Size of the device
    large BytesFree            # Bytes available to the user
    large BytesUsed            # Bytes already used
  ]])

  methods("File", "Fl", {
    { id=1,  name="StartStream" },
    { id=2,  name="StopStream" },
    { id=3,  name="Delete" },
    { id=4,  name="Move" },
    { id=5,  name="Copy" },
    { id=6,  name="SetDate" },
    { id=7,  name="ReadLine" },
    { id=8,  name="BufferContent" },
    { id=9,  name="Next" },
    { id=10, name="Watch" }
  })

  class("File", { version=1.2, src="../classes/class_file.cpp", output="../classes/class_file_def.c" }, [[
    large     Position  # The current read/write byte position in a file.
    int(FL)   Flags     # File flags and options.
    int       Static    # Set to `true` if a file object should be static.
    oid       Target    # Specifies a surface ID to target for user feedback and dialog boxes.
    ptr(char) Buffer    # Points to the internal data buffer if the file content is held in memory.
  ]],
  nil,
  [[
   inline CSTRING readLine() {
      struct fl::ReadLine args;
      if (Action(fl::ReadLine::id, this, &args) IS ERR::Okay) return args.Result;
      else return nullptr;
   }
  ]])

  methods("config", "Cfg", {
    { id=1,  name="ReadValue" },
    { id=2,  name="Set" },
    { id=3,  name="WriteValue" },
    { id=4,  name="DeleteKey" },
    { id=5,  name="DeleteGroup" },
    { id=6,  name="GetGroupFromIndex" },
    { id=7,  name="SortByKey" },
    { id=9,  name="MergeFile" },
    { id=10, name="Merge" }
  })

  class("Config", { src="../classes/class_config.cpp", output="../classes/class_config_def.c" }, [[
    str Path          # The location pointer
    str KeyFilter     # Enables key filtering, removing any unwanted keys on load.
    str GroupFilter   # Enables group filtering, removing any unwanted groups on load.
    int(CNF) Flags    # Not currently in use
  ]],
  nil,
  [[
   ConfigGroups *Groups;

   // For C++ only, these read variants avoid method calls for speed, but apply identical logic.

   inline ERR read(std::string_view pGroup, std::string_view pKey, double &pValue) {
      for (auto& [group, keys] : Groups[0]) {
         if ((!pGroup.empty()) and (group.compare(pGroup))) continue;
         if (pKey.empty()) pValue = strtod(keys.cbegin()->second.c_str(), nullptr);
         else if (auto it = keys.find(pKey); it != keys.end()) pValue = strtod(it->second.c_str(), nullptr);
         else return ERR::Search;
         return ERR::Okay;
      }
      return ERR::Search;
   }

   inline ERR read(std::string_view pGroup, std::string_view pKey, int &pValue) {
      for (auto& [group, keys] : Groups[0]) {
         if ((!pGroup.empty()) and (group.compare(pGroup))) continue;
         if (pKey.empty()) pValue = strtol(keys.cbegin()->second.c_str(), nullptr, 0);
         else if (auto it = keys.find(pKey); it != keys.end()) pValue = strtol(it->second.c_str(), nullptr, 0);
         else return ERR::Search;
         return ERR::Okay;
      }
      return ERR::Search;
   }

   inline ERR read(std::string_view pGroup, std::string_view pKey, std::string &pValue) {
      for (auto & [group, keys] : Groups[0]) {
         if ((!pGroup.empty()) and (group.compare(pGroup))) continue;
         if (pKey.empty()) pValue = keys.cbegin()->second;
         else if (auto it = keys.find(pKey); it != keys.end()) pValue = it->second;
         else return ERR::Search;
         return ERR::Okay;
      }
      return ERR::Search;
   }

   inline ERR write(std::string_view Group, std::string_view Key, std::string_view Value) {
      ConfigGroups &groups = *Groups;
      for (auto& [group, keys] : groups) {
         if (!group.compare(Group)) {
            if (auto it = keys.find(Key); it != keys.end()) {
               it->second.assign(Value);
            }
            else keys.emplace(Key, Value);
            return ERR::Okay;
         }
      }

      auto &new_group = Groups->emplace_back();
      new_group.first.assign(Group);
      new_group.second.emplace(Key, Value);
      return ERR::Okay;
   }
  ]])

  methods("Script", "Sc", {
    { id=1, name="Exec" },
    { id=2, name="DerefProcedure" },
    { id=3, name="Callback" },
    { id=4, name="GetProcedureID" }
  })

  class("Script", { src={ "../classes/class_script.cpp" }, output="../classes/class_script_def.c" }, [[
    oid Target           # The object that script objects must be initialised to, e.g. for obj.new()
    int(SCF) Flags       # Optional flags
    error Error          # If an error occurred, this field will indicate the error number
    int CurrentLine      # Current line being executed, or failed line if script execution terminated
    int LineOffset       # An optional offset to use when reporting line numbers
  ]],
  [[
   int64_t    ProcedureID;          // For callbacks
   KEYVALUE Vars; // Global parameters
   STRING   *Results;
   char     Language[4];          // 3-character language code, null-terminated
   const ScriptArg *ProcArgs;     // Procedure args - applies during Exec
   STRING   Path;                 // File location of the script
   STRING   String;
   STRING   WorkingPath;
   STRING   ErrorString;
   CSTRING  Procedure;
   STRING   CacheFile;
   int     ActivationCount;      // Incremented every time the script is activated.
   int     ResultsTotal;
   int     TotalArgs;            // Total number of ProcArgs
   char     LanguageDir[32];      // Directory to use for language files
   OBJECTID ScriptOwnerID;
  ]])

  c_insert([[
namespace sc {
template <std::size_t SIZE> ERR Call(const FUNCTION &Function, const std::array<ScriptArg, SIZE> &Args) noexcept {
   struct Callback args = { Function.ProcedureID, Args.data(), int(std::ssize(Args)), ERR::Okay };
   return Action(sc::Callback::id, Function.Context, &args);
}

template <std::size_t SIZE> ERR Call(const FUNCTION &Function, const std::array<ScriptArg, SIZE> &Args, ERR &Result) noexcept {
   struct Callback args = { Function.ProcedureID, Args.data(), int(std::ssize(Args)), ERR::Okay };
   ERR error = Action(sc::Callback::id, Function.Context, &args);
   Result = args.Error;
   return(error);
}

inline ERR Call(const FUNCTION &Function) noexcept {
   struct Callback args = { Function.ProcedureID, nullptr, 0, ERR::Okay };
   return Action(sc::Callback::id, Function.Context, &args);
}

inline ERR Call(const FUNCTION &Function, ERR &Result) noexcept {
   struct Callback args = { Function.ProcedureID, nullptr, 0, ERR::Okay };
   ERR error = Action(sc::Callback::id, Function.Context, &args);
   Result = args.Error;
   return(error);
}
} // namespace
  ]])

  struct("ActionEntry", { restrict='c', comment="For the Task Actions field." }, [[
     fptr(error obj ptr) PerformAction # Pointer to a custom action hook.
  ]])

  methods("Task", "Task", {
    { id=1, name="Expunge" },
    { id=2, name="AddArgument" },
    { id=3, name="Quit" },
    { id=4, name="GetEnv" },
    { id=5, name="SetEnv" }
  })

  class("Task", { src="../classes/class_task.cpp", output="../classes/class_task_def.c" }, [[
    double TimeOut
    int(TSF) Flags
    int ReturnCode
    int ProcessID    # Native process ID of the activated task
  ]])

  methods("Thread", "Th", {
    { id=1, name="SetData" }
  })

  class("Thread", { src="../classes/class_thread.cpp", output="../classes/class_thread_def.c" }, [[
   ptr   Data         # User data pointer.
   int   DataSize     # Size of user data.
   error Error        # Error code returned by the thread on completion.
   int(THF) Flags     # Optional flags.
  ]])

  methods("Module", "Mod", {
    { id=1,  name="ResolveSymbol" },
  })

  class("Module", { src="../classes/class_module.cpp" }, [[
    cstruct(*Function) FunctionList # Array of functions
    ptr ModBase                     # Ptr to function jump table
    class(*RootModule) Root         # Shared details on the module
    struct(*ModHeader) Header       # For creating in-memory modules only.
    int(MOF) Flags                  # Optional flags
  ]],
  nil,
  [[
   static ERR load(std::string Name, OBJECTPTR *Module = nullptr, APTR Functions = nullptr) {
      if (auto module = objModule::create::global(pf::FieldValue(FID_Name, Name.c_str()))) {
         #ifdef PARASOL_STATIC
            if (Module) *Module = module;
            if (Functions) ((APTR *)Functions)[0] = nullptr;
            return ERR::Okay;
         #else
            APTR functionbase;
            if (module->get(FID_ModBase, functionbase) IS ERR::Okay) {
               if (Module) *Module = module;
               if (Functions) ((APTR *)Functions)[0] = functionbase;
               return ERR::Okay;
            }
            else return ERR::GetField;
         #endif
      }
      else return ERR::CreateObject;
   }
  ]])

  -- Note that the fields following SystemTime are identical to struct DateTime

  methods("Time", "Pt", {
    { id=1, name="SetTime" },
  })

  class("Time", { src="../classes/class_time.cpp" }, [[
    large SystemTime  # Total number of microseconds passed since the system base time
    int Year          # Year   (-ve for BC, +ve for AD)
    int Month         # Month  (1 - 12)
    int Day           # Day    (1 - 31)
    int Hour          # Hour   (0 - 23)
    int Minute        # Minute (0 - 59)
    int Second        # Second (0 - 59)
    int TimeZone      # 0 is GMT, range is +1300 or -1300
    int DayOfWeek     # Day of week (0 = Sunday ..)
    int MilliSecond   # Millisecond (0 - 999)
    int MicroSecond   # Microsecond  (0 - 999999)
  ]])

  methods("Compression", "Cmp", {
    { id=1, name="CompressBuffer" },
    { id=2, name="CompressFile" },
    { id=3, name="DecompressBuffer" },
    { id=4, name="DecompressFile" },
    { id=5, name="RemoveFile" },
    { id=6, name="CompressStream" },
    { id=7, name="DecompressStream" },
    { id=8, name="CompressStreamStart" },
    { id=9, name="CompressStreamEnd" },
    { id=10, name="DecompressStreamEnd" },
    { id=11, name="DecompressStreamStart" },
    { id=12, name="DecompressObject" },
    { id=13, name="Scan" },
    { id=14, name="Find" }
  })

  class("Compression", { src={ "../compression/class_compression.cpp", "../compression/compression_fields.cpp" }, output="../compression/class_compression_def.c" }, [[
    large TotalOutput       # Total number of bytes output (e.g. during compression of a stream)
    oid Output              # Reference to output object for user messages
    int CompressionLevel    # Compression level (percentage - 0% none, 100% high)
    int(CMF) Flags          # Optional flags
    int SegmentSize         # Splits the compressed file if it surpasses a set byte limit (e.g. 1.44MB)
    int(PERMIT) Permissions # Default permissions to use for decompressed files
    int MinOutputSize       # Minimum recommended output buffer size
    int WindowBits          # Window bits, currently applicable to the default (zlib) compression
  ]])

  class("CompressedStream", { src="../compression/class_compressed_stream.cpp", output="../compression/class_compressed_stream_def.c" }, [[
    large TotalOutput  # Count of the total bytes that have been output.
    obj Input          # The object that is the source of the compressed data.
    obj Output         # The object that is the destination for the compressed data.
    int(CF) Format     # CF_GZIP, CF_ZLIB, CF_DEFLATE
  ]])

  c_insert([[
#ifndef PRV_CORE

// Note that the length of the data is only needed when messaging between processes, so we can skip it for these
// direct-access data channel macros.

#define acDataContent(a,b)  acDataFeed((a),0,DATA::CONTENT,(b),0)
#define acDataXML(a,b)      acDataFeed((a),0,DATA::XML,(b),0)
#define acDataText(a,b)     acDataFeed((a),0,DATA::TEXT,(b),0)

#endif // PRV_CORE

#ifdef __unix__
#include <pthread.h>
#endif

namespace pf {

#ifdef __system__
   struct ActionMessage {
      OBJECTID ObjectID;  // The object that is to receive the action
      int  Time;
      AC ActionID;        // ID of the action or method to execute
      bool SendArgs;

      // Action arguments follow this structure in a buffer
   };
#endif

// Event support

struct Event {
   EVENTID EventID;
   // Data follows
};

#define EVID_DISPLAY_RESOLUTION_CHANGE  GetEventID(EVG::DISPLAY, "resolution", "change")

#define EVID_GUI_SURFACE_FOCUS          GetEventID(EVG::GUI, "surface", "focus")

#define EVID_FILESYSTEM_VOLUME_CREATED  GetEventID(EVG::FILESYSTEM, "volume", "created")
#define EVID_FILESYSTEM_VOLUME_DELETED  GetEventID(EVG::FILESYSTEM, "volume", "deleted")

#define EVID_SYSTEM_TASK_CREATED        GetEventID(EVG::SYSTEM, "task", "created")
#define EVID_SYSTEM_TASK_REMOVED        GetEventID(EVG::SYSTEM, "task", "removed")

#define EVID_POWER_STATE_SUSPENDING     GetEventID(EVG::POWER, "state", "suspending")
#define EVID_POWER_STATE_RESUMED        GetEventID(EVG::POWER, "state", "resumed")
#define EVID_POWER_DISPLAY_STANDBY      GetEventID(EVG::POWER, "display", "standby")
#define EVID_POWER_BATTERY_LOW          GetEventID(EVG::POWER, "battery", "low")
#define EVID_POWER_BATTERY_CRITICAL     GetEventID(EVG::POWER, "battery", "critical")
#define EVID_POWER_CPUTEMP_HIGH         GetEventID(EVG::POWER, "cputemp", "high")
#define EVID_POWER_CPUTEMP_CRITICAL     GetEventID(EVG::POWER, "cputemp", "critical")
#define EVID_POWER_SCREENSAVER_ON       GetEventID(EVG::POWER, "screensaver", "on")
#define EVID_POWER_SCREENSAVER_OFF      GetEventID(EVG::POWER, "screensaver", "off")

#define EVID_IO_KEYMAP_CHANGE           GetEventID(EVG::IO, "keymap", "change")
#define EVID_IO_KEYBOARD_KEYPRESS       GetEventID(EVG::IO, "keyboard", "keypress")

#define EVID_AUDIO_VOLUME_MASTER        GetEventID(EVG::AUDIO, "volume", "master")
#define EVID_AUDIO_VOLUME_LINEIN        GetEventID(EVG::AUDIO, "volume", "linein")
#define EVID_AUDIO_VOLUME_MIC           GetEventID(EVG::AUDIO, "volume", "mic")
#define EVID_AUDIO_VOLUME_MUTED         GetEventID(EVG::AUDIO, "volume", "muted") // All volumes have been muted
#define EVID_AUDIO_VOLUME_UNMUTED       GetEventID(EVG::AUDIO, "volume", "unmuted") // All volumes have been unmuted

// Event structures.

typedef struct { EVENTID EventID; char Name[1]; } evVolumeCreated;
typedef struct { EVENTID EventID; char Name[1]; } evVolumeDeleted;
typedef struct { EVENTID EventID; OBJECTID TaskID; } evTaskCreated;
typedef struct { EVENTID EventID; OBJECTID TaskID; OBJECTID ProcessID; } evTaskRemoved;
typedef struct { EVENTID EventID; } evPowerSuspending;
typedef struct { EVENTID EventID; } evPowerResumed;
typedef struct { EVENTID EventID; } evUserLogin;
typedef struct { EVENTID EventID; } evKeymapChange;
typedef struct { EVENTID EventID; } evScreensaverOn;
typedef struct { EVENTID EventID; } evScreensaverOff;
typedef struct { EVENTID EventID; double Volume; int Muted; } evVolume;
typedef struct { EVENTID EventID; KQ Qualifiers; KEY Code; int Unicode; } evKey;
typedef struct { EVENTID EventID; int16_t TotalWithFocus; int16_t TotalLostFocus; OBJECTID FocusList[1]; } evFocus;

// Hotplug event structure.  The hotplug event is sent whenever a new hardware device is inserted by the user.

struct evHotplug {
   EVENTID EventID;
   int16_t Type;            // HT ID
   int16_t Action;          // HTA_INSERTED, HTA_REMOVED
   int VendorID;        // USB vendor ID
   union {
      int ProductID;    // USB product or device ID
      int DeviceID;
   };
   char  ID[20];         // Typically the PCI bus ID or USB bus ID, serial number or unique identifier
   char  Group[32];      // Group name in the config file
   char  Class[32];      // Class identifier (USB)
   union {
      char Product[40];  // Name of product or the hardware device
      char Device[40];
   };
   char Vendor[40];      // Name of vendor
};

} // namespace

namespace fl {

// Read endian values from files and objects.

template<class T> ERR ReadLE(OBJECTPTR Object, T *Result)
{
   uint8_t data[sizeof(T)];
   struct acRead read = { .Buffer = data, .Length = sizeof(T) };
   if (Action(AC::Read, Object, &read) IS ERR::Okay) {
      if (read.Result IS sizeof(T)) {
         if constexpr (std::endian::native == std::endian::little) {
            *Result = ((T *)data)[0];
         }
         else {
            switch(sizeof(T)) {
               case 2:  *Result = (data[1]<<8) | data[0]; break;
               case 4:  *Result = (data[0]<<24)|(data[1]<<16)|(data[2]<<8)|(data[3]); break;
               case 8:  *Result = ((int64_t)data[0]<<56)|((int64_t)data[1]<<48)|((int64_t)data[2]<<40)|((int64_t)data[3]<<32)|(data[4]<<24)|(data[5]<<16)|(data[6]<<8)|(data[7]); break;
               default: *Result = ((T *)data)[0];
            }
         }
         return ERR::Okay;
      }
      else return ERR::Read;
   }
   else return ERR::Read;
}

template<class T> ERR ReadBE(OBJECTPTR Object, T *Result)
{
   uint8_t data[sizeof(T)];
   struct acRead read = { .Buffer = data, .Length = sizeof(T) };
   if (Action(AC::Read, Object, &read) IS ERR::Okay) {
      if (read.Result IS sizeof(T)) {
         if constexpr (std::endian::native == std::endian::little) {
            switch(sizeof(T)) {
               case 2:  *Result = (data[1]<<8) | data[0]; break;
               case 4:  *Result = (data[0]<<24)|(data[1]<<16)|(data[2]<<8)|(data[3]); break;
               case 8:  *Result = ((int64_t)data[0]<<56)|((int64_t)data[1]<<48)|((int64_t)data[2]<<40)|((int64_t)data[3]<<32)|(data[4]<<24)|(data[5]<<16)|(data[6]<<8)|(data[7]); break;
               default: *Result = ((T *)data)[0];
            }
         }
         else {
            *Result = ((T *)data)[0];
         }
         return ERR::Okay;
      }
      else return ERR::Read;
   }
   else return ERR::Read;
}

} // namespace

// Function construction (refer types.h)

template <class T, class X = APTR> FUNCTION C_FUNCTION(T *pRoutine, X pMeta = 0) {
   auto func    = FUNCTION(CALL::STD_C);
   func.Context = CurrentContext();
   func.Routine = (APTR)pRoutine;
   func.Meta    = reinterpret_cast<void *>(pMeta);
   return func;
};

inline CSTRING Object::className() { return Class->ClassName; }
  ]])

  if (glProgram == "idl-compile") then
     loadFile("defs/errors.fdl")
  end
end)
