--$FLUID:Include

module({ name="Core", copyright="Paul Manias 1996-2024" }, function()
  c_include("<stdarg.h>", "<inttypes.h>")
  cpp_include("<list>", "<map>", "<string>", "<vector>", "<unordered_map>", "<bit>", "<atomic>", "<array>")

  platform("Windows", function()
     enum("NETMSG", {}, "START", "END")
  end)

  privateNames({ "ScriptArg", "CoreBase", "RootModule" })

  priority([[
#ifndef DEFINE_ENUM_FLAG_OPERATORS
template <size_t S> struct _ENUM_FLAG_INTEGER_FOR_SIZE;
template <> struct _ENUM_FLAG_INTEGER_FOR_SIZE<1> { typedef BYTE type; };
template <> struct _ENUM_FLAG_INTEGER_FOR_SIZE<2> { typedef WORD type; };
template <> struct _ENUM_FLAG_INTEGER_FOR_SIZE<4> { typedef LONG type; };
template <> struct _ENUM_FLAG_INTEGER_FOR_SIZE<8> { typedef LARGE type; };
// used as an approximation of std::underlying_type<T>
template <class T> struct _ENUM_FLAG_SIZED_INTEGER { typedef typename _ENUM_FLAG_INTEGER_FOR_SIZE<sizeof(T)>::type type; };

#define DEFINE_ENUM_FLAG_OPERATORS(ENUMTYPE) \
inline ENUMTYPE operator | (ENUMTYPE a, ENUMTYPE b) { return ENUMTYPE(((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)a) | ((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)b)); } \
inline ENUMTYPE operator & (ENUMTYPE a, ENUMTYPE b) { return ENUMTYPE(((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)a) & ((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)b)); } \
inline ENUMTYPE operator ~ (ENUMTYPE a) { return ENUMTYPE(~((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)a)); } \
inline ENUMTYPE operator ^ (ENUMTYPE a, ENUMTYPE b) { return ENUMTYPE(((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)a) ^ ((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)b)); } \
inline ENUMTYPE &operator |= (ENUMTYPE &a, ENUMTYPE b) { return (ENUMTYPE &)(((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type &)a) |= ((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)b)); } \
inline ENUMTYPE &operator &= (ENUMTYPE &a, ENUMTYPE b) { return (ENUMTYPE &)(((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type &)a) &= ((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)b)); }
#endif
  ]])

  loadFile(glPath .. 'common.fdl')
  loadFile(glPath .. 'common-graphics.fdl')

  flags("SCF", { comment="Script flags" },
     "EXIT_ON_ERROR: The script will automatically terminate its execution process if an error is detected.",
     "LOG_ALL: Enables execution debugging.  More information will be printed to the console in this mode.")

  flags("STR", { bits=32 },
     "MATCH_CASE|CASE: Perform a case-sensitive match.",
     "MATCH_LEN: The strings must be of equal length to be matched.",
     "WILDCARD: Allow the use of wildcard characters '|', '?' and '*'.")

  flags("MSF", { comment="Message flags." },
     "WAIT: Wait before inserting the message if the queue is at maximum capacity.",
     "UPDATE: If the Type parameter matches a message already inside the queue, the data for that message will be deleted, then the new message will be added to the end of the queue.",
     "NO_DUPLICATE: If the Type parameter matches a message already inside the queue, the new message will not be added and the function will immediately return with ERR_Okay.",
     "ADD: The default behaviour - this will add the message to the end of the queue.",
     "ADDRESS: Internal flag that changes the behaviour of the input parameters so that queues can be processed by address rather than ID.",
     "MESSAGE_ID: The Type parameter refers to a unique message ID rather than a message type for this call.")

  flags("PMF", { comment="Flags for ProcessMessages" },
     "SYSTEM_NO_BREAK: Private.  For system calls that need to avoid early termination.")

  flags("RFD", { bits=32, comment="Flags for RegisterFD()" },
     "WRITE: Activate the callback if there is room to write to the FD's buffer.",
     "EXCEPT: Activate the callback if error conditions are pending.",
     "READ: Activate the callback if there is data available to read.",
     "REMOVE: Stop monitoring this file descriptor.",
     "STOP_RECURSE: Internal flag to prevent recursion.",
     "ALLOW_RECURSION: Internal flag to allow recursion.",
     "SOCKET: Identifies the file descriptor as a socket (Linux systems only).",
     "RECALL: Set if the subscriber needs to manually check for incoming/outgoing data.  This is supported as a one-off check, so the flag will be disabled automatically when the subscriber is called.",
     "ALWAYS_CALL: Always call this FD's handler prior to the process going to sleep.")

  flags("TSF", { comment="Task flags" },
    "FOREIGN: Set this flag when using the task object to execute a foreign process - that is an executable that does not use the Parasol API.",
    "WAIT: This flag will cause the parent process to halt when the task is activated.  Control is returned to the parent process once the child process terminates.",
    "RESET_PATH: If set, the executed process will start in its own folder rather than the folder of the parent process.",
    "PRIVILEGED: During a normal execution process, any privileges of the parent process will be dropped so that the child process runs unprivileged.  This behaviour can be reversed if he PRIVILEGED flag is set, in which case the child process has the same privileges as the parent.",
    "SHELL: Enables shell mode.  On Unix systems, this means that a shell (usually BASH) will be used to launch the process.",
    "LOG_ALL: Additional debug messages will be printed during normal usage of the task class when this flag is set.",
    "QUIET: Setting this flag will divert all process output to /dev/null or the nearest equivalent for non-Unix systems.",
    "DETACHED: Forces new task to be detached from the parent.",
    "ATTACHED: Forces new task to be attached to the parent (child will close when parent closes).",
    "PIPE: Enable the output pipe to the launched process so that it can read data.")

  hash("AHASH", "0x%s",
    "ACTIVATE",     "CLEAR",         "FREEWARNING", "COPYDATA",
    "DATAFEED",     "DEACTIVATE",    "DRAW",      "FLUSH",       "FOCUS",        "FREE",
    "GETVAR",       "DRAGDROP",      "HIDE",      "INIT",        "LOCK",         "LOSTFOCUS",    "MOVE",
    "MOVETOBACK",   "MOVETOFRONT",   "NEWCHILD",  "NEWOWNER",    "NEWOBJECT",    "REDO",         "QUERY",
    "READ",         "RENAME",        "RESET",     "RESIZE",      "SAVEIMAGE",    "SAVETOOBJECT", "SCROLL",
    "SEEK",         "SETVAR",        "SHOW",      "TIMER",       "UNLOCK",       "NEXT",         "PREV",
    "WRITE",        "SETFIELD",      "CLIPBOARD", "REFRESH",     "DISABLE",      "ENABLE",       "REDIMENSION",
    "MOVETOPOINT",  "SCROLLTOPOINT", "CUSTOM",    "SORT",        "SAVESETTINGS", "SELECTAREA",   "SIGNAL",
    "UNDO")

  flags("MHF", { comment="Internal options for requesting function tables from modules." },
    "STATIC: Keep the module code in memory",
    "STRUCTURE|DEFAULT: Use structures to group exported functions (Linux, C/C++ standard)")

  flags("STP", { comment="ScrollToPoint flags" }, "X", "Y", "Z", "ANIM")

  flags("MTF", { comment="MoveToPoint flags" }, "X", "Y", "Z", "ANIM", "RELATIVE")

  flags("VLF", { comment="VlogF flags" }, "BRANCH", "ERROR", "WARNING", "CRITICAL", "INFO", "API", "EXTAPI", "DEBUG", "TRACE", "FUNCTION")

  flags("MOF", { comment="Module flags" },
    "LINK_LIBRARY: Module refers to a symbolic link library (e.g. libz DLL or SO)",
    "STATIC: This flag prevents the loaded module code from being unloaded when the module object is freed.  This may be needed in cases where a module is designed with the presumption that it will remain in memory after being loaded by the developer.",
    "SYSTEM_PROBE: Indicates that the module is being probed.  Do not use outside of the core library.")

  flags("THF", { comment="Thread flags" },
    "AUTO_FREE: Automatically destroy the Thread object when the user routine has completed.")

  enum("FDT", { type="int", start=0, comment="Flags for the SetDate() file method." },
    "MODIFIED: The date on which the file was last modified.",
    "CREATED: The date on which the file was created.  On some host platforms this datestamp may be read-only.",
    "ACCESSED: The date on which the file was last accessed by a user or application.",
    "ARCHIVED: The date on which the file was most recently archived.  Not supported by most filesystems.")

  flags("VOLUME", { comment="Options for SetVolume()" },
    "REPLACE: If the volume already exists, all paths that are attached to it will be replaced with the new path setting.",
    "PRIORITY: If the volume already exists, the path will be inserted at the beginning of the path list so that it has priority over the others.",
    "HIDDEN: Hides the volume so that it will not show up when reading the root folder.",
    "SYSTEM: Identifies the volume as being created by the system, is immutable and persistent between sessions.")

  flags("FDL", { comment="Options for the File Delete() method." },
    "FEEDBACK: Automatically manage user feedback for deleting files by presenting dialog boxes.")

  flags("CMF", { comment="Compression flags" },
    "PASSWORD: A password has been set on the object.",
    "NEW: Force the creation of a new file archive.  Any existing file data at the target location will be destroyed.",
    "CREATE_FILE: Create a new archive only if the source file does not already exist.",
    "READ_ONLY: Forces read-only access, which is strongly recommended if an existing archive is being opened with no modifications intended.  If this flag is not set, initialisation can fail if the user does not have write access to the source file.",
    "NO_LINKS: Treat symbolic links as normal files/folders.",
    "APPLY_SECURITY: When decompressing, apply individual file permissions if they are available in the compression file.")

  flags("RSF", { comment="Flags for ResolvePath()"},
    "NO_FILE_CHECK: Do not test for the existence of the targeted file or folder during the resolution process.",
    "CHECK_VIRTUAL: If the volume referenced by Path is traced to another volume that is reserved by a virtual file system driver, ERR_VirtualVolume is returned. The volume is still resolved as far as possible and the resulting path will be returned by this function.",
    "APPROXIMATE: Ignores file extensions for the purpose of file name matching.",
    "NO_DEEP_SCAN: Do not perform more than one iteration when resolving the source file path.",
    "PATH: Use the PATH environment variable to resolve the file name in the Path parameter.",
    "CASE_SENSITIVE: For use on host systems that use case-insensitive file systems such as Windows; this option checks that the discovered file is a case-sensitive match to the Path.")

  -- NB: The MFF flags are duplicated in the FileSystem's Win32 code if you're going to change these

  flags("MFF", { comment="Flags for the File Watch() method." },
    "READ: File was accessed (read).",
    "MODIFY|WRITE: File modified via write or truncation.",
    "CREATE: New file/link created or renamed in folder.",
    "DELETE: Existing file deleted",
    "MOVED|RENAME: Existing file moved or renamed.",
    "ATTRIB: File permissions or datestamp changed.",
    "OPENED: Existing file was opened.",
    "CLOSED: An opened file has been closed.",
    "UNMOUNT: Host filesystem was unmounted.",
    "FOLDER: Folder identifier; if passed to Watch() then indicates a preference for folder events only.",
    "FILE: File identifier; if passed to Watch() then indicates a preference for file events only.",
    "SELF: Event applies to the monitored folder and not a contained item",
    "DEEP: Receive notifications from sub-folders (Windows only).")

  enum("STT", { type="int", start=1, comment="Types for StrDatatype()." },
    "NUMBER: The string represents a whole number.",
    "FLOAT: The string represents a floating point number.",
    "HEX: The string represents a hexadecimal number.",
    "STRING: The string represents plain-text.")

  flags("OPF", { },
    "OPTIONS",
    "MAX_DEPTH",
    "DETAIL",
    "SHOW_MEMORY",
    "SHOW_IO",
    "SHOW_ERRORS",
    "ARGS",
    "ERROR",
    "PRIVILEGED",
    "SYSTEM_PATH",
    "MODULE_PATH",
    "ROOT_PATH",
    "SCAN_MODULES")

  enum("TOI", { type="int" },
    "LOCAL_CACHE",        -- For Android.  Defines the path of the local cache for assignment to localcache:
    "LOCAL_STORAGE",      -- For Android.  Defines the path of the local storage for assignment to localstorage:
    "ANDROID_ENV",        -- For Android.
    "ANDROID_CLASS",      -- For Android.
    "ANDROID_ASSETMGR")   -- For Android.  Permanent pointer to the AssetManager

  flags("RDF", { comment="Flags for the OpenDir() function." },
    "SIZE: Retrieve the byte size of each file.",
    "DATE|TIME: Retrieve the date stamp of each file.",
    "PERMISSIONS: Get permission/security information.",
    "FILES|FILE: Read all files in the folder.",
    "FOLDERS|FOLDER: Read all folders/volumes in the folder.",
    "VOLUME: Feedback only - indicates a volume.",
    "LINK: Feedback only - file/folder is actually a link to another location.",
    "TAGS: Receive additional information for each file, such as comments, author and copyright.  The results are stored in the Tags field of each file.",
    "HIDDEN: Feedback only - file/folder is hidden.",
    "QUALIFY|QUALIFIED: Return fully qualified folder names (i.e. trailing slash or colon for each name).",
    "VIRTUAL: Path is to a virtual device.",
    "STREAM: Path is connected via a stream, e.g. network connection.",
    "READ_ONLY: Read-only (not permissions related and might indicate read-only media).",
    "ARCHIVE: Feedback only - archive bit is set.",
    "OPENDIR: Internal option.",
    { READ_ALL = "SIZE|DATE|PERMISSIONS|FILES|FOLDERS" })

  flags("FL", { comment="File flags" },
    "WRITE: Prepares a file for writing data, starting at byte position 0.  To start writing from the end of a file, use the Seek action after the file has been initialised.",
    "NEW: Required when creating a new file.  If a file with the same name exists, its contents will be destroyed. If however the existing file is locked, the initalisation process will fail.",
    "READ: Required if the file needs to be opened for read access.",
    "FOLDER|DIRECTORY: The file object represents a folder.",
    "APPROXIMATE: Allows fuzzy matching of the file path when opening an existing file.  This means that the file extension will be ignored; for instance attempting to open a file of 'screenshot.png' when only a file name of 'screenshot.jpg' exists in the same folder, the 'screenshot.jpg' file will be opened instead.  If multiple files could potentially match to the file name, the file object will select the first match that is encountered.",
    "LINK: Read-Only.  Indicates that the file is a symbolic link or shortcut to another file.",
    "BUFFER: Activates a special mode in which the file data is stored in a memory buffer rather than a disk file.  Set the Size field to a value of at least 1 so that the initial buffer size is configured.  In this mode many of the available file operations are meaningless except for the Read, Write and Seek actions.",
    "LOOP: In loop mode, the file object's position marker for read/write operations is allowed to extend past the actual file size.  Any read/write operation beyond the file size will loop back to the file at a corrected offset - for example, reading position 330 of a 100 byte file will start the operation from the 30th byte.  Loop mode does not affect any other area besides the read, write and seek operations.  The loop feature is typically used to create multimedia data streams with minimal effort.",
    "FILE: Explicitly declares the file object as an entity that stores content (as opposed to a device or folder for example).",
    "RESET_DATE: For internal use only",
    "DEVICE: The file is a system device (must set if opening a device for read/write operations)",
    "STREAM: File data is streamed (e.g. PIPE, FIFO, socket) and may be accessed locally or via a network.",
    "EXCLUDE_FILES: Exclude files when scanning this folder.",
    "EXCLUDE_FOLDERS: Exclude folders when scanning this folder.")

  enum("LOC", { type="int", start=1, comment="AnalysePath() values" },
    "DIRECTORY|FOLDER: The path refers to a folder.",
    "VOLUME: The path refers to a volume name.",
    "FILE: The path refers to a file.")

  flags("LDF", { comment="Flags for LoadFile()" },
    "CHECK_EXISTS: Limits the routine to checking the file cache for the existence of the file.  If found, the relevant cache entry is returned. The open count is not incremented by this action (it is therefore unnecessary to follow-up with a call to UnloadFile()).  If no up-to-date cache entry is available, ERR_Search is returned.")

  enum("FBK", { type="int", start=1, comment="Flags for file feedback." },
    "MOVE_FILE: A file is to be, or has been moved.",
    "COPY_FILE: A file is to be, or has been copied.",
    "DELETE_FILE: A file is to be, or has been deleted.")

  enum("FFR", { type="int", start=0, comment="Return codes available to the feedback routine" },
    "OKAY|CONTINUE: Continue processing uninterrupted.",
    "SKIP: Skip processing of this entity.",
    "ABORT: Abort the entire operation.")

  enum("VAS", { type="int", start=1, comment="For use by VirtualVolume()" },
    "DEREGISTER: Remove the virtual volume from the system.",
    "SCAN_DIR",
    "DELETE",
    "RENAME",
    "OPEN_DIR",
    "CLOSE_DIR",
    "TEST_PATH",
    "WATCH_PATH",
    "IGNORE_FILE",
    "GET_INFO",
    "GET_DEVICE_INFO",
    "IDENTIFY_FILE",
    "MAKE_DIR",
    "SAME_FILE",
    "CASE_SENSITIVE: Set to true if the volume's paths are case-sensitive.",
    "READ_LINK",
    "CREATE_LINK",
    "DRIVER_SIZE")

  enum("FDB", { type="int", start=1, comment="Feedback event indicators." },
    "DECOMPRESS_FILE",
    "COMPRESS_FILE",
    "REMOVE_FILE",
    "DECOMPRESS_OBJECT")

  enum("CF", { type="int", start=1, comment="Compression stream formats" },
    "GZIP: The 'gzip' format",
    "ZLIB: The 'zlib' format",
    "DEFLATE: The 'deflate' format")

  flags("FOF", { comment="Flags that can be passed to FindObject()" },
    "SMART_NAMES: Parse numeric object names as ID references and support use of the 'Owner' reserved keyword.")

  flags("NF", { comment="Flags that can be passed to NewObject().  If a flag needs to be stored with the object, it must be specified in the lower word." },
    "UNTRACKED: An object created with this flag will not be tracked back to the object that created it.",
    "INITIALISED: Read-only indicator if the object has been initialised.",
    "INTEGRAL: Integral objects can only be allocated by classes that need to adopt the functionality of said object.  Integral objects do not appear in the object tree, effectively making them hidden from view.",
    "FREE_ON_UNLOCK: Read-only indicator for when the object is marked for deletion.",
    "FREE: Read-only indicator for when the object is being freed.",
    "TIMER_SUB: The object is subscribed to a timer interval.",
    "SUPPRESS_LOG: Private.  Turns off the initial log message.",
    "COLLECT: Marked for garbage collection.",
    "RECLASSED: The object switched from the base-class to a sub-class during initialisation.",
    "MESSAGE: Action has been called against the object through the message system (managed by ProcessMessages()).",
    "SIGNALLED: The object has been signalled and is awaiting processing.",
    { UNIQUE = "0x40000000: Use to allocate an object that has a guaranteed unique name.  This will prevent code from shadowing any object that exists with the same name, which can be imperative when creating shared objects.  If it is discovered that an identically named object exists, NewObject() will return ERR_ObjectExists.  This flag works in conjunction with the Name argument.",
      NAME   = "0x80000000: Use the Name parameter to name the created object.  This flag is not required if using NF_UNIQUE.",
      PRIVATE = 0
    }
  )

  const("MAX", { }, { FILENAME = 256 })  -- Maximum length for file names (not necessarily including path)

  const("MAX", nil, { NAME_LEN = 32 })

  const("MSGID", { comment="Reserved message ID's that are handled internally." }, {
     QUIT             = 1000,   -- Note that IDs >= 100 may be handled by non-Core code (external modules and applications)
     COMMAND          = 101,
     BREAK            = 100,
     CORE_END         = 100,    -- End marker for Core generated messages
     ACTION           = 99,     -- Start from 99 descending (lower risk of accidental ID matches)
     FREE             = 98,
     DEBUG            = 95,
     EVENT            = 94,
     VALIDATE_PROCESS = 93,
     THREAD_CALLBACK  = 92,
     THREAD_ACTION    = 91,
     WAIT_FOR_OBJECTS = 90
  })

  enum("IDTYPE", { type="int", start=1, comment="Types for AllocateID()" },
    "MESSAGE: Message ID's are allocated for the purpose of sending uniquely identifiable messages between tasks.",
    "GLOBAL: Global ID's have no specific association with anything.",
    "FUNCTION: Function ID's are used to track FUNCTION types and are assigned to the function ID field."
  )

  enum("TSTATE", { type="char", comment="Indicates the state of a process." },
    "RUNNING: The process is currently executing code.",
    "PAUSED: The process is asleep.",
    "STOPPING: The process is in its termination phase.",
    "TERMINATED: The process has closed.")

  enum("RES", { type="int", start=1 },
    "FREE_SWAP: The total amount of free swap memory.",
    "CONSOLE_FD: Internal reference to the FD of the console.",
    "KEY_STATE: Maintains the state of key qualifiers such as caps-lock and the shift keys.",
    "USER_ID: Internal",
    "DISPLAY_DRIVER: Internal.  Passes the name of the preferred display driver to the display module.",
    "PRIVILEGED_USER: If this value is set to 1, the process will operate in privileged mode (typically this enables full administrator rights).  This feature will only work for Unix processes that are granted admin rights when launched.  Setting the Value to 0 reverts to the user's permission settings.  SetResource() will return an error code indicating the level of success.",
    "PRIVILEGED: This is set to TRUE if the process has elevated privileges (such as superuser or administrative rights).",
    "CORE_IDL: Refers to the Core module's compressed IDL string.",
    "PARENT_CONTEXT: Read-only pointer to the parent object of the current context.",
    "LOG_LEVEL: The current level of log detail (larger numbers indicate more detail).",
    "TOTAL_SHARED_MEMORY: The total amount of shared memory in use (system wide).",
    "MAX_PROCESSES: The maximum number of processes that can be supported at any time.",
    "LOG_DEPTH: The current depth of log messages.",
    "JNI_ENV: Return the current JNI environment string.",
    "THREAD_ID: Return the ID of the current thread.",
    "OPEN_INFO: Pointer to the OpenInfo structure originally used to initialise the system.",
    "EXCEPTION_HANDLER: Internal",
    "NET_PROCESSING: Internal windows resource for Network module",
    "PROCESS_STATE: Life-cycle stage of the running process",
    "TOTAL_MEMORY: The total amount of installed memory.",
    "TOTAL_SWAP: The total amount of available swap space.",
    "CPU_SPEED: The average top-speed of all CPU cores in Mhz.",
    "FREE_MEMORY: The total amount of free memory.",
    "STATIC_BUILD: Returns true if the runtime is a statically linked build."
  )

  enum("RP", { type="int", start=1, comment="Path types for SetResourcePath()" },
    "MODULE_PATH: An alternative path leading to the system modules (normally 'system:modules/').  Introduced for platforms such as Android, where modules are stored in asset folders.",
    "SYSTEM_PATH: The path of the 'system:' volume, which otherwise defaults to '[root]:system/'.",
    "ROOT_PATH: Overrides the root path, which defaults to the location at which Parasol is installed.")

  flags("CLF", { comment="Flags for the MetaClass." },
    "PROMOTE_INTEGRAL: Promote class support for any integral object defined in the class definition structure.",
    "NO_OWNERSHIP: Objects created will not be tracked to the creating process, nor any parent object (SetOwner() will not work either).")

  flags("CNF", { comment="Flags for the Config class." },
    "STRIP_QUOTES: Removes quotes from key values that are quote-encapsulated.",
    "AUTO_SAVE: When the configuration object is freed, automatically save the configuration data back to the original file source.",
    "OPTIONAL_FILES: Files are optional (do not fail if a requested file does not exist).",
    "NEW: On initialisation, do not load any data from the referenced configuration file.")

-- Please note that when the user is using an international keyboard, the name of the key will not
-- actually match what the symbol represents for some key types.

  const("KEY", { type="int", comment="Raw key codes" }, {
    A = 1,
    B = 2,
    C = 3,
    D = 4,
    E = 5,
    F = 6,
    G = 7,
    H = 8,
    I = 9,
    J = 10,
    K = 11,
    L = 12,
    M = 13,
    N = 14,
    O = 15,
    P = 16,
    Q = 17,
    R = 18,
    S = 19,
    T = 20,
    U = 21,
    V = 22,
    W = 23,
    X = 24,
    Y = 25,
    Z = 26,
    ONE   = 27,
    TWO   = 28,
    THREE = 29,
    FOUR  = 30,
    FIVE  = 31,
    SIX   = 32,
    SEVEN = 33,
    EIGHT = 34,
    NINE  = 35,
    ZERO  = 36,
    REVERSE_QUOTE = 37,
    MINUS         = 38,
    EQUALS        = 39,
    L_SQUARE      = 40,
    R_SQUARE      = 41,
    SEMI_COLON    = 42,
    APOSTROPHE    = 43,
    COMMA         = 44,
    PERIOD        = 45,
    DOT           = 45, -- Synonym
    SLASH         = 46,
    BACK_SLASH    = 47,
    SPACE         = 48,
    -- Keypad keys
    NP_0        = 49,
    NP_1        = 50,
    NP_2        = 51,
    NP_3        = 52,
    NP_4        = 53,
    NP_5        = 54,
    NP_6        = 55,
    NP_7        = 56,
    NP_8        = 57,
    NP_9        = 58,
    NP_MULTIPLY = 59,
    NP_PLUS     = 60,
    NP_SEPARATOR = 61,
    NP_BAR      = 61, -- Synonym
    NP_MINUS    = 62,
    NP_DECIMAL  = 63,
    NP_DOT      = 63,   -- Synonym
    NP_DIVIDE   = 64,
    L_CONTROL   = 65,   -- Left Control
    R_CONTROL   = 66,   -- Right Control
    HELP        = 67,   -- Help
    L_SHIFT     = 68,   -- Left Shift
    R_SHIFT     = 69,   -- Right Shift
    CAPS_LOCK   = 70,   -- Caps Lock
    PRINT       = 71,   -- Print (not print-screen!)
    L_ALT       = 72,   -- Left Alt
    R_ALT       = 73,   -- Right Alt
    L_COMMAND   = 74,   -- Left Amiga/Win/Special
    R_COMMAND   = 75,   -- Right Amiga/Win/Special
    F1          = 76,   -- Function Key 1
    F2          = 77,   -- Function Key 2
    F3          = 78,   -- Function Key 3
    F4          = 79,   -- Function Key 4
    F5          = 80,   -- Function Key 5
    F6          = 81,   -- Function Key 6
    F7          = 82,   -- Function Key 7
    F8          = 83,   -- Function Key 8
    F9          = 84,   -- Function Key 9
    F10         = 85,   -- Function Key 10
    F11         = 86,   -- Function Key 11
    F12         = 87,   -- Function Key 12
    F13         = 88,   -- Function Key 13
    F14         = 89,   -- Function Key 14
    F15         = 90,   -- Function Key 15
    F16         = 91,   -- Function Key 16
    F17         = 92,   -- Function Key 17
    MACRO       = 93,
    NP_PLUS_MINUS = 94,  -- Plus/Minus on some numeric keypads
    LESS_GREATER  = 95,  -- Less/Greater key on foreign keyboards (no US equivalent?)
    UP          = 96,    -- Cursor Up
    DOWN        = 97,    -- Cursor Down
    RIGHT       = 98,    -- Cursor Right
    LEFT        = 99,    -- Cursor Left
    SCR_LOCK    = 100,   -- Scroll Lock
    PAUSE       = 101,   -- Pause
    WAKE        = 102,   -- Wake
    SLEEP       = 103,   -- Sleep
    POWER       = 104,   -- Power
    BACKSPACE   = 105,   -- Backspace
    TAB         = 106,   -- Tabulation
    ENTER       = 107,   -- Enter/Return
    ESCAPE      = 108,   -- Escape
    DELETE      = 109,   -- Delete
    CLEAR       = 110,   -- Clear
    HOME        = 111,   -- Home
    PAGE_UP     = 112,   -- Page Up
    PAGE_DOWN   = 113,   -- Page Down
    END         = 114,   -- End
    SELECT      = 115,   -- Select
    EXECUTE     = 116,   -- Execute
    INSERT      = 117,   -- Insert
    UNDO        = 118,   -- Undo
    REDO        = 119,   -- Redo
    MENU        = 120,   -- Menu / Shortcut / Application key
    FIND        = 121,   -- Find
    CANCEL      = 122,   -- Cancel
    BREAK       = 123,   -- Break
    NUM_LOCK    = 124,   -- Number lock
    PRT_SCR     = 125,   -- Print Screen
    NP_ENTER    = 126,   -- Numeric keypad enter
    SYSRQ       = 127,
    F18         = 128,
    F19         = 129,
    F20         = 130,
    WIN_CONTROL = 131,   -- Special MS internal control key, doesn't map to a real key
    -- A lot of the following are derived from Android
    VOLUME_UP   = 132,
    VOLUME_DOWN = 133,
    BACK        = 134, -- Not the same as backspace!
    CALL        = 135,
    END_CALL    = 136,
    CAMERA      = 137,
    AT          = 138,
    PLUS        = 139,
    LENS_FOCUS  = 140,
    STOP        = 141,
    NEXT        = 142,
    PREVIOUS    = 143,
    FORWARD     = 144,
    REWIND      = 145,
    MUTE        = 146,
    STAR        = 147, -- As seen on phone keypads
    POUND       = 148, -- As seen on phone keypads
    PLAY        = 149,
    -- End marker
    LIST_END    = 150
  })

  c_insert([[

#ifndef __GNUC__
#define __attribute__(a)
#endif

typedef const std::vector<std::pair<std::string, ULONG>> STRUCTS;
typedef std::map<std::string, std::string> KEYVALUE;
typedef std::map<std::string_view, std::string_view> CONST_KEYVALUE;

#ifndef STRINGIFY
#define STRINGIFY(x) #x
#define TOSTRING(x) STRINGIFY(x)
#endif

#define MOD_IDL NULL

#ifdef PARASOL_STATIC
__export void CloseCore(void);
__export ERROR OpenCore(struct OpenInfo *, struct CoreBase **);
#else
__export struct ModHeader ModHeader;
#endif

#ifdef MOD_NAME
#ifdef PARASOL_STATIC
#define PARASOL_MOD(init,close,open,expunge,IDL,Structures) static struct ModHeader ModHeader(init, close, open, expunge, IDL, Structures, TOSTRING(MOD_NAME));
#else
#define PARASOL_MOD(init,close,open,expunge,IDL,Structures) struct ModHeader ModHeader(init, close, open, expunge, IDL, Structures, TOSTRING(MOD_NAME));
#endif
#define MOD_PATH ("modules:" TOSTRING(MOD_NAME))
#else
#define MOD_NAME NULL
#endif

#define ARRAYSIZE(a) (LONG(sizeof(a)/sizeof(a[0])))

namespace pf {

template <class T> T roundup(T Num, LONG Alignment) {
   return (Num + Alignment) - (Num % Alignment); // Round up to Alignment value, e.g. (14,8) = 16
}

#ifdef PRINTF64I
  #define PF64 "I64d"
#elif PRINTF64_PRID
  #define PF64 PRId64
#else
  #define PF64 "lld"
#endif

// Use DEBUG_BREAK in critical areas where you would want to break in gdb.  This feature will only be compiled
// in to debug builds.

#ifdef _DEBUG
 #ifdef _MSC_VER
  #define DEBUG_BREAK __debugbreak();
 #else
  #define DEBUG_BREAK raise(SIGTRAP);
 #endif
#else
 #define DEBUG_BREAK
#endif

// Fast float-2-int conversion, with rounding to the nearest integer (F2I) and truncation (F2T)

#if defined(__GNUC__) && defined(__x86__)

INLINE LONG F2I(DOUBLE val) {
   // This will round if the CPU is kept in its default rounding mode
   LONG ret;
   asm ("fistpl %0" : "=m" (ret) : "t" (val) : "st");
   return(ret);
}

#else

INLINE LONG F2I(DOUBLE val) {
   DOUBLE t = val + 6755399441055744.0;
   return *((int *)(&t));
}

#endif

inline LONG F2T(DOUBLE val) // For numbers no larger than 16 bit, standard (LONG) is faster than F2T().
{
   if ((val > 32767.0) or (val < -32767.0)) return((LONG)val);
   else {
      val = val + (68719476736.0 * 1.5);
      if constexpr (std::endian::native == std::endian::little) {
         return ((LONG *)(APTR)&val)[0]>>16;
      }
      else return ((LONG *)&val)[1]>>16;
   }
}

} // namespace

// Structures to pass to OpenCore()

struct OpenTag {
   TOI Tag;
   union {
      LONG Long;
      LARGE Large;
      APTR Pointer;
      CSTRING String;
   } Value;
};

struct OpenInfo {
   CSTRING Name;            // OPF::NAME
   CSTRING *Args;           // OPF::ARGS
   CSTRING SystemPath;      // OPF::SYSTEM_PATH
   CSTRING ModulePath;      // OPF::MODULE_PATH
   CSTRING RootPath;        // OPF::ROOT_PATH
   OpenTag *Options;        // OPF::OPTIONS Typecast to va_list (defined in stdarg.h)
   OPF     Flags;           // OPF::flags need to be set for fields that have been defined in this structure.
   LONG    MaxDepth;        // OPF::MAX_DEPTH
   LONG    Detail;          // OPF::DETAIL
   LONG    ArgCount;        // OPF::ARGS
   ERROR   Error;           // OPF::ERROR
};

// Flags for defining fields, methods, actions and functions.  CLASSDEF's can only be used in field definitions for
// classes.  FUNCDEF's can only be used in argument definitions for methods, actions and functions.

#ifdef _LP64
#define FD_PTR64 FD_POINTER
#else
#define FD_PTR64 0
#endif

// Field flags for classes.  These are intended to simplify field definitions, e.g. using FDF_BYTEARRAY combines
// FD_ARRAY with FD_BYTE.  DO NOT use these for function definitions, they are not intended to be compatible.

// Sizes/Types

#define FT_POINTER  FD_POINTER
#define FT_FLOAT    FD_FLOAT
#define FT_LONG     FD_LONG
#define FT_DOUBLE   FD_DOUBLE
#define FT_LARGE    FD_LARGE
#define FT_STRING   (FD_POINTER|FD_STRING)
#define FT_UNLISTED FD_UNLISTED
#define FT_VARIABLE FD_VARIABLE

// Class field definitions.  See core.h for all FD definitions.

#define FDF_BYTE       FD_BYTE
#define FDF_WORD       FD_WORD     // Field is word sized (16-bit)
#define FDF_LONG       FD_LONG     // Field is long sized (32-bit)
#define FDF_DOUBLE     FD_DOUBLE   // Field is double floating point sized (64-bit)
#define FDF_LARGE      FD_LARGE    // Field is large sized (64-bit)
#define FDF_POINTER    FD_POINTER  // Field is an address pointer (typically 32-bit)
#define FDF_ARRAY      FD_ARRAY    // Field is a pointer to an array
#define FDF_CPP        FD_CPP      // Field is a C++ type variant
#define FDF_PTR        FD_POINTER
#define FDF_VARIABLE   FD_VARIABLE
#define FDF_SYNONYM    FD_SYNONYM

#define FDF_UNSIGNED    (FD_UNSIGNED)
#define FDF_FUNCTION    (FD_FUNCTION)           // sizeof(struct rkFunction) - use FDF_FUNCTIONPTR for sizeof(APTR)
#define FDF_FUNCTIONPTR (FD_FUNCTION|FD_POINTER)
#define FDF_STRUCT      (FD_STRUCT)
#define FDF_RESOURCE    (FD_RESOURCE)
#define FDF_OBJECT      (FD_POINTER|FD_OBJECT)   // Field refers to another object
#define FDF_OBJECTID    (FD_LONG|FD_OBJECT)      // Field refers to another object by ID
#define FDF_INTEGRAL    (FD_POINTER|FD_INTEGRAL) // Field refers to an integral object
#define FDF_STRING      (FD_POINTER|FD_STRING)   // Field points to a string.  NB: Ideally want to remove the FD_POINTER as it should be redundant
#define FDF_STR         (FDF_STRING)
#define FDF_SCALED      FD_SCALED
#define FDF_FLAGS       FD_FLAGS                // Field contains flags
#define FDF_ALLOC       FD_ALLOC                // Field is a dynamic allocation - either a memory block or object
#define FDF_LOOKUP      FD_LOOKUP               // Lookup names for values in this field
#define FDF_READ        FD_READ                 // Field is readable
#define FDF_WRITE       FD_WRITE                // Field is writeable
#define FDF_INIT        FD_INIT                 // Field can only be written prior to Init()
#define FDF_SYSTEM      FD_SYSTEM
#define FDF_ERROR       (FD_LONG|FD_ERROR)
#define FDF_REQUIRED    FD_REQUIRED
#define FDF_RGB         (FD_RGB|FD_BYTE|FD_ARRAY)
#define FDF_R           (FD_READ)
#define FDF_W           (FD_WRITE)
#define FDF_RW          (FD_READ|FD_WRITE)
#define FDF_RI          (FD_READ|FD_INIT)
#define FDF_I           (FD_INIT)
#define FDF_VIRTUAL     FD_VIRTUAL
#define FDF_LONGFLAGS   (FDF_LONG|FDF_FLAGS)
#define FDF_FIELDTYPES  (FD_LONG|FD_DOUBLE|FD_LARGE|FD_POINTER|FD_VARIABLE|FD_BYTE|FD_ARRAY|FD_FUNCTION)

// These constants have to match the FD* constants << 32

#define TDOUBLE   0x8000000000000000LL
#define TLONG     0x4000000000000000LL
#define TVAR      0x2000000000000000LL
#define TFLOAT    0x1000000000000000LL // NB: Floats are upscaled to doubles when passed as v-args.
#define TPTR      0x0800000000000000LL
#define TLARGE    0x0400000000000000LL
#define TFUNCTION 0x0200000000000000LL
#define TSTR      0x0080000000000000LL
#define TARRAY    0x0000100000000000LL
#define TSCALE    0x0020000000000000LL
#define TAGEND    0LL
#define TAGDIVERT -1LL
#define TSTRING   TSTR

#define nextutf8(str) if (*(str)) for (++(str); (*(str) & 0xc0) IS 0x80; (str)++);

//********************************************************************************************************************
// FieldValue is used to simplify the initialisation of new objects.

namespace pf {

struct FieldValue {
   ULONG FieldID;
   LONG Type;
   union {
      CSTRING String;
      APTR    Pointer;
      CPTR    CPointer;
      DOUBLE  Double;
      SCALE   Percent;
      LARGE   Large;
      LONG    Long;
   };

   //std::string not included as not compatible with constexpr
   constexpr FieldValue(ULONG pFID, CSTRING pValue)   : FieldID(pFID), Type(FD_STRING), String(pValue) { };
   constexpr FieldValue(ULONG pFID, LONG pValue)      : FieldID(pFID), Type(FD_LONG), Long(pValue) { };
   constexpr FieldValue(ULONG pFID, LARGE pValue)     : FieldID(pFID), Type(FD_LARGE), Large(pValue) { };
   constexpr FieldValue(ULONG pFID, DOUBLE pValue)    : FieldID(pFID), Type(FD_DOUBLE), Double(pValue) { };
   constexpr FieldValue(ULONG pFID, SCALE pValue)     : FieldID(pFID), Type(FD_DOUBLE|FD_SCALED), Percent(pValue) { };
   constexpr FieldValue(ULONG pFID, const FUNCTION &pValue) : FieldID(pFID), Type(FDF_FUNCTIONPTR), CPointer(&pValue) { };
   constexpr FieldValue(ULONG pFID, const FUNCTION *pValue) : FieldID(pFID), Type(FDF_FUNCTIONPTR), CPointer(pValue) { };
   constexpr FieldValue(ULONG pFID, APTR pValue)      : FieldID(pFID), Type(FD_POINTER), Pointer(pValue) { };
   constexpr FieldValue(ULONG pFID, CPTR pValue)      : FieldID(pFID), Type(FD_POINTER), CPointer(pValue) { };
   constexpr FieldValue(ULONG pFID, CPTR pValue, LONG pCustom) : FieldID(pFID), Type(pCustom), CPointer(pValue) { };
};


class FloatRect {
   public:
   DOUBLE X;    // Left-most coordinate
   DOUBLE Y;     // Top coordinate
   DOUBLE Width;   // Right-most coordinate
   DOUBLE Height;  // Bottom coordinate
   FloatRect() { }
   FloatRect(DOUBLE Value) : X(Value), Y(Value), Width(Value), Height(Value) { }
   FloatRect(DOUBLE pX, DOUBLE pY, DOUBLE pWidth, DOUBLE pHeight) : X(pX), Y(pY), Width(pWidth), Height(pHeight) { }
};

}

#include <string.h> // memset()
#include <stdlib.h> // strtol(), strtod()
]])

  struct("ObjectSignal", { comment="Required in calls to WaitForObjects()." }, [[
     obj Object
  ]])

  struct("ResourceManager", { comment="This structure must be placed at the start of any memory block allocated with the MEM::MANAGED flag.", restrict="c" }, [[
     cstr Name            # The name of the resource.
     fptr(error ptr) Free  # A function that will remove the resource's content when terminated.
  ]])

  struct("pfBase64Decode", { type="base64decode", comment="Private structure for the Base64Decode() function." }, [[
    uchar Step                # Internal
    uchar PlainChar           # Internal
    bit(uchar) Initialised    # Internal
  ]],
  [[
  pfBase64Decode() : Step(0), PlainChar(0), Initialised(0) { };
  ]])

  struct("pfBase64Encode", { type="base64encode", comment="Private structure for the Base64Encode() function." }, [[
    uchar Step             # Internal
    uchar Result           # Internal
    int StepCount          # Internal
  ]],
  [[
  pfBase64Encode() : Step(0), Result(0), StepCount(0) { };
  ]])

  struct("FunctionField", { comment="Used by ActionTable and Function structures to declare lists of parameters." }, [[
    cstr Name   # Name of the field
    uint Type   # Type of the field
  ]])

  struct("Function", { comment="Function list array structure" }, [[
    ptr Address     # Pointer to the function entry point
    cstr Name       # Name of the function
    cstruct(*FunctionField) Args  # A list of parameters accepted by the function
  ]])

  struct("ModHeader", { comment="Module file header", restrict="c" }, [[
    int(MHF) Flags                 # Special flags, type of function table wanted from the Core
    cstr Definitions               # Module definition string, usable by run-time languages such as Fluid
    fptr(error obj struct(*CoreBase)) Init # A one-off initialisation routine for when the module is first opened.
    fptr(void obj) Close           # A function that will be called each time the module is closed.
    fptr(error obj) Open           # A function that will be called each time the module is opened.
    fptr(error) Expunge            # Reference to an expunge function to terminate the module.
    cstr Name                      # Name of the module
  ]],
  [[
   STRUCTS *StructDefs;
   class RootModule *Root;
   ModHeader(ERROR (*pInit)(OBJECTPTR, struct CoreBase *),
      void  (*pClose)(OBJECTPTR),
      ERROR (*pOpen)(OBJECTPTR),
      ERROR (*pExpunge)(void),
      CSTRING pDef,
      STRUCTS *pStructs,
      CSTRING pName) {
      Flags         = MHF::DEFAULT;
      Definitions   = pDef;
      StructDefs    = pStructs;
      Init          = pInit;
      Close         = pClose;
      Open          = pOpen;
      Expunge       = pExpunge;
      Name          = pName;
      Root          = NULL;
   }
  ]])

  struct("FieldArray", { comment="Used to construct class blueprints for the MetaClass." }, [[
    cstr   Name      # The name of the field, e.g. "Width"
    ptr    GetField  # void GetField(*Object, APTR Result);
    ptr    SetField  # ERROR SetField(*Object, APTR Value);
    maxint Arg       # Can be a pointer or an integer value
    uint   Flags     # Special flags that describe the field
  ]],
  [[
  template <class G = APTR, class S = APTR, class T = MAXINT> FieldArray(CSTRING pName, ULONG pFlags, G pGetField = NULL, S pSetField = NULL, T pArg = 0) :
     Name(pName), GetField((APTR)pGetField), SetField((APTR)pSetField), Arg((MAXINT)pArg), Flags(pFlags)
     { }
  ]])

  struct("FieldDef", { comment="Used to define constants for field references." }, [[
    cstr Name  # The name of the constant.
    int Value  # The value of the constant.
  ]],
  [[
   template <class T> FieldDef(CSTRING pName, T pValue) : Name(pName), Value(LONG(pValue)) { }
  ]])

  struct("SystemState", { comment="Returned by the GetSystemState() function." }, [[
    cstr Platform      # String-based field indicating the user's platform.  Currently returns 'Native', 'Windows', 'OSX' or 'Linux'.
    hhandle ConsoleFD  # Internal
    int  Stage         # The current operating stage.  -1 = Initialising, 0 indicates normal operating status; 1 means that the program is shutting down; 2 indicates a program restart; 3 is for mode switches.
  ]])

  struct("Variable", { }, [[
    uint   Type     # Field definition flags
    int    Unused   # Unused 32-bit value for 64-bit alignment
    large  Large    # The value as a 64-bit integer.
    double Double   # The value as a 64-bit float-point number.
    ptr    Pointer  # The value as an address pointer.
  ]],
  [[
   Variable(LONG Value) : Type(FD_LARGE), Large(Value) { }
   Variable(LARGE Value) : Type(FD_LARGE), Large(Value) { }
   Variable(DOUBLE Value) : Type(FD_DOUBLE), Double(Value) { }
   Variable(APTR Value) : Type(FD_POINTER), Pointer(Value) { }
   Variable() { }
  ]])

  -- Structures for defining method and action invocations.

  struct("ActionArray", { }, [[
    ptr Routine     # Pointer to the function entry point
    int ActionCode  # Action identifier
  ]],
  [[
  template <class T> ActionArray(LONG pID, T pRoutine) : Routine((APTR)pRoutine), ActionCode(pID) { }
  ]])

  struct("MethodEntry", { restrict="c" }, [[
    int  MethodID   # Unique method identifier
    ptr  Routine    # The method entry point, defined as ERROR (*Routine)(OBJECTPTR, APTR);
    cstr Name       # Name of the method
    cstruct(*FunctionField) Args  # List of parameters accepted by the method
    int  Size       # Total byte-size of all accepted parameters when they are assembled as a C structure.
  ]],
  [[
   MethodEntry() : MethodID(0), Routine(NULL), Name(NULL) { }
   MethodEntry(LONG pID, APTR pRoutine, CSTRING pName, const struct FunctionField *pArgs, LONG pSize) :
      MethodID(pID), Routine(pRoutine), Name(pName), Args(pArgs), Size(pSize) { }
  ]])

  struct("ActionTable", { comment="Structure for ActionList" }, [[
    uint Hash   # Hash of the action name.
    int  Size   # Byte-size of the structure for this action.
    cstr Name   # Name of the action.
    cstruct(*FunctionField) Args  # List of fields that are passed to this action.
  ]])

  struct("ChildEntry", { comment="Structure for ListChildren() function" }, [[
    oid ObjectID  # Object ID
    cid ClassID   # The class ID of the referenced object.
  ]])

  struct("Message", { comment="Message header." }, [[
     large Time  # A timestamp acquired from PreciseTime() when the message was first passed to SendMessage().
     int UID     # A unique identifier automatically created by SendMessage().
     int Type    # A message type identifier as defined by the client.
     int Size    # The size of the message data, in bytes.  If there is no data associated with the message, the Size will be set to zero.</>
  ]])

  struct("MemInfo", { type="meminfo" }, [[
    ptr  Start         # The starting address of the memory block (does not apply to shared blocks).
    oid  ObjectID      # The object that owns the memory block.
    uint  Size         # The size of the memory block.
    int(MEM) Flags     # The type of memory.
    mem  MemoryID      # The unique ID for this block.
    short AccessCount  # Total number of active locks on this block.
  ]])

  struct("MsgHandler", { restrict="c" }, [[
    ptr(struct(MsgHandler)) Prev  # Previous message handler in the chain
    ptr(struct(MsgHandler)) Next  # Next message handler in the chain
    ptr Custom                    # Custom pointer to send to the message handler
    func Function                 # Call this function
    int MsgType                   # Type of message being filtered
  ]])

  struct("CacheFile", { restrict="c", comment="Internal structure for managing files cached by LoadFile()." }, [[
    large TimeStamp   # The file's last-modified timestamp.
    large Size        # Byte size of the cached data.
    large LastUse     # The last time that this file was requested.
    cstr Path         # Pointer to the resolved file path.
    ptr Data          # Pointer to the cached data.
  ]])

  struct("CompressionFeedback", { }, [[
    int(FDB) FeedbackID     # Set to one of the FDB event indicators
    int   Index             # Index of the current file
    cstr  Path              # Name of the current file/path in the archive
    cstr  Dest              # Destination file/path during decompression
    large Progress          # Progress indicator (byte position for the file being de/compressed).
    large OriginalSize      # Original size of the file
    large CompressedSize    # Compressed size of the file
    short Year              # Year of the original file's datestamp.
    short Month             # Month of the original file's datestamp.
    short Day               # Day of the original file's datestamp.
    short Hour              # Hour of the original file's datestamp.
    short Minute            # Minute of the original file's datestamp.
    short Second            # Second of the original file's datestamp.
  ]])

  struct("CompressedItem", { }, [[
    large OriginalSize            # Original size of the file
    large CompressedSize          # Compressed size of the file
    struct(*CompressedItem) Next  # Used only if this is a linked-list.
    cstr Path                     # Path to the file (includes folder prefixes).  Archived folders will include the trailing slash.
    int(PERMIT) Permissions       # Original permissions - see PERMIT flags.
    int  UserID                   # Original user ID
    int  GroupID                  # Original group ID
    int  OthersID                 # Original others ID
    int(FL) Flags                 # FL flags
    struct(DateTime) Created      # Date and time of the file's creation.
    struct(DateTime) Modified     # Date and time last modified.
  ]],
  [[
    std::unordered_map<std::string, std::string> *Tags;
  ]])

  struct("FileInfo", { comment="Returned by GetFileInfo()" }, [[
    large Size                 # The size of the file's content.
    large TimeStamp            # 64-bit time stamp - usable only for comparison (e.g. sorting).
    struct(*FileInfo) Next     # Next structure in the list, or NULL.
    str Name                   # The name of the file.  This string remains valid until the next call to GetFileInfo().
    int(RDF) Flags             # Additional flags to describe the file.
    int(PERMIT) Permissions    # Standard permission flags.
    int UserID                 # User  ID (Unix systems only).
    int GroupID                # Group ID (Unix systems only).
    struct(DateTime) Created   # The date/time of the file's creation.
    struct(DateTime) Modified  # The date/time of the last file modification.
  ]],
  [[
    std::unordered_map<std::string, std::string> *Tags;
  ]]) -- NB: Private fields can follow this structure.

  struct("DirInfo", { comment="Used by OpenDir() only" }, [[
    struct(*FileInfo) Info # Pointer to a FileInfo structure
  ]],
  [[
   #ifdef PRV_FILE
   APTR   Driver;
   APTR   prvHandle;        // Directory handle.  If virtual, may store a private data address
   STRING prvPath;          // Original folder location string
   STRING prvResolvedPath;  // Resolved folder location
   RDF    prvFlags;         // OpenFolder() RDF flags
   LONG   prvTotal;         // Total number of items in the folder
   ULONG  prvVirtualID;     // Unique ID (name hash) for a virtual device
   union {
      LONG prvIndex;        // Current index within the folder when scanning
      APTR prvIndexPtr;
   };
   WORD   prvResolveLen;    // Byte length of ResolvedPath
   #endif
  ]])

  -- NB: Duplicated to windows.c
  struct("FileFeedback", { }, [[
    large Size          # Size of the file
    large Position      # Current seek position within the file if moving or copying
    str Path            # Path to the file
    str Dest            # Destination file/path if moving or copying
    int(FBK) FeedbackID # Set to one of the FBK values
    char(32) Reserved   # Reserved in case of future expansion
  ]])

  struct("Field", { comment="Used to describe the public fields of a class." }, [[
    maxint Arg         # An option to complement the field type.  Can be a pointer or an integer value
    fptr(error ptr ptr) GetValue # A virtual function that will retrieve the value for this field.
    ptr SetValue       # A virtual function that will set the value for this field.
    fptr(error obj struct(*Field) int cptr int) WriteValue # An internal function for writing to this field.
    cstr Name          # The English name for the field, e.g. "Width"
    uint FieldID       # Provides a fast way of finding fields, e.g. FID_WIDTH
    ushort Offset      # Field offset within the object
    ushort Index       # Field array index
    uint Flags         # Special flags that describe the field
  ]]) -- [32/52]

  c_insert([[
struct ScriptArg { // For use with scExec
   CSTRING Name;
   ULONG Type;
   union {
      APTR   Address;
      LONG   Long;
      LARGE  Large;
      DOUBLE Double;
   };

   ScriptArg(CSTRING pName, OBJECTPTR pValue, ULONG pType = FD_OBJECTPTR) : Name(pName), Type(pType), Address((APTR)pValue) { }
   ScriptArg(CSTRING pName, std::string &pValue, ULONG pType = FD_STRING) : Name(pName), Type(pType), Address((APTR)pValue.data()) { }
   ScriptArg(CSTRING pName, const std::string &pValue, ULONG pType = FD_STRING) : Name(pName), Type(pType), Address((APTR)pValue.data()) { }
   ScriptArg(CSTRING pName, CSTRING pValue, ULONG pType = FD_STRING) : Name(pName), Type(pType), Address((APTR)pValue) { }
   ScriptArg(CSTRING pName, APTR pValue, ULONG pType = FD_PTR) : Name(pName), Type(pType), Address(pValue) { }
   ScriptArg(CSTRING pName, LONG pValue, ULONG pType = FD_LONG) : Name(pName), Type(pType), Long(pValue) { }
   ScriptArg(CSTRING pName, ULONG pValue, ULONG pType = FD_LONG) : Name(pName), Type(pType), Long(pValue) { }
   ScriptArg(CSTRING pName, LARGE pValue, ULONG pType = FD_LARGE) : Name(pName), Type(pType), Large(pValue) { }
   ScriptArg(CSTRING pName, DOUBLE pValue, ULONG pType = FD_DOUBLE) : Name(pName), Type(pType), Double(pValue) { }
};
]])

  functionNames(nil,
    "AccessMemory",
    "Action",
    "ActionList",
    "ActionMsg",
    "ResolveClassID",
    "AllocateID",
    "AllocMemory",
    "AccessObject",
    "CheckAction",
    "CheckMemoryExists",
    "CheckObjectExists",
    "InitObject",
    "VirtualVolume",
    "CurrentContext",
    "GetFieldArray",
    "AdjustLogLevel",
    "ReadFileToBuffer",
    "FindObject",
    "FindClass",
    "AnalysePath",
    "UTF8Copy",
    "FreeResource",
    "GetClassID",
    "GetOwnerID",
    "GetField",
    "GetFieldVariable",
    "CompareFilePaths",
    "GetSystemState",
    "ListChildren",
    "Base64Decode",
    "RegisterFD",
    "ResolvePath",
    "MemoryIDInfo",
    "MemoryPtrInfo",
    "NewObject",
    "NotifySubscribers",
    "StrReadLocale",
    "UTF8ValidEncoding",
    "ProcessMessages",
    "IdentifyFile",
    "ReallocMemory",
    "GetMessage",
    "ReleaseMemory",
    "ResolveClassName",
    "SendMessage",
    "SetOwner",
    "SetContext",
    "SetField",
    "FieldName",
    "ScanDir",
    "SetName",
    "LogReturn",
    "StrCompare",
    "SubscribeAction",
    "SubscribeEvent",
    "SubscribeTimer",
    "UpdateTimer",
    "UnsubscribeAction",
    "UnsubscribeEvent",
    "BroadcastEvent",
    "WaitTime",
    "GetEventID",
    "GenCRC32",
    "GetResource",
    "SetResource",
    "ScanMessages",
    "StrDatatype",
    "UnloadFile",
    "CreateFolder",
    "LoadFile",
    "SetVolume",
    "DeleteVolume",
    "MoveFile",
    "UpdateMessage",
    "AddMsgHandler",
    "QueueAction",
    "PreciseTime",
    "OpenDir",
    "GetObjectPtr",
    "FindField",
    "GetErrorMsg",
    "GetActionMsg",
    "FuncError",
    "SetArray",
    "StrHash",
    "LockObject",
    "ReleaseObject",
    "ActionThread",
    "AddInfoTag",
    "SetDefaultPermissions",
    "VLogF",
    "Base64Encode",
    "ReadInfoTag",
    "SetResourcePath",
    "CurrentTask",
    "ResolveGroupID",
    "ResolveUserID",
    "CreateLink",
    "DeleteFile",
    "UTF8CharOffset",
    "UTF8Length",
    "UTF8OffsetToChar",
    "UTF8PrevLength",
    "UTF8CharLength",
    "UTF8ReadValue",
    "UTF8WriteValue",
    "CopyFile",
    "WaitForObjects")

  c_insert([=[

//********************************************************************************************************************

#define PRIME_HASH 2654435761UL
#define END_FIELD FieldArray(NULL, 0)
#define FDEF static const struct FunctionField

template <class T> inline MEMORYID GetMemoryID(T &&A) {
   return ((MEMORYID *)A)[-2];
}

inline ERROR DeregisterFD(HOSTHANDLE Handle) {
   return RegisterFD(Handle, RFD::REMOVE|RFD::READ|RFD::WRITE|RFD::EXCEPT|RFD::ALWAYS_CALL, 0, 0);
}

#define DeleteMsg(a,b)  UpdateMessage(a,b,(APTR)-1,0,0)

inline OBJECTPTR GetParentContext() { return (OBJECTPTR)(MAXINT)GetResource(RES::PARENT_CONTEXT); }
inline APTR GetResourcePtr(RES ID) { return (APTR)(MAXINT)GetResource(ID); }

inline CSTRING to_cstring(const std::string &A) { return A.c_str(); }
constexpr inline CSTRING to_cstring(CSTRING A) { return A; }

template <class T, class U> inline ERROR StrMatch(T &&A, U &&B) {
   return StrCompare(to_cstring(A), to_cstring(B), 0, STR::MATCH_LEN);
}

template <class T> inline LONG StrCopy(T &&Source, STRING Dest, LONG Length = 0x7fffffff)
{
   auto src = to_cstring(Source);
   if ((Length > 0) and (src) and (Dest)) {
      LONG i = 0;
      while (*src) {
         if (i IS Length) {
            Dest[i-1] = 0;
            return i;
         }
         Dest[i++] = *src++;
      }

      Dest[i] = 0;
      return i;
   }
   else return 0;
}

#ifndef PRV_CORE_DATA
// These overloaded functions can't be used in the Core as they will confuse the compiler in key areas.

inline ERROR SubscribeAction(OBJECTPTR Object, LONG Action, FUNCTION Callback) {
   return SubscribeAction(Object,Action,&Callback);
}

inline ERROR SubscribeEvent(LARGE Event, FUNCTION Callback, APTR Custom, APTR Handle) {
   return SubscribeEvent(Event,&Callback,Custom,Handle);
}

inline ERROR SubscribeTimer(DOUBLE Interval, FUNCTION Callback, APTR Subscription) {
   return SubscribeTimer(Interval,&Callback,Subscription);
}

inline ERROR ReleaseMemory(const void *Address) {
   if (!Address) return ERR_NullArgs;
   return ReleaseMemory(((MEMORYID *)Address)[-2]);
}

inline ERROR FreeResource(const void *Address) {
   if (!Address) return ERR_NullArgs;
   return FreeResource(((LONG *)Address)[-2]);
}

inline ERROR AllocMemory(LONG Size, MEM Flags, APTR Address) {
   return AllocMemory(Size, Flags, (APTR *)Address, NULL);
}

template<class T> inline ERROR NewObject(LARGE ClassID, T **Result) {
   return NewObject(ClassID, NF::NIL, Result);
}

inline ERROR MemoryIDInfo(MEMORYID ID, struct MemInfo * MemInfo) {
   return MemoryIDInfo(ID,MemInfo,sizeof(struct MemInfo));
}

inline ERROR MemoryPtrInfo(APTR Address, struct MemInfo * MemInfo) {
   return MemoryPtrInfo(Address,MemInfo,sizeof(struct MemInfo));
}

inline ERROR QueueAction(LONG Action, OBJECTID ObjectID) {
   return QueueAction(Action, ObjectID, NULL);
}

template <class T, class U> inline ERROR StrCompare(T &&A, U &&B, LONG Length = 0, STR Flags = STR::NIL) {
   return StrCompare(to_cstring(A), to_cstring(B), Length, Flags);
}

inline ULONG StrHash(const std::string Value) {
   return StrHash(Value.c_str(), FALSE);
}

template <class T> inline ERROR SetArray(OBJECTPTR Object, FIELD FieldID, pf::vector<T> &Array)
{
   return SetArray(Object, FieldID, Array.data(), Array.size());
}

template <class T> inline ERROR SetArray(OBJECTPTR Object, FIELD FieldID, std::vector<T> &Array)
{
   return SetArray(Object, FieldID, Array.data(), Array.size());
}

template <class T, std::size_t SIZE> inline ERROR SetArray(OBJECTPTR Object, FIELD FieldID, std::array<T, SIZE> Array)
{
   return SetArray(Object, FieldID, Array.data(), SIZE);
}
#endif

typedef KEYVALUE ConfigKeys;
typedef std::pair<std::string, ConfigKeys> ConfigGroup;
typedef std::vector<ConfigGroup> ConfigGroups;

inline void CopyMemory(const void *Src, APTR Dest, LONG Length)
{
   memmove(Dest, Src, Length);
}

[[nodiscard]] inline LONG StrSearchCase(CSTRING Keyword, CSTRING String)
{
   LONG i;
   LONG pos = 0;
   while (String[pos]) {
      for (i=0; Keyword[i]; i++) if (String[pos+i] != Keyword[i]) break;
      if (!Keyword[i]) return pos;
      for (++pos; (String[pos] & 0xc0) IS 0x80; pos++);
   }

   return -1;
}

[[nodiscard]] inline LONG StrSearch(CSTRING Keyword, CSTRING String)
{
   LONG i;
   LONG pos = 0;
   while (String[pos]) {
      for (i=0; Keyword[i]; i++) if (std::toupper(String[pos+i]) != std::toupper(Keyword[i])) break;
      if (!Keyword[i]) return pos;
      for (++pos; (String[pos] & 0xc0) IS 0x80; pos++);
   }

   return -1;
}

[[nodiscard]] inline STRING StrClone(CSTRING String)
{
   if (!String) return NULL;

   auto len = LONG(strlen(String));
   STRING newstr;
   if (!AllocMemory(len+1, MEM::STRING, (APTR *)&newstr, NULL)) {
      CopyMemory(String, newstr, len+1);
      return newstr;
   }
   else return NULL;
}

[[nodiscard]] inline LONG StrLength(CSTRING String) {
   if (String) return LONG(strlen(String));
   else return 0;
}

template <class T> inline LARGE StrToInt(T &&String) {
   CSTRING str = to_cstring(String);
   if (!str) return 0;

   while ((*str < '0') or (*str > '9')) { // Ignore any leading characters
      if (!str[0]) return 0;
      else if (*str IS '-') break;
      else if (*str IS '+') break;
      else str++;
   }

   return strtoll(str, NULL, 0);
}

template <class T> inline DOUBLE StrToFloat(T &&String) {
   CSTRING str = to_cstring(String);
   if (!str) return 0;

   while ((*str != '-') and (*str != '.') and ((*str < '0') or (*str > '9'))) {
      if (!*str) return 0;
      str++;
   }

   return strtod(str, NULL);
}

// NB: Prefer std::to_string(value) where viable to get the std::string of a number.

inline LONG IntToStr(LARGE Integer, STRING String, LONG StringSize) {
   auto str = std::to_string(Integer);
   auto len = LONG(str.copy(String, StringSize-1));
   String[len] = 0;
   return len;
}

inline ERROR ClearMemory(APTR Memory, LONG Length) {
   if (!Memory) return ERR_NullArgs;
   memset(Memory, 0, Length); // memset() is assumed to be optimised by the compiler.
   return ERR_Okay;
}

namespace pf {

static THREADVAR LONG _tlUniqueThreadID = 0;

[[nodiscard]] inline LONG _get_thread_id(void) {
   if (_tlUniqueThreadID) return _tlUniqueThreadID;
   _tlUniqueThreadID = GetResource(RES::THREAD_ID);
   return _tlUniqueThreadID;
}

// For extremely verbose debug logs, run cmake with -DPARASOL_VLOG=ON

class Log { // C++ wrapper for Parasol's log functionality
   private:
      LONG branches = 0;

   public:
      CSTRING header;

      Log() {
         header = NULL;
      }

      Log(CSTRING Header) {
         header = Header;
      }

      ~Log() {
         while (branches > 0) { branches--; LogReturn(); }
      }

      void branch(CSTRING Message = "", ...) __attribute__((format(printf, 2, 3))) {
         va_list arg;
         va_start(arg, Message);
         VLogF(VLF::API|VLF::BRANCH, header, Message, arg);
         va_end(arg);
         branches++;
      }

      #ifdef _DEBUG
      void traceBranch(CSTRING Message = "", ...) __attribute__((format(printf, 2, 3))) {
         va_list arg;
         va_start(arg, Message);
         VLogF(VLF::TRACE|VLF::BRANCH, header, Message, arg);
         va_end(arg);
         branches++;
      }
      #else
      void traceBranch(CSTRING Message = "", ...) __attribute__((format(printf, 2, 3))) { }
      #endif

      void debranch() {
         branches--;
         LogReturn();
      }

      void app(CSTRING Message, ...) { // Info level, recommended for applications only
         va_list arg;
         va_start(arg, Message);
         VLogF(VLF::INFO, header, Message, arg);
         va_end(arg);
      }

      void msg(CSTRING Message, ...) __attribute__((format(printf, 2, 3))) { // Defaults to API level, recommended for modules
         va_list arg;
         va_start(arg, Message);
         VLogF(VLF::API, header, Message, arg);
         va_end(arg);
      }

      void msg(VLF Flags, CSTRING Message, ...) __attribute__((format(printf, 3, 4))) { // Defaults to API level, recommended for modules
         va_list arg;
         va_start(arg, Message);
         VLogF(Flags, header, Message, arg);
         va_end(arg);
         if ((Flags & VLF::BRANCH) != VLF::NIL) branches++;
      }

      void extmsg(CSTRING Message, ...) __attribute__((format(printf, 2, 3))) { // Extended API message
         va_list arg;
         va_start(arg, Message);
         VLogF(VLF::EXTAPI, header, Message, arg);
         va_end(arg);
      }

      void pmsg(CSTRING Message, ...) __attribute__((format(printf, 2, 3))) { // "Parent message", uses the scope of the caller
         va_list arg;
         va_start(arg, Message);
         VLogF(VLF::API, NULL, Message, arg);
         va_end(arg);
      }

      void warning(CSTRING Message, ...) __attribute__((format(printf, 2, 3))) {
         va_list arg;
         va_start(arg, Message);
         VLogF(VLF::WARNING, header, Message, arg);
         va_end(arg);
      }

      void error(CSTRING Message, ...) __attribute__((format(printf, 2, 3))) { // NB: Use for messages intended for the user, not the developer
         va_list arg;
         va_start(arg, Message);
         VLogF(VLF::ERROR, header, Message, arg);
         va_end(arg);
      }

      void debug(CSTRING Message, ...) __attribute__((format(printf, 2, 3))) {
         va_list arg;
         va_start(arg, Message);
         VLogF(VLF::DEBUG, header, Message, arg);
         va_end(arg);
      }

      void function(CSTRING Message, ...) __attribute__((format(printf, 2, 3))) { // Equivalent to branch() but without a new branch being created
         va_list arg;
         va_start(arg, Message);
         VLogF(VLF::API|VLF::FUNCTION, header, Message, arg);
         va_end(arg);
      }

      ERROR error(ERROR Code) { // Technically a warning
         FuncError(header, Code);
         return Code;
      }

      ERROR warning(ERROR Code) {
         FuncError(header, Code);
         return Code;
      }

      void trace(CSTRING Message, ...) {
         #ifdef _DEBUG
            va_list arg;
            va_start(arg, Message);
            VLogF(VLF::TRACE, header, Message, arg);
            va_end(arg);
         #endif
      }

      void traceWarning(CSTRING Message, ...) {
         #ifdef _DEBUG
            va_list arg;
            va_start(arg, Message);
            VLogF(VLF::WARNING, header, Message, arg);
            va_end(arg);
         #endif
      }

      ERROR traceWarning(ERROR Code) {
         #ifdef _DEBUG
            FuncError(header, Code);
         #endif
         return Code;
      }
};

class LogLevel {
   private:
      LONG level;
   public:
      LogLevel(LONG Level) : level(Level) {
         AdjustLogLevel(Level);
      }

      ~LogLevel() {
         AdjustLogLevel(-level);
      }
};

} // namespace

//********************************************************************************************************************
// Refer to BaseClass->get() to see what this is about...

template <class T> inline LARGE FIELD_TAG()   { return 0; }
template <> inline LARGE FIELD_TAG<DOUBLE>()  { return TDOUBLE; }
template <> inline LARGE FIELD_TAG<LONG>()    { return TLONG; }
template <> inline LARGE FIELD_TAG<FLOAT>()   { return TFLOAT; }
template <> inline LARGE FIELD_TAG<APTR>()    { return TPTR; }
template <> inline LARGE FIELD_TAG<LARGE>()   { return TLARGE; }
template <> inline LARGE FIELD_TAG<CSTRING>() { return TSTRING; }
template <> inline LARGE FIELD_TAG<STRING>()  { return TSTRING; }
template <> inline LARGE FIELD_TAG<SCALE>()   { return TDOUBLE|TSCALE; }

//********************************************************************************************************************
// Header used for all objects.

struct BaseClass { // Must be 64-bit aligned
   union {
      objMetaClass *Class;          // [Public] Class pointer
      class extMetaClass *ExtClass; // [Private] Internal version of the class pointer
   };
   APTR     ChildPrivate;        // Address for the ChildPrivate structure, if allocated
   APTR     CreatorMeta;         // The creator of the object is permitted to store a custom data pointer here.
   std::atomic_uint64_t NotifyFlags; // Action subscription flags - space for 64 actions max
   OBJECTID UID;                 // Unique object identifier
   OBJECTID OwnerID;             // The owner of this object
   NF       Flags;               // Object flags
   volatile LONG  ThreadID;      // Managed by locking functions
   char Name[MAX_NAME_LEN];      // The name of the object (optional)
   std::atomic_uchar ThreadPending; // ActionThread() increments this.
   std::atomic_char Queue;       // Counter of locks gained by incQueue()
   std::atomic_char SleepQueue;  // For the use of LockObject() only
   std::atomic_bool Locked;      // Set if locked by AccessObject()/LockObject()
   BYTE ActionDepth;             // Incremented each time an action or method is called on the object

   inline bool initialised() { return (Flags & NF::INITIALISED) != NF::NIL; }
   inline bool defined(NF pFlags) { return (Flags & pFlags) != NF::NIL; }
   inline bool isSubClass();
   inline OBJECTID ownerID() { return OwnerID; }
   inline NF flags() { return Flags; }

   CSTRING className();

   inline bool collecting() { // Is object being freed or marked for collection?
      return (Flags & (NF::FREE|NF::COLLECT|NF::FREE_ON_UNLOCK)) != NF::NIL;
   }

   inline bool terminating() { // Is object currently being freed?
      return (Flags & NF::FREE) != NF::NIL;
   }

   // Use lock() to quickly obtain an object lock without a call to LockObject()

   inline ERROR lock() {
      if (++Queue IS 1) {
         ThreadID = pf::_get_thread_id();
         return ERR_Okay;
      }
      else {
         if (ThreadID IS pf::_get_thread_id()) return ERR_Okay; // If this is for the same thread then it's a nested lock, so there's no issue.
         --Queue; // Restore the lock count
         return LockObject(this, -1); // Can fail if object is marked for deletion.
      }
   }

   inline void unlock() {
      // Prefer to use ReleaseObject() if there are threads that need to be woken
      if (SleepQueue.load() > 0) ReleaseObject(this);
      else --Queue;
   }

   inline bool hasOwner(OBJECTID ID) { // Return true if ID has ownership.
      auto oid = this->OwnerID;
      while ((oid) and (oid != ID)) oid = GetOwnerID(oid);
      return oid ? true : false;
   }

   inline ERROR set(ULONG FieldID, int Value)             { return SetField(this, (FIELD)FieldID|TLONG, Value); }
   inline ERROR set(ULONG FieldID, unsigned int Value)    { return SetField(this, (FIELD)FieldID|TLONG, Value); }
   inline ERROR set(ULONG FieldID, LARGE Value)           { return SetField(this, (FIELD)FieldID|TLARGE, Value); }
   inline ERROR set(ULONG FieldID, DOUBLE Value)          { return SetField(this, (FIELD)FieldID|TDOUBLE, Value); }
   inline ERROR set(ULONG FieldID, const FUNCTION *Value) { return SetField(this, (FIELD)FieldID|TFUNCTION, Value); }
   inline ERROR set(ULONG FieldID, const char *Value)     { return SetField(this, (FIELD)FieldID|TSTRING, Value); }
   inline ERROR set(ULONG FieldID, const unsigned char *Value) { return SetField(this, (FIELD)FieldID|TSTRING, Value); }
   inline ERROR set(ULONG FieldID, const std::string &Value)   { return SetField(this, (FIELD)FieldID|TSTRING, Value.c_str()); }
   inline ERROR set(ULONG FieldID, const Variable *Value)      { return SetField(this, (FIELD)FieldID|TVAR, Value); }
   // Works both for regular data pointers and function pointers if field is defined correctly.
   inline ERROR set(ULONG FieldID, const void *Value) { return SetField(this, (FIELD)FieldID|TPTR, Value); }

   inline ERROR setScale(ULONG FieldID, DOUBLE Value) { return SetField(this, (FIELD)FieldID|TDOUBLE|TSCALE, Value); }

   // There are two mechanisms for retrieving object values; the first allows the value to be retrieved with an error
   // code and the value itself; the second ignores the error code and returns a value that could potentially be invalid.

   inline ERROR get(ULONG FieldID, LONG *Value)     { return GetField(this, (FIELD)FieldID|TLONG, Value); }
   inline ERROR get(ULONG FieldID, LARGE *Value)    { return GetField(this, (FIELD)FieldID|TLARGE, Value); }
   inline ERROR get(ULONG FieldID, DOUBLE *Value)   { return GetField(this, (FIELD)FieldID|TDOUBLE, Value); }
   inline ERROR get(ULONG FieldID, STRING *Value)   { return GetField(this, (FIELD)FieldID|TSTRING, Value); }
   inline ERROR get(ULONG FieldID, CSTRING *Value)  { return GetField(this, (FIELD)FieldID|TSTRING, Value); }
   inline ERROR get(ULONG FieldID, Variable *Value) { return GetField(this, (FIELD)FieldID|TVAR, Value); }
   inline ERROR getPtr(ULONG FieldID, APTR Value)   { return GetField(this, (FIELD)FieldID|TPTR, Value); }
   inline ERROR getScale(ULONG FieldID, DOUBLE *Value) { return GetField(this, (FIELD)FieldID|TDOUBLE|TSCALE, Value); }

   template <class T> inline T get(ULONG FieldID) { // Validity of the result is not guaranteed
      T val;
      GetField(this, (FIELD)FieldID|FIELD_TAG<T>(), &val);
      return val;
   };

   template <typename... Args> ERROR setFields(Args&&... pFields) {
      pf::Log log("setFields");

      lock();

      std::initializer_list<pf::FieldValue> Fields = { std::forward<Args>(pFields)... };

      auto ctx = CurrentContext();
      for (auto &f : Fields) {
         OBJECTPTR target;
         if (auto field = FindField(this, f.FieldID, &target)) {
            if ((!(field->Flags & (FD_INIT|FD_WRITE))) and (ctx != target)) {
               log.warning("%s.%s is immutable.", className(), field->Name);
            }
            else if ((field->Flags & FD_INIT) and (target->initialised()) and (ctx != target)) {
               log.warning("%s.%s is init-only.", className(), field->Name);
            }
            else {
               if (target != this) target->lock();

               ERROR error;
               if (f.Type & (FD_POINTER|FD_STRING|FD_ARRAY|FD_FUNCTION|FD_VARIABLE)) {
                  error = field->WriteValue(target, field, f.Type, f.Pointer, 0);
               }
               else if (f.Type & (FD_DOUBLE|FD_FLOAT)) {
                  error = field->WriteValue(target, field, f.Type, &f.Double, 1);
               }
               else if (f.Type & FD_LARGE) {
                  error = field->WriteValue(target, field, f.Type, &f.Large, 1);
               }
               else error = field->WriteValue(target, field, f.Type, &f.Long, 1);

               if (target != this) target->unlock();

               // NB: NoSupport is considered a 'soft' error that does not warrant failure.

               if ((error) and (error != ERR_NoSupport)) {
                  log.warning("%s.%s: %s", target->className(), field->Name, GetErrorMsg(error));
                  unlock();
                  return error;
               }
            }
         }
         else {
            unlock();
            return log.warning(ERR_UnsupportedField);
         }
      }

      unlock();
      return ERR_Okay;
   }

} __attribute__ ((aligned (8)));

namespace pf {

template<class T = BaseClass>
class Create {
   private:
      T *obj;

   public:
      ERROR error;

      // Return an unscoped direct object pointer.  NB: Globals are still tracked to their owner

      template <typename... Args> static T * global(Args&&... Fields) {
         pf::Create<T> object = { std::forward<Args>(Fields)... };
         if (object.ok()) {
            auto result = *object;
            object.obj = NULL;
            return result;
         }
         else return NULL;
      }

      inline static T * global(const std::initializer_list<FieldValue> Fields) {
         pf::Create<T> object(Fields);
         if (object.ok()) {
            auto result = *object;
            object.obj = NULL;
            return result;
         }
         else return NULL;
      }

      // Return an unscoped integral object (suitable for class allocations only).

      template <typename... Args> static T * integral(Args&&... Fields) {
         pf::Create<T> object({ std::forward<Args>(Fields)... }, NF::INTEGRAL);
         if (object.ok()) return *object;
         else return NULL;
      }

      inline static T * integral(const std::initializer_list<FieldValue> Fields) {
         pf::Create<T> object(Fields, NF::INTEGRAL);
         if (object.ok()) return *object;
         else return NULL;
      }

      // Return an unscoped and untracked object pointer.

      template <typename... Args> static T * untracked(Args&&... Fields) {
         pf::Create<T> object({ std::forward<Args>(Fields)... }, NF::UNTRACKED);
         if (object.ok()) return *object;
         else return NULL;
      }

      inline static T * untracked(const std::initializer_list<FieldValue> Fields) {
         pf::Create<T> object(Fields, NF::UNTRACKED);
         if (object.ok()) return *object;
         else return NULL;
      }

      // Create a scoped object that is not initialised.

      Create(NF Flags = NF::NIL) : obj(NULL), error(ERR_NewObject) {
         if (!NewObject(T::CLASS_ID, Flags, (BaseClass **)&obj)) {
            error = ERR_Okay;
         }
      }

      // Create a scoped object that is fully initialised.

      Create(const std::initializer_list<FieldValue> Fields, NF Flags = NF::NIL) : obj(NULL), error(ERR_Failed) {
         pf::Log log("CreateObject");
         log.branch(T::CLASS_NAME);

         if (!NewObject(T::CLASS_ID, NF::SUPPRESS_LOG|Flags, (BaseClass **)&obj)) {
            for (auto &f : Fields) {
               OBJECTPTR target;
               if (auto field = FindField(obj, f.FieldID, &target)) {
                  if (!(field->Flags & (FD_WRITE|FD_INIT))) {
                     error = log.warning(ERR_NoFieldAccess);
                     return;
                  }
                  else {
                     target->lock();

                     if (f.Type & (FD_POINTER|FD_STRING|FD_ARRAY|FD_FUNCTION|FD_VARIABLE)) {
                        error = field->WriteValue(target, field, f.Type, f.Pointer, 0);
                     }
                     else if (f.Type & (FD_DOUBLE|FD_FLOAT)) {
                        error = field->WriteValue(target, field, f.Type, &f.Double, 1);
                     }
                     else if (f.Type & FD_LARGE) {
                        error = field->WriteValue(target, field, f.Type, &f.Large, 1);
                     }
                     else error = field->WriteValue(target, field, f.Type, &f.Long, 1);

                     target->unlock();

                     // NB: NoSupport is considered a 'soft' error that does not warrant failure.

                     if ((error) and (error != ERR_NoSupport)) return;
                  }
               }
               else {
                  log.warning("%s.%s field not supported.", T::CLASS_NAME, FieldName(f.FieldID));
                  error = log.warning(ERR_UnsupportedField);
                  return;
               }
            }

            if ((error = InitObject(obj))) {
               FreeResource(obj->UID);
               obj = NULL;
            }
         }
         else error = ERR_NewObject;
      }

      ~Create() {
         if (obj) {
            if (obj->initialised()) {
               if ((obj->BaseClass::Flags & (NF::UNTRACKED|NF::INTEGRAL)) != NF::NIL)  {
                  return; // Detected a successfully created unscoped object
               }
            }
            FreeResource(obj->UID);
            obj = NULL;
         }
      }

      T * operator->() { return obj; }; // Promotes underlying methods and fields
      T * & operator*() { return obj; }; // To allow object pointer referencing when calling functions

      inline bool ok() { return error == ERR_Okay; }
};
}

inline OBJECTID CurrentTaskID() { return ((OBJECTPTR)CurrentTask())->UID; }
inline APTR SetResourcePtr(RES Res, APTR Value) { return (APTR)(MAXINT)(SetResource(Res, (MAXINT)Value)); }

// Action and Notification Structures

struct acClipboard     { CLIPMODE Mode; };
struct acCopyData      { OBJECTPTR Dest; };
struct acCustom        { LONG Number; CSTRING String; };
struct acDataFeed      { OBJECTPTR Object; DATA Datatype; const void *Buffer; LONG Size; };
struct acDragDrop      { OBJECTPTR Source; LONG Item; CSTRING Datatype; };
struct acDraw          { LONG X; LONG Y; LONG Width; LONG Height; };
struct acGetVar        { CSTRING Field; STRING Buffer; LONG Size; };
struct acMove          { DOUBLE DeltaX; DOUBLE DeltaY; DOUBLE DeltaZ; };
struct acMoveToPoint   { DOUBLE X; DOUBLE Y; DOUBLE Z; MTF Flags; };
struct acNewChild      { OBJECTPTR Object; };
struct acNewOwner      { OBJECTPTR NewOwner; };
struct acRead          { APTR Buffer; LONG Length; LONG Result; };
struct acRedimension   { DOUBLE X; DOUBLE Y; DOUBLE Z; DOUBLE Width; DOUBLE Height; DOUBLE Depth; };
struct acRedo          { LONG Steps; };
struct acRename        { CSTRING Name; };
struct acResize        { DOUBLE Width; DOUBLE Height; DOUBLE Depth; };
struct acSaveImage     { OBJECTPTR Dest; union { CLASSID ClassID; CLASSID Class; }; };
struct acSaveToObject  { OBJECTPTR Dest; union { CLASSID ClassID; CLASSID Class; }; };
struct acScroll        { DOUBLE DeltaX; DOUBLE DeltaY; DOUBLE DeltaZ; };
struct acScrollToPoint { DOUBLE X; DOUBLE Y; DOUBLE Z; STP Flags; };
struct acSeek          { DOUBLE Offset; SEEK Position; };
struct acSelectArea    { DOUBLE X; DOUBLE Y; DOUBLE Width; DOUBLE Height; };
struct acSetVar        { CSTRING Field; CSTRING Value; };
struct acUndo          { LONG Steps; };
struct acWrite         { CPTR Buffer; LONG Length; LONG Result; };

// Action Macros

inline ERROR acActivate(OBJECTPTR Object) { return Action(AC_Activate,Object,NULL); }
inline ERROR acClear(OBJECTPTR Object) { return Action(AC_Clear,Object,NULL); }
inline ERROR acDeactivate(OBJECTPTR Object) { return Action(AC_Deactivate,Object,NULL); }
inline ERROR acDisable(OBJECTPTR Object) { return Action(AC_Disable,Object,NULL); }
inline ERROR acDraw(OBJECTPTR Object) { return Action(AC_Draw,Object,NULL); }
inline ERROR acEnable(OBJECTPTR Object) { return Action(AC_Enable,Object,NULL); }
inline ERROR acFlush(OBJECTPTR Object) { return Action(AC_Flush,Object,NULL); }
inline ERROR acFocus(OBJECTPTR Object) { return Action(AC_Focus,Object,NULL); }
inline ERROR acHide(OBJECTPTR Object) { return Action(AC_Hide,Object,NULL); }
inline ERROR acLock(OBJECTPTR Object) { return Action(AC_Lock,Object,NULL); }
inline ERROR acLostFocus(OBJECTPTR Object) { return Action(AC_LostFocus,Object,NULL); }
inline ERROR acMoveToBack(OBJECTPTR Object) { return Action(AC_MoveToBack,Object,NULL); }
inline ERROR acMoveToFront(OBJECTPTR Object) { return Action(AC_MoveToFront,Object,NULL); }
inline ERROR acNext(OBJECTPTR Object) { return Action(AC_Next,Object,NULL); }
inline ERROR acPrev(OBJECTPTR Object) { return Action(AC_Prev,Object,NULL); }
inline ERROR acQuery(OBJECTPTR Object) { return Action(AC_Query,Object,NULL); }
inline ERROR acRefresh(OBJECTPTR Object) { return Action(AC_Refresh, Object, NULL); }
inline ERROR acReset(OBJECTPTR Object) { return Action(AC_Reset,Object,NULL); }
inline ERROR acSaveSettings(OBJECTPTR Object) { return Action(AC_SaveSettings,Object,NULL); }
inline ERROR acShow(OBJECTPTR Object) { return Action(AC_Show,Object,NULL); }
inline ERROR acSignal(OBJECTPTR Object) { return Action(AC_Signal,Object,NULL); }
inline ERROR acSort(OBJECTPTR Object) { return Action(AC_Sort,Object,NULL); }
inline ERROR acUnlock(OBJECTPTR Object) { return Action(AC_Unlock,Object,NULL); }

inline ERROR acClipboard(OBJECTPTR Object, CLIPMODE Mode) {
   struct acClipboard args = { Mode };
   return Action(AC_Clipboard, Object, &args);
}

inline ERROR acDragDrop(OBJECTPTR Object, OBJECTPTR Source, LONG Item, CSTRING Datatype) {
   struct acDragDrop args = { Source, Item, Datatype };
   return Action(AC_DragDrop, Object, &args);
}

inline ERROR acDrawArea(OBJECTPTR Object, LONG X, LONG Y, LONG Width, LONG Height) {
   struct acDraw args = { X, Y, Width, Height };
   return Action(AC_Draw, Object, &args);
}

inline ERROR acDataFeed(OBJECTPTR Object, OBJECTPTR Sender, DATA Datatype, const void *Buffer, LONG Size) {
   struct acDataFeed args = { Sender, Datatype, Buffer, Size };
   return Action(AC_DataFeed, Object, &args);
}

inline ERROR acGetVar(OBJECTPTR Object, CSTRING FieldName, STRING Buffer, LONG Size) {
   struct acGetVar args = { FieldName, Buffer, Size };
   ERROR error = Action(AC_GetVar, Object, &args);
   if ((error) and (Buffer)) Buffer[0] = 0;
   return error;
}

inline ERROR acMove(OBJECTPTR Object, DOUBLE X, DOUBLE Y, DOUBLE Z) {
   struct acMove args = { X, Y, Z };
   return Action(AC_Move, Object, &args);
}

inline ERROR acRead(OBJECTPTR Object, APTR Buffer, LONG Bytes, LONG *Read) {
   ERROR error;
   struct acRead read = { (BYTE *)Buffer, Bytes };
   if (!(error = Action(AC_Read, Object, &read))) {
      if (Read) *Read = read.Result;
      return ERR_Okay;
   }
   else {
      if (Read) *Read = 0;
      return error;
   }
}

inline ERROR acRedo(OBJECTPTR Object, LONG Steps = 1) {
   struct acRedo args = { Steps };
   return Action(AC_Redo, Object, &args);
}

inline ERROR acRedimension(OBJECTPTR Object, DOUBLE X, DOUBLE Y, DOUBLE Z, DOUBLE Width, DOUBLE Height, DOUBLE Depth) {
   struct acRedimension args = { X, Y, Z, Width, Height, Depth };
   return Action(AC_Redimension, Object, &args);
}

inline ERROR acRename(OBJECTPTR Object, CSTRING Name) {
   struct acRename args = { Name };
   return Action(AC_Rename, Object, &args);
}

inline ERROR acResize(OBJECTPTR Object, DOUBLE Width, DOUBLE Height, DOUBLE Depth) {
   struct acResize args = { Width, Height, Depth };
   return Action(AC_Resize, Object, &args);
}

inline ERROR acScroll(OBJECTPTR Object, DOUBLE X, DOUBLE Y, DOUBLE Z) {
   struct acScroll args = { X, Y, Z };
   return Action(AC_Scroll, Object, &args);
}

inline ERROR acScrollToPoint(OBJECTPTR Object, DOUBLE X, DOUBLE Y, DOUBLE Z, STP Flags) {
   struct acScrollToPoint args = { X, Y, Z, Flags };
   return Action(AC_ScrollToPoint, Object, &args);
}

inline ERROR acMoveToPoint(OBJECTPTR Object, DOUBLE X, DOUBLE Y, DOUBLE Z, MTF Flags) {
   struct acMoveToPoint moveto = { X, Y, Z, Flags };
   return Action(AC_MoveToPoint, Object, &moveto);
}

inline ERROR acSaveImage(OBJECTPTR Object, OBJECTPTR Dest, CLASSID ClassID = 0) {
   struct acSaveImage args = { Dest, { ClassID } };
   return Action(AC_SaveImage, Object, &args);
}

inline ERROR acSaveToObject(OBJECTPTR Object, OBJECTPTR Dest, CLASSID ClassID = 0) {
   struct acSaveToObject args = { Dest, { ClassID } };
   return Action(AC_SaveToObject, Object, &args);
}

inline ERROR acSeek(OBJECTPTR Object, DOUBLE Offset, SEEK Position) {
   struct acSeek args = { Offset, Position };
   return Action(AC_Seek, Object, &args);
}

inline ERROR acSetVars(OBJECTPTR Object, CSTRING tags, ...) {
   struct acSetVar args;
   va_list list;

   va_start(list, tags);
   while ((args.Field = va_arg(list, STRING)) != TAGEND) {
      args.Value = va_arg(list, STRING);
      if (Action(AC_SetVar, Object, &args) != ERR_Okay) {
         va_end(list);
         return ERR_Failed;
      }
   }
   va_end(list);
   return ERR_Okay;
}

inline ERROR acUndo(OBJECTPTR Object, LONG Steps) {
   struct acUndo args = { Steps };
   return Action(AC_Undo, Object, &args);
}

inline ERROR acWrite(OBJECTPTR Object, CPTR Buffer, LONG Bytes, LONG *Result) {
   ERROR error;
   struct acWrite write = { (BYTE *)Buffer, Bytes };
   if (!(error = Action(AC_Write, Object, &write))) {
      if (Result) *Result = write.Result;
   }
   else if (Result) *Result = 0;
   return error;
}

inline LONG acWriteResult(OBJECTPTR Object, CPTR Buffer, LONG Bytes) {
   struct acWrite write = { (BYTE *)Buffer, Bytes };
   if (!Action(AC_Write, Object, &write)) return write.Result;
   else return 0;
}

#define acSeekStart(a,b)    acSeek((a),(b),SEEK::START)
#define acSeekEnd(a,b)      acSeek((a),(b),SEEK::END)
#define acSeekCurrent(a,b)  acSeek((a),(b),SEEK::CURRENT)

inline ERROR acSelectArea(OBJECTPTR Object, DOUBLE X, DOUBLE Y, DOUBLE Width, DOUBLE Height) {
   struct acSelectArea area = { X, Y, Width, Height };
   return Action(AC_SelectArea, Object, &area);
}

inline ERROR acSetVar(OBJECTPTR Object, CSTRING FieldName, CSTRING Value) {
   struct acSetVar args = { FieldName, Value };
   return Action(AC_SetVar, Object, &args);
}

#define GetVar(a,b,c,d)  acGetVar(a,b,c,d)
#define SetVar(a,b,c)    acSetVar(a,b,c)
]=])

  methods("MetaClass", "mc", {
    { id=1, name="FindField" }
  })

  class("MetaClass", { src="../classes/class_metaclass.cpp" }, [[
    double ClassVersion    # Version of the class
    cstruct(*FieldArray) Fields  # Original field array supplied by the module.
    array(struct(Field)) Dictionary # Field lookup by ID
    cstr ClassName         # Name of the class
    cstr FileExtension     # File extension that is supported by this class.
    cstr FileDescription   # File description
    cstr FileHeader        # Internal file header for identifying the file
    cstr Path              # Module path to the class
    int Size               # Byte-size of the class when produced as an object
    int(CLF) Flags         # Special flags
    cid ClassID            # ID of this class
    cid BaseClassID        # Base-class ID
    int OpenCount          # Number of objects allocated to this class
    int(CCF) Category      # Assigned category
  ]])

c_insert([[
inline bool BaseClass::isSubClass() { return Class->ClassID != Class->BaseClassID; }
]])

  class("StorageDevice", { src="../classes/class_storagedevice.cpp" }, [[
    large(DEVICE) DeviceFlags  # Flags identifying the type of media
    large DeviceSize           # Size of the device
    large BytesFree            # Bytes available to the user
    large BytesUsed            # Bytes already used
  ]])

  methods("File", "Fl", {
    { id=1,  name="StartStream" },
    { id=2,  name="StopStream" },
    { id=3,  name="Delete" },
    { id=4,  name="Move" },
    { id=5,  name="Copy" },
    { id=6,  name="SetDate" },
    { id=7,  name="ReadLine", inline=false },
    { id=8,  name="BufferContent" },
    { id=9,  name="Next" },
    { id=10, name="Watch" }
  })

  class("File", { version=1.2, src="../classes/class_file.cpp", output="../classes/class_file_def.c" }, [[
    large     Position  # The current read/write byte position in a file.
    int(FL)   Flags     # File flags and options.
    int       Static    # Set to TRUE if a file object should be static.
    oid       Target    # Specifies a surface ID to target for user feedback and dialog boxes.
    ptr(char) Buffer    # Points to the internal data buffer if the file content is held in memory.
  ]])

  methods("config", "Cfg", {
    { id=1,  name="ReadValue" },
    { id=2,  name="Set" },
    { id=3,  name="WriteValue" },
    { id=4,  name="DeleteKey" },
    { id=5,  name="DeleteGroup" },
    { id=6,  name="GetGroupFromIndex" },
    { id=7,  name="SortByKey" },
    { id=9,  name="MergeFile" },
    { id=10, name="Merge" }
  })

  class("Config", { src="../classes/class_config.cpp", output="../classes/class_config_def.c" }, [[
    str Path          # The location pointer
    str KeyFilter     # Enables key filtering, removing any unwanted keys on load.
    str GroupFilter   # Enables group filtering, removing any unwanted groups on load.
    int(CNF) Flags    # Not currently in use
  ]],
  nil,
  [[
   ConfigGroups *Groups;

   // For C++ only, these read variants avoid method calls for speed, but apply identical logic.

   inline ERROR read(CSTRING pGroup, CSTRING pKey, DOUBLE *pValue) {
      for (auto& [group, keys] : Groups[0]) {
         if ((pGroup) and (group.compare(pGroup))) continue;
         if (!pKey) {
            *pValue = strtod(keys.cbegin()->second.c_str(), NULL);
            return ERR_Okay;
         }
         else if (keys.contains(pKey)) {
            *pValue = strtod(keys[pKey].c_str(), NULL);
            return ERR_Okay;
         }
      }
      return ERR_Search;
   }

   inline ERROR read(CSTRING pGroup, CSTRING pKey, LONG *pValue) {
      for (auto& [group, keys] : Groups[0]) {
         if ((pGroup) and (group.compare(pGroup))) continue;
         if (!pKey) {
            *pValue = strtol(keys.cbegin()->second.c_str(), NULL, 0);
            return ERR_Okay;
         }
         else if (keys.contains(pKey)) {
            *pValue = strtol(keys[pKey].c_str(), NULL, 0);
            return ERR_Okay;
         }
      }
      return ERR_Search;
   }

   inline ERROR read(CSTRING pGroup, CSTRING pKey, std::string &pValue) {
      for (auto& [group, keys] : Groups[0]) {
         if ((pGroup) and (group.compare(pGroup))) continue;
         if (!pKey) {
            pValue = keys.cbegin()->second;
            return ERR_Okay;
         }
         else if (keys.contains(pKey)) {
            pValue = keys[pKey];
            return ERR_Okay;
         }
      }
      return ERR_Search;
   }

   inline ERROR write(CSTRING Group, CSTRING Key, CSTRING Value) {
      struct cfgWriteValue write = { Group, Key, Value };
      return Action(MT_CfgWriteValue, this, &write);
   }
   inline ERROR write(CSTRING Group, CSTRING Key, STRING Value) {
      struct cfgWriteValue write = { Group, Key, Value };
      return Action(MT_CfgWriteValue, this, &write);
   }
   inline ERROR write(CSTRING Group, CSTRING Key, std::string Value) {
      struct cfgWriteValue write = { Group, Key, Value.c_str() };
      return Action(MT_CfgWriteValue, this, &write);
   }
   template <class T> inline ERROR write(CSTRING Group, CSTRING Key, T Value) {
      auto str = std::to_string(Value);
      struct cfgWriteValue write = { Group, Key, str.c_str() };
      return Action(MT_CfgWriteValue, this, &write);
   }
  ]])

  c_insert([[
inline ERROR cfgRead(OBJECTPTR Self, CSTRING Group, CSTRING Key, DOUBLE *Value)
{
   ERROR error;
   struct cfgReadValue read = { .Group = Group, .Key = Key };
   if (!(error = Action(MT_CfgReadValue, Self, &read))) {
      *Value = strtod(read.Data, NULL);
      return ERR_Okay;
   }
   else { *Value = 0; return error; }
}

inline ERROR cfgRead(OBJECTPTR Self, CSTRING Group, CSTRING Key, LONG *Value)
{
   ERROR error;
   struct cfgReadValue read = { .Group = Group, .Key = Key };
   if (!(error = Action(MT_CfgReadValue, Self, &read))) {
      *Value = strtol(read.Data, NULL, 0);
      return ERR_Okay;
   }
   else { *Value = 0; return error; }
}
  ]])

  methods("Script", "Sc", {
    { id=1, name="Exec" },
    { id=2, name="DerefProcedure" },
    { id=3, name="Callback" },
    { id=4, name="GetProcedureID" }
  })

  class("Script", { src={ "../classes/class_script.cpp" }, output="../classes/class_script_def.c" }, [[
    oid Target           # The object that script objects must be initialised to, e.g. for obj.new()
    int(SCF) Flags       # Optional flags
    error Error          # If an error occurred, this field will indicate the error number
    int CurrentLine      # Current line being executed, or failed line if script execution terminated
    int LineOffset       # An optional offset to use when reporting line numbers
  ]],
  [[
   LARGE    ProcedureID;          // For callbacks
   KEYVALUE Vars; // Global parameters
   STRING   *Results;
   char     Language[4];          // 3-character language code, null-terminated
   const ScriptArg *ProcArgs;     // Procedure args - applies during Exec
   STRING   Path;                 // File location of the script
   STRING   String;
   STRING   WorkingPath;
   STRING   ErrorString;
   CSTRING  Procedure;
   STRING   CacheFile;
   LONG     ActivationCount;      // Incremented every time the script is activated.
   LONG     ResultsTotal;
   LONG     TotalArgs;            // Total number of ProcArgs
   char     LanguageDir[32];      // Directory to use for language files
   OBJECTID ScriptOwnerID;
  ]])

  methods("Task", "Task", {
    { id=1, name="Expunge" },
    { id=2, name="AddArgument" },
    { id=3, name="Quit" },
    { id=4, name="GetEnv" },
    { id=5, name="SetEnv" }
  })

  class("Task", { src="../classes/class_task.cpp", output="../classes/class_task_def.c" }, [[
    double TimeOut
    int(TSF) Flags
    int ReturnCode
    int ProcessID    # Native process ID of the activated task
  ]])

  methods("Thread", "Th", {
    { id=1, name="SetData" }
  })

  class("Thread", { src="../classes/class_thread.cpp", output="../classes/class_thread_def.c" }, [[
   ptr   Data         # User data pointer.
   int   DataSize     # Size of user data.
   int   StackSize    # Pre-set stack size
   error Error        # Error code returned by the thread on completion.
   int(THF) Flags     # Optional flags.
  ]])

  methods("Module", "Mod", {
    { id=1,  name="ResolveSymbol" },
  })

  class("Module", { src="../classes/class_module.cpp" }, [[
    cstruct(*Function) FunctionList # Array of functions
    ptr ModBase                     # Ptr to function jump table
    class(*RootModule) Root         # Shared details on the module
    struct(*ModHeader) Header       # For creating in-memory modules only.
    int(MOF) Flags                  # Optional flags
  ]],
  nil,
  [[
   static ERROR load(std::string Name, OBJECTPTR *Module = NULL, APTR Functions = NULL) {
      if (auto module = objModule::create::global(pf::FieldValue(FID_Name, Name.c_str()))) {
         #ifdef PARASOL_STATIC
            if (Module) *Module = module;
            if (Functions) ((APTR *)Functions)[0] = NULL;
            return ERR_Okay;
         #else
            APTR functionbase;
            if (!module->getPtr(FID_ModBase, &functionbase)) {
               if (Module) *Module = module;
               if (Functions) ((APTR *)Functions)[0] = functionbase;
               return ERR_Okay;
            }
            else return ERR_GetField;
         #endif
      }
      else return ERR_CreateObject;
   }
  ]])

  -- Note that the fields following SystemTime are identical to struct DateTime

  methods("Time", "Tm", {
    { id=1, name="SetTime" },
  })

  class("Time", { src="../classes/class_time.cpp" }, [[
    large SystemTime  # Total number of microseconds passed since the system base time
    int Year          # Year   (-ve for BC, +ve for AD)
    int Month         # Month  (1 - 12)
    int Day           # Day    (1 - 31)
    int Hour          # Hour   (0 - 23)
    int Minute        # Minute (0 - 59)
    int Second        # Second (0 - 59)
    int TimeZone      # 0 is GMT, range is +1300 or -1300
    int DayOfWeek     # Day of week (0 = Sunday ..)
    int MilliSecond   # Millisecond (0 - 999)
    int MicroSecond   # Microsecond  (0 - 999999)
  ]])

  methods("Compression", "Cmp", {
    { id=1, name="CompressBuffer" },
    { id=2, name="CompressFile" },
    { id=3, name="DecompressBuffer" },
    { id=4, name="DecompressFile" },
    { id=5, name="RemoveFile" },
    { id=6, name="CompressStream" },
    { id=7, name="DecompressStream" },
    { id=8, name="CompressStreamStart" },
    { id=9, name="CompressStreamEnd" },
    { id=10, name="DecompressStreamEnd" },
    { id=11, name="DecompressStreamStart" },
    { id=12, name="DecompressObject" },
    { id=13, name="Scan" },
    { id=14, name="Find" }
  })

  class("Compression", { src={ "../compression/class_compression.cpp", "../compression/compression_fields.cpp" }, output="../compression/class_compression_def.c" }, [[
    large TotalOutput       # Total number of bytes output (e.g. during compression of a stream)
    oid Output              # Reference to output object for user messages
    int CompressionLevel    # Compression level (percentage - 0% none, 100% high)
    int(CMF) Flags          # Optional flags
    int SegmentSize         # Splits the compressed file if it surpasses a set byte limit (e.g. 1.44MB)
    int(PERMIT) Permissions # Default permissions to use for decompressed files
    int MinOutputSize       # Minimum recommended output buffer size
    int WindowBits          # Window bits, currently applicable to the default (zlib) compression
  ]])

  class("CompressedStream", { src="../compression/class_compressed_stream.cpp", output="../compression/class_compressed_stream_def.c" }, [[
    large TotalOutput  # Count of the total bytes that have been output.
    obj Input          # The object that is the source of the compressed data.
    obj Output         # The object that is the destination for the compressed data.
    int(CF) Format     # CF_GZIP, CF_ZLIB, CF_DEFLATE
  ]])

  c_insert([[
#ifndef PRV_CORE

// Note that the length of the data is only needed when messaging between processes, so we can skip it for these
// direct-access data channel macros.

#define acDataContent(a,b)  acDataFeed((a),0,DATA::CONTENT,(b),0)
#define acDataXML(a,b)      acDataFeed((a),0,DATA::XML,(b),0)
#define acDataText(a,b)     acDataFeed((a),0,DATA::TEXT,(b),0)

inline ERROR acCustom(OBJECTID ObjectID, LONG Number, CSTRING String) {
   struct acCustom args = { Number, String };
   return ActionMsg(AC_Custom, ObjectID, &args);
}

inline ERROR acDataFeed(OBJECTID ObjectID, OBJECTPTR Sender, DATA Datatype, const APTR Data, LONG Size) {
   struct acDataFeed channel = { Sender, Datatype, Data, Size };
   return ActionMsg(AC_DataFeed, ObjectID, &channel);
}

inline ERROR acDragDrop(OBJECTID ObjectID, OBJECTPTR Source, LONG Item, CSTRING Datatype) {
   struct acDragDrop args = { Source, Item, Datatype };
   return ActionMsg(AC_DragDrop, ObjectID, &args);
}

inline ERROR acDrawArea(OBJECTID ObjectID, LONG X, LONG Y, LONG Width, LONG Height) {
   struct acDraw draw = { X, Y, Width, Height };
   return ActionMsg(AC_Draw, ObjectID, &draw);
}

inline ERROR acMove(OBJECTID ObjectID, DOUBLE X, DOUBLE Y, DOUBLE Z = 0) {
   struct acMove move = { X, Y, Z };
   return ActionMsg(AC_Move, ObjectID, &move);
}

inline ERROR acMoveToPoint(OBJECTID ObjectID, DOUBLE X, DOUBLE Y, DOUBLE Z = 0, MTF Flags = MTF::X|MTF::Y) {
   struct acMoveToPoint moveto = { X, Y, Z, Flags };
   return ActionMsg(AC_MoveToPoint, ObjectID, &moveto);
}

inline ERROR acRedimension(OBJECTID ObjectID, DOUBLE X, DOUBLE Y, DOUBLE Z, DOUBLE Width, DOUBLE Height, DOUBLE Depth) {
   struct acRedimension resize = { X, Y, Z, Width, Height, Depth };
   return ActionMsg(AC_Redimension, ObjectID, &resize);
}

inline ERROR acResize(OBJECTID ObjectID, DOUBLE Width, DOUBLE Height, DOUBLE Depth) {
   struct acResize resize = { Width, Height, Depth };
   return ActionMsg(AC_Resize, ObjectID, &resize);
}

inline ERROR acScrollToPoint(OBJECTID ObjectID, DOUBLE X, DOUBLE Y, DOUBLE Z = 0, STP Flags = STP::X|STP::Y) {
   struct acScrollToPoint scroll = { X, Y, Z, Flags };
   return ActionMsg(AC_ScrollToPoint, ObjectID, &scroll);
}

inline ERROR acScroll(OBJECTID ObjectID, DOUBLE X, DOUBLE Y, DOUBLE Z = 0) {
   struct acScroll scroll = { X, Y, Z };
   return ActionMsg(AC_Scroll, ObjectID, &scroll);
}

inline ERROR acSelectArea(OBJECTID ObjectID, DOUBLE X, DOUBLE Y, DOUBLE Width, DOUBLE Height) {
   struct acSelectArea area = { X, Y, Width, Height };
   return ActionMsg(AC_SelectArea, ObjectID, &area);
}

inline ERROR acActivate(OBJECTID ObjectID) { return ActionMsg(AC_Activate, ObjectID, NULL); }
inline ERROR acClear(OBJECTID ObjectID) { return ActionMsg(AC_Clear, ObjectID, NULL); }
inline ERROR acDisable(OBJECTID ObjectID) { return ActionMsg(AC_Disable, ObjectID, NULL); }
inline ERROR acDraw(OBJECTID ObjectID) { return ActionMsg(AC_Draw, ObjectID, NULL); }
inline ERROR acEnable(OBJECTID ObjectID) { return ActionMsg(AC_Enable, ObjectID, NULL); }
inline ERROR acFlush(OBJECTID ObjectID) { return ActionMsg(AC_Flush, ObjectID, NULL); }
inline ERROR acFocus(OBJECTID ObjectID) { return ActionMsg(AC_Focus, ObjectID, NULL); }
inline ERROR acHide(OBJECTID ObjectID) { return ActionMsg(AC_Hide, ObjectID, NULL); }
inline ERROR acLostFocus(OBJECTID ObjectID) { return ActionMsg(AC_LostFocus, ObjectID, NULL); }
inline ERROR acMoveToBack(OBJECTID ObjectID) { return ActionMsg(AC_MoveToBack, ObjectID, NULL); }
inline ERROR acMoveToFront(OBJECTID ObjectID) { return ActionMsg(AC_MoveToFront, ObjectID, NULL); }
inline ERROR acQuery(OBJECTID ObjectID) { return ActionMsg(AC_Query, ObjectID, NULL); }
inline ERROR acRefresh(OBJECTID ObjectID) { return ActionMsg(AC_Refresh, ObjectID, NULL); }
inline ERROR acSaveSettings(OBJECTID ObjectID) { return ActionMsg(AC_SaveSettings, ObjectID, NULL); }
inline ERROR acShow(OBJECTID ObjectID) { return ActionMsg(AC_Show, ObjectID, NULL); }

inline ERROR acWrite(OBJECTID ObjectID, CPTR Buffer, LONG Bytes) {
   struct acWrite write = { (BYTE *)Buffer, Bytes };
   return ActionMsg(AC_Write, ObjectID, &write);
}

inline FIELD ResolveField(CSTRING Field) {
   return StrHash(Field, FALSE);
}

#endif // PRV_CORE

#ifdef __unix__
#include <pthread.h>
#endif

#ifdef __system__

struct ActionMessage {
   OBJECTID ObjectID;        // The object that is to receive the action
   LONG  Time;
   ACTIONID ActionID;        // ID of the action or method to execute
   bool SendArgs;            //

   // Action arguments follow this structure in a buffer
};

#endif

// Event support

struct rkEvent {
   EVENTID EventID;
   // Data follows
};

#define EVID_DISPLAY_RESOLUTION_CHANGE  GetEventID(EVG::DISPLAY, "resolution", "change")

#define EVID_GUI_SURFACE_FOCUS          GetEventID(EVG::GUI, "surface", "focus")

#define EVID_FILESYSTEM_VOLUME_CREATED  GetEventID(EVG::FILESYSTEM, "volume", "created")
#define EVID_FILESYSTEM_VOLUME_DELETED  GetEventID(EVG::FILESYSTEM, "volume", "deleted")

#define EVID_SYSTEM_TASK_CREATED        GetEventID(EVG::SYSTEM, "task", "created")
#define EVID_SYSTEM_TASK_REMOVED        GetEventID(EVG::SYSTEM, "task", "removed")

#define EVID_POWER_STATE_SUSPENDING     GetEventID(EVG::POWER, "state", "suspending")
#define EVID_POWER_STATE_RESUMED        GetEventID(EVG::POWER, "state", "resumed")
#define EVID_POWER_DISPLAY_STANDBY      GetEventID(EVG::POWER, "display", "standby")
#define EVID_POWER_BATTERY_LOW          GetEventID(EVG::POWER, "battery", "low")
#define EVID_POWER_BATTERY_CRITICAL     GetEventID(EVG::POWER, "battery", "critical")
#define EVID_POWER_CPUTEMP_HIGH         GetEventID(EVG::POWER, "cputemp", "high")
#define EVID_POWER_CPUTEMP_CRITICAL     GetEventID(EVG::POWER, "cputemp", "critical")
#define EVID_POWER_SCREENSAVER_ON       GetEventID(EVG::POWER, "screensaver", "on")
#define EVID_POWER_SCREENSAVER_OFF      GetEventID(EVG::POWER, "screensaver", "off")

#define EVID_IO_KEYMAP_CHANGE           GetEventID(EVG::IO, "keymap", "change")
#define EVID_IO_KEYBOARD_KEYPRESS       GetEventID(EVG::IO, "keyboard", "keypress")

#define EVID_AUDIO_VOLUME_MASTER        GetEventID(EVG::AUDIO, "volume", "master")
#define EVID_AUDIO_VOLUME_LINEIN        GetEventID(EVG::AUDIO, "volume", "linein")
#define EVID_AUDIO_VOLUME_MIC           GetEventID(EVG::AUDIO, "volume", "mic")
#define EVID_AUDIO_VOLUME_MUTED         GetEventID(EVG::AUDIO, "volume", "muted") // All volumes have been muted
#define EVID_AUDIO_VOLUME_UNMUTED       GetEventID(EVG::AUDIO, "volume", "unmuted") // All volumes have been unmuted

// Event structures.

typedef struct { EVENTID EventID; char Name[1]; } evVolumeCreated;
typedef struct { EVENTID EventID; char Name[1]; } evVolumeDeleted;
typedef struct { EVENTID EventID; OBJECTID TaskID; } evTaskCreated;
typedef struct { EVENTID EventID; OBJECTID TaskID; OBJECTID ProcessID; } evTaskRemoved;
typedef struct { EVENTID EventID; } evPowerSuspending;
typedef struct { EVENTID EventID; } evPowerResumed;
typedef struct { EVENTID EventID; } evUserLogin;
typedef struct { EVENTID EventID; } evKeymapChange;
typedef struct { EVENTID EventID; } evScreensaverOn;
typedef struct { EVENTID EventID; } evScreensaverOff;
typedef struct { EVENTID EventID; DOUBLE Volume; LONG Muted; } evVolume;
typedef struct { EVENTID EventID; KQ Qualifiers; KEY Code; LONG Unicode; } evKey;
typedef struct { EVENTID EventID; WORD TotalWithFocus; WORD TotalLostFocus; OBJECTID FocusList[1]; } evFocus;

// Hotplug event structure.  The hotplug event is sent whenever a new hardware device is inserted by the user.

struct evHotplug {
   EVENTID EventID;
   WORD Type;            // HT ID
   WORD Action;          // HTA_INSERTED, HTA_REMOVED
   LONG VendorID;        // USB vendor ID
   union {
      LONG ProductID;    // USB product or device ID
      LONG DeviceID;
   };
   char  ID[20];         // Typically the PCI bus ID or USB bus ID, serial number or unique identifier
   char  Group[32];    // Group name in the config file
   char  Class[32];      // Class identifier (USB)
   union {
      char Product[40]; // Name of product or the hardware device
      char Device[40];
   };
   char Vendor[40];     // Name of vendor
};

// File Methods.

inline CSTRING flReadLine(OBJECTPTR Object) {
   struct flReadLine args;
   if (!Action(MT_FlReadLine, Object, &args)) return args.Result;
   else return NULL;
}

// Read endian values from files and objects.

template<class T> ERROR flReadLE(OBJECTPTR Object, T *Result)
{
   UBYTE data[sizeof(T)];
   struct acRead read = { .Buffer = data, .Length = sizeof(T) };
   if (!Action(AC_Read, Object, &read)) {
      if (read.Result IS sizeof(T)) {
         if constexpr (std::endian::native == std::endian::little) {
            *Result = ((T *)data)[0];
         }
         else {
            switch(sizeof(T)) {
               case 2:  *Result = (data[1]<<8) | data[0]; break;
               case 4:  *Result = (data[0]<<24)|(data[1]<<16)|(data[2]<<8)|(data[3]); break;
               case 8:  *Result = ((LARGE)data[0]<<56)|((LARGE)data[1]<<48)|((LARGE)data[2]<<40)|((LARGE)data[3]<<32)|(data[4]<<24)|(data[5]<<16)|(data[6]<<8)|(data[7]); break;
               default: *Result = ((T *)data)[0];
            }
         }
         return ERR_Okay;
      }
      else return ERR_Read;
   }
   else return ERR_Read;
}

template<class T> ERROR flReadBE(OBJECTPTR Object, T *Result)
{
   UBYTE data[sizeof(T)];
   struct acRead read = { .Buffer = data, .Length = sizeof(T) };
   if (!Action(AC_Read, Object, &read)) {
      if (read.Result IS sizeof(T)) {
         if constexpr (std::endian::native == std::endian::little) {
            switch(sizeof(T)) {
               case 2:  *Result = (data[1]<<8) | data[0]; break;
               case 4:  *Result = (data[0]<<24)|(data[1]<<16)|(data[2]<<8)|(data[3]); break;
               case 8:  *Result = ((LARGE)data[0]<<56)|((LARGE)data[1]<<48)|((LARGE)data[2]<<40)|((LARGE)data[3]<<32)|(data[4]<<24)|(data[5]<<16)|(data[6]<<8)|(data[7]); break;
               default: *Result = ((T *)data)[0];
            }
         }
         else {
            *Result = ((T *)data)[0];
         }
         return ERR_Okay;
      }
      else return ERR_Read;
   }
   else return ERR_Read;
}

// Function construction (refer types.h)

template <class T> FUNCTION::FUNCTION(T *pRoutine) {
   Type = CALL_STDC;
   StdC.Context = CurrentContext();
   StdC.Routine = (APTR)pRoutine;
};

template <class T> FUNCTION::FUNCTION(T *pRoutine, OBJECTPTR pContext, APTR pMeta) {
   Type = CALL_STDC;
   StdC.Context = pContext;
   StdC.Routine = (APTR)pRoutine;
   StdC.Meta    = pMeta;
};

template <class T> FUNCTION::FUNCTION(T *pRoutine, APTR pMeta) {
   Type = CALL_STDC;
   StdC.Context = CurrentContext();
   StdC.Routine = (APTR)pRoutine;
   StdC.Meta    = pMeta;
};

inline CSTRING BaseClass::className() { return Class->ClassName; }
  ]])

  if (glProgram == "idl-def") then
     loadFile("defs/errors.fdl")
  end
end)
