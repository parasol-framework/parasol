--$FLUID:Include

module({ name="Core", copyright="Paul Manias 1996-2025", timestamp=20241015 }, function()
  c_include("<stdarg.h>", "<inttypes.h>")
  cpp_include("<list>", "<map>", "<string>", "<vector>", "<unordered_map>", "<bit>", "<atomic>", "<array>", "<charconv>", "<sstream>", "<cmath>", "<type_traits>", "ankerl/unordered_dense.h")

  platform("Windows", function()
     enum("NETMSG", {}, "START", "END")
  end)

  privateNames({ "ScriptArg", "CoreBase", "RootModule" })

  priority([[
#if defined(_DEBUG)
 #ifndef _MSC_VER
  #include <signal.h>
 #endif
#endif

// For use in requires statements
template <typename T> concept pcPointer = std::is_pointer_v<T>;
template <typename T> concept pcObject = std::is_base_of_v<Object, T>;

#ifndef DEFINE_ENUM_FLAG_OPERATORS
template <size_t S> struct _ENUM_FLAG_INTEGER_FOR_SIZE;
template <> struct _ENUM_FLAG_INTEGER_FOR_SIZE<1> { typedef int8_t type; };
template <> struct _ENUM_FLAG_INTEGER_FOR_SIZE<2> { typedef int16_t type; };
template <> struct _ENUM_FLAG_INTEGER_FOR_SIZE<4> { typedef int type; };
template <> struct _ENUM_FLAG_INTEGER_FOR_SIZE<8> { typedef int64_t type; };
// used as an approximation of std::underlying_type<T>
template <class T> struct _ENUM_FLAG_SIZED_INTEGER { typedef typename _ENUM_FLAG_INTEGER_FOR_SIZE<sizeof(T)>::type type; };

#define DEFINE_ENUM_FLAG_OPERATORS(ENUMTYPE) \
constexpr ENUMTYPE operator | (ENUMTYPE a, ENUMTYPE b) noexcept { return ENUMTYPE(((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)a) | ((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)b)); } \
constexpr ENUMTYPE operator & (ENUMTYPE a, ENUMTYPE b) noexcept { return ENUMTYPE(((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)a) & ((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)b)); } \
constexpr ENUMTYPE operator ~ (ENUMTYPE a) noexcept { return ENUMTYPE(~((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)a)); } \
constexpr ENUMTYPE operator ^ (ENUMTYPE a, ENUMTYPE b) noexcept { return ENUMTYPE(((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)a) ^ ((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)b)); } \
constexpr ENUMTYPE &operator |= (ENUMTYPE &a, ENUMTYPE b) noexcept { return (ENUMTYPE &)(((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type &)a) |= ((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)b)); } \
constexpr ENUMTYPE &operator &= (ENUMTYPE &a, ENUMTYPE b) noexcept { return (ENUMTYPE &)(((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type &)a) &= ((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)b)); }
#endif

template<typename T>
constexpr bool defined(T flags, T test_flag) noexcept {
   static_assert(std::is_enum_v<T>, "Type must be an enum");
   using underlying = std::underlying_type_t<T>;
   return (static_cast<underlying>(flags) & static_cast<underlying>(test_flag)) != 0;
}

  ]])

  loadFile(glPath .. 'common.fdl')
  loadFile(glPath .. 'common-graphics.fdl')

  flags("SCF", { comment="Script flags" },
     "EXIT_ON_ERROR: The script will automatically terminate its execution process if an error is detected.",
     "LOG_ALL: Enables execution debugging.  More information will be printed to the console in this mode.")

  flags("STR", { bits=32 },
     "MATCH_CASE|CASE: Perform a case-sensitive match.",
     "MATCH_LEN: The strings must be of equal length to be matched.")

  flags("MSF", { comment="Message flags." },
     "UPDATE: If the `Type` parameter matches a message already inside the queue, the data for that message will be deleted, then the new message will be added to the end of the queue.",
     "NO_DUPLICATE: If the `Type` parameter matches a message already inside the queue, the new message will not be added and the function will immediately return with `ERR::Okay`.")

  flags("PMF", { comment="Flags for ProcessMessages" },
     "SYSTEM_NO_BREAK: Private.  For system calls that need to avoid early termination.")

  flags("RFD", { bits=32, comment="Flags for RegisterFD()" },
     "WRITE: Activate the callback if there is room to write to the FD's buffer.",
     "EXCEPT: Activate the callback if error conditions are pending.",
     "READ: Activate the callback if there is data available to read.",
     "REMOVE: Stop monitoring this file descriptor.",
     "STOP_RECURSE: Internal flag to prevent recursion.",
     "ALLOW_RECURSION: Internal flag to allow recursion.",
     "SOCKET: Identifies the file descriptor as a socket (Linux systems only).",
     "RECALL: Set if the subscriber needs to manually check for incoming/outgoing data.  This is supported as a one-off check, so the flag will be disabled automatically when the subscriber is called.",
     "ALWAYS_CALL: Always call this FD's handler prior to the process going to sleep.")

  flags("TSF", { comment="Task flags" },
    "WAIT: The parent process will halt when the task is running.  Control is returned to the parent process once the child process terminates.",
    "RESET_PATH: The new process will start in its own folder and not the folder of the parent process.",
    "PRIVILEGED: The child process will inherit the system privileges of its parent.",
    "SHELL: Enables shell mode.  On Unix systems, this means that a shell (usually BASH) will be used to launch the process.",
    "VERBOSE: Enable verbose logging.",
    "QUIET: Divert all process output to `/dev/null` or the nearest equivalent for non-Unix systems.",
    "DETACHED: Forces the new process to be detached from the parent.",
    "ATTACHED: Forces the new process to be attached to the parent (child will close when parent closes).",
    "PIPE: Enable the output pipe to the launched process so that it can read data.")

  hash("AHASH", "0x%s",
    "ACTIVATE",     "CLEAR",         "FREEWARNING",  "COPYDATA",
    "DATAFEED",     "DEACTIVATE",    "DRAW",         "FLUSH",       "FOCUS",        "FREE",
    "GETKEY",       "DRAGDROP",      "HIDE",         "INIT",        "LOCK",         "LOSTFOCUS",    "MOVE",
    "MOVETOBACK",   "MOVETOFRONT",   "NEWCHILD",     "NEWOWNER",    "NEWOBJECT",    "REDO",         "QUERY",
    "READ",         "RENAME",        "RESET",        "RESIZE",      "SAVEIMAGE",    "SAVETOOBJECT",
    "SEEK",         "SETKEY",        "SHOW",         "TIMER",       "UNLOCK",       "NEXT",         "PREV",
    "WRITE",        "SETFIELD",      "CLIPBOARD",    "REFRESH",     "DISABLE",      "ENABLE",       "REDIMENSION",
    "MOVETOPOINT",  "SORT",          "SAVESETTINGS", "SIGNAL",      "NEWPLACEMENT", "UNDO")

  flags("MHF", { comment="Internal options for requesting function tables from modules." },
    "STATIC: Keep the module code in memory",
    "STRUCTURE|DEFAULT: Use structures to group exported functions (Linux, C/C++ standard)")

  flags("MTF", { comment="MoveToPoint flags" }, "X", "Y", "Z", "ANIM", "RELATIVE")

  flags("VLF", { comment="VlogF flags" }, "BRANCH", "ERROR", "WARNING", "CRITICAL", "INFO", "API", "DETAIL", "TRACE", "FUNCTION")

  flags("MOF", { comment="Module flags" },
    "LINK_LIBRARY: Module refers to a symbolic link library (e.g. libz DLL or SO)",
    "STATIC: This flag prevents the loaded module code from being unloaded when the module object is freed.  This may be needed in cases where a module is designed with the presumption that it will remain in memory after being loaded by the developer.",
    "SYSTEM_PROBE: Indicates that the module is being probed.  Do not use outside of the core library.")

  flags("THF", { comment="Thread flags" },
    "AUTO_FREE: Automatically destroy the Thread object when the user routine has completed.")

  enum("FDT", { type="int", start=0, comment="Flags for the SetDate() file method." },
    "MODIFIED: The date on which the file was last modified.",
    "CREATED: The date on which the file was created.  On some host platforms this datestamp may be read-only.",
    "ACCESSED: The date on which the file was last accessed by a user or application.",
    "ARCHIVED: The date on which the file was most recently archived.  Not supported by most filesystems.")

  flags("VOLUME", { comment="Options for SetVolume()" },
    "REPLACE: If the volume already exists, all paths that are attached to it will be replaced with the new path setting.",
    "PRIORITY: If the volume already exists, the path will be inserted at the beginning of the path list so that it has priority over the others.",
    "HIDDEN: Hides the volume so that it will not show up when reading volumes from the root path `:`.",
    "SYSTEM: Identifies the volume as being created by the system (this flag is not for client use).")

  flags("FDL", { comment="Options for the File Delete() method." },
    "FEEDBACK: Automatically manage user feedback for deleting files by presenting dialog boxes.")

  flags("CMF", { comment="Compression flags" },
    "PASSWORD: A password has been set on the object.",
    "NEW: Force the creation of a new file archive.  Any existing file data at the target location will be destroyed.",
    "CREATE_FILE: Create a new archive only if the source file does not already exist.",
    "READ_ONLY: Forces read-only access, which is strongly recommended if an existing archive is being opened with no modifications intended.  If this flag is not set, initialisation can fail if the user does not have write access to the source file.",
    "NO_LINKS: Treat symbolic links as normal files/folders.",
    "APPLY_SECURITY: When decompressing, apply individual file permissions if they are available in the compression file.")

  flags("RSF", { comment="Flags for ResolvePath()"},
    "NO_FILE_CHECK: Do not test for the existence of the targeted file or folder during the resolution process.",
    "CHECK_VIRTUAL: If the volume referenced by Path is traced to another volume that is reserved by a virtual file system driver, `ERR::VirtualVolume` is returned. The volume is still resolved as far as possible and the resulting path will be returned by this function.",
    "APPROXIMATE: Ignores file extensions for the purpose of file name matching.",
    "NO_DEEP_SCAN: Do not perform more than one iteration when resolving the source file path.",
    "PATH: Use the `PATH` environment variable to resolve the file name in the `Path` parameter.",
    "CASE_SENSITIVE: For use on host systems that use case-insensitive file systems such as Windows; this option checks that the discovered file is a case-sensitive match to the Path.")

  -- NB: The MFF flags are duplicated in the FileSystem's Win32 code if you're going to change these

  flags("MFF", { comment="Flags for the File Watch() method." },
    "READ: File was accessed (read).",
    "MODIFY|WRITE: File modified via write or truncation.",
    "CREATE: New file/link created or renamed in folder.",
    "DELETE: Existing file deleted",
    "MOVED|RENAME: Existing file moved or renamed.",
    "ATTRIB: File permissions or datestamp changed.",
    "OPENED: Existing file was opened.",
    "CLOSED: An opened file has been closed.",
    "UNMOUNT: Host filesystem was unmounted.",
    "FOLDER: Folder identifier; if passed to @File.Watch() then indicates a preference for folder events only.",
    "FILE: File identifier; if passed to @File.Watch() then indicates a preference for file events only.",
    "SELF: Event applies to the monitored folder and not a contained item",
    "DEEP: Receive notifications from sub-folders (Windows only).")

  enum("STT", { type="int", start=1, comment="Types for StrDatatype()." },
    "NUMBER: The string represents a whole number.",
    "FLOAT: The string represents a floating point number.",
    "HEX: The string represents a hexadecimal number.",
    "STRING: The string represents plain-text.")

  flags("OPF", { },
    "OPTIONS",
    "MAX_DEPTH",
    "DETAIL",
    "SHOW_MEMORY",
    "SHOW_IO",
    "SHOW_ERRORS",
    "ARGS",
    "ERROR",
    "PRIVILEGED",
    "SYSTEM_PATH",
    "MODULE_PATH",
    "ROOT_PATH",
    "SCAN_MODULES")

  enum("TOI", { type="int" },
    "LOCAL_CACHE",        -- For Android.  Defines the path of the local cache for assignment to localcache:
    "LOCAL_STORAGE",      -- For Android.  Defines the path of the local storage for assignment to localstorage:
    "ANDROID_ENV",        -- For Android.
    "ANDROID_CLASS",      -- For Android.
    "ANDROID_ASSETMGR")   -- For Android.  Permanent pointer to the AssetManager

  flags("RDF", { comment="Flags for the OpenDir() function." },
    "SIZE: Retrieve the byte size of each file.",
    "DATE|TIME: Retrieve the date stamp of each file.",
    "PERMISSIONS: Get permission/security information.",
    "FILES|FILE: Read all files in the folder.",
    "FOLDERS|FOLDER: Read all folders/volumes in the folder.",
    "VOLUME: Feedback only - indicates a volume.",
    "LINK: Feedback only - file/folder is actually a link to another location.",
    "TAGS: Receive additional information for each file, such as comments, author and copyright.  The results are stored in the `Tags` field of each file.",
    "HIDDEN: Feedback only - file/folder is hidden.",
    "QUALIFY|QUALIFIED: Return fully qualified folder names (i.e. trailing slash or colon for each name).",
    "VIRTUAL: Path is to a virtual device.",
    "STREAM: Path is connected via a stream, e.g. network connection.",
    "READ_ONLY: Read-only (not permissions related and might indicate read-only media).",
    "ARCHIVE: Feedback only - archive bit is set.",
    "OPENDIR: Internal option.",
    { READ_ALL = "SIZE|DATE|PERMISSIONS|FILES|FOLDERS" })

  flags("FL", { comment="File flags" },
    "WRITE: Prepares a file for writing data, starting at byte position 0.  To start writing from the end of a file, use the Seek action after the file has been initialised.",
    "NEW: Required when creating a new file.  If a file with the same name exists, its contents will be destroyed. If however the existing file is locked, the initalisation process will fail.",
    "READ: Required if the file needs to be opened for read access.",
    "FOLDER|DIRECTORY: The file object represents a folder.",
    "APPROXIMATE: Allows fuzzy matching of the file path when opening an existing file.  This means that the file extension will be ignored; for instance attempting to open a file of 'screenshot.png' when only a file name of 'screenshot.jpg' exists in the same folder, the 'screenshot.jpg' file will be opened instead.  If multiple files could potentially match to the file name, the file object will select the first match that is encountered.",
    "LINK: Read-Only.  Indicates that the file is a symbolic link or shortcut to another file.",
    "BUFFER: Activates a special mode in which the file data is stored in a memory buffer rather than a disk file.  Set the Size field to a value of at least 1 so that the initial buffer size is configured.  In this mode many of the available file operations are meaningless except for the Read, Write and Seek actions.",
    "LOOP: In loop mode, the file object's position marker for read/write operations is allowed to extend past the actual file size.  Any read/write operation beyond the file size will loop back to the file at a corrected offset - for example, reading position 330 of a 100 byte file will start the operation from the 30th byte.  Loop mode does not affect any other area besides the read, write and seek operations.  The loop feature is typically used to create multimedia data streams with minimal effort.",
    "FILE: Explicitly declares the file object as an entity that stores content (as opposed to a device or folder for example).",
    "RESET_DATE: For internal use only",
    "DEVICE: The file is a system device (must set if opening a device for read/write operations)",
    "STREAM: File data is streamed (e.g. PIPE, FIFO, socket) and may be accessed locally or via a network.",
    "EXCLUDE_FILES: Exclude files when scanning this folder.",
    "EXCLUDE_FOLDERS: Exclude folders when scanning this folder.")

  enum("LOC", { type="int", start=1, comment="AnalysePath() values" },
    "DIRECTORY|FOLDER: The path refers to a folder.",
    "VOLUME: The path refers to a volume name.",
    "FILE: The path refers to a file.")

  flags("LDF", { comment="Flags for LoadFile()" },
    "CHECK_EXISTS: Limits the routine to checking the file cache for the existence of the file.  If found, the relevant cache entry is returned. The open count is not incremented by this action (it is therefore unnecessary to follow-up with a call to UnloadFile()).  If no up-to-date cache entry is available, `ERR::Search` is returned.")

  enum("FBK", { type="int", start=1, comment="Flags for file feedback." },
    "MOVE_FILE: A file is to be, or has been moved.",
    "COPY_FILE: A file is to be, or has been copied.",
    "DELETE_FILE: A file is to be, or has been deleted.")

  enum("FFR", { type="int", start=0, comment="Return codes available to the feedback routine" },
    "OKAY|CONTINUE: Continue processing uninterrupted.",
    "SKIP: Skip processing of this entity.",
    "ABORT: Abort the entire operation.")

  enum("VAS", { type="int", start=1, comment="For use by VirtualVolume()" },
    "DEREGISTER: Remove the virtual volume from the system.",
    "SCAN_DIR",
    "DELETE",
    "RENAME",
    "OPEN_DIR",
    "CLOSE_DIR",
    "TEST_PATH",
    "WATCH_PATH",
    "IGNORE_FILE",
    "GET_INFO",
    "GET_DEVICE_INFO",
    "IDENTIFY_FILE",
    "MAKE_DIR",
    "SAME_FILE",
    "CASE_SENSITIVE: Set to true if the volume's paths are case-sensitive.",
    "READ_LINK",
    "CREATE_LINK",
    "DRIVER_SIZE")

  enum("FDB", { type="int", start=1, comment="Feedback event indicators." },
    "DECOMPRESS_FILE",
    "COMPRESS_FILE",
    "REMOVE_FILE",
    "DECOMPRESS_OBJECT")

  enum("CF", { type="int", start=1, comment="Compression stream formats" },
    "GZIP: The 'gzip' format",
    "ZLIB: The 'zlib' format",
    "DEFLATE: The 'deflate' format")

  flags("FOF", { comment="Flags that can be passed to FindObject()" },
    "SMART_NAMES: Parse numeric object names as ID references and support use of the 'Owner' reserved keyword.")

  flags("NF", { comment="Flags that can be passed to NewObject().  If a flag needs to be stored with the object, it must be specified in the lower word." },
    "UNTRACKED: An object created with this flag will not be tracked back to the object that created it.",
    "INITIALISED: Read-only indicator if the object has been initialised.",
    "LOCAL: Classes can allocate local objects to stop them from being associated with the client.",
    "FREE_ON_UNLOCK: Read-only indicator for when the object is marked for deletion.",
    "FREE: Read-only indicator for when the object is being freed.",
    "TIMER_SUB: The object is subscribed to a timer interval.",
    "SUPPRESS_LOG: Private.  Turns off the initial log message.",
    "COLLECT: Marked for garbage collection.",
    "RECLASSED: The object switched from the base-class to a sub-class during initialisation.",
    "MESSAGE: Action has been called against the object through the message system (managed by ~Core.ProcessMessages()).",
    "SIGNALLED: The object has been signalled and is awaiting processing.",
    "PERMIT_TERMINATE: Private.  Permits termination when a lock is held on the object.",
    { UNIQUE = "0x40000000: Use to allocate an object that has a guaranteed unique name.  This will prevent code from shadowing any object that exists with the same name, which can be imperative when creating shared objects.  If it is discovered that an identically named object exists, ~Core.NewObject() will return `ERR::ObjectExists`.  This flag works in conjunction with the `Name` parameter.",
      NAME   = "0x80000000: Use the Name parameter to name the created object.  This flag is not required if using `UNIQUE`.",
      PRIVATE = 0
    }
  )

  const("MAX", { }, {
     FILENAME = 256, -- Maximum length for file names (not necessarily including path)
     NAME_LEN = 31   -- Refer to the 'Object' struct for more info on the NAME_LEN value
  })

  const("MSGID", { type="int", comment="Reserved message ID's that are handled internally." }, {
     QUIT             = 1000,   -- Note that IDs >= 100 may be handled by non-Core code (external modules and applications)
     COMMAND          = 101,
     BREAK            = 100,
     CORE_END         = 100,    -- End marker for Core generated messages
     ACTION           = 99,     -- Start from 99 descending (lower risk of accidental ID matches)
     FREE             = 98,
     DEBUG            = 97,
     EVENT            = 96,
     VALIDATE_PROCESS = 95,
     THREAD_CALLBACK  = 94,
     THREAD_ACTION    = 93,
     FLUID_THREAD_CALLBACK = 92,
     WAIT_FOR_OBJECTS = 91
  })

  enum("IDTYPE", { type="int", start=1, comment="Types for AllocateID()" },
    "MESSAGE: Message ID's are allocated for the purpose of sending uniquely identifiable messages between tasks.",
    "GLOBAL: Global ID's have no specific association with anything.",
    "FUNCTION: Function ID's are used to track `FUNCTION` types and are assigned to the function ID field."
  )

  enum("TSTATE", { type="char", comment="Indicates the state of a process." },
    "RUNNING: The process is currently executing code.",
    "PAUSED: The process is asleep.",
    "STOPPING: The process is in its termination phase.",
    "TERMINATED: The process has closed.")

  enum("RES", { type="int", start=1 },
    "FREE_SWAP: The total amount of free swap memory.",
    "CONSOLE_FD: Internal reference to the FD of the console.",
    "KEY_STATE: Maintains the state of key qualifiers such as caps-lock and the shift keys.",
    "USER_ID: Internal",
    "DISPLAY_DRIVER: Internal.  Passes the name of the preferred display driver to the display module.",
    "PRIVILEGED_USER: If this value is set to 1, the process will operate in privileged mode (typically this enables full administrator rights).  This feature will only work for Unix processes that are granted admin rights when launched.  Setting the Value to 0 reverts to the user's permission settings.  SetResource() will return an error code indicating the level of success.",
    "PRIVILEGED: This is set to `true` if the process has elevated privileges (such as superuser or administrative rights).",
    "CORE_IDL: Refers to the Core module's compressed IDL string.",
    "STATIC_BUILD: Returns true if the runtime is a statically linked build.",
    "LOG_LEVEL: The current level of log detail (larger numbers indicate more detail).",
    "TOTAL_SHARED_MEMORY: The total amount of shared memory in use (system wide).",
    "LOG_DEPTH: The current depth of log messages.",
    "JNI_ENV: Return the current JNI environment string.",
    "THREAD_ID: Return the ID of the current thread.",
    "OPEN_INFO: Pointer to the OpenInfo structure originally used to initialise the system.",
    "EXCEPTION_HANDLER: Internal",
    "NET_PROCESSING: Internal windows resource for Network module",
    "PROCESS_STATE: Life-cycle stage of the running process",
    "TOTAL_MEMORY: The total amount of installed memory.",
    "TOTAL_SWAP: The total amount of available swap space.",
    "CPU_SPEED: The average top-speed of all CPU cores in Mhz.",
    "FREE_MEMORY: The total amount of free memory.",
    "MEMORY_USAGE: The total amount of memory used by the current process, in bytes."
  )

  enum("RP", { type="int", start=1, comment="Path types for SetResourcePath()" },
    "MODULE_PATH: An alternative path leading to the system modules (normally `system:modules/`).  Introduced for platforms such as Android, where modules are stored in asset folders.",
    "SYSTEM_PATH: The path of the `system:` volume, which otherwise defaults to `[root]:system/`.",
    "ROOT_PATH: Overrides the root path, which defaults to the location at which Parasol is installed.")

  flags("CLF", { comment="Flags for the MetaClass." },
    "INHERIT_LOCAL: Inherit the functionality of local objects defined in the class spec.",
    "NO_OWNERSHIP: Objects created will not be tracked to the creating process, nor any parent object (~Core.SetOwner() will not work either).")

  flags("CNF", { comment="Flags for the Config class." },
    "STRIP_QUOTES: Removes quotes from key values that are quote-encapsulated.",
    "AUTO_SAVE: When the configuration object is freed, automatically save the configuration data back to the original file source.",
    "OPTIONAL_FILES: Files are optional (do not fail if a requested file does not exist).",
    "NEW: On initialisation, do not load any data from the referenced configuration file.")

-- Please note that when the user is using an international keyboard, the name of the key will not
-- actually match what the symbol represents for some key types.

  const("KEY", { type="int", comment="Raw key codes" }, {
    A = 1,
    B = 2,
    C = 3,
    D = 4,
    E = 5,
    F = 6,
    G = 7,
    H = 8,
    I = 9,
    J = 10,
    K = 11,
    L = 12,
    M = 13,
    N = 14,
    O = 15,
    P = 16,
    Q = 17,
    R = 18,
    S = 19,
    T = 20,
    U = 21,
    V = 22,
    W = 23,
    X = 24,
    Y = 25,
    Z = 26,
    ONE   = 27,
    TWO   = 28,
    THREE = 29,
    FOUR  = 30,
    FIVE  = 31,
    SIX   = 32,
    SEVEN = 33,
    EIGHT = 34,
    NINE  = 35,
    ZERO  = 36,
    REVERSE_QUOTE = 37,
    MINUS         = 38,
    EQUALS        = 39,
    L_SQUARE      = 40,
    R_SQUARE      = 41,
    SEMI_COLON    = 42,
    APOSTROPHE    = 43,
    COMMA         = 44,
    PERIOD        = 45,
    DOT           = 45, -- Synonym
    SLASH         = 46,
    BACK_SLASH    = 47,
    SPACE         = 48,
    -- Keypad keys
    NP_0        = 49,
    NP_1        = 50,
    NP_2        = 51,
    NP_3        = 52,
    NP_4        = 53,
    NP_5        = 54,
    NP_6        = 55,
    NP_7        = 56,
    NP_8        = 57,
    NP_9        = 58,
    NP_MULTIPLY = 59,
    NP_PLUS     = 60,
    NP_SEPARATOR = 61,
    NP_BAR      = 61, -- Synonym
    NP_MINUS    = 62,
    NP_DECIMAL  = 63,
    NP_DOT      = 63,   -- Synonym
    NP_DIVIDE   = 64,
    L_CONTROL   = 65,   -- Left Control
    R_CONTROL   = 66,   -- Right Control
    HELP        = 67,   -- Help
    L_SHIFT     = 68,   -- Left Shift
    R_SHIFT     = 69,   -- Right Shift
    CAPS_LOCK   = 70,   -- Caps Lock
    PRINT       = 71,   -- Print (not print-screen!)
    L_ALT       = 72,   -- Left Alt
    R_ALT       = 73,   -- Right Alt
    L_COMMAND   = 74,   -- Left Amiga/Win/Special
    R_COMMAND   = 75,   -- Right Amiga/Win/Special
    F1          = 76,   -- Function Key 1
    F2          = 77,   -- Function Key 2
    F3          = 78,   -- Function Key 3
    F4          = 79,   -- Function Key 4
    F5          = 80,   -- Function Key 5
    F6          = 81,   -- Function Key 6
    F7          = 82,   -- Function Key 7
    F8          = 83,   -- Function Key 8
    F9          = 84,   -- Function Key 9
    F10         = 85,   -- Function Key 10
    F11         = 86,   -- Function Key 11
    F12         = 87,   -- Function Key 12
    F13         = 88,   -- Function Key 13
    F14         = 89,   -- Function Key 14
    F15         = 90,   -- Function Key 15
    F16         = 91,   -- Function Key 16
    F17         = 92,   -- Function Key 17
    MACRO       = 93,
    NP_PLUS_MINUS = 94,  -- Plus/Minus on some numeric keypads
    LESS_GREATER  = 95,  -- Less/Greater key on foreign keyboards (no US equivalent?)
    UP          = 96,    -- Cursor Up
    DOWN        = 97,    -- Cursor Down
    RIGHT       = 98,    -- Cursor Right
    LEFT        = 99,    -- Cursor Left
    SCR_LOCK    = 100,   -- Scroll Lock
    PAUSE       = 101,   -- Pause
    WAKE        = 102,   -- Wake
    SLEEP       = 103,   -- Sleep
    POWER       = 104,   -- Power
    BACKSPACE   = 105,   -- Backspace
    TAB         = 106,   -- Tabulation
    ENTER       = 107,   -- Enter/Return
    ESCAPE      = 108,   -- Escape
    DELETE      = 109,   -- Delete
    CLEAR       = 110,   -- Clear
    HOME        = 111,   -- Home
    PAGE_UP     = 112,   -- Page Up
    PAGE_DOWN   = 113,   -- Page Down
    END         = 114,   -- End
    SELECT      = 115,   -- Select
    EXECUTE     = 116,   -- Execute
    INSERT      = 117,   -- Insert
    UNDO        = 118,   -- Undo
    REDO        = 119,   -- Redo
    MENU        = 120,   -- Menu / Shortcut / Application key
    FIND        = 121,   -- Find
    CANCEL      = 122,   -- Cancel
    BREAK       = 123,   -- Break
    NUM_LOCK    = 124,   -- Number lock
    PRT_SCR     = 125,   -- Print Screen
    NP_ENTER    = 126,   -- Numeric keypad enter
    SYSRQ       = 127,
    F18         = 128,
    F19         = 129,
    F20         = 130,
    WIN_CONTROL = 131,   -- Special MS internal control key, doesn't map to a real key
    -- A lot of the following are derived from Android
    VOLUME_UP   = 132,
    VOLUME_DOWN = 133,
    BACK        = 134, -- Not the same as backspace!
    CALL        = 135,
    END_CALL    = 136,
    CAMERA      = 137,
    AT          = 138,
    PLUS        = 139,
    LENS_FOCUS  = 140,
    STOP        = 141,
    NEXT        = 142,
    PREVIOUS    = 143,
    FORWARD     = 144,
    REWIND      = 145,
    MUTE        = 146,
    STAR        = 147, -- As seen on phone keypads
    POUND       = 148, -- As seen on phone keypads
    PLAY        = 149,
    -- End marker
    LIST_END    = 150
  })

  c_insert([[

typedef AC ACTIONID;

#ifndef __GNUC__
#define __attribute__(a)
#endif

typedef const std::vector<std::pair<std::string, uint32_t>> STRUCTS;
typedef std::map<std::string, std::string, std::less<>> KEYVALUE;

#ifndef STRINGIFY
#define STRINGIFY(x) #x
#define TOSTRING(x) STRINGIFY(x)
#endif

#define MOD_IDL nullptr

#ifdef PARASOL_STATIC
__export void CloseCore(void);
__export ERR OpenCore(struct OpenInfo *, struct CoreBase **);
#else
__export struct ModHeader ModHeader;
#endif

#ifdef MOD_NAME
#ifdef PARASOL_STATIC
#define PARASOL_MOD(init,close,open,expunge,IDL,Structures) static struct ModHeader ModHeader(init, close, open, expunge, IDL, Structures, TOSTRING(MOD_NAME), TOSTRING(MOD_NAMESPACE));
#else
#define PARASOL_MOD(init,close,open,expunge,IDL,Structures) struct ModHeader ModHeader(init, close, open, expunge, IDL, Structures, TOSTRING(MOD_NAME), TOSTRING(MOD_NAMESPACE));
#endif
#define MOD_PATH ("modules:" TOSTRING(MOD_NAME))
#else
#define MOD_NAME nullptr
#endif

namespace pf {

template <class T> T roundup(T Num, int Alignment) {
   return (Num + Alignment) - (Num % Alignment); // Round up to Alignment value, e.g. (14,8) = 16
}

#ifdef PRINTF64I
  #define PF64 "I64d"
#elif PRINTF64_PRID
  #define PF64 PRId64
#else
  #define PF64 "lld"
#endif

// Use DEBUG_BREAK in critical areas where you would want to break in gdb.  This feature will only be compiled
// in to debug builds.

#ifdef _DEBUG
 #ifdef _MSC_VER
  #define DEBUG_BREAK __debugbreak();
 #elif __linux__
  #define DEBUG_BREAK raise(SIGTRAP);
 #else
  #define DEBUG_BREAK
 #endif
#else
 #define DEBUG_BREAK
#endif

// Fast float-2-int conversion, with rounding to the nearest integer (F2I) and truncation (F2T)

#if defined(__GNUC__) && defined(__x86__)

constexpr int F2I(double val) noexcept {
   if (std::is_constant_evaluated()) {
      return (int)std::round(val);
   }
   // This will round if the CPU is kept in its default rounding mode
   int ret;
   asm ("fistpl %0" : "=m" (ret) : "t" (val) : "st");
   return(ret);
}

#else

inline int F2I(double val) {
   double t = val + 6755399441055744.0;
   return *((int *)(&t));
}

#endif

constexpr int F2T(double val) noexcept // For numbers no larger than 16 bit, standard (int) is faster than F2T().
{
   if ((val > 32767.0) or (val < -32767.0)) return((int)val);
   else {
      val = val + (68719476736.0 * 1.5);
      if constexpr (std::endian::native == std::endian::little) {
         return ((int *)(APTR)&val)[0]>>16;
      }
      else return ((int *)&val)[1]>>16;
   }
}

} // namespace

// Structures to pass to OpenCore()

struct OpenTag {
   TOI Tag;
   union {
      int Int;
      int64_t Int64;
      APTR Pointer;
      CSTRING String;
   } Value;
};

struct OpenInfo {
   CSTRING Name;            // OPF::NAME
   CSTRING *Args;           // OPF::ARGS
   CSTRING SystemPath;      // OPF::SYSTEM_PATH
   CSTRING ModulePath;      // OPF::MODULE_PATH
   CSTRING RootPath;        // OPF::ROOT_PATH
   OpenTag *Options;        // OPF::OPTIONS Typecast to va_list (defined in stdarg.h)
   OPF     Flags;           // OPF::flags need to be set for fields that have been defined in this structure.
   int     MaxDepth;        // OPF::MAX_DEPTH
   int     Detail;          // OPF::DETAIL
   int     ArgCount;        // OPF::ARGS
   ERR     Error;           // OPF::ERROR
};

// Flags for defining fields, methods, actions and functions.  CLASSDEF's can only be used in field definitions for
// classes.  FUNCDEF's can only be used in argument definitions for methods, actions and functions.

#ifdef _LP64
#define FD_PTR64 FD_POINTER
#else
#define FD_PTR64 0
#endif

// Field flags for classes.  These are intended to simplify field definitions, e.g. using FDF_BYTEARRAY combines
// FD_ARRAY with FD_BYTE.  DO NOT use these for function definitions, they are not intended to be compatible.

// Sizes/Types

#define FT_POINTER  FD_POINTER
#define FT_FLOAT    FD_FLOAT
#define FT_INT      FD_INT
#define FT_DOUBLE   FD_DOUBLE
#define FT_INT64    FD_INT64
#define FT_STRING   (FD_POINTER|FD_STRING)
#define FT_UNLISTED FD_UNLISTED
#define FT_UNIT     FD_UNIT

// Class field definitions.  See core.h for all FD definitions.

#define FDF_BYTE       FD_BYTE
#define FDF_WORD       FD_WORD     // Field is word sized (16-bit)
#define FDF_INT        FD_INT      // Field is int sized (32-bit)
#define FDF_DOUBLE     FD_DOUBLE   // Field is double floating point sized (64-bit)
#define FDF_INT64      FD_INT64    // Field is large sized (64-bit)
#define FDF_POINTER    FD_POINTER  // Field is an address pointer (typically 32-bit)
#define FDF_ARRAY      FD_ARRAY    // Field is a pointer to an array
#define FDF_CPP        FD_CPP      // Field is a C++ type variant
#define FDF_PTR        FD_POINTER
#define FDF_UNIT       FD_UNIT
#define FDF_SYNONYM    FD_SYNONYM

#define FDF_UNSIGNED    FD_UNSIGNED
#define FDF_FUNCTION    FD_FUNCTION           // sizeof(FUNCTION) - use FDF_FUNCTIONPTR for sizeof(APTR)
#define FDF_FUNCTIONPTR (FD_FUNCTION|FD_POINTER)
#define FDF_STRUCT      FD_STRUCT
#define FDF_RESOURCE    FD_RESOURCE
#define FDF_OBJECT      (FD_POINTER|FD_OBJECT)   // Field refers to another object
#define FDF_OBJECTID    (FD_INT|FD_OBJECT)      // Field refers to another object by ID
#define FDF_LOCAL       (FD_POINTER|FD_LOCAL)    // Field refers to a local object
#define FDF_STRING      (FD_POINTER|FD_STRING)   // Field points to a string.  NB: Ideally want to remove the FD_POINTER as it should be redundant
#define FDF_STR         FDF_STRING
#define FDF_SCALED      FD_SCALED
#define FDF_FLAGS       FD_FLAGS                // Field contains flags
#define FDF_ALLOC       FD_ALLOC                // Field is a dynamic allocation - either a memory block or object
#define FDF_LOOKUP      FD_LOOKUP               // Lookup names for values in this field
#define FDF_READ        FD_READ                 // Field is readable
#define FDF_WRITE       FD_WRITE                // Field is writeable
#define FDF_INIT        FD_INIT                 // Field can only be written prior to Init()
#define FDF_SYSTEM      FD_SYSTEM
#define FDF_ERROR       (FD_INT|FD_ERROR)
#define FDF_RGB         (FD_RGB|FD_BYTE|FD_ARRAY)
#define FDF_R           FD_READ
#define FDF_W           FD_WRITE
#define FDF_RW          (FD_READ|FD_WRITE)
#define FDF_RI          (FD_READ|FD_INIT)
#define FDF_I           FD_INIT
#define FDF_VIRTUAL     FD_VIRTUAL
#define FDF_INTFLAGS    (FDF_INT|FDF_FLAGS)
#define FDF_FIELDTYPES  (FD_INT|FD_DOUBLE|FD_INT64|FD_POINTER|FD_UNIT|FD_BYTE|FD_ARRAY|FD_FUNCTION)

// These constants have to match the FD* constants << 32

#define TDOUBLE   0x8000000000000000LL
#define TINT      0x4000000000000000LL
#define TUNIT     0x2000000000000000LL
#define TFLOAT    0x1000000000000000LL // NB: Floats are upscaled to doubles when passed as v-args.
#define TPTR      0x0800000000000000LL
#define TINT64    0x0400000000000000LL
#define TFUNCTION 0x0200000000000000LL
#define TSTR      0x0080000000000000LL
#define TARRAY    0x0000100000000000LL
#define TSCALE    0x0020000000000000LL
#define TAGEND    0LL
#define TAGDIVERT -1LL
#define TSTRING   TSTR

#define nextutf8(str) if (*(str)) for (++(str); (*(str) & 0xc0) IS 0x80; (str)++);

//********************************************************************************************************************
// FieldValue is used to simplify the initialisation of new objects.

namespace pf {

struct FieldValue {
   uint32_t FieldID;
   int Type;
   union {
      CSTRING String;
      APTR    Pointer;
      CPTR    CPointer;
      double  Double;
      SCALE   Percent;
      int64_t Int64;
      int     Int;
   };

   //std::string not included as not compatible with constexpr
   constexpr FieldValue(uint32_t pFID, CSTRING pValue)  : FieldID(pFID), Type(FD_STRING), String(pValue) { };
   constexpr FieldValue(uint32_t pFID, int pValue)      : FieldID(pFID), Type(FD_INT), Int(pValue) { };
   constexpr FieldValue(uint32_t pFID, int64_t pValue)  : FieldID(pFID), Type(FD_INT64), Int64(pValue) { };
   constexpr FieldValue(uint32_t pFID, size_t pValue)   : FieldID(pFID), Type(FD_INT64), Int64(pValue) { };
   constexpr FieldValue(uint32_t pFID, double pValue)   : FieldID(pFID), Type(FD_DOUBLE), Double(pValue) { };
   constexpr FieldValue(uint32_t pFID, SCALE pValue)    : FieldID(pFID), Type(FD_DOUBLE|FD_SCALED), Percent(pValue) { };
   constexpr FieldValue(uint32_t pFID, const FUNCTION &pValue) : FieldID(pFID), Type(FDF_FUNCTIONPTR), CPointer(&pValue) { };
   constexpr FieldValue(uint32_t pFID, const FUNCTION *pValue) : FieldID(pFID), Type(FDF_FUNCTIONPTR), CPointer(pValue) { };
   constexpr FieldValue(uint32_t pFID, APTR pValue)     : FieldID(pFID), Type(FD_POINTER), Pointer(pValue) { };
   constexpr FieldValue(uint32_t pFID, CPTR pValue)     : FieldID(pFID), Type(FD_POINTER), CPointer(pValue) { };
   constexpr FieldValue(uint32_t pFID, CPTR pValue, int pCustom) : FieldID(pFID), Type(pCustom), CPointer(pValue) { };
};


class FloatRect {
   public:
   double X, Y, Width, Height;
   constexpr FloatRect() noexcept = default;
   constexpr FloatRect(double Value) noexcept : X(Value), Y(Value), Width(Value), Height(Value) { }
   constexpr FloatRect(double pX, double pY, double pWidth, double pHeight) noexcept : X(pX), Y(pY), Width(pWidth), Height(pHeight) { }
   constexpr double left() const noexcept { return X; }
   constexpr double top() const noexcept { return Y; }
   constexpr double right() const noexcept { return X + Width; }
   constexpr double bottom() const noexcept { return Y + Height; }
};

}

#include <string.h> // memset()
#include <stdlib.h> // strtol(), strtod()

namespace dmf { // Helper functions for DMF flags
inline bool has(DMF Value, DMF Flags) { return (Value & Flags) != DMF::NIL; }

inline bool hasX(DMF Value) { return (Value & DMF::FIXED_X) != DMF::NIL; }
inline bool hasY(DMF Value) { return (Value & DMF::FIXED_Y) != DMF::NIL; }
inline bool hasWidth(DMF Value) { return (Value & DMF::FIXED_WIDTH) != DMF::NIL; }
inline bool hasHeight(DMF Value) { return (Value & DMF::FIXED_HEIGHT) != DMF::NIL; }
inline bool hasXOffset(DMF Value) { return (Value & DMF::FIXED_X_OFFSET) != DMF::NIL; }
inline bool hasYOffset(DMF Value) { return (Value & DMF::FIXED_Y_OFFSET) != DMF::NIL; }
inline bool hasRadiusX(DMF Value) { return (Value & DMF::FIXED_RADIUS_X) != DMF::NIL; }
inline bool hasRadiusY(DMF Value) { return (Value & DMF::FIXED_RADIUS_Y) != DMF::NIL; }
inline bool hasScaledX(DMF Value) { return (Value & DMF::SCALED_X) != DMF::NIL; }
inline bool hasScaledY(DMF Value) { return (Value & DMF::SCALED_Y) != DMF::NIL; }
inline bool hasScaledWidth(DMF Value) { return (Value & DMF::SCALED_WIDTH) != DMF::NIL; }
inline bool hasScaledHeight(DMF Value) { return (Value & DMF::SCALED_HEIGHT) != DMF::NIL; }
inline bool hasScaledXOffset(DMF Value) { return (Value & DMF::SCALED_X_OFFSET) != DMF::NIL; }
inline bool hasScaledYOffset(DMF Value) { return (Value & DMF::SCALED_Y_OFFSET) != DMF::NIL; }
inline bool hasScaledCenterX(DMF Value) { return (Value & DMF::SCALED_CENTER_X) != DMF::NIL; }
inline bool hasScaledCenterY(DMF Value) { return (Value & DMF::SCALED_CENTER_Y) != DMF::NIL; }
inline bool hasScaledRadiusX(DMF Value) { return (Value & DMF::SCALED_RADIUS_X) != DMF::NIL; }
inline bool hasScaledRadiusY(DMF Value) { return (Value & DMF::SCALED_RADIUS_Y) != DMF::NIL; }

inline bool hasAnyHorizontalPosition(DMF Value) { return (Value & (DMF::FIXED_X|DMF::SCALED_X|DMF::FIXED_X_OFFSET|DMF::SCALED_X_OFFSET)) != DMF::NIL; }
inline bool hasAnyVerticalPosition(DMF Value) { return (Value & (DMF::FIXED_Y|DMF::SCALED_Y|DMF::FIXED_Y_OFFSET|DMF::SCALED_Y_OFFSET)) != DMF::NIL; }
inline bool hasAnyScaledRadius(DMF Value) { return (Value & (DMF::SCALED_RADIUS_X|DMF::SCALED_RADIUS_Y)) != DMF::NIL; }
inline bool hasAnyX(DMF Value) { return (Value & (DMF::SCALED_X|DMF::FIXED_X)) != DMF::NIL; }
inline bool hasAnyY(DMF Value) { return (Value & (DMF::SCALED_Y|DMF::FIXED_Y)) != DMF::NIL; }
inline bool hasAnyWidth(DMF Value) { return (Value & (DMF::SCALED_WIDTH|DMF::FIXED_WIDTH)) != DMF::NIL; }
inline bool hasAnyHeight(DMF Value) { return (Value & (DMF::SCALED_HEIGHT|DMF::FIXED_HEIGHT)) != DMF::NIL; }
inline bool hasAnyXOffset(DMF Value) { return (Value & (DMF::SCALED_X_OFFSET|DMF::FIXED_X_OFFSET)) != DMF::NIL; }
inline bool hasAnyYOffset(DMF Value) { return (Value & (DMF::SCALED_Y_OFFSET|DMF::FIXED_Y_OFFSET)) != DMF::NIL; }
}

]])

  struct("ObjectSignal", { comment="Required in calls to WaitForObjects()." }, [[
     obj Object # Reference to an object to monitor.
  ]])

  struct("ResourceManager", { comment="This structure must be placed at the start of any memory block allocated with the MEM::MANAGED flag.", restrict="c" }, [[
     cstr Name             # The name of the resource.
     fptr(error ptr) Free  # A function that will remove the resource's content when terminated.
  ]])

  struct("FunctionField", { comment="Used by ActionTable and Function structures to declare lists of parameters." }, [[
    cstr Name   # Name of the field
    uint Type   # Type of the field
  ]])

  struct("Function", { comment="Function list array structure" }, [[
    ptr Address     # Pointer to the function entry point
    cstr Name       # Name of the function
    cstruct(*FunctionField) Args  # A list of parameters accepted by the function
  ]])

  struct("ModHeader", { comment="Module file header", restrict="c" }, [[
    int(MHF) Flags                 # Special flags, type of function table wanted from the Core
    cstr Definitions               # Module definition string, usable by run-time languages such as Fluid
    fptr(error obj struct(*CoreBase)) Init # A one-off initialisation routine for when the module is first opened.
    fptr(void obj) Close           # A function that will be called each time the module is closed.
    fptr(error obj) Open           # A function that will be called each time the module is opened.
    fptr(error) Expunge            # Reference to an expunge function to terminate the module.
    cstr Name                      # Name of the module
    cstr Namespace                 # A reserved system-wide namespace for function names.
  ]],
  [[
   STRUCTS *StructDefs;
   class RootModule *Root;
   ModHeader(ERR (*pInit)(OBJECTPTR, struct CoreBase *),
      void  (*pClose)(OBJECTPTR),
      ERR (*pOpen)(OBJECTPTR),
      ERR (*pExpunge)(void),
      CSTRING pDef,
      STRUCTS *pStructs,
      CSTRING pName,
      CSTRING pNamespace) {
      Flags         = MHF::DEFAULT;
      Definitions   = pDef;
      StructDefs    = pStructs;
      Init          = pInit;
      Close         = pClose;
      Open          = pOpen;
      Expunge       = pExpunge;
      Name          = pName;
      Namespace     = pNamespace;
      Root          = nullptr;
   }
  ]])

  struct("FieldArray", { comment="Used to construct class blueprints for the MetaClass." }, [[
    cstr   Name      # The name of the field, e.g. `Width`
    ptr    GetField  # `void GetField(*Object, APTR Result);`
    ptr    SetField  # `ERR SetField(*Object, APTR Value);`
    maxint Arg       # Can be a pointer or an integer value
    uint   Flags     # Special flags that describe the field
  ]],
  [[
  template <class G = APTR, class S = APTR, class T = MAXINT> FieldArray(CSTRING pName, uint32_t pFlags, G pGetField = nullptr, S pSetField = nullptr, T pArg = 0) :
     Name(pName), GetField((APTR)pGetField), SetField((APTR)pSetField), Arg((MAXINT)pArg), Flags(pFlags)
     { }
  ]])

  struct("FieldDef", { comment="Used to define constants for field references." }, [[
    cstr Name  # The name of the constant.
    int Value  # The value of the constant.
  ]],
  [[
   template <class T> FieldDef(CSTRING pName, T pValue) : Name(pName), Value(int(pValue)) { }
  ]])

  struct("SystemState", { comment="Returned by the GetSystemState() function." }, [[
    cstr Platform      # String-based field indicating the user's platform.  Currently returns `Native`, `Windows`, `OSX` or `Linux`.
    hhandle ConsoleFD  # Internal
    int  Stage         # The current operating stage.  `-1` = Initialising, `0` indicates normal operating status; `1` means that the program is shutting down; `2` indicates a program restart; `3` is for mode switches.
  ]])

  struct("Unit", { }, [[
    double Value  # The unit value.
    uint   Type   # Additional type information
  ]],
  [[
   constexpr Unit(double pValue, int pType = FD_DOUBLE) : Value(pValue), Type(pType) { }
   constexpr Unit() : Value(0), Type(0) { }
   explicit Unit(std::string_view String) { read(String); }
   constexpr operator double() const { return Value; }
   constexpr void set(const double pValue) { Value = pValue; }
   bool scaled() { return (Type & FD_SCALED) ? true : false; }
   inline void read(std::string_view String) {
      const auto start = String.find_first_not_of(" \n\r\t");
      if (start != std::string::npos) String.remove_prefix(start);
      if (String.starts_with('+')) String.remove_prefix(1);
      auto [ end, error ] = std::from_chars(String.data(), String.data() + String.size(), Value);
      if (error != std::errc()) { Value = 0; return; }

      String = String.substr(end - String.data());
      if (String.starts_with("%")) { Value *= 0.01; Type = FD_DOUBLE|FD_SCALED; }
      else Type = FD_DOUBLE;
   }
   ]])

  -- Structures for defining method and action invocations.

  struct("ActionArray", { }, [[
    ptr Routine     # Pointer to the function entry point
    int(AC) ActionCode  # Action identifier
  ]],
  [[
  template <class T> ActionArray(AC pID, T pRoutine) : Routine((APTR)pRoutine), ActionCode(pID) { }
  ]])

  struct("MethodEntry", { restrict="c" }, [[
    int(AC) MethodID  # Unique method identifier
    ptr  Routine      # The method entry point, defined as `ERR (*Routine)(OBJECTPTR, APTR);`
    cstr Name         # Name of the method
    cstruct(*FunctionField) Args  # List of parameters accepted by the method
    int  Size         # Total byte-size of all accepted parameters when they are assembled as a C structure.
  ]],
  [[
   MethodEntry() : MethodID(AC::NIL), Routine(nullptr), Name(nullptr) { }
   MethodEntry(AC pID, APTR pRoutine, CSTRING pName, const struct FunctionField *pArgs, int pSize) :
      MethodID(pID), Routine(pRoutine), Name(pName), Args(pArgs), Size(pSize) { }
  ]])

  struct("ActionTable", { comment="Structure for ActionList" }, [[
    uint Hash   # Hash of the action name.
    int  Size   # Byte-size of the structure for this action.
    cstr Name   # Name of the action.
    cstruct(*FunctionField) Args  # List of fields that are passed to this action.
  ]])

  struct("ChildEntry", { comment="Structure for ListChildren() function" }, [[
    oid ObjectID  # Object ID
    cid ClassID   # The class ID of the referenced object.
  ]])

  struct("Message", { comment="Message header." }, [[
     large Time  # A timestamp acquired from ~Core.PreciseTime() when the message was first passed to ~Core.SendMessage().
     int UID     # A unique identifier automatically created by ~Core.SendMessage().
     int(MSGID) Type # A message type identifier as defined by the client.
     int Size    # The byte-size of the message data, or zero if no data is provided.
  ]])

  struct("MemInfo", { type="meminfo" }, [[
    ptr  Start         # The starting address of the memory block (does not apply to shared blocks).
    oid  ObjectID      # The object that owns the memory block.
    uint Size          # The size of the memory block.
    int(MEM) Flags     # The type of memory.
    mem   MemoryID     # The unique ID for this block.
    short AccessCount  # Total number of active locks on this block.
  ]])

  struct("MsgHandler", { restrict="c" }, [[
    ptr(struct(MsgHandler)) Prev  # Previous message handler in the chain.
    ptr(struct(MsgHandler)) Next  # Next message handler in the chain.
    func Function                 # Call this function to handle the message.
    int(MSGID) MsgType            # Type of message being filtered.
  ]])

  struct("CacheFile", { restrict="c", comment="Internal structure for managing files cached by LoadFile()." }, [[
    large TimeStamp   # The file's last-modified timestamp.
    large Size        # Byte size of the cached data.
    large LastUse     # The last time that this file was requested.
    cstr Path         # Pointer to the resolved file path.
    ptr Data          # Pointer to the cached data.
  ]])

  struct("CompressionFeedback", { }, [[
    int(FDB) FeedbackID     # Set to one of the FDB event indicators
    int   Index             # Index of the current file
    cstr  Path              # Name of the current file/path in the archive
    cstr  Dest              # Destination file/path during decompression
    large Progress          # Progress indicator (byte position for the file being de/compressed).
    large OriginalSize      # Original size of the file
    large CompressedSize    # Compressed size of the file
    short Year              # Year of the original file's datestamp.
    short Month             # Month of the original file's datestamp.
    short Day               # Day of the original file's datestamp.
    short Hour              # Hour of the original file's datestamp.
    short Minute            # Minute of the original file's datestamp.
    short Second            # Second of the original file's datestamp.
  ]],
  [[
   CompressionFeedback() : FeedbackID(FDB::NIL), Index(0), Path(nullptr), Dest(nullptr),
      Progress(0), OriginalSize(0), CompressedSize(0),
      Year(0), Month(0), Day(0), Hour(0), Minute(0), Second(0) { }

   CompressionFeedback(FDB pFeedback, int pIndex, CSTRING pPath, CSTRING pDest) :
      FeedbackID(pFeedback), Index(pIndex), Path(pPath), Dest(pDest),
      Progress(0), OriginalSize(0), CompressedSize(0),
      Year(0), Month(0), Day(0), Hour(0), Minute(0), Second(0) { }
  ]])

  struct("CompressedItem", { }, [[
    large OriginalSize            # Original size of the file
    large CompressedSize          # Compressed size of the file
    struct(*CompressedItem) Next  # Used only if this is a linked-list.
    cstr Path                     # Path to the file (includes folder prefixes).  Archived folders will include the trailing slash.
    int(PERMIT) Permissions       # Original permissions - see `PERMIT` flags.
    int  UserID                   # Original user ID
    int  GroupID                  # Original group ID
    int  OthersID                 # Original others ID
    int(FL) Flags                 # `FL` flags
    struct(DateTime) Created      # Date and time of the file's creation.
    struct(DateTime) Modified     # Date and time last modified.
  ]],
  [[
    ankerl::unordered_dense::map<std::string, std::string> *Tags;
  ]])

  struct("FileInfo", { comment="Metadata for describing a file." }, [[
    large Size                 # The size of the file's content.
    large TimeStamp            # 64-bit time stamp - usable only for comparison (e.g. sorting).
    struct(*FileInfo) Next     # Next structure in the list, or `NULL`.
    str Name                   # The name of the file.
    int(RDF) Flags             # Additional flags to describe the file.
    int(PERMIT) Permissions    # Standard permission flags.
    int UserID                 # User  ID (Unix systems only).
    int GroupID                # Group ID (Unix systems only).
    struct(DateTime) Created   # The date/time of the file's creation.
    struct(DateTime) Modified  # The date/time of the last file modification.
  ]],
  [[
    ankerl::unordered_dense::map<std::string, std::string> *Tags;
  ]]) -- NB: Private fields can follow this structure.

  struct("DirInfo", { comment="Used by OpenDir() only" }, [[
    struct(*FileInfo) Info # Pointer to a !FileInfo structure
  ]],
  [[
   #ifdef PRV_FILE
   APTR   Driver;
   APTR   prvHandle;        // Directory handle.  If virtual, may store a private data address
   STRING prvPath;          // Original folder location string
   STRING prvResolvedPath;  // Resolved folder location
   RDF    prvFlags;         // OpenFolder() RDF flags
   int    prvTotal;         // Total number of items in the folder
   uint32_t prvVirtualID;   // Unique ID (name hash) for a virtual device
   union {
      int prvIndex;         // Current index within the folder when scanning
      APTR prvIndexPtr;
   };
   int16_t   prvResolveLen;    // Byte length of ResolvedPath
   #endif
  ]])

  -- NB: Duplicated to windows.c
  struct("FileFeedback", { }, [[
    large Size          # Size of the file
    large Position      # Current seek position within the file if moving or copying
    str Path            # Path to the file
    str Dest            # Destination file/path if moving or copying
    int(FBK) FeedbackID # Set to one of the `FBK` values
    char(32) Reserved   # Reserved in case of future expansion
  ]],
  [[
  FileFeedback() : Size(0), Position(0), Path(nullptr), Dest(nullptr), FeedbackID(FBK::NIL) { }
  ]])

  struct("Field", { comment="Used to describe the public fields of a class." }, [[
    maxint Arg         # An option to complement the field type.  Can be a pointer or an integer value
    fptr(error ptr ptr) GetValue # A virtual function that will retrieve the value for this field.
    ptr SetValue       # A virtual function that will set the value for this field.
    fptr(error obj struct(*Field) int cptr int) WriteValue # An internal function for writing to this field.
    cstr Name          # The English name for the field, e.g. `Width`
    uint FieldID       # Provides a fast way of finding fields, e.g. `FID_Width`
    ushort Offset      # Field offset within the object
    ushort Index       # Field array index
    uint Flags         # Special flags that describe the field
  ]],
  [[
   bool readable() {
      return (Flags & FD_READ) ? true : false;
   }
   bool writeable() {
      return (Flags & (FD_WRITE|FD_INIT)) ? true : false;
   }
  ]]) -- [32/52]

  c_insert([[
struct ScriptArg { // For use with sc::Exec
   CSTRING Name;
   uint32_t Type;
   union {
      APTR    Address;
      int     Int;
      int64_t Int64;
      double  Double;
   };

   ScriptArg(CSTRING pName, OBJECTPTR pValue, uint32_t pType = FD_OBJECTPTR) : Name(pName), Type(pType), Address((APTR)pValue) { }
   ScriptArg(CSTRING pName, std::string &pValue, uint32_t pType = FD_STRING) : Name(pName), Type(pType), Address((APTR)pValue.data()) { }
   ScriptArg(CSTRING pName, const std::string &pValue, uint32_t pType = FD_STRING) : Name(pName), Type(pType), Address((APTR)pValue.data()) { }
   ScriptArg(CSTRING pName, CSTRING pValue, uint32_t pType = FD_STRING) : Name(pName), Type(pType), Address((APTR)pValue) { }
   ScriptArg(CSTRING pName, APTR pValue, uint32_t pType = FD_PTR) : Name(pName), Type(pType), Address(pValue) { }
   ScriptArg(CSTRING pName, int pValue, uint32_t pType = FD_INT) : Name(pName), Type(pType), Int(pValue) { }
   ScriptArg(CSTRING pName, uint32_t pValue, uint32_t pType = FD_INT) : Name(pName), Type(pType), Int(pValue) { }
   ScriptArg(CSTRING pName, int64_t pValue, uint32_t pType = FD_INT64) : Name(pName), Type(pType), Int64(pValue) { }
   ScriptArg(CSTRING pName, double pValue, uint32_t pType = FD_DOUBLE) : Name(pName), Type(pType), Double(pValue) { }
};
]])

  functionNames(nil,
    "AccessMemory",
    "Action",
    "ActionList",
    "DeleteFile",
    "ResolveClassID",
    "AllocateID",
    "AllocMemory",
    "AccessObject",
    "CheckAction",
    "CheckMemoryExists",
    "CheckObjectExists",
    "InitObject",
    "VirtualVolume",
    "CurrentContext",
    "AdjustLogLevel",
    "ReadFileToBuffer",
    "FindObject",
    "FindClass",
    "AnalysePath",
    "FreeResource",
    "GetClassID",
    "GetOwnerID",
    "CompareFilePaths",
    "GetSystemState",
    "ListChildren",
    "RegisterFD",
    "ResolvePath",
    "MemoryIDInfo",
    "MemoryPtrInfo",
    "NewObject",
    "NotifySubscribers",
    "CopyFile",
    "ProcessMessages",
    "IdentifyFile",
    "ReallocMemory",
    "ReleaseMemory",
    "ResolveClassName",
    "SendMessage",
    "SetOwner",
    "ProtectMemory",
    "SetObjectContext",
    "FieldName",
    "ScanDir",
    "SetName",
    "LogReturn",
    "SubscribeAction",
    "SubscribeEvent",
    "SubscribeTimer",
    "UpdateTimer",
    "UnsubscribeAction",
    "UnsubscribeEvent",
    "BroadcastEvent",
    "WaitTime",
    "GetEventID",
    "GenCRC32",
    "GetResource",
    "SetResource",
    "ScanMessages",
    "WaitForObjects",
    "UnloadFile",
    "CreateFolder",
    "LoadFile",
    "SetVolume",
    "DeleteVolume",
    "MoveFile",
    "UpdateMessage",
    "AddMsgHandler",
    "QueueAction",
    "PreciseTime",
    "OpenDir",
    "GetObjectPtr",
    "FindField",
    "GetErrorMsg",
    "GetActionMsg",
    "FuncError",
    "LockObject",
    "ReleaseObject",
    "AsyncAction",
    "AddInfoTag",
    "SetDefaultPermissions",
    "VLogF",
    "ReadInfoTag",
    "SetResourcePath",
    "CurrentTask",
    "ResolveGroupID",
    "ResolveUserID",
    "CreateLink",
    "ParentContext",
    "SetResourceMgr")

  c_insert([=[

//********************************************************************************************************************

#define END_FIELD FieldArray(nullptr, 0)
#define FDEF static const struct FunctionField

template <class T> inline MEMORYID GetMemoryID(T &&A) {
   return ((MEMORYID *)A)[-2];
}

inline ERR DeregisterFD(HOSTHANDLE Handle) {
   return RegisterFD(Handle, RFD::REMOVE|RFD::READ|RFD::WRITE|RFD::EXCEPT|RFD::ALWAYS_CALL, 0, 0);
}

inline APTR GetResourcePtr(RES ID) { return (APTR)(MAXINT)GetResource(ID); }

inline CSTRING to_cstring(const std::string &A) { return A.c_str(); }
constexpr inline CSTRING to_cstring(CSTRING A) { return A; }
#ifndef PRV_CORE_DATA
// These overloaded functions can't be used in the Core as they will confuse the compiler in key areas.

inline ERR SubscribeAction(OBJECTPTR Object, AC Action, FUNCTION Callback) {
   return SubscribeAction(Object,Action,&Callback);
}

inline ERR SubscribeEvent(int64_t Event, FUNCTION Callback, APTR *Handle) {
   return SubscribeEvent(Event,&Callback,Handle);
}

inline ERR SubscribeTimer(double Interval, FUNCTION Callback, APTR *Subscription) {
   return SubscribeTimer(Interval,&Callback,Subscription);
}

inline ERR ReleaseMemory(const void *Address) {
   if (!Address) return ERR::NullArgs;
   return ReleaseMemory(((MEMORYID *)Address)[-2]);
}

inline ERR FreeResource(const void *Address) {
   if (!Address) return ERR::NullArgs;
   return FreeResource(((int *)Address)[-2]);
}

inline ERR AllocMemory(int Size, MEM Flags, APTR Address) {
   return AllocMemory(Size, Flags, (APTR *)Address, nullptr);
}

template<class T> inline ERR NewObject(CLASSID ClassID, T **Result) {
   return NewObject(ClassID, NF::NIL, (OBJECTPTR *)Result);
}

template<class T> inline ERR NewLocalObject(CLASSID ClassID, T **Result) {
   return NewObject(ClassID, NF::LOCAL, (OBJECTPTR *)Result);
}

inline ERR MemoryIDInfo(MEMORYID ID, struct MemInfo * MemInfo) {
   return MemoryIDInfo(ID,MemInfo,sizeof(struct MemInfo));
}

inline ERR MemoryPtrInfo(APTR Address, struct MemInfo * MemInfo) {
   return MemoryPtrInfo(Address,MemInfo,sizeof(struct MemInfo));
}

inline ERR QueueAction(AC Action, OBJECTID ObjectID) {
   return QueueAction(Action, ObjectID, nullptr);
}
#endif

typedef KEYVALUE ConfigKeys;
typedef std::pair<std::string, ConfigKeys> ConfigGroup;
typedef std::vector<ConfigGroup> ConfigGroups;

namespace pf {

inline void copymem(const void *Src, APTR Dest, std::size_t Length) {
   memmove(Dest, Src, Length);
}

inline void clearmem(APTR Memory, std::size_t Length) {
   if (Memory) memset(Memory, 0, Length);
}

static thread_local int _tlUniqueThreadID = 0;

[[nodiscard]] inline int _get_thread_id(void) {
   if (_tlUniqueThreadID) return _tlUniqueThreadID;
   _tlUniqueThreadID = GetResource(RES::THREAD_ID);
   return _tlUniqueThreadID;
}

} // namespace

#include <parasol/log.h>
#include <parasol/objects.h>

inline OBJECTID CurrentTaskID() { return ((OBJECTPTR)CurrentTask())->UID; }
inline APTR SetResourcePtr(RES Res, APTR Value) { return (APTR)(MAXINT)(SetResource(Res, (MAXINT)Value)); }

]=])

  methods("MetaClass", "mc", {
    { id=1, name="FindField" }
  })

  class("MetaClass", { src="../classes/class_metaclass.cpp" }, [[
    double ClassVersion    # Version of the class
    cstruct(*FieldArray) Fields  # Original field array supplied by the module.
    array(struct(Field)) Dictionary # Field lookup by ID
    cstr ClassName         # Name of the class
    cstr FileExtension     # File extension that is supported by this class.
    cstr FileDescription   # File description
    cstr FileHeader        # Internal file header for identifying the file
    cstr Path              # Module path to the class
    cstr Icon              # An icon that can be used to represent class data.
    int Size               # Byte-size of the class when produced as an object
    int(CLF) Flags         # Special flags
    cid ClassID            # ID of this class
    cid BaseClassID        # Base-class ID
    int OpenCount          # Number of objects allocated to this class
    int(CCF) Category      # Assigned category
  ]])

c_insert([[
inline bool Object::isSubClass() { return Class->ClassID != Class->BaseClassID; }
inline CLASSID Object::classID() { return Class->ClassID; }
inline CLASSID Object::baseClassID() { return Class->BaseClassID; }
]])

  class("StorageDevice", { src="../classes/class_storagedevice.cpp" }, [[
    large(DEVICE) DeviceFlags  # Flags identifying the type of media
    large DeviceSize           # Size of the device
    large BytesFree            # Bytes available to the user
    large BytesUsed            # Bytes already used
  ]])

  methods("File", "Fl", {
    { id=1,  name="StartStream" },
    { id=2,  name="StopStream" },
    { id=3,  name="Delete" },
    { id=4,  name="Move" },
    { id=5,  name="Copy" },
    { id=6,  name="SetDate" },
    { id=7,  name="ReadLine" },
    { id=8,  name="BufferContent" },
    { id=9,  name="Next" },
    { id=10, name="Watch" }
  })

  class("File", { version=1.2, src="../classes/class_file.cpp", output="../classes/class_file_def.c" }, [[
    large     Position  # The current read/write byte position in a file.
    int(FL)   Flags     # File flags and options.
    int       Static    # Set to `true` if a file object should be static.
    oid       Target    # Specifies a surface ID to target for user feedback and dialog boxes.
    ptr(char) Buffer    # Points to the internal data buffer if the file content is held in memory.
  ]],
  nil,
  [[
   inline CSTRING readLine() {
      struct fl::ReadLine args;
      if (Action(fl::ReadLine::id, this, &args) IS ERR::Okay) return args.Result;
      else return nullptr;
   }
  ]])

  methods("config", "Cfg", {
    { id=1,  name="ReadValue" },
    { id=2,  name="Set" },
    { id=3,  name="WriteValue" },
    { id=4,  name="DeleteKey" },
    { id=5,  name="DeleteGroup" },
    { id=6,  name="GetGroupFromIndex" },
    { id=7,  name="SortByKey" },
    { id=9,  name="MergeFile" },
    { id=10, name="Merge" }
  })

  class("Config", { src="../classes/class_config.cpp", output="../classes/class_config_def.c" }, [[
    str Path          # The location pointer
    str KeyFilter     # Enables key filtering, removing any unwanted keys on load.
    str GroupFilter   # Enables group filtering, removing any unwanted groups on load.
    int(CNF) Flags    # Not currently in use
  ]],
  nil,
  [[
   ConfigGroups *Groups;

   // For C++ only, these read variants avoid method calls for speed, but apply identical logic.

   inline ERR read(std::string_view pGroup, std::string_view pKey, double &pValue) {
      for (auto& [group, keys] : Groups[0]) {
         if ((!pGroup.empty()) and (group.compare(pGroup))) continue;
         if (pKey.empty()) pValue = strtod(keys.cbegin()->second.c_str(), nullptr);
         else if (auto it = keys.find(pKey); it != keys.end()) pValue = strtod(it->second.c_str(), nullptr);
         else return ERR::Search;
         return ERR::Okay;
      }
      return ERR::Search;
   }

   inline ERR read(std::string_view pGroup, std::string_view pKey, int &pValue) {
      for (auto& [group, keys] : Groups[0]) {
         if ((!pGroup.empty()) and (group.compare(pGroup))) continue;
         if (pKey.empty()) pValue = strtol(keys.cbegin()->second.c_str(), nullptr, 0);
         else if (auto it = keys.find(pKey); it != keys.end()) pValue = strtol(it->second.c_str(), nullptr, 0);
         else return ERR::Search;
         return ERR::Okay;
      }
      return ERR::Search;
   }

   inline ERR read(std::string_view pGroup, std::string_view pKey, std::string &pValue) {
      for (auto & [group, keys] : Groups[0]) {
         if ((!pGroup.empty()) and (group.compare(pGroup))) continue;
         if (pKey.empty()) pValue = keys.cbegin()->second;
         else if (auto it = keys.find(pKey); it != keys.end()) pValue = it->second;
         else return ERR::Search;
         return ERR::Okay;
      }
      return ERR::Search;
   }

   inline ERR write(std::string_view Group, std::string_view Key, std::string_view Value) {
      ConfigGroups &groups = *Groups;
      for (auto& [group, keys] : groups) {
         if (!group.compare(Group)) {
            if (auto it = keys.find(Key); it != keys.end()) {
               it->second.assign(Value);
            }
            else keys.emplace(Key, Value);
            return ERR::Okay;
         }
      }

      auto &new_group = Groups->emplace_back();
      new_group.first.assign(Group);
      new_group.second.emplace(Key, Value);
      return ERR::Okay;
   }
  ]])

  methods("Script", "Sc", {
    { id=1, name="Exec" },
    { id=2, name="DerefProcedure" },
    { id=3, name="Callback" },
    { id=4, name="GetProcedureID" }
  })

  class("Script", { src={ "../classes/class_script.cpp" }, output="../classes/class_script_def.c" }, [[
    oid Target           # The object that script objects must be initialised to, e.g. for obj.new()
    int(SCF) Flags       # Optional flags
    error Error          # If an error occurred, this field will indicate the error number
    int CurrentLine      # Current line being executed, or failed line if script execution terminated
    int LineOffset       # An optional offset to use when reporting line numbers
  ]],
  [[
   int64_t    ProcedureID;          // For callbacks
   KEYVALUE Vars; // Global parameters
   STRING   *Results;
   char     Language[4];          // 3-character language code, null-terminated
   const ScriptArg *ProcArgs;     // Procedure args - applies during Exec
   STRING   Path;                 // File location of the script
   STRING   String;
   STRING   WorkingPath;
   STRING   ErrorString;
   CSTRING  Procedure;
   STRING   CacheFile;
   int     ActivationCount;      // Incremented every time the script is activated.
   int     ResultsTotal;
   int     TotalArgs;            // Total number of ProcArgs
   char     LanguageDir[32];      // Directory to use for language files
   OBJECTID ScriptOwnerID;
  ]])

  c_insert([[
namespace sc {
template <std::size_t SIZE> ERR Call(const FUNCTION &Function, const std::array<ScriptArg, SIZE> &Args) noexcept {
   struct Callback args = { Function.ProcedureID, Args.data(), int(std::ssize(Args)), ERR::Okay };
   return Action(sc::Callback::id, Function.Context, &args);
}

template <std::size_t SIZE> ERR Call(const FUNCTION &Function, const std::array<ScriptArg, SIZE> &Args, ERR &Result) noexcept {
   struct Callback args = { Function.ProcedureID, Args.data(), int(std::ssize(Args)), ERR::Okay };
   ERR error = Action(sc::Callback::id, Function.Context, &args);
   Result = args.Error;
   return(error);
}

inline ERR Call(const FUNCTION &Function) noexcept {
   struct Callback args = { Function.ProcedureID, nullptr, 0, ERR::Okay };
   return Action(sc::Callback::id, Function.Context, &args);
}

inline ERR Call(const FUNCTION &Function, ERR &Result) noexcept {
   struct Callback args = { Function.ProcedureID, nullptr, 0, ERR::Okay };
   ERR error = Action(sc::Callback::id, Function.Context, &args);
   Result = args.Error;
   return(error);
}
} // namespace
  ]])

  struct("ActionEntry", { restrict='c', comment="For the Task Actions field." }, [[
     fptr(error obj ptr) PerformAction # Pointer to a custom action hook.
  ]])

  methods("Task", "Task", {
    { id=1, name="Expunge" },
    { id=2, name="AddArgument" },
    { id=3, name="Quit" },
    { id=4, name="GetEnv" },
    { id=5, name="SetEnv" }
  })

  class("Task", { src="../classes/class_task.cpp", output="../classes/class_task_def.c" }, [[
    double TimeOut
    int(TSF) Flags
    int ReturnCode
    int ProcessID    # Native process ID of the activated task
  ]])

  methods("Thread", "Th", {
    { id=1, name="SetData" }
  })

  class("Thread", { src="../classes/class_thread.cpp", output="../classes/class_thread_def.c" }, [[
   ptr   Data         # User data pointer.
   int   DataSize     # Size of user data.
   error Error        # Error code returned by the thread on completion.
   int(THF) Flags     # Optional flags.
  ]])

  methods("Module", "Mod", {
    { id=1,  name="ResolveSymbol" },
  })

  class("Module", { src="../classes/class_module.cpp" }, [[
    cstruct(*Function) FunctionList # Array of functions
    ptr ModBase                     # Ptr to function jump table
    class(*RootModule) Root         # Shared details on the module
    struct(*ModHeader) Header       # For creating in-memory modules only.
    int(MOF) Flags                  # Optional flags
  ]],
  nil,
  [[
   static ERR load(std::string Name, OBJECTPTR *Module = nullptr, APTR Functions = nullptr) {
      if (auto module = objModule::create::global(pf::FieldValue(FID_Name, Name.c_str()))) {
         #ifdef PARASOL_STATIC
            if (Module) *Module = module;
            if (Functions) ((APTR *)Functions)[0] = nullptr;
            return ERR::Okay;
         #else
            APTR functionbase;
            if (module->get(FID_ModBase, functionbase) IS ERR::Okay) {
               if (Module) *Module = module;
               if (Functions) ((APTR *)Functions)[0] = functionbase;
               return ERR::Okay;
            }
            else return ERR::GetField;
         #endif
      }
      else return ERR::CreateObject;
   }
  ]])

  -- Note that the fields following SystemTime are identical to struct DateTime

  methods("Time", "Pt", {
    { id=1, name="SetTime" },
  })

  class("Time", { src="../classes/class_time.cpp" }, [[
    large SystemTime  # Total number of microseconds passed since the system base time
    int Year          # Year   (-ve for BC, +ve for AD)
    int Month         # Month  (1 - 12)
    int Day           # Day    (1 - 31)
    int Hour          # Hour   (0 - 23)
    int Minute        # Minute (0 - 59)
    int Second        # Second (0 - 59)
    int TimeZone      # 0 is GMT, range is +1300 or -1300
    int DayOfWeek     # Day of week (0 = Sunday ..)
    int MilliSecond   # Millisecond (0 - 999)
    int MicroSecond   # Microsecond  (0 - 999999)
  ]])

  methods("Compression", "Cmp", {
    { id=1, name="CompressBuffer" },
    { id=2, name="CompressFile" },
    { id=3, name="DecompressBuffer" },
    { id=4, name="DecompressFile" },
    { id=5, name="RemoveFile" },
    { id=6, name="CompressStream" },
    { id=7, name="DecompressStream" },
    { id=8, name="CompressStreamStart" },
    { id=9, name="CompressStreamEnd" },
    { id=10, name="DecompressStreamEnd" },
    { id=11, name="DecompressStreamStart" },
    { id=12, name="DecompressObject" },
    { id=13, name="Scan" },
    { id=14, name="Find" }
  })

  class("Compression", { src={ "../compression/class_compression.cpp", "../compression/compression_fields.cpp" }, output="../compression/class_compression_def.c" }, [[
    large TotalOutput       # Total number of bytes output (e.g. during compression of a stream)
    oid Output              # Reference to output object for user messages
    int CompressionLevel    # Compression level (percentage - 0% none, 100% high)
    int(CMF) Flags          # Optional flags
    int SegmentSize         # Splits the compressed file if it surpasses a set byte limit (e.g. 1.44MB)
    int(PERMIT) Permissions # Default permissions to use for decompressed files
    int MinOutputSize       # Minimum recommended output buffer size
    int WindowBits          # Window bits, currently applicable to the default (zlib) compression
  ]])

  class("CompressedStream", { src="../compression/class_compressed_stream.cpp", output="../compression/class_compressed_stream_def.c" }, [[
    large TotalOutput  # Count of the total bytes that have been output.
    obj Input          # The object that is the source of the compressed data.
    obj Output         # The object that is the destination for the compressed data.
    int(CF) Format     # CF_GZIP, CF_ZLIB, CF_DEFLATE
  ]])

  c_insert([[
#ifndef PRV_CORE

// Note that the length of the data is only needed when messaging between processes, so we can skip it for these
// direct-access data channel macros.

#define acDataContent(a,b)  acDataFeed((a),0,DATA::CONTENT,(b),0)
#define acDataXML(a,b)      acDataFeed((a),0,DATA::XML,(b),0)
#define acDataText(a,b)     acDataFeed((a),0,DATA::TEXT,(b),0)

#endif // PRV_CORE

#ifdef __unix__
#include <pthread.h>
#endif

namespace pf {

#ifdef __system__
   struct ActionMessage {
      OBJECTID ObjectID;  // The object that is to receive the action
      int  Time;
      AC ActionID;        // ID of the action or method to execute
      bool SendArgs;

      // Action arguments follow this structure in a buffer
   };
#endif

// Event support

struct Event {
   EVENTID EventID;
   // Data follows
};

#define EVID_DISPLAY_RESOLUTION_CHANGE  GetEventID(EVG::DISPLAY, "resolution", "change")

#define EVID_GUI_SURFACE_FOCUS          GetEventID(EVG::GUI, "surface", "focus")

#define EVID_FILESYSTEM_VOLUME_CREATED  GetEventID(EVG::FILESYSTEM, "volume", "created")
#define EVID_FILESYSTEM_VOLUME_DELETED  GetEventID(EVG::FILESYSTEM, "volume", "deleted")

#define EVID_SYSTEM_TASK_CREATED        GetEventID(EVG::SYSTEM, "task", "created")
#define EVID_SYSTEM_TASK_REMOVED        GetEventID(EVG::SYSTEM, "task", "removed")

#define EVID_POWER_STATE_SUSPENDING     GetEventID(EVG::POWER, "state", "suspending")
#define EVID_POWER_STATE_RESUMED        GetEventID(EVG::POWER, "state", "resumed")
#define EVID_POWER_DISPLAY_STANDBY      GetEventID(EVG::POWER, "display", "standby")
#define EVID_POWER_BATTERY_LOW          GetEventID(EVG::POWER, "battery", "low")
#define EVID_POWER_BATTERY_CRITICAL     GetEventID(EVG::POWER, "battery", "critical")
#define EVID_POWER_CPUTEMP_HIGH         GetEventID(EVG::POWER, "cputemp", "high")
#define EVID_POWER_CPUTEMP_CRITICAL     GetEventID(EVG::POWER, "cputemp", "critical")
#define EVID_POWER_SCREENSAVER_ON       GetEventID(EVG::POWER, "screensaver", "on")
#define EVID_POWER_SCREENSAVER_OFF      GetEventID(EVG::POWER, "screensaver", "off")

#define EVID_IO_KEYMAP_CHANGE           GetEventID(EVG::IO, "keymap", "change")
#define EVID_IO_KEYBOARD_KEYPRESS       GetEventID(EVG::IO, "keyboard", "keypress")

#define EVID_AUDIO_VOLUME_MASTER        GetEventID(EVG::AUDIO, "volume", "master")
#define EVID_AUDIO_VOLUME_LINEIN        GetEventID(EVG::AUDIO, "volume", "linein")
#define EVID_AUDIO_VOLUME_MIC           GetEventID(EVG::AUDIO, "volume", "mic")
#define EVID_AUDIO_VOLUME_MUTED         GetEventID(EVG::AUDIO, "volume", "muted") // All volumes have been muted
#define EVID_AUDIO_VOLUME_UNMUTED       GetEventID(EVG::AUDIO, "volume", "unmuted") // All volumes have been unmuted

// Event structures.

typedef struct { EVENTID EventID; char Name[1]; } evVolumeCreated;
typedef struct { EVENTID EventID; char Name[1]; } evVolumeDeleted;
typedef struct { EVENTID EventID; OBJECTID TaskID; } evTaskCreated;
typedef struct { EVENTID EventID; OBJECTID TaskID; OBJECTID ProcessID; } evTaskRemoved;
typedef struct { EVENTID EventID; } evPowerSuspending;
typedef struct { EVENTID EventID; } evPowerResumed;
typedef struct { EVENTID EventID; } evUserLogin;
typedef struct { EVENTID EventID; } evKeymapChange;
typedef struct { EVENTID EventID; } evScreensaverOn;
typedef struct { EVENTID EventID; } evScreensaverOff;
typedef struct { EVENTID EventID; double Volume; int Muted; } evVolume;
typedef struct { EVENTID EventID; KQ Qualifiers; KEY Code; int Unicode; } evKey;
typedef struct { EVENTID EventID; int16_t TotalWithFocus; int16_t TotalLostFocus; OBJECTID FocusList[1]; } evFocus;

// Hotplug event structure.  The hotplug event is sent whenever a new hardware device is inserted by the user.

struct evHotplug {
   EVENTID EventID;
   int16_t Type;            // HT ID
   int16_t Action;          // HTA_INSERTED, HTA_REMOVED
   int VendorID;        // USB vendor ID
   union {
      int ProductID;    // USB product or device ID
      int DeviceID;
   };
   char  ID[20];         // Typically the PCI bus ID or USB bus ID, serial number or unique identifier
   char  Group[32];      // Group name in the config file
   char  Class[32];      // Class identifier (USB)
   union {
      char Product[40];  // Name of product or the hardware device
      char Device[40];
   };
   char Vendor[40];      // Name of vendor
};

} // namespace

namespace fl {

// Read endian values from files and objects.

template<class T> ERR ReadLE(OBJECTPTR Object, T *Result)
{
   uint8_t data[sizeof(T)];
   struct acRead read = { .Buffer = data, .Length = sizeof(T) };
   if (Action(AC::Read, Object, &read) IS ERR::Okay) {
      if (read.Result IS sizeof(T)) {
         if constexpr (std::endian::native == std::endian::little) {
            *Result = ((T *)data)[0];
         }
         else {
            switch(sizeof(T)) {
               case 2:  *Result = (data[1]<<8) | data[0]; break;
               case 4:  *Result = (data[0]<<24)|(data[1]<<16)|(data[2]<<8)|(data[3]); break;
               case 8:  *Result = ((int64_t)data[0]<<56)|((int64_t)data[1]<<48)|((int64_t)data[2]<<40)|((int64_t)data[3]<<32)|(data[4]<<24)|(data[5]<<16)|(data[6]<<8)|(data[7]); break;
               default: *Result = ((T *)data)[0];
            }
         }
         return ERR::Okay;
      }
      else return ERR::Read;
   }
   else return ERR::Read;
}

template<class T> ERR ReadBE(OBJECTPTR Object, T *Result)
{
   uint8_t data[sizeof(T)];
   struct acRead read = { .Buffer = data, .Length = sizeof(T) };
   if (Action(AC::Read, Object, &read) IS ERR::Okay) {
      if (read.Result IS sizeof(T)) {
         if constexpr (std::endian::native == std::endian::little) {
            switch(sizeof(T)) {
               case 2:  *Result = (data[1]<<8) | data[0]; break;
               case 4:  *Result = (data[0]<<24)|(data[1]<<16)|(data[2]<<8)|(data[3]); break;
               case 8:  *Result = ((int64_t)data[0]<<56)|((int64_t)data[1]<<48)|((int64_t)data[2]<<40)|((int64_t)data[3]<<32)|(data[4]<<24)|(data[5]<<16)|(data[6]<<8)|(data[7]); break;
               default: *Result = ((T *)data)[0];
            }
         }
         else {
            *Result = ((T *)data)[0];
         }
         return ERR::Okay;
      }
      else return ERR::Read;
   }
   else return ERR::Read;
}

} // namespace

// Function construction (refer types.h)

template <class T, class X = APTR> FUNCTION C_FUNCTION(T *pRoutine, X pMeta = 0) {
   auto func    = FUNCTION(CALL::STD_C);
   func.Context = CurrentContext();
   func.Routine = (APTR)pRoutine;
   func.Meta    = reinterpret_cast<void *>(pMeta);
   return func;
};

inline CSTRING Object::className() { return Class->ClassName; }
  ]])

  if (glProgram == "idl-compile") then
     loadFile("defs/errors.fdl")
  end
end)
