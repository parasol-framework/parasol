--$FLUID:Include

module({ name="Core", copyright="Paul Manias 1996-2024" }, function()
  c_include("<stdarg.h>", "<inttypes.h>")
  cpp_include("<list>", "<map>", "<string>", "<vector>", "<unordered_map>", "<bit>", "<atomic>", "<array>")

  platform("Windows", function()
     enum("NETMSG", {}, "START", "END")
  end)

  privateNames({ "ScriptArg", "CoreBase", "RootModule" })

  priority([[
#if defined(_DEBUG) && defined(__linux__)
 #include <signal.h>
#endif

#ifndef DEFINE_ENUM_FLAG_OPERATORS
template <size_t S> struct _ENUM_FLAG_INTEGER_FOR_SIZE;
template <> struct _ENUM_FLAG_INTEGER_FOR_SIZE<1> { typedef BYTE type; };
template <> struct _ENUM_FLAG_INTEGER_FOR_SIZE<2> { typedef WORD type; };
template <> struct _ENUM_FLAG_INTEGER_FOR_SIZE<4> { typedef LONG type; };
template <> struct _ENUM_FLAG_INTEGER_FOR_SIZE<8> { typedef LARGE type; };
// used as an approximation of std::underlying_type<T>
template <class T> struct _ENUM_FLAG_SIZED_INTEGER { typedef typename _ENUM_FLAG_INTEGER_FOR_SIZE<sizeof(T)>::type type; };

#define DEFINE_ENUM_FLAG_OPERATORS(ENUMTYPE) \
inline ENUMTYPE operator | (ENUMTYPE a, ENUMTYPE b) { return ENUMTYPE(((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)a) | ((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)b)); } \
inline ENUMTYPE operator & (ENUMTYPE a, ENUMTYPE b) { return ENUMTYPE(((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)a) & ((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)b)); } \
inline ENUMTYPE operator ~ (ENUMTYPE a) { return ENUMTYPE(~((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)a)); } \
inline ENUMTYPE operator ^ (ENUMTYPE a, ENUMTYPE b) { return ENUMTYPE(((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)a) ^ ((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)b)); } \
inline ENUMTYPE &operator |= (ENUMTYPE &a, ENUMTYPE b) { return (ENUMTYPE &)(((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type &)a) |= ((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)b)); } \
inline ENUMTYPE &operator &= (ENUMTYPE &a, ENUMTYPE b) { return (ENUMTYPE &)(((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type &)a) &= ((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)b)); }
#endif
  ]])

  loadFile(glPath .. 'common.fdl')
  loadFile(glPath .. 'common-graphics.fdl')

  flags("SCF", { comment="Script flags" },
     "EXIT_ON_ERROR: The script will automatically terminate its execution process if an error is detected.",
     "LOG_ALL: Enables execution debugging.  More information will be printed to the console in this mode.")

  flags("STR", { bits=32 },
     "MATCH_CASE|CASE: Perform a case-sensitive match.",
     "MATCH_LEN: The strings must be of equal length to be matched.")

  flags("MSF", { comment="Message flags." },
     "WAIT: Wait before inserting the message if the queue is at maximum capacity.",
     "UPDATE: If the `Type` parameter matches a message already inside the queue, the data for that message will be deleted, then the new message will be added to the end of the queue.",
     "NO_DUPLICATE: If the `Type` parameter matches a message already inside the queue, the new message will not be added and the function will immediately return with `ERR::Okay`.",
     "ADD: The default behaviour - this will add the message to the end of the queue.",
     "ADDRESS: Internal flag that changes the behaviour of the input parameters so that queues can be processed by address rather than ID.",
     "MESSAGE_ID: The Type parameter refers to a unique message ID rather than a message type for this call.")

  flags("PMF", { comment="Flags for ProcessMessages" },
     "SYSTEM_NO_BREAK: Private.  For system calls that need to avoid early termination.")

  flags("RFD", { bits=32, comment="Flags for RegisterFD()" },
     "WRITE: Activate the callback if there is room to write to the FD's buffer.",
     "EXCEPT: Activate the callback if error conditions are pending.",
     "READ: Activate the callback if there is data available to read.",
     "REMOVE: Stop monitoring this file descriptor.",
     "STOP_RECURSE: Internal flag to prevent recursion.",
     "ALLOW_RECURSION: Internal flag to allow recursion.",
     "SOCKET: Identifies the file descriptor as a socket (Linux systems only).",
     "RECALL: Set if the subscriber needs to manually check for incoming/outgoing data.  This is supported as a one-off check, so the flag will be disabled automatically when the subscriber is called.",
     "ALWAYS_CALL: Always call this FD's handler prior to the process going to sleep.")

  flags("TSF", { comment="Task flags" },
    "FOREIGN: Set this flag when using the task object to execute a foreign process - that is an executable that does not use the Parasol API.",
    "WAIT: This flag will cause the parent process to halt when the task is activated.  Control is returned to the parent process once the child process terminates.",
    "RESET_PATH: If set, the executed process will start in its own folder rather than the folder of the parent process.",
    "PRIVILEGED: During a normal execution process, any privileges of the parent process will be dropped so that the child process runs unprivileged.  This behaviour can be reversed if he PRIVILEGED flag is set, in which case the child process has the same privileges as the parent.",
    "SHELL: Enables shell mode.  On Unix systems, this means that a shell (usually BASH) will be used to launch the process.",
    "LOG_ALL: Additional debug messages will be printed during normal usage of the task class when this flag is set.",
    "QUIET: Setting this flag will divert all process output to `/dev/null` or the nearest equivalent for non-Unix systems.",
    "DETACHED: Forces new task to be detached from the parent.",
    "ATTACHED: Forces new task to be attached to the parent (child will close when parent closes).",
    "PIPE: Enable the output pipe to the launched process so that it can read data.")

  hash("AHASH", "0x%s",
    "ACTIVATE",     "CLEAR",         "FREEWARNING", "COPYDATA",
    "DATAFEED",     "DEACTIVATE",    "DRAW",      "FLUSH",       "FOCUS",        "FREE",
    "GETKEY",       "DRAGDROP",      "HIDE",      "INIT",        "LOCK",         "LOSTFOCUS",    "MOVE",
    "MOVETOBACK",   "MOVETOFRONT",   "NEWCHILD",  "NEWOWNER",    "NEWOBJECT",    "REDO",         "QUERY",
    "READ",         "RENAME",        "RESET",     "RESIZE",      "SAVEIMAGE",    "SAVETOOBJECT",
    "SEEK",         "SETKEY",        "SHOW",      "TIMER",       "UNLOCK",       "NEXT",         "PREV",
    "WRITE",        "SETFIELD",      "CLIPBOARD", "REFRESH",     "DISABLE",      "ENABLE",       "REDIMENSION",
    "MOVETOPOINT",  "SORT",          "SAVESETTINGS", "SIGNAL",
    "UNDO")

  flags("MHF", { comment="Internal options for requesting function tables from modules." },
    "STATIC: Keep the module code in memory",
    "STRUCTURE|DEFAULT: Use structures to group exported functions (Linux, C/C++ standard)")

  flags("MTF", { comment="MoveToPoint flags" }, "X", "Y", "Z", "ANIM", "RELATIVE")

  flags("VLF", { comment="VlogF flags" }, "BRANCH", "ERROR", "WARNING", "CRITICAL", "INFO", "API", "DETAIL", "TRACE", "FUNCTION")

  flags("MOF", { comment="Module flags" },
    "LINK_LIBRARY: Module refers to a symbolic link library (e.g. libz DLL or SO)",
    "STATIC: This flag prevents the loaded module code from being unloaded when the module object is freed.  This may be needed in cases where a module is designed with the presumption that it will remain in memory after being loaded by the developer.",
    "SYSTEM_PROBE: Indicates that the module is being probed.  Do not use outside of the core library.")

  flags("THF", { comment="Thread flags" },
    "AUTO_FREE: Automatically destroy the Thread object when the user routine has completed.")

  enum("FDT", { type="int", start=0, comment="Flags for the SetDate() file method." },
    "MODIFIED: The date on which the file was last modified.",
    "CREATED: The date on which the file was created.  On some host platforms this datestamp may be read-only.",
    "ACCESSED: The date on which the file was last accessed by a user or application.",
    "ARCHIVED: The date on which the file was most recently archived.  Not supported by most filesystems.")

  flags("VOLUME", { comment="Options for SetVolume()" },
    "REPLACE: If the volume already exists, all paths that are attached to it will be replaced with the new path setting.",
    "PRIORITY: If the volume already exists, the path will be inserted at the beginning of the path list so that it has priority over the others.",
    "HIDDEN: Hides the volume so that it will not show up when reading the root folder.",
    "SYSTEM: Identifies the volume as being created by the system, is immutable and persistent between sessions.")

  flags("FDL", { comment="Options for the File Delete() method." },
    "FEEDBACK: Automatically manage user feedback for deleting files by presenting dialog boxes.")

  flags("CMF", { comment="Compression flags" },
    "PASSWORD: A password has been set on the object.",
    "NEW: Force the creation of a new file archive.  Any existing file data at the target location will be destroyed.",
    "CREATE_FILE: Create a new archive only if the source file does not already exist.",
    "READ_ONLY: Forces read-only access, which is strongly recommended if an existing archive is being opened with no modifications intended.  If this flag is not set, initialisation can fail if the user does not have write access to the source file.",
    "NO_LINKS: Treat symbolic links as normal files/folders.",
    "APPLY_SECURITY: When decompressing, apply individual file permissions if they are available in the compression file.")

  flags("RSF", { comment="Flags for ResolvePath()"},
    "NO_FILE_CHECK: Do not test for the existence of the targeted file or folder during the resolution process.",
    "CHECK_VIRTUAL: If the volume referenced by Path is traced to another volume that is reserved by a virtual file system driver, `ERR::VirtualVolume` is returned. The volume is still resolved as far as possible and the resulting path will be returned by this function.",
    "APPROXIMATE: Ignores file extensions for the purpose of file name matching.",
    "NO_DEEP_SCAN: Do not perform more than one iteration when resolving the source file path.",
    "PATH: Use the `PATH` environment variable to resolve the file name in the `Path` parameter.",
    "CASE_SENSITIVE: For use on host systems that use case-insensitive file systems such as Windows; this option checks that the discovered file is a case-sensitive match to the Path.")

  -- NB: The MFF flags are duplicated in the FileSystem's Win32 code if you're going to change these

  flags("MFF", { comment="Flags for the File Watch() method." },
    "READ: File was accessed (read).",
    "MODIFY|WRITE: File modified via write or truncation.",
    "CREATE: New file/link created or renamed in folder.",
    "DELETE: Existing file deleted",
    "MOVED|RENAME: Existing file moved or renamed.",
    "ATTRIB: File permissions or datestamp changed.",
    "OPENED: Existing file was opened.",
    "CLOSED: An opened file has been closed.",
    "UNMOUNT: Host filesystem was unmounted.",
    "FOLDER: Folder identifier; if passed to @File.Watch() then indicates a preference for folder events only.",
    "FILE: File identifier; if passed to @File.Watch() then indicates a preference for file events only.",
    "SELF: Event applies to the monitored folder and not a contained item",
    "DEEP: Receive notifications from sub-folders (Windows only).")

  enum("STT", { type="int", start=1, comment="Types for StrDatatype()." },
    "NUMBER: The string represents a whole number.",
    "FLOAT: The string represents a floating point number.",
    "HEX: The string represents a hexadecimal number.",
    "STRING: The string represents plain-text.")

  flags("OPF", { },
    "OPTIONS",
    "MAX_DEPTH",
    "DETAIL",
    "SHOW_MEMORY",
    "SHOW_IO",
    "SHOW_ERRORS",
    "ARGS",
    "ERROR",
    "PRIVILEGED",
    "SYSTEM_PATH",
    "MODULE_PATH",
    "ROOT_PATH",
    "SCAN_MODULES")

  enum("TOI", { type="int" },
    "LOCAL_CACHE",        -- For Android.  Defines the path of the local cache for assignment to localcache:
    "LOCAL_STORAGE",      -- For Android.  Defines the path of the local storage for assignment to localstorage:
    "ANDROID_ENV",        -- For Android.
    "ANDROID_CLASS",      -- For Android.
    "ANDROID_ASSETMGR")   -- For Android.  Permanent pointer to the AssetManager

  flags("RDF", { comment="Flags for the OpenDir() function." },
    "SIZE: Retrieve the byte size of each file.",
    "DATE|TIME: Retrieve the date stamp of each file.",
    "PERMISSIONS: Get permission/security information.",
    "FILES|FILE: Read all files in the folder.",
    "FOLDERS|FOLDER: Read all folders/volumes in the folder.",
    "VOLUME: Feedback only - indicates a volume.",
    "LINK: Feedback only - file/folder is actually a link to another location.",
    "TAGS: Receive additional information for each file, such as comments, author and copyright.  The results are stored in the `Tags` field of each file.",
    "HIDDEN: Feedback only - file/folder is hidden.",
    "QUALIFY|QUALIFIED: Return fully qualified folder names (i.e. trailing slash or colon for each name).",
    "VIRTUAL: Path is to a virtual device.",
    "STREAM: Path is connected via a stream, e.g. network connection.",
    "READ_ONLY: Read-only (not permissions related and might indicate read-only media).",
    "ARCHIVE: Feedback only - archive bit is set.",
    "OPENDIR: Internal option.",
    { READ_ALL = "SIZE|DATE|PERMISSIONS|FILES|FOLDERS" })

  flags("FL", { comment="File flags" },
    "WRITE: Prepares a file for writing data, starting at byte position 0.  To start writing from the end of a file, use the Seek action after the file has been initialised.",
    "NEW: Required when creating a new file.  If a file with the same name exists, its contents will be destroyed. If however the existing file is locked, the initalisation process will fail.",
    "READ: Required if the file needs to be opened for read access.",
    "FOLDER|DIRECTORY: The file object represents a folder.",
    "APPROXIMATE: Allows fuzzy matching of the file path when opening an existing file.  This means that the file extension will be ignored; for instance attempting to open a file of 'screenshot.png' when only a file name of 'screenshot.jpg' exists in the same folder, the 'screenshot.jpg' file will be opened instead.  If multiple files could potentially match to the file name, the file object will select the first match that is encountered.",
    "LINK: Read-Only.  Indicates that the file is a symbolic link or shortcut to another file.",
    "BUFFER: Activates a special mode in which the file data is stored in a memory buffer rather than a disk file.  Set the Size field to a value of at least 1 so that the initial buffer size is configured.  In this mode many of the available file operations are meaningless except for the Read, Write and Seek actions.",
    "LOOP: In loop mode, the file object's position marker for read/write operations is allowed to extend past the actual file size.  Any read/write operation beyond the file size will loop back to the file at a corrected offset - for example, reading position 330 of a 100 byte file will start the operation from the 30th byte.  Loop mode does not affect any other area besides the read, write and seek operations.  The loop feature is typically used to create multimedia data streams with minimal effort.",
    "FILE: Explicitly declares the file object as an entity that stores content (as opposed to a device or folder for example).",
    "RESET_DATE: For internal use only",
    "DEVICE: The file is a system device (must set if opening a device for read/write operations)",
    "STREAM: File data is streamed (e.g. PIPE, FIFO, socket) and may be accessed locally or via a network.",
    "EXCLUDE_FILES: Exclude files when scanning this folder.",
    "EXCLUDE_FOLDERS: Exclude folders when scanning this folder.")

  enum("LOC", { type="int", start=1, comment="AnalysePath() values" },
    "DIRECTORY|FOLDER: The path refers to a folder.",
    "VOLUME: The path refers to a volume name.",
    "FILE: The path refers to a file.")

  flags("LDF", { comment="Flags for LoadFile()" },
    "CHECK_EXISTS: Limits the routine to checking the file cache for the existence of the file.  If found, the relevant cache entry is returned. The open count is not incremented by this action (it is therefore unnecessary to follow-up with a call to UnloadFile()).  If no up-to-date cache entry is available, `ERR::Search` is returned.")

  enum("FBK", { type="int", start=1, comment="Flags for file feedback." },
    "MOVE_FILE: A file is to be, or has been moved.",
    "COPY_FILE: A file is to be, or has been copied.",
    "DELETE_FILE: A file is to be, or has been deleted.")

  enum("FFR", { type="int", start=0, comment="Return codes available to the feedback routine" },
    "OKAY|CONTINUE: Continue processing uninterrupted.",
    "SKIP: Skip processing of this entity.",
    "ABORT: Abort the entire operation.")

  enum("VAS", { type="int", start=1, comment="For use by VirtualVolume()" },
    "DEREGISTER: Remove the virtual volume from the system.",
    "SCAN_DIR",
    "DELETE",
    "RENAME",
    "OPEN_DIR",
    "CLOSE_DIR",
    "TEST_PATH",
    "WATCH_PATH",
    "IGNORE_FILE",
    "GET_INFO",
    "GET_DEVICE_INFO",
    "IDENTIFY_FILE",
    "MAKE_DIR",
    "SAME_FILE",
    "CASE_SENSITIVE: Set to true if the volume's paths are case-sensitive.",
    "READ_LINK",
    "CREATE_LINK",
    "DRIVER_SIZE")

  enum("FDB", { type="int", start=1, comment="Feedback event indicators." },
    "DECOMPRESS_FILE",
    "COMPRESS_FILE",
    "REMOVE_FILE",
    "DECOMPRESS_OBJECT")

  enum("CF", { type="int", start=1, comment="Compression stream formats" },
    "GZIP: The 'gzip' format",
    "ZLIB: The 'zlib' format",
    "DEFLATE: The 'deflate' format")

  flags("FOF", { comment="Flags that can be passed to FindObject()" },
    "SMART_NAMES: Parse numeric object names as ID references and support use of the 'Owner' reserved keyword.")

  flags("NF", { comment="Flags that can be passed to NewObject().  If a flag needs to be stored with the object, it must be specified in the lower word." },
    "UNTRACKED: An object created with this flag will not be tracked back to the object that created it.",
    "INITIALISED: Read-only indicator if the object has been initialised.",
    "LOCAL: Classes can allocate local objects to stop them from being associated with the client.",
    "FREE_ON_UNLOCK: Read-only indicator for when the object is marked for deletion.",
    "FREE: Read-only indicator for when the object is being freed.",
    "TIMER_SUB: The object is subscribed to a timer interval.",
    "SUPPRESS_LOG: Private.  Turns off the initial log message.",
    "COLLECT: Marked for garbage collection.",
    "RECLASSED: The object switched from the base-class to a sub-class during initialisation.",
    "MESSAGE: Action has been called against the object through the message system (managed by ~Core.ProcessMessages()).",
    "SIGNALLED: The object has been signalled and is awaiting processing.",
    { UNIQUE = "0x40000000: Use to allocate an object that has a guaranteed unique name.  This will prevent code from shadowing any object that exists with the same name, which can be imperative when creating shared objects.  If it is discovered that an identically named object exists, ~Core.NewObject() will return `ERR::ObjectExists`.  This flag works in conjunction with the `Name` parameter.",
      NAME   = "0x80000000: Use the Name parameter to name the created object.  This flag is not required if using `UNIQUE`.",
      PRIVATE = 0
    }
  )

  const("MAX", { }, {
     FILENAME = 256, -- Maximum length for file names (not necessarily including path)
     NAME_LEN = 31   -- Refer to the 'Object' struct for more info on the NAME_LEN value
  })

  const("MSGID", { comment="Reserved message ID's that are handled internally." }, {
     QUIT             = 1000,   -- Note that IDs >= 100 may be handled by non-Core code (external modules and applications)
     COMMAND          = 101,
     BREAK            = 100,
     CORE_END         = 100,    -- End marker for Core generated messages
     ACTION           = 99,     -- Start from 99 descending (lower risk of accidental ID matches)
     FREE             = 98,
     DEBUG            = 95,
     EVENT            = 94,
     VALIDATE_PROCESS = 93,
     THREAD_CALLBACK  = 92,
     THREAD_ACTION    = 91,
     WAIT_FOR_OBJECTS = 90
  })

  enum("IDTYPE", { type="int", start=1, comment="Types for AllocateID()" },
    "MESSAGE: Message ID's are allocated for the purpose of sending uniquely identifiable messages between tasks.",
    "GLOBAL: Global ID's have no specific association with anything.",
    "FUNCTION: Function ID's are used to track `FUNCTION` types and are assigned to the function ID field."
  )

  enum("TSTATE", { type="char", comment="Indicates the state of a process." },
    "RUNNING: The process is currently executing code.",
    "PAUSED: The process is asleep.",
    "STOPPING: The process is in its termination phase.",
    "TERMINATED: The process has closed.")

  enum("RES", { type="int", start=1 },
    "FREE_SWAP: The total amount of free swap memory.",
    "CONSOLE_FD: Internal reference to the FD of the console.",
    "KEY_STATE: Maintains the state of key qualifiers such as caps-lock and the shift keys.",
    "USER_ID: Internal",
    "DISPLAY_DRIVER: Internal.  Passes the name of the preferred display driver to the display module.",
    "PRIVILEGED_USER: If this value is set to 1, the process will operate in privileged mode (typically this enables full administrator rights).  This feature will only work for Unix processes that are granted admin rights when launched.  Setting the Value to 0 reverts to the user's permission settings.  SetResource() will return an error code indicating the level of success.",
    "PRIVILEGED: This is set to `true` if the process has elevated privileges (such as superuser or administrative rights).",
    "CORE_IDL: Refers to the Core module's compressed IDL string.",
    "STATIC_BUILD: Returns true if the runtime is a statically linked build.",
    "LOG_LEVEL: The current level of log detail (larger numbers indicate more detail).",
    "TOTAL_SHARED_MEMORY: The total amount of shared memory in use (system wide).",
    "MAX_PROCESSES: The maximum number of processes that can be supported at any time.",
    "LOG_DEPTH: The current depth of log messages.",
    "JNI_ENV: Return the current JNI environment string.",
    "THREAD_ID: Return the ID of the current thread.",
    "OPEN_INFO: Pointer to the OpenInfo structure originally used to initialise the system.",
    "EXCEPTION_HANDLER: Internal",
    "NET_PROCESSING: Internal windows resource for Network module",
    "PROCESS_STATE: Life-cycle stage of the running process",
    "TOTAL_MEMORY: The total amount of installed memory.",
    "TOTAL_SWAP: The total amount of available swap space.",
    "CPU_SPEED: The average top-speed of all CPU cores in Mhz.",
    "FREE_MEMORY: The total amount of free memory."
  )

  enum("RP", { type="int", start=1, comment="Path types for SetResourcePath()" },
    "MODULE_PATH: An alternative path leading to the system modules (normally `system:modules/`).  Introduced for platforms such as Android, where modules are stored in asset folders.",
    "SYSTEM_PATH: The path of the `system:` volume, which otherwise defaults to `[root]:system/`.",
    "ROOT_PATH: Overrides the root path, which defaults to the location at which Parasol is installed.")

  flags("CLF", { comment="Flags for the MetaClass." },
    "INHERIT_LOCAL: Inherit the functionality of local objects defined in the class spec.",
    "NO_OWNERSHIP: Objects created will not be tracked to the creating process, nor any parent object (~Core.SetOwner() will not work either).")

  flags("CNF", { comment="Flags for the Config class." },
    "STRIP_QUOTES: Removes quotes from key values that are quote-encapsulated.",
    "AUTO_SAVE: When the configuration object is freed, automatically save the configuration data back to the original file source.",
    "OPTIONAL_FILES: Files are optional (do not fail if a requested file does not exist).",
    "NEW: On initialisation, do not load any data from the referenced configuration file.")

-- Please note that when the user is using an international keyboard, the name of the key will not
-- actually match what the symbol represents for some key types.

  const("KEY", { type="int", comment="Raw key codes" }, {
    A = 1,
    B = 2,
    C = 3,
    D = 4,
    E = 5,
    F = 6,
    G = 7,
    H = 8,
    I = 9,
    J = 10,
    K = 11,
    L = 12,
    M = 13,
    N = 14,
    O = 15,
    P = 16,
    Q = 17,
    R = 18,
    S = 19,
    T = 20,
    U = 21,
    V = 22,
    W = 23,
    X = 24,
    Y = 25,
    Z = 26,
    ONE   = 27,
    TWO   = 28,
    THREE = 29,
    FOUR  = 30,
    FIVE  = 31,
    SIX   = 32,
    SEVEN = 33,
    EIGHT = 34,
    NINE  = 35,
    ZERO  = 36,
    REVERSE_QUOTE = 37,
    MINUS         = 38,
    EQUALS        = 39,
    L_SQUARE      = 40,
    R_SQUARE      = 41,
    SEMI_COLON    = 42,
    APOSTROPHE    = 43,
    COMMA         = 44,
    PERIOD        = 45,
    DOT           = 45, -- Synonym
    SLASH         = 46,
    BACK_SLASH    = 47,
    SPACE         = 48,
    -- Keypad keys
    NP_0        = 49,
    NP_1        = 50,
    NP_2        = 51,
    NP_3        = 52,
    NP_4        = 53,
    NP_5        = 54,
    NP_6        = 55,
    NP_7        = 56,
    NP_8        = 57,
    NP_9        = 58,
    NP_MULTIPLY = 59,
    NP_PLUS     = 60,
    NP_SEPARATOR = 61,
    NP_BAR      = 61, -- Synonym
    NP_MINUS    = 62,
    NP_DECIMAL  = 63,
    NP_DOT      = 63,   -- Synonym
    NP_DIVIDE   = 64,
    L_CONTROL   = 65,   -- Left Control
    R_CONTROL   = 66,   -- Right Control
    HELP        = 67,   -- Help
    L_SHIFT     = 68,   -- Left Shift
    R_SHIFT     = 69,   -- Right Shift
    CAPS_LOCK   = 70,   -- Caps Lock
    PRINT       = 71,   -- Print (not print-screen!)
    L_ALT       = 72,   -- Left Alt
    R_ALT       = 73,   -- Right Alt
    L_COMMAND   = 74,   -- Left Amiga/Win/Special
    R_COMMAND   = 75,   -- Right Amiga/Win/Special
    F1          = 76,   -- Function Key 1
    F2          = 77,   -- Function Key 2
    F3          = 78,   -- Function Key 3
    F4          = 79,   -- Function Key 4
    F5          = 80,   -- Function Key 5
    F6          = 81,   -- Function Key 6
    F7          = 82,   -- Function Key 7
    F8          = 83,   -- Function Key 8
    F9          = 84,   -- Function Key 9
    F10         = 85,   -- Function Key 10
    F11         = 86,   -- Function Key 11
    F12         = 87,   -- Function Key 12
    F13         = 88,   -- Function Key 13
    F14         = 89,   -- Function Key 14
    F15         = 90,   -- Function Key 15
    F16         = 91,   -- Function Key 16
    F17         = 92,   -- Function Key 17
    MACRO       = 93,
    NP_PLUS_MINUS = 94,  -- Plus/Minus on some numeric keypads
    LESS_GREATER  = 95,  -- Less/Greater key on foreign keyboards (no US equivalent?)
    UP          = 96,    -- Cursor Up
    DOWN        = 97,    -- Cursor Down
    RIGHT       = 98,    -- Cursor Right
    LEFT        = 99,    -- Cursor Left
    SCR_LOCK    = 100,   -- Scroll Lock
    PAUSE       = 101,   -- Pause
    WAKE        = 102,   -- Wake
    SLEEP       = 103,   -- Sleep
    POWER       = 104,   -- Power
    BACKSPACE   = 105,   -- Backspace
    TAB         = 106,   -- Tabulation
    ENTER       = 107,   -- Enter/Return
    ESCAPE      = 108,   -- Escape
    DELETE      = 109,   -- Delete
    CLEAR       = 110,   -- Clear
    HOME        = 111,   -- Home
    PAGE_UP     = 112,   -- Page Up
    PAGE_DOWN   = 113,   -- Page Down
    END         = 114,   -- End
    SELECT      = 115,   -- Select
    EXECUTE     = 116,   -- Execute
    INSERT      = 117,   -- Insert
    UNDO        = 118,   -- Undo
    REDO        = 119,   -- Redo
    MENU        = 120,   -- Menu / Shortcut / Application key
    FIND        = 121,   -- Find
    CANCEL      = 122,   -- Cancel
    BREAK       = 123,   -- Break
    NUM_LOCK    = 124,   -- Number lock
    PRT_SCR     = 125,   -- Print Screen
    NP_ENTER    = 126,   -- Numeric keypad enter
    SYSRQ       = 127,
    F18         = 128,
    F19         = 129,
    F20         = 130,
    WIN_CONTROL = 131,   -- Special MS internal control key, doesn't map to a real key
    -- A lot of the following are derived from Android
    VOLUME_UP   = 132,
    VOLUME_DOWN = 133,
    BACK        = 134, -- Not the same as backspace!
    CALL        = 135,
    END_CALL    = 136,
    CAMERA      = 137,
    AT          = 138,
    PLUS        = 139,
    LENS_FOCUS  = 140,
    STOP        = 141,
    NEXT        = 142,
    PREVIOUS    = 143,
    FORWARD     = 144,
    REWIND      = 145,
    MUTE        = 146,
    STAR        = 147, -- As seen on phone keypads
    POUND       = 148, -- As seen on phone keypads
    PLAY        = 149,
    -- End marker
    LIST_END    = 150
  })

  c_insert([[

#ifndef __GNUC__
#define __attribute__(a)
#endif

typedef const std::vector<std::pair<std::string, ULONG>> STRUCTS;
typedef std::map<std::string, std::string, std::less<>> KEYVALUE;

#ifndef STRINGIFY
#define STRINGIFY(x) #x
#define TOSTRING(x) STRINGIFY(x)
#endif

#define MOD_IDL NULL

#ifdef PARASOL_STATIC
__export void CloseCore(void);
__export ERR OpenCore(struct OpenInfo *, struct CoreBase **);
#else
__export struct ModHeader ModHeader;
#endif

#ifdef MOD_NAME
#ifdef PARASOL_STATIC
#define PARASOL_MOD(init,close,open,expunge,IDL,Structures) static struct ModHeader ModHeader(init, close, open, expunge, IDL, Structures, TOSTRING(MOD_NAME));
#else
#define PARASOL_MOD(init,close,open,expunge,IDL,Structures) struct ModHeader ModHeader(init, close, open, expunge, IDL, Structures, TOSTRING(MOD_NAME));
#endif
#define MOD_PATH ("modules:" TOSTRING(MOD_NAME))
#else
#define MOD_NAME NULL
#endif

namespace pf {

template <class T> T roundup(T Num, LONG Alignment) {
   return (Num + Alignment) - (Num % Alignment); // Round up to Alignment value, e.g. (14,8) = 16
}

#ifdef PRINTF64I
  #define PF64 "I64d"
#elif PRINTF64_PRID
  #define PF64 PRId64
#else
  #define PF64 "lld"
#endif

// Use DEBUG_BREAK in critical areas where you would want to break in gdb.  This feature will only be compiled
// in to debug builds.

#ifdef _DEBUG
 #ifdef _MSC_VER
  #define DEBUG_BREAK __debugbreak();
 #else
  #define DEBUG_BREAK raise(SIGTRAP);
 #endif
#else
 #define DEBUG_BREAK
#endif

// Fast float-2-int conversion, with rounding to the nearest integer (F2I) and truncation (F2T)

#if defined(__GNUC__) && defined(__x86__)

INLINE LONG F2I(DOUBLE val) {
   // This will round if the CPU is kept in its default rounding mode
   LONG ret;
   asm ("fistpl %0" : "=m" (ret) : "t" (val) : "st");
   return(ret);
}

#else

INLINE LONG F2I(DOUBLE val) {
   DOUBLE t = val + 6755399441055744.0;
   return *((int *)(&t));
}

#endif

inline LONG F2T(DOUBLE val) // For numbers no larger than 16 bit, standard (LONG) is faster than F2T().
{
   if ((val > 32767.0) or (val < -32767.0)) return((LONG)val);
   else {
      val = val + (68719476736.0 * 1.5);
      if constexpr (std::endian::native == std::endian::little) {
         return ((LONG *)(APTR)&val)[0]>>16;
      }
      else return ((LONG *)&val)[1]>>16;
   }
}

} // namespace

// Structures to pass to OpenCore()

struct OpenTag {
   TOI Tag;
   union {
      LONG Long;
      LARGE Large;
      APTR Pointer;
      CSTRING String;
   } Value;
};

struct OpenInfo {
   CSTRING Name;            // OPF::NAME
   CSTRING *Args;           // OPF::ARGS
   CSTRING SystemPath;      // OPF::SYSTEM_PATH
   CSTRING ModulePath;      // OPF::MODULE_PATH
   CSTRING RootPath;        // OPF::ROOT_PATH
   OpenTag *Options;        // OPF::OPTIONS Typecast to va_list (defined in stdarg.h)
   OPF     Flags;           // OPF::flags need to be set for fields that have been defined in this structure.
   LONG    MaxDepth;        // OPF::MAX_DEPTH
   LONG    Detail;          // OPF::DETAIL
   LONG    ArgCount;        // OPF::ARGS
   ERR     Error;           // OPF::ERROR
};

// Flags for defining fields, methods, actions and functions.  CLASSDEF's can only be used in field definitions for
// classes.  FUNCDEF's can only be used in argument definitions for methods, actions and functions.

#ifdef _LP64
#define FD_PTR64 FD_POINTER
#else
#define FD_PTR64 0
#endif

// Field flags for classes.  These are intended to simplify field definitions, e.g. using FDF_BYTEARRAY combines
// FD_ARRAY with FD_BYTE.  DO NOT use these for function definitions, they are not intended to be compatible.

// Sizes/Types

#define FT_POINTER  FD_POINTER
#define FT_FLOAT    FD_FLOAT
#define FT_LONG     FD_LONG
#define FT_DOUBLE   FD_DOUBLE
#define FT_LARGE    FD_LARGE
#define FT_STRING   (FD_POINTER|FD_STRING)
#define FT_UNLISTED FD_UNLISTED
#define FT_UNIT     FD_UNIT

// Class field definitions.  See core.h for all FD definitions.

#define FDF_BYTE       FD_BYTE
#define FDF_WORD       FD_WORD     // Field is word sized (16-bit)
#define FDF_LONG       FD_LONG     // Field is long sized (32-bit)
#define FDF_DOUBLE     FD_DOUBLE   // Field is double floating point sized (64-bit)
#define FDF_LARGE      FD_LARGE    // Field is large sized (64-bit)
#define FDF_POINTER    FD_POINTER  // Field is an address pointer (typically 32-bit)
#define FDF_ARRAY      FD_ARRAY    // Field is a pointer to an array
#define FDF_CPP        FD_CPP      // Field is a C++ type variant
#define FDF_PTR        FD_POINTER
#define FDF_UNIT       FD_UNIT
#define FDF_SYNONYM    FD_SYNONYM

#define FDF_UNSIGNED    FD_UNSIGNED
#define FDF_FUNCTION    FD_FUNCTION           // sizeof(struct rkFunction) - use FDF_FUNCTIONPTR for sizeof(APTR)
#define FDF_FUNCTIONPTR (FD_FUNCTION|FD_POINTER)
#define FDF_STRUCT      FD_STRUCT
#define FDF_RESOURCE    FD_RESOURCE
#define FDF_OBJECT      (FD_POINTER|FD_OBJECT)   // Field refers to another object
#define FDF_OBJECTID    (FD_LONG|FD_OBJECT)      // Field refers to another object by ID
#define FDF_LOCAL       (FD_POINTER|FD_LOCAL)    // Field refers to a local object
#define FDF_STRING      (FD_POINTER|FD_STRING)   // Field points to a string.  NB: Ideally want to remove the FD_POINTER as it should be redundant
#define FDF_STR         FDF_STRING
#define FDF_SCALED      FD_SCALED
#define FDF_FLAGS       FD_FLAGS                // Field contains flags
#define FDF_ALLOC       FD_ALLOC                // Field is a dynamic allocation - either a memory block or object
#define FDF_LOOKUP      FD_LOOKUP               // Lookup names for values in this field
#define FDF_READ        FD_READ                 // Field is readable
#define FDF_WRITE       FD_WRITE                // Field is writeable
#define FDF_INIT        FD_INIT                 // Field can only be written prior to Init()
#define FDF_SYSTEM      FD_SYSTEM
#define FDF_ERROR       (FD_LONG|FD_ERROR)
#define FDF_RGB         (FD_RGB|FD_BYTE|FD_ARRAY)
#define FDF_R           FD_READ
#define FDF_W           FD_WRITE
#define FDF_RW          (FD_READ|FD_WRITE)
#define FDF_RI          (FD_READ|FD_INIT)
#define FDF_I           FD_INIT
#define FDF_VIRTUAL     FD_VIRTUAL
#define FDF_LONGFLAGS   (FDF_LONG|FDF_FLAGS)
#define FDF_FIELDTYPES  (FD_LONG|FD_DOUBLE|FD_LARGE|FD_POINTER|FD_UNIT|FD_BYTE|FD_ARRAY|FD_FUNCTION)

// These constants have to match the FD* constants << 32

#define TDOUBLE   0x8000000000000000LL
#define TLONG     0x4000000000000000LL
#define TUNIT     0x2000000000000000LL
#define TFLOAT    0x1000000000000000LL // NB: Floats are upscaled to doubles when passed as v-args.
#define TPTR      0x0800000000000000LL
#define TLARGE    0x0400000000000000LL
#define TFUNCTION 0x0200000000000000LL
#define TSTR      0x0080000000000000LL
#define TARRAY    0x0000100000000000LL
#define TSCALE    0x0020000000000000LL
#define TAGEND    0LL
#define TAGDIVERT -1LL
#define TSTRING   TSTR

#define nextutf8(str) if (*(str)) for (++(str); (*(str) & 0xc0) IS 0x80; (str)++);

//********************************************************************************************************************
// FieldValue is used to simplify the initialisation of new objects.

namespace pf {

struct FieldValue {
   ULONG FieldID;
   LONG Type;
   union {
      CSTRING String;
      APTR    Pointer;
      CPTR    CPointer;
      DOUBLE  Double;
      SCALE   Percent;
      LARGE   Large;
      LONG    Long;
   };

   //std::string not included as not compatible with constexpr
   constexpr FieldValue(ULONG pFID, CSTRING pValue)   : FieldID(pFID), Type(FD_STRING), String(pValue) { };
   constexpr FieldValue(ULONG pFID, LONG pValue)      : FieldID(pFID), Type(FD_LONG), Long(pValue) { };
   constexpr FieldValue(ULONG pFID, LARGE pValue)     : FieldID(pFID), Type(FD_LARGE), Large(pValue) { };
   constexpr FieldValue(ULONG pFID, DOUBLE pValue)    : FieldID(pFID), Type(FD_DOUBLE), Double(pValue) { };
   constexpr FieldValue(ULONG pFID, SCALE pValue)     : FieldID(pFID), Type(FD_DOUBLE|FD_SCALED), Percent(pValue) { };
   constexpr FieldValue(ULONG pFID, const FUNCTION &pValue) : FieldID(pFID), Type(FDF_FUNCTIONPTR), CPointer(&pValue) { };
   constexpr FieldValue(ULONG pFID, const FUNCTION *pValue) : FieldID(pFID), Type(FDF_FUNCTIONPTR), CPointer(pValue) { };
   constexpr FieldValue(ULONG pFID, APTR pValue)      : FieldID(pFID), Type(FD_POINTER), Pointer(pValue) { };
   constexpr FieldValue(ULONG pFID, CPTR pValue)      : FieldID(pFID), Type(FD_POINTER), CPointer(pValue) { };
   constexpr FieldValue(ULONG pFID, CPTR pValue, LONG pCustom) : FieldID(pFID), Type(pCustom), CPointer(pValue) { };
};


class FloatRect {
   public:
   DOUBLE X;    // Left-most coordinate
   DOUBLE Y;     // Top coordinate
   DOUBLE Width;   // Right-most coordinate
   DOUBLE Height;  // Bottom coordinate
   FloatRect() { }
   FloatRect(DOUBLE Value) : X(Value), Y(Value), Width(Value), Height(Value) { }
   FloatRect(DOUBLE pX, DOUBLE pY, DOUBLE pWidth, DOUBLE pHeight) : X(pX), Y(pY), Width(pWidth), Height(pHeight) { }
};

}

#include <string.h> // memset()
#include <stdlib.h> // strtol(), strtod()

namespace dmf { // Helper functions for DMF flags
inline bool has(DMF Value, DMF Flags) { return (Value & Flags) != DMF::NIL; }

inline bool hasX(DMF Value) { return (Value & DMF::FIXED_X) != DMF::NIL; }
inline bool hasY(DMF Value) { return (Value & DMF::FIXED_Y) != DMF::NIL; }
inline bool hasWidth(DMF Value) { return (Value & DMF::FIXED_WIDTH) != DMF::NIL; }
inline bool hasHeight(DMF Value) { return (Value & DMF::FIXED_HEIGHT) != DMF::NIL; }
inline bool hasXOffset(DMF Value) { return (Value & DMF::FIXED_X_OFFSET) != DMF::NIL; }
inline bool hasYOffset(DMF Value) { return (Value & DMF::FIXED_Y_OFFSET) != DMF::NIL; }
inline bool hasScaledX(DMF Value) { return (Value & DMF::SCALED_X) != DMF::NIL; }
inline bool hasScaledY(DMF Value) { return (Value & DMF::SCALED_Y) != DMF::NIL; }
inline bool hasScaledWidth(DMF Value) { return (Value & DMF::SCALED_WIDTH) != DMF::NIL; }
inline bool hasScaledHeight(DMF Value) { return (Value & DMF::SCALED_HEIGHT) != DMF::NIL; }
inline bool hasScaledXOffset(DMF Value) { return (Value & DMF::SCALED_X_OFFSET) != DMF::NIL; }
inline bool hasScaledYOffset(DMF Value) { return (Value & DMF::SCALED_Y_OFFSET) != DMF::NIL; }
inline bool hasScaledCenterX(DMF Value) { return (Value & DMF::SCALED_CENTER_X) != DMF::NIL; }
inline bool hasScaledCenterY(DMF Value) { return (Value & DMF::SCALED_CENTER_Y) != DMF::NIL; }
inline bool hasScaledRadiusX(DMF Value) { return (Value & DMF::SCALED_RADIUS_X) != DMF::NIL; }
inline bool hasScaledRadiusY(DMF Value) { return (Value & DMF::SCALED_RADIUS_Y) != DMF::NIL; }

inline bool hasAnyHorizontalPosition(DMF Value) { return (Value & (DMF::FIXED_X|DMF::SCALED_X|DMF::FIXED_X_OFFSET|DMF::SCALED_X_OFFSET)) != DMF::NIL; }
inline bool hasAnyVerticalPosition(DMF Value) { return (Value & (DMF::FIXED_Y|DMF::SCALED_Y|DMF::FIXED_Y_OFFSET|DMF::SCALED_Y_OFFSET)) != DMF::NIL; }
inline bool hasAnyScaledRadius(DMF Value) { return (Value & (DMF::SCALED_RADIUS_X|DMF::SCALED_RADIUS_Y)) != DMF::NIL; }
inline bool hasAnyX(DMF Value) { return (Value & (DMF::SCALED_X|DMF::FIXED_X)) != DMF::NIL; }
inline bool hasAnyY(DMF Value) { return (Value & (DMF::SCALED_Y|DMF::FIXED_Y)) != DMF::NIL; }
inline bool hasAnyWidth(DMF Value) { return (Value & (DMF::SCALED_WIDTH|DMF::FIXED_WIDTH)) != DMF::NIL; }
inline bool hasAnyHeight(DMF Value) { return (Value & (DMF::SCALED_HEIGHT|DMF::FIXED_HEIGHT)) != DMF::NIL; }
inline bool hasAnyXOffset(DMF Value) { return (Value & (DMF::SCALED_X_OFFSET|DMF::FIXED_X_OFFSET)) != DMF::NIL; }
inline bool hasAnyYOffset(DMF Value) { return (Value & (DMF::SCALED_Y_OFFSET|DMF::FIXED_Y_OFFSET)) != DMF::NIL; }
}

]])

  struct("ObjectSignal", { comment="Required in calls to WaitForObjects()." }, [[
     obj Object # Reference to an object to monitor.
  ]])

  struct("ResourceManager", { comment="This structure must be placed at the start of any memory block allocated with the MEM::MANAGED flag.", restrict="c" }, [[
     cstr Name             # The name of the resource.
     fptr(error ptr) Free  # A function that will remove the resource's content when terminated.
  ]])

  struct("FunctionField", { comment="Used by ActionTable and Function structures to declare lists of parameters." }, [[
    cstr Name   # Name of the field
    uint Type   # Type of the field
  ]])

  struct("Function", { comment="Function list array structure" }, [[
    ptr Address     # Pointer to the function entry point
    cstr Name       # Name of the function
    cstruct(*FunctionField) Args  # A list of parameters accepted by the function
  ]])

  struct("ModHeader", { comment="Module file header", restrict="c" }, [[
    int(MHF) Flags                 # Special flags, type of function table wanted from the Core
    cstr Definitions               # Module definition string, usable by run-time languages such as Fluid
    fptr(error obj struct(*CoreBase)) Init # A one-off initialisation routine for when the module is first opened.
    fptr(void obj) Close           # A function that will be called each time the module is closed.
    fptr(error obj) Open           # A function that will be called each time the module is opened.
    fptr(error) Expunge            # Reference to an expunge function to terminate the module.
    cstr Name                      # Name of the module
  ]],
  [[
   STRUCTS *StructDefs;
   class RootModule *Root;
   ModHeader(ERR (*pInit)(OBJECTPTR, struct CoreBase *),
      void  (*pClose)(OBJECTPTR),
      ERR (*pOpen)(OBJECTPTR),
      ERR (*pExpunge)(void),
      CSTRING pDef,
      STRUCTS *pStructs,
      CSTRING pName) {
      Flags         = MHF::DEFAULT;
      Definitions   = pDef;
      StructDefs    = pStructs;
      Init          = pInit;
      Close         = pClose;
      Open          = pOpen;
      Expunge       = pExpunge;
      Name          = pName;
      Root          = NULL;
   }
  ]])

  struct("FieldArray", { comment="Used to construct class blueprints for the MetaClass." }, [[
    cstr   Name      # The name of the field, e.g. `Width`
    ptr    GetField  # `void GetField(*Object, APTR Result);`
    ptr    SetField  # `ERR SetField(*Object, APTR Value);`
    maxint Arg       # Can be a pointer or an integer value
    uint   Flags     # Special flags that describe the field
  ]],
  [[
  template <class G = APTR, class S = APTR, class T = MAXINT> FieldArray(CSTRING pName, ULONG pFlags, G pGetField = NULL, S pSetField = NULL, T pArg = 0) :
     Name(pName), GetField((APTR)pGetField), SetField((APTR)pSetField), Arg((MAXINT)pArg), Flags(pFlags)
     { }
  ]])

  struct("FieldDef", { comment="Used to define constants for field references." }, [[
    cstr Name  # The name of the constant.
    int Value  # The value of the constant.
  ]],
  [[
   template <class T> FieldDef(CSTRING pName, T pValue) : Name(pName), Value(LONG(pValue)) { }
  ]])

  struct("SystemState", { comment="Returned by the GetSystemState() function." }, [[
    cstr Platform      # String-based field indicating the user's platform.  Currently returns `Native`, `Windows`, `OSX` or `Linux`.
    hhandle ConsoleFD  # Internal
    int  Stage         # The current operating stage.  `-1` = Initialising, `0` indicates normal operating status; `1` means that the program is shutting down; `2` indicates a program restart; `3` is for mode switches.
  ]])

  struct("Unit", { }, [[
    double Value  # The unit value.
    uint   Type   # Additional type information
  ]],
  [[
   Unit(double pValue, LONG pType = FD_DOUBLE) : Value(pValue), Type(pType) { }
   Unit() : Value(0), Type(0) { }
   operator double() const { return Value; }
   inline void set(const double pValue) { Value = pValue; }
   inline bool scaled() { return (Type & FD_SCALED) ? true : false; }
   ]])

  -- Structures for defining method and action invocations.

  struct("ActionArray", { }, [[
    ptr Routine     # Pointer to the function entry point
    int ActionCode  # Action identifier
  ]],
  [[
  template <class T> ActionArray(LONG pID, T pRoutine) : Routine((APTR)pRoutine), ActionCode(pID) { }
  ]])

  struct("MethodEntry", { restrict="c" }, [[
    int  MethodID   # Unique method identifier
    ptr  Routine    # The method entry point, defined as `ERR (*Routine)(OBJECTPTR, APTR);`
    cstr Name       # Name of the method
    cstruct(*FunctionField) Args  # List of parameters accepted by the method
    int  Size       # Total byte-size of all accepted parameters when they are assembled as a C structure.
  ]],
  [[
   MethodEntry() : MethodID(0), Routine(NULL), Name(NULL) { }
   MethodEntry(LONG pID, APTR pRoutine, CSTRING pName, const struct FunctionField *pArgs, LONG pSize) :
      MethodID(pID), Routine(pRoutine), Name(pName), Args(pArgs), Size(pSize) { }
  ]])

  struct("ActionTable", { comment="Structure for ActionList" }, [[
    uint Hash   # Hash of the action name.
    int  Size   # Byte-size of the structure for this action.
    cstr Name   # Name of the action.
    cstruct(*FunctionField) Args  # List of fields that are passed to this action.
  ]])

  struct("ChildEntry", { comment="Structure for ListChildren() function" }, [[
    oid ObjectID  # Object ID
    cid ClassID   # The class ID of the referenced object.
  ]])

  struct("Message", { comment="Message header." }, [[
     large Time  # A timestamp acquired from ~Core.PreciseTime() when the message was first passed to ~Core.SendMessage().
     int UID     # A unique identifier automatically created by ~Core.SendMessage().
     int Type    # A message type identifier as defined by the client.
     int Size    # The byte-size of the message data, or zero if no data is provided.
  ]])

  struct("MemInfo", { type="meminfo" }, [[
    ptr  Start         # The starting address of the memory block (does not apply to shared blocks).
    oid  ObjectID      # The object that owns the memory block.
    uint Size          # The size of the memory block.
    int(MEM) Flags     # The type of memory.
    mem   MemoryID     # The unique ID for this block.
    short AccessCount  # Total number of active locks on this block.
  ]])

  struct("MsgHandler", { restrict="c" }, [[
    ptr(struct(MsgHandler)) Prev  # Previous message handler in the chain
    ptr(struct(MsgHandler)) Next  # Next message handler in the chain
    ptr Custom                    # Custom pointer to send to the message handler
    func Function                 # Call this function
    int MsgType                   # Type of message being filtered
  ]])

  struct("CacheFile", { restrict="c", comment="Internal structure for managing files cached by LoadFile()." }, [[
    large TimeStamp   # The file's last-modified timestamp.
    large Size        # Byte size of the cached data.
    large LastUse     # The last time that this file was requested.
    cstr Path         # Pointer to the resolved file path.
    ptr Data          # Pointer to the cached data.
  ]])

  struct("CompressionFeedback", { }, [[
    int(FDB) FeedbackID     # Set to one of the FDB event indicators
    int   Index             # Index of the current file
    cstr  Path              # Name of the current file/path in the archive
    cstr  Dest              # Destination file/path during decompression
    large Progress          # Progress indicator (byte position for the file being de/compressed).
    large OriginalSize      # Original size of the file
    large CompressedSize    # Compressed size of the file
    short Year              # Year of the original file's datestamp.
    short Month             # Month of the original file's datestamp.
    short Day               # Day of the original file's datestamp.
    short Hour              # Hour of the original file's datestamp.
    short Minute            # Minute of the original file's datestamp.
    short Second            # Second of the original file's datestamp.
  ]])

  struct("CompressedItem", { }, [[
    large OriginalSize            # Original size of the file
    large CompressedSize          # Compressed size of the file
    struct(*CompressedItem) Next  # Used only if this is a linked-list.
    cstr Path                     # Path to the file (includes folder prefixes).  Archived folders will include the trailing slash.
    int(PERMIT) Permissions       # Original permissions - see `PERMIT` flags.
    int  UserID                   # Original user ID
    int  GroupID                  # Original group ID
    int  OthersID                 # Original others ID
    int(FL) Flags                 # `FL` flags
    struct(DateTime) Created      # Date and time of the file's creation.
    struct(DateTime) Modified     # Date and time last modified.
  ]],
  [[
    std::unordered_map<std::string, std::string> *Tags;
  ]])

  struct("FileInfo", { comment="Metadata for describing a file." }, [[
    large Size                 # The size of the file's content.
    large TimeStamp            # 64-bit time stamp - usable only for comparison (e.g. sorting).
    struct(*FileInfo) Next     # Next structure in the list, or `NULL`.
    str Name                   # The name of the file.
    int(RDF) Flags             # Additional flags to describe the file.
    int(PERMIT) Permissions    # Standard permission flags.
    int UserID                 # User  ID (Unix systems only).
    int GroupID                # Group ID (Unix systems only).
    struct(DateTime) Created   # The date/time of the file's creation.
    struct(DateTime) Modified  # The date/time of the last file modification.
  ]],
  [[
    std::unordered_map<std::string, std::string> *Tags;
  ]]) -- NB: Private fields can follow this structure.

  struct("DirInfo", { comment="Used by OpenDir() only" }, [[
    struct(*FileInfo) Info # Pointer to a !FileInfo structure
  ]],
  [[
   #ifdef PRV_FILE
   APTR   Driver;
   APTR   prvHandle;        // Directory handle.  If virtual, may store a private data address
   STRING prvPath;          // Original folder location string
   STRING prvResolvedPath;  // Resolved folder location
   RDF    prvFlags;         // OpenFolder() RDF flags
   LONG   prvTotal;         // Total number of items in the folder
   ULONG  prvVirtualID;     // Unique ID (name hash) for a virtual device
   union {
      LONG prvIndex;        // Current index within the folder when scanning
      APTR prvIndexPtr;
   };
   WORD   prvResolveLen;    // Byte length of ResolvedPath
   #endif
  ]])

  -- NB: Duplicated to windows.c
  struct("FileFeedback", { }, [[
    large Size          # Size of the file
    large Position      # Current seek position within the file if moving or copying
    str Path            # Path to the file
    str Dest            # Destination file/path if moving or copying
    int(FBK) FeedbackID # Set to one of the `FBK` values
    char(32) Reserved   # Reserved in case of future expansion
  ]])

  struct("Field", { comment="Used to describe the public fields of a class." }, [[
    maxint Arg         # An option to complement the field type.  Can be a pointer or an integer value
    fptr(error ptr ptr) GetValue # A virtual function that will retrieve the value for this field.
    ptr SetValue       # A virtual function that will set the value for this field.
    fptr(error obj struct(*Field) int cptr int) WriteValue # An internal function for writing to this field.
    cstr Name          # The English name for the field, e.g. `Width`
    uint FieldID       # Provides a fast way of finding fields, e.g. `FID_Width`
    ushort Offset      # Field offset within the object
    ushort Index       # Field array index
    uint Flags         # Special flags that describe the field
  ]]) -- [32/52]

  c_insert([[
struct ScriptArg { // For use with sc::Exec
   CSTRING Name;
   ULONG Type;
   union {
      APTR   Address;
      LONG   Long;
      LARGE  Large;
      DOUBLE Double;
   };

   ScriptArg(CSTRING pName, OBJECTPTR pValue, ULONG pType = FD_OBJECTPTR) : Name(pName), Type(pType), Address((APTR)pValue) { }
   ScriptArg(CSTRING pName, std::string &pValue, ULONG pType = FD_STRING) : Name(pName), Type(pType), Address((APTR)pValue.data()) { }
   ScriptArg(CSTRING pName, const std::string &pValue, ULONG pType = FD_STRING) : Name(pName), Type(pType), Address((APTR)pValue.data()) { }
   ScriptArg(CSTRING pName, CSTRING pValue, ULONG pType = FD_STRING) : Name(pName), Type(pType), Address((APTR)pValue) { }
   ScriptArg(CSTRING pName, APTR pValue, ULONG pType = FD_PTR) : Name(pName), Type(pType), Address(pValue) { }
   ScriptArg(CSTRING pName, LONG pValue, ULONG pType = FD_LONG) : Name(pName), Type(pType), Long(pValue) { }
   ScriptArg(CSTRING pName, ULONG pValue, ULONG pType = FD_LONG) : Name(pName), Type(pType), Long(pValue) { }
   ScriptArg(CSTRING pName, LARGE pValue, ULONG pType = FD_LARGE) : Name(pName), Type(pType), Large(pValue) { }
   ScriptArg(CSTRING pName, DOUBLE pValue, ULONG pType = FD_DOUBLE) : Name(pName), Type(pType), Double(pValue) { }
};
]])

  functionNames(nil,
    "AccessMemory",
    "Action",
    "ActionList",
    "DeleteFile",
    "ResolveClassID",
    "AllocateID",
    "AllocMemory",
    "AccessObject",
    "CheckAction",
    "CheckMemoryExists",
    "CheckObjectExists",
    "InitObject",
    "VirtualVolume",
    "CurrentContext",
    "GetFieldArray",
    "AdjustLogLevel",
    "ReadFileToBuffer",
    "FindObject",
    "FindClass",
    "AnalysePath",
    "FreeResource",
    "GetClassID",
    "GetOwnerID",
    "GetField",
    "GetFieldVariable",
    "CompareFilePaths",
    "GetSystemState",
    "ListChildren",
    "RegisterFD",
    "ResolvePath",
    "MemoryIDInfo",
    "MemoryPtrInfo",
    "NewObject",
    "NotifySubscribers",
    "CopyFile",
    "ProcessMessages",
    "IdentifyFile",
    "ReallocMemory",
    "GetMessage",
    "ReleaseMemory",
    "ResolveClassName",
    "SendMessage",
    "SetOwner",
    "SetContext",
    "SetField",
    "FieldName",
    "ScanDir",
    "SetName",
    "LogReturn",
    "SubscribeAction",
    "SubscribeEvent",
    "SubscribeTimer",
    "UpdateTimer",
    "UnsubscribeAction",
    "UnsubscribeEvent",
    "BroadcastEvent",
    "WaitTime",
    "GetEventID",
    "GenCRC32",
    "GetResource",
    "SetResource",
    "ScanMessages",
    "WaitForObjects",
    "UnloadFile",
    "CreateFolder",
    "LoadFile",
    "SetVolume",
    "DeleteVolume",
    "MoveFile",
    "UpdateMessage",
    "AddMsgHandler",
    "QueueAction",
    "PreciseTime",
    "OpenDir",
    "GetObjectPtr",
    "FindField",
    "GetErrorMsg",
    "GetActionMsg",
    "FuncError",
    "SetArray",
    "LockObject",
    "ReleaseObject",
    "ActionThread",
    "AddInfoTag",
    "SetDefaultPermissions",
    "VLogF",
    "ReadInfoTag",
    "SetResourcePath",
    "CurrentTask",
    "ResolveGroupID",
    "ResolveUserID",
    "CreateLink",
    "ParentContext")

  c_insert([=[

//********************************************************************************************************************

#define END_FIELD FieldArray(NULL, 0)
#define FDEF static const struct FunctionField

template <class T> inline MEMORYID GetMemoryID(T &&A) {
   return ((MEMORYID *)A)[-2];
}

inline ERR DeregisterFD(HOSTHANDLE Handle) {
   return RegisterFD(Handle, RFD::REMOVE|RFD::READ|RFD::WRITE|RFD::EXCEPT|RFD::ALWAYS_CALL, 0, 0);
}

inline APTR GetResourcePtr(RES ID) { return (APTR)(MAXINT)GetResource(ID); }

inline CSTRING to_cstring(const std::string &A) { return A.c_str(); }
constexpr inline CSTRING to_cstring(CSTRING A) { return A; }
#ifndef PRV_CORE_DATA
// These overloaded functions can't be used in the Core as they will confuse the compiler in key areas.

inline ERR SubscribeAction(OBJECTPTR Object, LONG Action, FUNCTION Callback) {
   return SubscribeAction(Object,Action,&Callback);
}

inline ERR SubscribeEvent(LARGE Event, FUNCTION Callback, APTR Custom, APTR *Handle) {
   return SubscribeEvent(Event,&Callback,Custom,Handle);
}

inline ERR SubscribeTimer(DOUBLE Interval, FUNCTION Callback, APTR *Subscription) {
   return SubscribeTimer(Interval,&Callback,Subscription);
}

inline ERR ReleaseMemory(const void *Address) {
   if (!Address) return ERR::NullArgs;
   return ReleaseMemory(((MEMORYID *)Address)[-2]);
}

inline ERR FreeResource(const void *Address) {
   if (!Address) return ERR::NullArgs;
   return FreeResource(((LONG *)Address)[-2]);
}

inline ERR AllocMemory(LONG Size, MEM Flags, APTR Address) {
   return AllocMemory(Size, Flags, (APTR *)Address, NULL);
}

template<class T> inline ERR NewObject(CLASSID ClassID, T **Result) {
   return NewObject(ClassID, NF::NIL, (OBJECTPTR *)Result);
}

template<class T> inline ERR NewLocalObject(CLASSID ClassID, T **Result) {
   return NewObject(ClassID, NF::LOCAL, (OBJECTPTR *)Result);
}

inline ERR MemoryIDInfo(MEMORYID ID, struct MemInfo * MemInfo) {
   return MemoryIDInfo(ID,MemInfo,sizeof(struct MemInfo));
}

inline ERR MemoryPtrInfo(APTR Address, struct MemInfo * MemInfo) {
   return MemoryPtrInfo(Address,MemInfo,sizeof(struct MemInfo));
}

inline ERR QueueAction(LONG Action, OBJECTID ObjectID) {
   return QueueAction(Action, ObjectID, NULL);
}

template <class T> inline ERR SetArray(OBJECTPTR Object, FIELD FieldID, pf::vector<T> &Array)
{
   return SetArray(Object, FieldID, Array.data(), Array.size());
}

template <class T> inline ERR SetArray(OBJECTPTR Object, FIELD FieldID, std::vector<T> &Array)
{
   return SetArray(Object, FieldID, Array.data(), Array.size());
}

template <class T, std::size_t SIZE> inline ERR SetArray(OBJECTPTR Object, FIELD FieldID, std::array<T, SIZE> Array)
{
   return SetArray(Object, FieldID, Array.data(), SIZE);
}
#endif

typedef KEYVALUE ConfigKeys;
typedef std::pair<std::string, ConfigKeys> ConfigGroup;
typedef std::vector<ConfigGroup> ConfigGroups;

namespace pf {

inline void copymem(const void *Src, APTR Dest, std::size_t Length) {
   memmove(Dest, Src, Length);
}

inline void clearmem(APTR Memory, std::size_t Length) {
   if (Memory) memset(Memory, 0, Length);
}

static THREADVAR LONG _tlUniqueThreadID = 0;

[[nodiscard]] inline LONG _get_thread_id(void) {
   if (_tlUniqueThreadID) return _tlUniqueThreadID;
   _tlUniqueThreadID = GetResource(RES::THREAD_ID);
   return _tlUniqueThreadID;
}

// For extremely verbose debug logs, run cmake with -DPARASOL_VLOG=ON

class Log { // C++ wrapper for Parasol's log functionality
   private:
      LONG branches = 0;

   public:
      CSTRING header;

      Log() {
         header = NULL;
      }

      Log(CSTRING Header) {
         header = Header;
      }

      ~Log() {
         while (branches > 0) { branches--; LogReturn(); }
      }

      void branch(CSTRING Message = "", ...) __attribute__((format(printf, 2, 3))) {
         va_list arg;
         va_start(arg, Message);
         VLogF(VLF::API|VLF::BRANCH, header, Message, arg);
         va_end(arg);
         branches++;
      }

      #ifdef _DEBUG
      void traceBranch(CSTRING Message = "", ...) __attribute__((format(printf, 2, 3))) {
         va_list arg;
         va_start(arg, Message);
         VLogF(VLF::TRACE|VLF::BRANCH, header, Message, arg);
         va_end(arg);
         branches++;
      }
      #else
      void traceBranch(CSTRING Message = "", ...) __attribute__((format(printf, 2, 3))) { }
      #endif

      void debranch() {
         branches--;
         LogReturn();
      }

      void app(CSTRING Message, ...) { // Info level, recommended for applications only
         va_list arg;
         va_start(arg, Message);
         VLogF(VLF::INFO, header, Message, arg);
         va_end(arg);
      }

      void msg(CSTRING Message, ...) __attribute__((format(printf, 2, 3))) { // Defaults to API level, recommended for modules
         va_list arg;
         va_start(arg, Message);
         VLogF(VLF::API, header, Message, arg);
         va_end(arg);
      }

      void msg(VLF Flags, CSTRING Message, ...) __attribute__((format(printf, 3, 4))) { // Defaults to API level, recommended for modules
         va_list arg;
         va_start(arg, Message);
         VLogF(Flags, header, Message, arg);
         va_end(arg);
         if ((Flags & VLF::BRANCH) != VLF::NIL) branches++;
      }

      void detail(CSTRING Message, ...) __attribute__((format(printf, 2, 3))) { // Detailed API message
         va_list arg;
         va_start(arg, Message);
         VLogF(VLF::DETAIL, header, Message, arg);
         va_end(arg);
      }

      void pmsg(CSTRING Message, ...) __attribute__((format(printf, 2, 3))) { // "Parent message", uses the scope of the caller
         va_list arg;
         va_start(arg, Message);
         VLogF(VLF::API, NULL, Message, arg);
         va_end(arg);
      }

      void warning(CSTRING Message, ...) __attribute__((format(printf, 2, 3))) {
         va_list arg;
         va_start(arg, Message);
         VLogF(VLF::WARNING, header, Message, arg);
         va_end(arg);
      }

      void error(CSTRING Message, ...) __attribute__((format(printf, 2, 3))) { // NB: Use for messages intended for the user, not the developer
         va_list arg;
         va_start(arg, Message);
         VLogF(VLF::ERROR, header, Message, arg);
         va_end(arg);
      }

      void function(CSTRING Message, ...) __attribute__((format(printf, 2, 3))) { // Equivalent to branch() but without a new branch being created
         va_list arg;
         va_start(arg, Message);
         VLogF(VLF::API|VLF::FUNCTION, header, Message, arg);
         va_end(arg);
      }

      ERR error(ERR Code) { // Technically a warning
         FuncError(header, Code);
         return Code;
      }

      ERR warning(ERR Code) {
         FuncError(header, Code);
         return Code;
      }

      void trace(CSTRING Message, ...) {
         #ifdef _DEBUG
            va_list arg;
            va_start(arg, Message);
            VLogF(VLF::TRACE, header, Message, arg);
            va_end(arg);
         #endif
      }

      void traceWarning(CSTRING Message, ...) {
         #ifdef _DEBUG
            va_list arg;
            va_start(arg, Message);
            VLogF(VLF::WARNING, header, Message, arg);
            va_end(arg);
         #endif
      }

      ERR traceWarning(ERR Code) {
         #ifdef _DEBUG
            FuncError(header, Code);
         #endif
         return Code;
      }
};

class LogLevel {
   private:
      LONG level;
   public:
      LogLevel(LONG Level) : level(Level) {
         AdjustLogLevel(Level);
      }

      ~LogLevel() {
         AdjustLogLevel(-level);
      }
};

} // namespace

//********************************************************************************************************************
// Refer to Object->get() to see what this is about...

template <class T> inline LARGE FIELD_TAG()     { return 0; }
template <> inline LARGE FIELD_TAG<DOUBLE>()    { return TDOUBLE; }
template <> inline LARGE FIELD_TAG<LONG>()      { return TLONG; }
template <> inline LARGE FIELD_TAG<FLOAT>()     { return TFLOAT; }
template <> inline LARGE FIELD_TAG<OBJECTPTR>() { return TPTR; }
template <> inline LARGE FIELD_TAG<APTR>()      { return TPTR; }
template <> inline LARGE FIELD_TAG<LARGE>()     { return TLARGE; }
template <> inline LARGE FIELD_TAG<CSTRING>()   { return TSTRING; }
template <> inline LARGE FIELD_TAG<STRING>()    { return TSTRING; }
template <> inline LARGE FIELD_TAG<SCALE>()     { return TDOUBLE|TSCALE; }

//********************************************************************************************************************
// Header used for all objects.

struct Object { // Must be 64-bit aligned
   union {
      objMetaClass *Class;          // [Public] Class pointer
      class extMetaClass *ExtClass; // [Private] Internal version of the class pointer
   };
   APTR     ChildPrivate;        // Address for the ChildPrivate structure, if allocated
   APTR     CreatorMeta;         // The creator of the object is permitted to store a custom data pointer here.
   struct Object *Owner;      // The owner of this object
   std::atomic_uint64_t NotifyFlags; // Action subscription flags - space for 64 actions max
   std::atomic_uchar ThreadPending; // ActionThread() increments this.
   std::atomic_char Queue;       // Counter of locks gained by incQueue()
   std::atomic_char SleepQueue;  // For the use of LockObject() only
   BYTE ActionDepth;             // Incremented each time an action or method is called on the object
   OBJECTID UID;                 // Unique object identifier
   NF       Flags;               // Object flags
   volatile LONG  ThreadID;      // Managed by locking functions
   char Name[MAX_NAME_LEN];      // The name of the object.  NOTE: This value can be adjusted to ensure that the struct is always 8-bit aligned.
   std::atomic_bool Locked;      // Set if locked by AccessObject()/LockObject()

   inline bool initialised() { return (Flags & NF::INITIALISED) != NF::NIL; }
   inline bool defined(NF pFlags) { return (Flags & pFlags) != NF::NIL; }
   inline bool isSubClass();
   inline OBJECTID ownerID() { return Owner ? Owner->UID : 0; }
   inline CLASSID classID();
   inline CLASSID baseClassID();
   inline NF flags() { return Flags; }

   CSTRING className();

   inline bool collecting() { // Is object being freed or marked for collection?
      return (Flags & (NF::FREE|NF::COLLECT|NF::FREE_ON_UNLOCK)) != NF::NIL;
   }

   inline bool terminating() { // Is object currently being freed?
      return (Flags & NF::FREE) != NF::NIL;
   }

   // Use lock() to quickly obtain an object lock without a call to LockObject()

   inline ERR lock() {
      if (++Queue IS 1) {
         ThreadID = pf::_get_thread_id();
         return ERR::Okay;
      }
      else {
         if (ThreadID IS pf::_get_thread_id()) return ERR::Okay; // If this is for the same thread then it's a nested lock, so there's no issue.
         --Queue; // Restore the lock count
         return LockObject(this, -1); // Can fail if object is marked for deletion.
      }
   }

   inline void unlock() {
      // Prefer to use ReleaseObject() if there are threads that need to be woken
      if (SleepQueue.load() > 0) ReleaseObject(this);
      else --Queue;
   }

   inline bool hasOwner(OBJECTID ID) { // Return true if ID has ownership.
      auto obj = this->Owner;
      while ((obj) and (obj->UID != ID)) obj = obj->Owner;
      return obj ? true : false;
   }

   inline ERR setArray(ULONG FieldID, FLOAT *Value, LONG Size)  { return SetArray(this, (FIELD)FieldID|TFLOAT, Value, Size); }
   inline ERR setArray(ULONG FieldID, DOUBLE *Value, LONG Size) { return SetArray(this, (FIELD)FieldID|TDOUBLE, Value, Size); }
   inline ERR setArray(ULONG FieldID, LONG *Value, LONG Size)   { return SetArray(this, (FIELD)FieldID|TLONG, Value, Size); }
   inline ERR setArray(ULONG FieldID, LARGE *Value, LONG Size)  { return SetArray(this, (FIELD)FieldID|TLARGE, Value, Size); }

   inline ERR set(ULONG FieldID, int Value)             { return SetField(this, (FIELD)FieldID|TLONG, Value); }
   inline ERR set(ULONG FieldID, long Value)            { return SetField(this, (FIELD)FieldID|TLONG, Value); }
   inline ERR set(ULONG FieldID, unsigned int Value)    { return SetField(this, (FIELD)FieldID|TLONG, Value); }
   inline ERR set(ULONG FieldID, LARGE Value)           { return SetField(this, (FIELD)FieldID|TLARGE, Value); }
   inline ERR set(ULONG FieldID, DOUBLE Value)          { return SetField(this, (FIELD)FieldID|TDOUBLE, Value); }
   inline ERR set(ULONG FieldID, const FUNCTION *Value) { return SetField(this, (FIELD)FieldID|TFUNCTION, Value); }
   inline ERR set(ULONG FieldID, const char *Value)     { return SetField(this, (FIELD)FieldID|TSTRING, Value); }
   inline ERR set(ULONG FieldID, const unsigned char *Value) { return SetField(this, (FIELD)FieldID|TSTRING, Value); }
   inline ERR set(ULONG FieldID, const std::string &Value)   { return SetField(this, (FIELD)FieldID|TSTRING, Value.c_str()); }
   inline ERR set(ULONG FieldID, const Unit *Value)          { return SetField(this, (FIELD)FieldID|TUNIT, Value); }
   // Works both for regular data pointers and function pointers if field is defined correctly.
   inline ERR set(ULONG FieldID, const void *Value) { return SetField(this, (FIELD)FieldID|TPTR, Value); }

   inline ERR setScale(ULONG FieldID, DOUBLE Value) { return SetField(this, (FIELD)FieldID|TDOUBLE|TSCALE, Value); }

   // There are two mechanisms for retrieving object values; the first allows the value to be retrieved with an error
   // code and the value itself; the second ignores the error code and returns a value that could potentially be invalid.

   inline ERR get(ULONG FieldID, LONG *Value)     { return GetField(this, (FIELD)FieldID|TLONG, Value); }
   inline ERR get(ULONG FieldID, LARGE *Value)    { return GetField(this, (FIELD)FieldID|TLARGE, Value); }
   inline ERR get(ULONG FieldID, DOUBLE *Value)   { return GetField(this, (FIELD)FieldID|TDOUBLE, Value); }
   inline ERR get(ULONG FieldID, STRING *Value)   { return GetField(this, (FIELD)FieldID|TSTRING, Value); }
   inline ERR get(ULONG FieldID, CSTRING *Value)  { return GetField(this, (FIELD)FieldID|TSTRING, Value); }
   inline ERR get(ULONG FieldID, Unit *Value)     { return GetField(this, (FIELD)FieldID|TUNIT, Value); }
   inline ERR getPtr(ULONG FieldID, APTR Value)   { return GetField(this, (FIELD)FieldID|TPTR, Value); }
   inline ERR getScale(ULONG FieldID, DOUBLE *Value) { return GetField(this, (FIELD)FieldID|TDOUBLE|TSCALE, Value); }

   template <class T> inline T get(ULONG FieldID) { // Validity of the result is not guaranteed
      T val;
      GetField(this, (FIELD)FieldID|FIELD_TAG<T>(), &val);
      return val;
   };

   template <typename... Args> ERR setFields(Args&&... pFields) {
      pf::Log log("setFields");

      lock();

      std::initializer_list<pf::FieldValue> Fields = { std::forward<Args>(pFields)... };

      auto ctx = CurrentContext();
      for (auto &f : Fields) {
         OBJECTPTR target;
         if (auto field = FindField(this, f.FieldID, &target)) {
            if ((!(field->Flags & (FD_INIT|FD_WRITE))) and (ctx != target)) {
               log.warning("%s.%s is immutable.", className(), field->Name);
            }
            else if ((field->Flags & FD_INIT) and (target->initialised()) and (ctx != target)) {
               log.warning("%s.%s is init-only.", className(), field->Name);
            }
            else {
               if (target != this) target->lock();

               ERR error;
               if (f.Type & (FD_POINTER|FD_STRING|FD_ARRAY|FD_FUNCTION|FD_UNIT)) {
                  error = field->WriteValue(target, field, f.Type, f.Pointer, 0);
               }
               else if (f.Type & (FD_DOUBLE|FD_FLOAT)) {
                  error = field->WriteValue(target, field, f.Type, &f.Double, 1);
               }
               else if (f.Type & FD_LARGE) {
                  error = field->WriteValue(target, field, f.Type, &f.Large, 1);
               }
               else error = field->WriteValue(target, field, f.Type, &f.Long, 1);

               if (target != this) target->unlock();

               // NB: NoSupport is considered a 'soft' error that does not warrant failure.

               if ((error != ERR::Okay) and (error != ERR::NoSupport)) {
                  log.warning("%s.%s: %s", target->className(), field->Name, GetErrorMsg(error));
                  unlock();
                  return error;
               }
            }
         }
         else {
            unlock();
            return log.warning(ERR::UnsupportedField);
         }
      }

      unlock();
      return ERR::Okay;
   }

} __attribute__ ((aligned (8)));

namespace pf {

template<class T = Object>
class Create {
   private:
      T *obj;

   public:
      ERR error;

      // Return an unscoped direct object pointer.  NB: Globals are still tracked to their owner; use untracked() if
      // you don't want this.

      template <typename... Args> static T * global(Args&&... Fields) {
         pf::Create<T> object = { std::forward<Args>(Fields)... };
         if (object.ok()) {
            auto result = *object;
            object.obj = NULL;
            return result;
         }
         else return NULL;
      }

      inline static T * global(const std::initializer_list<FieldValue> Fields) {
         pf::Create<T> object(Fields);
         if (object.ok()) {
            auto result = *object;
            object.obj = NULL;
            return result;
         }
         else return NULL;
      }

      // Return an unscoped local object (suitable for class allocations only).

      template <typename... Args> static T * local(Args&&... Fields) {
         pf::Create<T> object({ std::forward<Args>(Fields)... }, NF::LOCAL);
         if (object.ok()) return *object;
         else return NULL;
      }

      inline static T * local(const std::initializer_list<FieldValue> Fields) {
         pf::Create<T> object(Fields, NF::LOCAL);
         if (object.ok()) return *object;
         else return NULL;
      }

      // Return an unscoped and untracked object pointer.

      template <typename... Args> static T * untracked(Args&&... Fields) {
         pf::Create<T> object({ std::forward<Args>(Fields)... }, NF::UNTRACKED);
         if (object.ok()) return *object;
         else return NULL;
      }

      inline static T * untracked(const std::initializer_list<FieldValue> Fields) {
         pf::Create<T> object(Fields, NF::UNTRACKED);
         if (object.ok()) return *object;
         else return NULL;
      }

      // Create a scoped object that is not initialised.

      Create(NF Flags = NF::NIL) : obj(NULL), error(ERR::NewObject) {
         if (NewObject(T::CLASS_ID, Flags, (Object **)&obj) IS ERR::Okay) {
            error = ERR::Okay;
         }
      }

      // Create a scoped object that is fully initialised.

      Create(const std::initializer_list<FieldValue> Fields, NF Flags = NF::NIL) : obj(NULL), error(ERR::Failed) {
         pf::Log log("CreateObject");
         log.branch(T::CLASS_NAME);

         if (NewObject(T::CLASS_ID, NF::SUPPRESS_LOG|Flags, (Object **)&obj) IS ERR::Okay) {
            for (auto &f : Fields) {
               OBJECTPTR target;
               if (auto field = FindField(obj, f.FieldID, &target)) {
                  if (!(field->Flags & (FD_WRITE|FD_INIT))) {
                     error = log.warning(ERR::NoFieldAccess);
                     return;
                  }
                  else {
                     target->lock();

                     if (f.Type & (FD_POINTER|FD_STRING|FD_ARRAY|FD_FUNCTION|FD_UNIT)) {
                        error = field->WriteValue(target, field, f.Type, f.Pointer, 0);
                     }
                     else if (f.Type & (FD_DOUBLE|FD_FLOAT)) {
                        error = field->WriteValue(target, field, f.Type, &f.Double, 1);
                     }
                     else if (f.Type & FD_LARGE) {
                        error = field->WriteValue(target, field, f.Type, &f.Large, 1);
                     }
                     else error = field->WriteValue(target, field, f.Type, &f.Long, 1);

                     target->unlock();

                     // NB: NoSupport is considered a 'soft' error that does not warrant failure.

                     if ((error != ERR::Okay) and (error != ERR::NoSupport)) return;
                  }
               }
               else {
                  log.warning("%s.%s field not supported.", T::CLASS_NAME, FieldName(f.FieldID));
                  error = log.warning(ERR::UnsupportedField);
                  return;
               }
            }

            if ((error = InitObject(obj)) != ERR::Okay) {
               FreeResource(obj->UID);
               obj = NULL;
            }
         }
         else error = ERR::NewObject;
      }

      ~Create() {
         if (obj) {
            if (obj->initialised()) {
               if ((obj->Object::Flags & (NF::UNTRACKED|NF::LOCAL)) != NF::NIL)  {
                  return; // Detected a successfully created unscoped object
               }
            }
            FreeResource(obj->UID);
            obj = NULL;
         }
      }

      T * operator->() { return obj; }; // Promotes underlying methods and fields
      T * & operator*() { return obj; }; // To allow object pointer referencing when calling functions

      inline bool ok() { return error == ERR::Okay; }
};
}

inline OBJECTID CurrentTaskID() { return ((OBJECTPTR)CurrentTask())->UID; }
inline APTR SetResourcePtr(RES Res, APTR Value) { return (APTR)(MAXINT)(SetResource(Res, (MAXINT)Value)); }

// Action and Notification Structures

struct acClipboard     { static const ACTIONID id = AC_Clipboard; CLIPMODE Mode; };
struct acCopyData      { static const ACTIONID id = AC_CopyData; OBJECTPTR Dest; };
struct acDataFeed      { static const ACTIONID id = AC_DataFeed; OBJECTPTR Object; DATA Datatype; const void *Buffer; LONG Size; };
struct acDragDrop      { static const ACTIONID id = AC_DragDrop; OBJECTPTR Source; LONG Item; CSTRING Datatype; };
struct acDraw          { static const ACTIONID id = AC_Draw; LONG X; LONG Y; LONG Width; LONG Height; };
struct acGetKey        { static const ACTIONID id = AC_GetKey; CSTRING Key; STRING Value; LONG Size; };
struct acMove          { static const ACTIONID id = AC_Move; DOUBLE DeltaX; DOUBLE DeltaY; DOUBLE DeltaZ; };
struct acMoveToPoint   { static const ACTIONID id = AC_MoveToPoint; DOUBLE X; DOUBLE Y; DOUBLE Z; MTF Flags; };
struct acNewChild      { static const ACTIONID id = AC_NewChild; OBJECTPTR Object; };
struct acNewOwner      { static const ACTIONID id = AC_NewOwner; OBJECTPTR NewOwner; };
struct acRead          { static const ACTIONID id = AC_Read; APTR Buffer; LONG Length; LONG Result; };
struct acRedimension   { static const ACTIONID id = AC_Redimension; DOUBLE X; DOUBLE Y; DOUBLE Z; DOUBLE Width; DOUBLE Height; DOUBLE Depth; };
struct acRedo          { static const ACTIONID id = AC_Redo; LONG Steps; };
struct acRename        { static const ACTIONID id = AC_Rename; CSTRING Name; };
struct acResize        { static const ACTIONID id = AC_Resize; DOUBLE Width; DOUBLE Height; DOUBLE Depth; };
struct acSaveImage     { static const ACTIONID id = AC_SaveImage; OBJECTPTR Dest; union { CLASSID ClassID; CLASSID Class; }; };
struct acSaveToObject  { static const ACTIONID id = AC_SaveToObject; OBJECTPTR Dest; union { CLASSID ClassID; CLASSID Class; }; };
struct acSeek          { static const ACTIONID id = AC_Seek; DOUBLE Offset; SEEK Position; };
struct acSetKey        { static const ACTIONID id = AC_SetKey; CSTRING Key; CSTRING Value; };
struct acUndo          { static const ACTIONID id = AC_Undo; LONG Steps; };
struct acWrite         { static const ACTIONID id = AC_Write; CPTR Buffer; LONG Length; LONG Result; };

// Action Macros

inline ERR acActivate(OBJECTPTR Object) { return Action(AC_Activate,Object,NULL); }
inline ERR acClear(OBJECTPTR Object) { return Action(AC_Clear,Object,NULL); }
inline ERR acDeactivate(OBJECTPTR Object) { return Action(AC_Deactivate,Object,NULL); }
inline ERR acDisable(OBJECTPTR Object) { return Action(AC_Disable,Object,NULL); }
inline ERR acDraw(OBJECTPTR Object) { return Action(AC_Draw,Object,NULL); }
inline ERR acEnable(OBJECTPTR Object) { return Action(AC_Enable,Object,NULL); }
inline ERR acFlush(OBJECTPTR Object) { return Action(AC_Flush,Object,NULL); }
inline ERR acFocus(OBJECTPTR Object) { return Action(AC_Focus,Object,NULL); }
inline ERR acHide(OBJECTPTR Object) { return Action(AC_Hide,Object,NULL); }
inline ERR acLock(OBJECTPTR Object) { return Action(AC_Lock,Object,NULL); }
inline ERR acLostFocus(OBJECTPTR Object) { return Action(AC_LostFocus,Object,NULL); }
inline ERR acMoveToBack(OBJECTPTR Object) { return Action(AC_MoveToBack,Object,NULL); }
inline ERR acMoveToFront(OBJECTPTR Object) { return Action(AC_MoveToFront,Object,NULL); }
inline ERR acNext(OBJECTPTR Object) { return Action(AC_Next,Object,NULL); }
inline ERR acPrev(OBJECTPTR Object) { return Action(AC_Prev,Object,NULL); }
inline ERR acQuery(OBJECTPTR Object) { return Action(AC_Query,Object,NULL); }
inline ERR acRefresh(OBJECTPTR Object) { return Action(AC_Refresh, Object, NULL); }
inline ERR acReset(OBJECTPTR Object) { return Action(AC_Reset,Object,NULL); }
inline ERR acSaveSettings(OBJECTPTR Object) { return Action(AC_SaveSettings,Object,NULL); }
inline ERR acShow(OBJECTPTR Object) { return Action(AC_Show,Object,NULL); }
inline ERR acSignal(OBJECTPTR Object) { return Action(AC_Signal,Object,NULL); }
inline ERR acUnlock(OBJECTPTR Object) { return Action(AC_Unlock,Object,NULL); }

inline ERR acClipboard(OBJECTPTR Object, CLIPMODE Mode) {
   struct acClipboard args = { Mode };
   return Action(AC_Clipboard, Object, &args);
}

inline ERR acDragDrop(OBJECTPTR Object, OBJECTPTR Source, LONG Item, CSTRING Datatype) {
   struct acDragDrop args = { Source, Item, Datatype };
   return Action(AC_DragDrop, Object, &args);
}

inline ERR acDrawArea(OBJECTPTR Object, LONG X, LONG Y, LONG Width, LONG Height) {
   struct acDraw args = { X, Y, Width, Height };
   return Action(AC_Draw, Object, &args);
}

inline ERR acDataFeed(OBJECTPTR Object, OBJECTPTR Sender, DATA Datatype, const void *Buffer, LONG Size) {
   struct acDataFeed args = { Sender, Datatype, Buffer, Size };
   return Action(AC_DataFeed, Object, &args);
}

inline ERR acGetKey(OBJECTPTR Object, CSTRING Key, STRING Value, LONG Size) {
   struct acGetKey args = { Key, Value, Size };
   ERR error = Action(AC_GetKey, Object, &args);
   if ((error != ERR::Okay) and (Value)) Value[0] = 0;
   return error;
}

inline ERR acMove(OBJECTPTR Object, DOUBLE X, DOUBLE Y, DOUBLE Z) {
   struct acMove args = { X, Y, Z };
   return Action(AC_Move, Object, &args);
}

inline ERR acRead(OBJECTPTR Object, APTR Buffer, LONG Bytes, LONG *Read) {
   struct acRead read = { (BYTE *)Buffer, Bytes };
   if (auto error = Action(AC_Read, Object, &read); error IS ERR::Okay) {
      if (Read) *Read = read.Result;
      return ERR::Okay;
   }
   else {
      if (Read) *Read = 0;
      return error;
   }
}

inline ERR acRedo(OBJECTPTR Object, LONG Steps = 1) {
   struct acRedo args = { Steps };
   return Action(AC_Redo, Object, &args);
}

inline ERR acRedimension(OBJECTPTR Object, DOUBLE X, DOUBLE Y, DOUBLE Z, DOUBLE Width, DOUBLE Height, DOUBLE Depth) {
   struct acRedimension args = { X, Y, Z, Width, Height, Depth };
   return Action(AC_Redimension, Object, &args);
}

inline ERR acRename(OBJECTPTR Object, CSTRING Name) {
   struct acRename args = { Name };
   return Action(AC_Rename, Object, &args);
}

inline ERR acResize(OBJECTPTR Object, DOUBLE Width, DOUBLE Height, DOUBLE Depth) {
   struct acResize args = { Width, Height, Depth };
   return Action(AC_Resize, Object, &args);
}

inline ERR acMoveToPoint(OBJECTPTR Object, DOUBLE X, DOUBLE Y, DOUBLE Z, MTF Flags) {
   struct acMoveToPoint moveto = { X, Y, Z, Flags };
   return Action(AC_MoveToPoint, Object, &moveto);
}

inline ERR acSaveImage(OBJECTPTR Object, OBJECTPTR Dest, CLASSID ClassID = CLASSID::NIL) {
   struct acSaveImage args = { Dest, { ClassID } };
   return Action(AC_SaveImage, Object, &args);
}

inline ERR acSaveToObject(OBJECTPTR Object, OBJECTPTR Dest, CLASSID ClassID = CLASSID::NIL) {
   struct acSaveToObject args = { Dest, { ClassID } };
   return Action(AC_SaveToObject, Object, &args);
}

inline ERR acSeek(OBJECTPTR Object, DOUBLE Offset, SEEK Position) {
   struct acSeek args = { Offset, Position };
   return Action(AC_Seek, Object, &args);
}

inline ERR acSetKeys(OBJECTPTR Object, CSTRING tags, ...) {
   struct acSetKey args;
   va_list list;

   va_start(list, tags);
   while ((args.Key = va_arg(list, STRING)) != TAGEND) {
      args.Value = va_arg(list, STRING);
      if (Action(AC_SetKey, Object, &args) != ERR::Okay) {
         va_end(list);
         return ERR::Failed;
      }
   }
   va_end(list);
   return ERR::Okay;
}

inline ERR acUndo(OBJECTPTR Object, LONG Steps) {
   struct acUndo args = { Steps };
   return Action(AC_Undo, Object, &args);
}

inline ERR acWrite(OBJECTPTR Object, CPTR Buffer, LONG Bytes, LONG *Result = NULL) {
   struct acWrite write = { (BYTE *)Buffer, Bytes };
   if (auto error = Action(AC_Write, Object, &write); error IS ERR::Okay) {
      if (Result) *Result = write.Result;
      return error;
   }
   else {
      if (Result) *Result = 0;
      return error;
   }
}

inline LONG acWriteResult(OBJECTPTR Object, CPTR Buffer, LONG Bytes) {
   struct acWrite write = { (BYTE *)Buffer, Bytes };
   if (Action(AC_Write, Object, &write) IS ERR::Okay) return write.Result;
   else return 0;
}

#define acSeekStart(a,b)    acSeek((a),(b),SEEK::START)
#define acSeekEnd(a,b)      acSeek((a),(b),SEEK::END)
#define acSeekCurrent(a,b)  acSeek((a),(b),SEEK::CURRENT)

inline ERR acSetKey(OBJECTPTR Object, CSTRING Key, CSTRING Value) {
   struct acSetKey args = { Key, Value };
   return Action(AC_SetKey, Object, &args);
}

#define GetKey(a,b,c,d)  acGetKey(a,b,c,d)
#define SetKey(a,b,c)    acSetKey(a,b,c)
]=])

  methods("MetaClass", "mc", {
    { id=1, name="FindField" }
  })

  class("MetaClass", { src="../classes/class_metaclass.cpp" }, [[
    double ClassVersion    # Version of the class
    cstruct(*FieldArray) Fields  # Original field array supplied by the module.
    array(struct(Field)) Dictionary # Field lookup by ID
    cstr ClassName         # Name of the class
    cstr FileExtension     # File extension that is supported by this class.
    cstr FileDescription   # File description
    cstr FileHeader        # Internal file header for identifying the file
    cstr Path              # Module path to the class
    int Size               # Byte-size of the class when produced as an object
    int(CLF) Flags         # Special flags
    cid ClassID            # ID of this class
    cid BaseClassID        # Base-class ID
    int OpenCount          # Number of objects allocated to this class
    int(CCF) Category      # Assigned category
  ]])

c_insert([[
inline bool Object::isSubClass() { return Class->ClassID != Class->BaseClassID; }
inline CLASSID Object::classID() { return Class->ClassID; }
inline CLASSID Object::baseClassID() { return Class->BaseClassID; }
]])

  class("StorageDevice", { src="../classes/class_storagedevice.cpp" }, [[
    large(DEVICE) DeviceFlags  # Flags identifying the type of media
    large DeviceSize           # Size of the device
    large BytesFree            # Bytes available to the user
    large BytesUsed            # Bytes already used
  ]])

  methods("File", "Fl", {
    { id=1,  name="StartStream" },
    { id=2,  name="StopStream" },
    { id=3,  name="Delete" },
    { id=4,  name="Move" },
    { id=5,  name="Copy" },
    { id=6,  name="SetDate" },
    { id=7,  name="ReadLine" },
    { id=8,  name="BufferContent" },
    { id=9,  name="Next" },
    { id=10, name="Watch" }
  })

  class("File", { version=1.2, src="../classes/class_file.cpp", output="../classes/class_file_def.c" }, [[
    large     Position  # The current read/write byte position in a file.
    int(FL)   Flags     # File flags and options.
    int       Static    # Set to `true` if a file object should be static.
    oid       Target    # Specifies a surface ID to target for user feedback and dialog boxes.
    ptr(char) Buffer    # Points to the internal data buffer if the file content is held in memory.
  ]],
  nil,
  [[
   inline CSTRING readLine() {
      struct fl::ReadLine args;
      if (Action(fl::ReadLine::id, this, &args) IS ERR::Okay) return args.Result;
      else return NULL;
   }
  ]])

  methods("config", "Cfg", {
    { id=1,  name="ReadValue" },
    { id=2,  name="Set" },
    { id=3,  name="WriteValue" },
    { id=4,  name="DeleteKey" },
    { id=5,  name="DeleteGroup" },
    { id=6,  name="GetGroupFromIndex" },
    { id=7,  name="SortByKey" },
    { id=9,  name="MergeFile" },
    { id=10, name="Merge" }
  })

  class("Config", { src="../classes/class_config.cpp", output="../classes/class_config_def.c" }, [[
    str Path          # The location pointer
    str KeyFilter     # Enables key filtering, removing any unwanted keys on load.
    str GroupFilter   # Enables group filtering, removing any unwanted groups on load.
    int(CNF) Flags    # Not currently in use
  ]],
  nil,
  [[
   ConfigGroups *Groups;

   // For C++ only, these read variants avoid method calls for speed, but apply identical logic.

   inline ERR read(std::string_view pGroup, std::string_view pKey, DOUBLE &pValue) {
      for (auto& [group, keys] : Groups[0]) {
         if ((!pGroup.empty()) and (group.compare(pGroup))) continue;
         if (pKey.empty()) pValue = strtod(keys.cbegin()->second.c_str(), NULL);
         else if (auto it = keys.find(pKey); it != keys.end()) pValue = strtod(it->second.c_str(), NULL);
         else return ERR::Search;
         return ERR::Okay;
      }
      return ERR::Search;
   }

   inline ERR read(std::string_view pGroup, std::string_view pKey, LONG &pValue) {
      for (auto& [group, keys] : Groups[0]) {
         if ((!pGroup.empty()) and (group.compare(pGroup))) continue;
         if (pKey.empty()) pValue = strtol(keys.cbegin()->second.c_str(), NULL, 0);
         else if (auto it = keys.find(pKey); it != keys.end()) pValue = strtol(it->second.c_str(), NULL, 0);
         else return ERR::Search;
         return ERR::Okay;
      }
      return ERR::Search;
   }

   inline ERR read(std::string_view pGroup, std::string_view pKey, std::string &pValue) {
      for (auto & [group, keys] : Groups[0]) {
         if ((!pGroup.empty()) and (group.compare(pGroup))) continue;
         if (pKey.empty()) pValue = keys.cbegin()->second;
         else if (auto it = keys.find(pKey); it != keys.end()) pValue = it->second;
         else return ERR::Search;
         return ERR::Okay;
      }
      return ERR::Search;
   }

   inline ERR write(std::string_view Group, std::string_view Key, std::string_view Value) {
      ConfigGroups &groups = *Groups;
      for (auto& [group, keys] : groups) {
         if (!group.compare(Group)) {
            if (auto it = keys.find(Key); it != keys.end()) {
               it->second.assign(Value);
               return ERR::Okay;
            }
         }
      }

      auto &new_group = Groups->emplace_back();
      new_group.first.assign(Group);
      new_group.second.emplace(Key, Value);
      return ERR::Okay;
   }
  ]])

  methods("Script", "Sc", {
    { id=1, name="Exec" },
    { id=2, name="DerefProcedure" },
    { id=3, name="Callback" },
    { id=4, name="GetProcedureID" }
  })

  class("Script", { src={ "../classes/class_script.cpp" }, output="../classes/class_script_def.c" }, [[
    oid Target           # The object that script objects must be initialised to, e.g. for obj.new()
    int(SCF) Flags       # Optional flags
    error Error          # If an error occurred, this field will indicate the error number
    int CurrentLine      # Current line being executed, or failed line if script execution terminated
    int LineOffset       # An optional offset to use when reporting line numbers
  ]],
  [[
   LARGE    ProcedureID;          // For callbacks
   KEYVALUE Vars; // Global parameters
   STRING   *Results;
   char     Language[4];          // 3-character language code, null-terminated
   const ScriptArg *ProcArgs;     // Procedure args - applies during Exec
   STRING   Path;                 // File location of the script
   STRING   String;
   STRING   WorkingPath;
   STRING   ErrorString;
   CSTRING  Procedure;
   STRING   CacheFile;
   LONG     ActivationCount;      // Incremented every time the script is activated.
   LONG     ResultsTotal;
   LONG     TotalArgs;            // Total number of ProcArgs
   char     LanguageDir[32];      // Directory to use for language files
   OBJECTID ScriptOwnerID;
  ]])

  c_insert([[
namespace sc {
template <std::size_t SIZE> ERR Call(const FUNCTION &Function, const std::array<ScriptArg, SIZE> &Args) noexcept {
   struct Callback args = { Function.ProcedureID, Args.data(), LONG(std::ssize(Args)), ERR::Okay };
   return Action(sc::Callback::id, Function.Context, &args);
}

template <std::size_t SIZE> ERR Call(const FUNCTION &Function, const std::array<ScriptArg, SIZE> &Args, ERR &Result) noexcept {
   struct Callback args = { Function.ProcedureID, Args.data(), LONG(std::ssize(Args)), ERR::Okay };
   ERR error = Action(sc::Callback::id, Function.Context, &args);
   Result = args.Error;
   return(error);
}

inline ERR Call(const FUNCTION &Function) noexcept {
   struct Callback args = { Function.ProcedureID, NULL, 0, ERR::Okay };
   return Action(sc::Callback::id, Function.Context, &args);
}

inline ERR Call(const FUNCTION &Function, ERR &Result) noexcept {
   struct Callback args = { Function.ProcedureID, NULL, 0, ERR::Okay };
   ERR error = Action(sc::Callback::id, Function.Context, &args);
   Result = args.Error;
   return(error);
}
} // namespace
  ]])

  struct("ActionEntry", { restrict='c', comment="For the Task Actions field." }, [[
     fptr(error obj ptr) PerformAction # Pointer to a custom action hook.
  ]])

  methods("Task", "Task", {
    { id=1, name="Expunge" },
    { id=2, name="AddArgument" },
    { id=3, name="Quit" },
    { id=4, name="GetEnv" },
    { id=5, name="SetEnv" }
  })

  class("Task", { src="../classes/class_task.cpp", output="../classes/class_task_def.c" }, [[
    double TimeOut
    int(TSF) Flags
    int ReturnCode
    int ProcessID    # Native process ID of the activated task
  ]])

  methods("Thread", "Th", {
    { id=1, name="SetData" }
  })

  class("Thread", { src="../classes/class_thread.cpp", output="../classes/class_thread_def.c" }, [[
   ptr   Data         # User data pointer.
   int   DataSize     # Size of user data.
   int   StackSize    # Pre-set stack size
   error Error        # Error code returned by the thread on completion.
   int(THF) Flags     # Optional flags.
  ]])

  methods("Module", "Mod", {
    { id=1,  name="ResolveSymbol" },
  })

  class("Module", { src="../classes/class_module.cpp" }, [[
    cstruct(*Function) FunctionList # Array of functions
    ptr ModBase                     # Ptr to function jump table
    class(*RootModule) Root         # Shared details on the module
    struct(*ModHeader) Header       # For creating in-memory modules only.
    int(MOF) Flags                  # Optional flags
  ]],
  nil,
  [[
   static ERR load(std::string Name, OBJECTPTR *Module = NULL, APTR Functions = NULL) {
      if (auto module = objModule::create::global(pf::FieldValue(FID_Name, Name.c_str()))) {
         #ifdef PARASOL_STATIC
            if (Module) *Module = module;
            if (Functions) ((APTR *)Functions)[0] = NULL;
            return ERR::Okay;
         #else
            APTR functionbase;
            if (module->getPtr(FID_ModBase, &functionbase) IS ERR::Okay) {
               if (Module) *Module = module;
               if (Functions) ((APTR *)Functions)[0] = functionbase;
               return ERR::Okay;
            }
            else return ERR::GetField;
         #endif
      }
      else return ERR::CreateObject;
   }
  ]])

  -- Note that the fields following SystemTime are identical to struct DateTime

  methods("Time", "Pt", {
    { id=1, name="SetTime" },
  })

  class("Time", { src="../classes/class_time.cpp" }, [[
    large SystemTime  # Total number of microseconds passed since the system base time
    int Year          # Year   (-ve for BC, +ve for AD)
    int Month         # Month  (1 - 12)
    int Day           # Day    (1 - 31)
    int Hour          # Hour   (0 - 23)
    int Minute        # Minute (0 - 59)
    int Second        # Second (0 - 59)
    int TimeZone      # 0 is GMT, range is +1300 or -1300
    int DayOfWeek     # Day of week (0 = Sunday ..)
    int MilliSecond   # Millisecond (0 - 999)
    int MicroSecond   # Microsecond  (0 - 999999)
  ]])

  methods("Compression", "Cmp", {
    { id=1, name="CompressBuffer" },
    { id=2, name="CompressFile" },
    { id=3, name="DecompressBuffer" },
    { id=4, name="DecompressFile" },
    { id=5, name="RemoveFile" },
    { id=6, name="CompressStream" },
    { id=7, name="DecompressStream" },
    { id=8, name="CompressStreamStart" },
    { id=9, name="CompressStreamEnd" },
    { id=10, name="DecompressStreamEnd" },
    { id=11, name="DecompressStreamStart" },
    { id=12, name="DecompressObject" },
    { id=13, name="Scan" },
    { id=14, name="Find" }
  })

  class("Compression", { src={ "../compression/class_compression.cpp", "../compression/compression_fields.cpp" }, output="../compression/class_compression_def.c" }, [[
    large TotalOutput       # Total number of bytes output (e.g. during compression of a stream)
    oid Output              # Reference to output object for user messages
    int CompressionLevel    # Compression level (percentage - 0% none, 100% high)
    int(CMF) Flags          # Optional flags
    int SegmentSize         # Splits the compressed file if it surpasses a set byte limit (e.g. 1.44MB)
    int(PERMIT) Permissions # Default permissions to use for decompressed files
    int MinOutputSize       # Minimum recommended output buffer size
    int WindowBits          # Window bits, currently applicable to the default (zlib) compression
  ]])

  class("CompressedStream", { src="../compression/class_compressed_stream.cpp", output="../compression/class_compressed_stream_def.c" }, [[
    large TotalOutput  # Count of the total bytes that have been output.
    obj Input          # The object that is the source of the compressed data.
    obj Output         # The object that is the destination for the compressed data.
    int(CF) Format     # CF_GZIP, CF_ZLIB, CF_DEFLATE
  ]])

  c_insert([[
#ifndef PRV_CORE

// Note that the length of the data is only needed when messaging between processes, so we can skip it for these
// direct-access data channel macros.

#define acDataContent(a,b)  acDataFeed((a),0,DATA::CONTENT,(b),0)
#define acDataXML(a,b)      acDataFeed((a),0,DATA::XML,(b),0)
#define acDataText(a,b)     acDataFeed((a),0,DATA::TEXT,(b),0)

#endif // PRV_CORE

#ifdef __unix__
#include <pthread.h>
#endif

#ifdef __system__

struct ActionMessage {
   OBJECTID ObjectID;        // The object that is to receive the action
   LONG  Time;
   ACTIONID ActionID;        // ID of the action or method to execute
   bool SendArgs;            //

   // Action arguments follow this structure in a buffer
};

#endif

// Event support

struct rkEvent {
   EVENTID EventID;
   // Data follows
};

#define EVID_DISPLAY_RESOLUTION_CHANGE  GetEventID(EVG::DISPLAY, "resolution", "change")

#define EVID_GUI_SURFACE_FOCUS          GetEventID(EVG::GUI, "surface", "focus")

#define EVID_FILESYSTEM_VOLUME_CREATED  GetEventID(EVG::FILESYSTEM, "volume", "created")
#define EVID_FILESYSTEM_VOLUME_DELETED  GetEventID(EVG::FILESYSTEM, "volume", "deleted")

#define EVID_SYSTEM_TASK_CREATED        GetEventID(EVG::SYSTEM, "task", "created")
#define EVID_SYSTEM_TASK_REMOVED        GetEventID(EVG::SYSTEM, "task", "removed")

#define EVID_POWER_STATE_SUSPENDING     GetEventID(EVG::POWER, "state", "suspending")
#define EVID_POWER_STATE_RESUMED        GetEventID(EVG::POWER, "state", "resumed")
#define EVID_POWER_DISPLAY_STANDBY      GetEventID(EVG::POWER, "display", "standby")
#define EVID_POWER_BATTERY_LOW          GetEventID(EVG::POWER, "battery", "low")
#define EVID_POWER_BATTERY_CRITICAL     GetEventID(EVG::POWER, "battery", "critical")
#define EVID_POWER_CPUTEMP_HIGH         GetEventID(EVG::POWER, "cputemp", "high")
#define EVID_POWER_CPUTEMP_CRITICAL     GetEventID(EVG::POWER, "cputemp", "critical")
#define EVID_POWER_SCREENSAVER_ON       GetEventID(EVG::POWER, "screensaver", "on")
#define EVID_POWER_SCREENSAVER_OFF      GetEventID(EVG::POWER, "screensaver", "off")

#define EVID_IO_KEYMAP_CHANGE           GetEventID(EVG::IO, "keymap", "change")
#define EVID_IO_KEYBOARD_KEYPRESS       GetEventID(EVG::IO, "keyboard", "keypress")

#define EVID_AUDIO_VOLUME_MASTER        GetEventID(EVG::AUDIO, "volume", "master")
#define EVID_AUDIO_VOLUME_LINEIN        GetEventID(EVG::AUDIO, "volume", "linein")
#define EVID_AUDIO_VOLUME_MIC           GetEventID(EVG::AUDIO, "volume", "mic")
#define EVID_AUDIO_VOLUME_MUTED         GetEventID(EVG::AUDIO, "volume", "muted") // All volumes have been muted
#define EVID_AUDIO_VOLUME_UNMUTED       GetEventID(EVG::AUDIO, "volume", "unmuted") // All volumes have been unmuted

// Event structures.

typedef struct { EVENTID EventID; char Name[1]; } evVolumeCreated;
typedef struct { EVENTID EventID; char Name[1]; } evVolumeDeleted;
typedef struct { EVENTID EventID; OBJECTID TaskID; } evTaskCreated;
typedef struct { EVENTID EventID; OBJECTID TaskID; OBJECTID ProcessID; } evTaskRemoved;
typedef struct { EVENTID EventID; } evPowerSuspending;
typedef struct { EVENTID EventID; } evPowerResumed;
typedef struct { EVENTID EventID; } evUserLogin;
typedef struct { EVENTID EventID; } evKeymapChange;
typedef struct { EVENTID EventID; } evScreensaverOn;
typedef struct { EVENTID EventID; } evScreensaverOff;
typedef struct { EVENTID EventID; DOUBLE Volume; LONG Muted; } evVolume;
typedef struct { EVENTID EventID; KQ Qualifiers; KEY Code; LONG Unicode; } evKey;
typedef struct { EVENTID EventID; WORD TotalWithFocus; WORD TotalLostFocus; OBJECTID FocusList[1]; } evFocus;

// Hotplug event structure.  The hotplug event is sent whenever a new hardware device is inserted by the user.

struct evHotplug {
   EVENTID EventID;
   WORD Type;            // HT ID
   WORD Action;          // HTA_INSERTED, HTA_REMOVED
   LONG VendorID;        // USB vendor ID
   union {
      LONG ProductID;    // USB product or device ID
      LONG DeviceID;
   };
   char  ID[20];         // Typically the PCI bus ID or USB bus ID, serial number or unique identifier
   char  Group[32];      // Group name in the config file
   char  Class[32];      // Class identifier (USB)
   union {
      char Product[40];  // Name of product or the hardware device
      char Device[40];
   };
   char Vendor[40];      // Name of vendor
};

namespace fl {

// Read endian values from files and objects.

template<class T> ERR ReadLE(OBJECTPTR Object, T *Result)
{
   UBYTE data[sizeof(T)];
   struct acRead read = { .Buffer = data, .Length = sizeof(T) };
   if (Action(AC_Read, Object, &read) IS ERR::Okay) {
      if (read.Result IS sizeof(T)) {
         if constexpr (std::endian::native == std::endian::little) {
            *Result = ((T *)data)[0];
         }
         else {
            switch(sizeof(T)) {
               case 2:  *Result = (data[1]<<8) | data[0]; break;
               case 4:  *Result = (data[0]<<24)|(data[1]<<16)|(data[2]<<8)|(data[3]); break;
               case 8:  *Result = ((LARGE)data[0]<<56)|((LARGE)data[1]<<48)|((LARGE)data[2]<<40)|((LARGE)data[3]<<32)|(data[4]<<24)|(data[5]<<16)|(data[6]<<8)|(data[7]); break;
               default: *Result = ((T *)data)[0];
            }
         }
         return ERR::Okay;
      }
      else return ERR::Read;
   }
   else return ERR::Read;
}

template<class T> ERR ReadBE(OBJECTPTR Object, T *Result)
{
   UBYTE data[sizeof(T)];
   struct acRead read = { .Buffer = data, .Length = sizeof(T) };
   if (Action(AC_Read, Object, &read) IS ERR::Okay) {
      if (read.Result IS sizeof(T)) {
         if constexpr (std::endian::native == std::endian::little) {
            switch(sizeof(T)) {
               case 2:  *Result = (data[1]<<8) | data[0]; break;
               case 4:  *Result = (data[0]<<24)|(data[1]<<16)|(data[2]<<8)|(data[3]); break;
               case 8:  *Result = ((LARGE)data[0]<<56)|((LARGE)data[1]<<48)|((LARGE)data[2]<<40)|((LARGE)data[3]<<32)|(data[4]<<24)|(data[5]<<16)|(data[6]<<8)|(data[7]); break;
               default: *Result = ((T *)data)[0];
            }
         }
         else {
            *Result = ((T *)data)[0];
         }
         return ERR::Okay;
      }
      else return ERR::Read;
   }
   else return ERR::Read;
}

} // namespace

// Function construction (refer types.h)

template <class T> FUNCTION C_FUNCTION(T *pRoutine, APTR pMeta = NULL) {
   auto func    = FUNCTION(CALL::STD_C);
   func.Context = CurrentContext();
   func.Routine = (APTR)pRoutine;
   func.Meta    = pMeta;
   return func;
};

inline CSTRING Object::className() { return Class->ClassName; }
  ]])

  if (glProgram == "idl-compile") then
     loadFile("defs/errors.fdl")
  end
end)
