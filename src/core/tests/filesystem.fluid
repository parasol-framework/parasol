--[[
Tests for file functions
--]]

   glPath = 'parasol:'

----------------------------------------------------------------------------------------------------------------------
-- Test that the standard extraction pattern for folder and file names works as expected.

function testPathExtract()
   local pattern = '([^:/]+)/-$'

   assert(string.match('temp:test.txt', pattern) is 'test.txt', 'Failed to extract "test.txt"')
   assert(string.match('temp:folder/', pattern) is 'folder', 'Failed to extract "folder"')
   assert(string.match('temp:folder/test.', pattern) is 'test.', 'Failed to extract "test."')
   assert(string.match('temp:folder/subfolder/', pattern) is 'subfolder', 'Failed to extract "subfolder"')
   assert(string.match('temp:.hidden', pattern) is '.hidden', 'Failed to extract ".hidden"')
   assert(string.match('simple.txt', pattern) is 'simple.txt', 'Failed to extract "simple.txt"')
   assert(string.match('temp:', pattern) is nil, 'Expected no result when extracting file name from path "temp:"')
end

----------------------------------------------------------------------------------------------------------------------

function testFolderScan()
   local folder = obj.new('file', { src=glPath } )

   local names
   local err, file = folder.mtNext()
   local count = 0
   while err is ERR_Okay do
      count += 1
      local date = file.date
      if not date then error("Unable to get file's modification date.") end

      local name = file.path:match('([^:/]+)/-$')

      if not names then
         names = '"' .. tostring(name) .. '"'
      else
         names ..= ', "' .. tostring(name) .. '"'
      end
      logOutput(tostring(name) .. ', Size: ' .. file.size .. ', Date: ' .. date.year .. '/' .. date.month .. '/' .. date.day)
      err, file = folder.mtNext()
   end

   assert(count != 0, 'No files found in "' .. glPath .. '": ' .. mSys.GetErrorMsg(err))

   return 'Found ' .. count .. ' files.'
end

----------------------------------------------------------------------------------------------------------------------

function testScanDir()
   local err, dir = mSys.OpenDir(glPath, bit.bor(RDF_FILES,RDF_FOLDERS,RDF_QUALIFY,RDF_DATE,RDF_SIZE,RDF_TAGS))
   if (err is ERR_Okay) then
      local err = mSys.ScanDir(dir)
      while (err is ERR_Okay) do
         local fl = dir.info
         local created = fl.created

         logOutput(fl.name .. ', Size: ' .. fl.size .. ', Date: ' .. created.year .. '/' .. created.month .. '/' .. created.day)

         if (created.year < 1900) or (created.year > 3000) or (created.month < 1) or (created.month > 12) or (created.day < 1) or (created.day > 31) then
            error('Invalid Year/Month/Day retrieved for "' .. fl.name .. '"')
         end

         err = mSys.ScanDir(dir)
      end
   else
      error('OpenDir() error: ' .. mSys.GetErrorMsg(err))
   end
end

----------------------------------------------------------------------------------------------------------------------

function testScanVolumes()
   local err, dir = mSys.OpenDir(':', bit.bor(RDF_FILES,RDF_FOLDERS,RDF_TAGS))
   if err is ERR_Okay then
      local volumes = { }
      local names
      local err = mSys.ScanDir(dir)
      while (err is ERR_Okay) do
         local fl = dir.info
         names = not names ? fl.name :> names .. ' ' .. fl.name
         volumes[fl.name] = true
         err = mSys.ScanDir(dir)
      end

      logOutput(names)

      if not volumes['parasol'] then error("The expected 'parasol' volume is not present.") end
      --if not volumes['bin'] then error("The expected 'bin' volume is not present.") end
      if not volumes['user'] then error("The expected 'user' volume is not present.") end
      if not volumes['system'] then error("The expected 'system' volume is not present.") end
   else
      error("OpenDir() error: " .. mSys.GetErrorMsg(err))
   end
end

----------------------------------------------------------------------------------------------------------------------
-- This code loads a raw file, converts it to a string, reverses it and then writes the string back to the file.

function testStringify()
   local fl = obj.new('file', { src=glRawPath, flags='!READ|WRITE' } )
   local buf = string.alloc(fl.size)
   local err, result = fl.acRead(buf, fl.size)
   assert(err is ERR_Okay, 'Failed to read file ' .. fl.location)

   fl.acSeek(POS_START, 0)
   fl.acWrite(buf:reverse())
end

----------------------------------------------------------------------------------------------------------------------

function testFileIcons()
   if mSys.AnalysePath('icons:') != ERR_Okay then
      -- Icons not available, skip test
      return
   end

   local icon_pairs = {
      { path='fonts:fonts.cfg',            icon='icons:filetypes/text' },
      { path='fonts:truetype/Micro-6.ttf', icon='icons:filetypes/font' },
      { path='scripts:common.fluid',       icon='icons:filetypes/source' }
   }

   for k, v in ipairs(icon_pairs) do
      local icon = obj.new('file', { path=v.path }).icon
      if (icon != v.icon) then
         error('Icon for ' .. v.path .. ' evaluated to ' .. icon .. ' instead of expected "' .. v.icon .. '"')
      end
   end
end

----------------------------------------------------------------------------------------------------------------------

function testAnalyseVolume()
   local err, type = mSys.AnalysePath('user:')
   assert(err is ERR_Okay, 'AnalysePath() failed with error: ' .. mSys.GetErrorMsg(err))

   assert(type is LOC_VOLUME, 'AnalysePath() returned type ' .. type .. ' and not LOC_VOLUME')
end

----------------------------------------------------------------------------------------------------------------------

function testAnalyseFile()
   local err, type = mSys.AnalysePath('scripts:gui.fluid')
   assert(err is ERR_Okay, 'AnalysePath() failed with error: ' .. mSys.GetErrorMsg(err))

   assert(type is LOC_FILE, 'AnalysePath() returned type ' .. type .. ' and not LOC_FILE')
end

----------------------------------------------------------------------------------------------------------------------

   return {
      tests = {
         testPathExtract, testFolderScan, testScanDir,
         testStringify, testScanVolumes, testFileIcons,
         testAnalyseVolume, testAnalyseFile
      },
      init = function()
         global glRawPath = 'user:test.out'
         local out = obj.new('file', { src=glRawPath, flags='!NEW|WRITE' } )
         out.acWrite('ABCD', 4)
         out = nil
         collectgarbage()
      end,
      cleanup = function()
         mSys.DeleteFile(glRawPath)
      end
   }
