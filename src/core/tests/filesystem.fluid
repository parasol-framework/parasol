--[[
Tests for file functions
--]]

   glPath = 'parasol:'

@BeforeAll function init()
   global glRawPath = 'user:test.out'
   out = obj.new('file', { src=glRawPath, flags='!NEW|WRITE' } )
   out.acWrite('ABCD', 4)
   out = nil
   collectgarbage()
end

@AfterAll function cleanup()
   mSys.DeleteFile(glRawPath)
end

----------------------------------------------------------------------------------------------------------------------
-- Test that the standard extraction pattern for folder and file names works as expected.

@Test function testPathExtract()
   pattern = '([^:/]+)/-$'

   assert(string.match('temp:test.txt', pattern) is 'test.txt', 'Failed to extract "test.txt"')
   assert(string.match('temp:folder/', pattern) is 'folder', 'Failed to extract "folder"')
   assert(string.match('temp:folder/test.', pattern) is 'test.', 'Failed to extract "test."')
   assert(string.match('temp:folder/subfolder/', pattern) is 'subfolder', 'Failed to extract "subfolder"')
   assert(string.match('temp:.hidden', pattern) is '.hidden', 'Failed to extract ".hidden"')
   assert(string.match('simple.txt', pattern) is 'simple.txt', 'Failed to extract "simple.txt"')
   assert(string.match('temp:', pattern) is nil, 'Expected no result when extracting file name from path "temp:"')
end

----------------------------------------------------------------------------------------------------------------------

@Test function testFolderScan()
   folder = obj.new('file', { src=glPath } )

   names = nil
   err, file = folder.mtNext()
   count = 0
   while err is ERR_Okay do
      count++
      date = file.date
      if not date then error("Unable to get file's modification date.") end

      name = file.path:match('([^:/]+)/-$')

      if not names then
         names = '"' .. tostring(name) .. '"'
      else
         names ..= ', "' .. tostring(name) .. '"'
      end
      logOutput(tostring(name) .. ', Size: ' .. file.size .. ', Date: ' .. date.year .. '/' .. date.month .. '/' .. date.day)
      err, file = folder.mtNext()
   end

   assert(count != 0, 'No files found in "' .. glPath .. '": ' .. mSys.GetErrorMsg(err))

   return 'Found ' .. count .. ' files.'
end

----------------------------------------------------------------------------------------------------------------------

@Test function testScanDir()
   err, dir = mSys.OpenDir(glPath, bit.bor(RDF_FILES,RDF_FOLDERS,RDF_QUALIFY,RDF_DATE,RDF_SIZE,RDF_TAGS))
   if err is ERR_Okay then
      err = mSys.ScanDir(dir)
      while err is ERR_Okay do
         fl = dir.info
         created = fl.created

         logOutput(fl.name .. ', Size: ' .. fl.size .. ', Date: ' .. created.year .. '/' .. created.month .. '/' .. created.day)

         if (created.year < 1900) or (created.year > 3000) or (created.month < 1) or (created.month > 12) or (created.day < 1) or (created.day > 31) then
            error('Invalid Year/Month/Day retrieved for "' .. fl.name .. '"')
         end

         err = mSys.ScanDir(dir)
      end
   else
      error('OpenDir() error: ' .. mSys.GetErrorMsg(err))
   end
end

----------------------------------------------------------------------------------------------------------------------

@Test function testScanVolumes()
   err, dir = mSys.OpenDir(':', RDF_FILES | RDF_FOLDERS | RDF_TAGS)
   if err is ERR_Okay then
      volumes = { }
      names = nil
      err = mSys.ScanDir(dir)
      while err is ERR_Okay do
         fl = dir.info
         names = not names ? fl.name :> names .. ' ' .. fl.name
         volumes[fl.name] = true
         err = mSys.ScanDir(dir)
      end

      logOutput(names)

      assert(volumes['parasol'], "The expected 'parasol' volume is not present.")
      assert(volumes['user'], "The expected 'user' volume is not present.")
      assert(volumes['system'], "The expected 'system' volume is not present.")
   else
      error("OpenDir() error: " .. mSys.GetErrorMsg(err))
   end
end

----------------------------------------------------------------------------------------------------------------------
-- This code loads a raw file, converts it to a string, reverses it and then writes the string back to the file.

@Test function testStringify()
   fl = obj.new('file', { src=glRawPath, flags='!READ|WRITE' } )
   buf = string.alloc(fl.size)
   err, result = fl.acRead(buf, fl.size)
   assert(err is ERR_Okay, 'Failed to read file ' .. fl.location)

   fl.acSeek(POS_START, 0)
   fl.acWrite(buf:reverse())
end

----------------------------------------------------------------------------------------------------------------------

@Test function testFileIcons()
   if mSys.AnalysePath('icons:') != ERR_Okay then
      -- Icons not available, skip test
      return
   end

   icon_pairs = {
      { path='fonts:fonts.cfg',            icon='icons:filetypes/text' },
      { path='fonts:truetype/Micro-6.ttf', icon='icons:filetypes/font' },
      { path='scripts:common.fluid',       icon='icons:filetypes/source' }
   }

   for k, v in ipairs(icon_pairs) do
      icon = obj.new('file', { path=v.path }).icon
      if icon != v.icon then
         error('Icon for ' .. v.path .. ' evaluated to ' .. icon .. ' instead of expected "' .. v.icon .. '"')
      end
   end
end

----------------------------------------------------------------------------------------------------------------------

@Test function testAnalyseVolume()
   err, type = mSys.AnalysePath('user:')
   assert(err is ERR_Okay, 'AnalysePath() failed with error: ' .. mSys.GetErrorMsg(err))
   assert(type is LOC_VOLUME, 'AnalysePath() returned type ' .. type .. ' and not LOC_VOLUME')
end

----------------------------------------------------------------------------------------------------------------------

@Test function testAnalyseFile()
   err, type = mSys.AnalysePath('scripts:gui.fluid')
   assert(err is ERR_Okay, 'AnalysePath() failed with error: ' .. mSys.GetErrorMsg(err))
   assert(type is LOC_FILE, 'AnalysePath() returned type ' .. type .. ' and not LOC_FILE')
end
