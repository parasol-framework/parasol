-- Error handling and resilience edge cases

function testInvalidEscapeRaises()
   local err = catch(function() return regex.new("\\x") end)
   assert(err != ERR_Okay, "Invalid escape should trigger compilation error")
end

function testMismatchedBracketRaises()
   local err = catch(function() return regex.new("[abc") end)
   assert(err != ERR_Okay, "Mismatched bracket should raise error")
end

function testUnknownUnicodeProperty()
   local err = catch(function() return regex.new("\\p{NotAProperty}") end)
   assert(err != ERR_Okay, "Unknown Unicode property should be rejected")
end

function testRegexObjectsSurviveGarbageCollection()
   for index = 1, 50 do
      local matcher = regex.new("item" .. index)
      assert(matcher.test("item" .. index), "Compiled regex should operate before GC")
   end
   collectgarbage()
   local matcher = regex.new("final")
   assert(matcher.test("final"), "Regex creation should remain stable after GC cycle")
end

function testEmptyPatternMatch()
   local matcher = regex.new("")
   assert(matcher.test("anything"), "Empty pattern should match any string")
   local replaced = matcher.replace("abc", "-")
   assert(replaced:sub(1, 1) == "-", "Replacement on empty pattern should insert replacement at start")
end

return {
   tests = {
      'testInvalidEscapeRaises',
      'testMismatchedBracketRaises',
      'testUnknownUnicodeProperty',
      'testRegexObjectsSurviveGarbageCollection',
      'testEmptyPatternMatch'
   }
}
