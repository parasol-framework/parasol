-- Validation for character classes, escapes, and custom ranges

function testDigitClass()
   local matcher = regex.new("\\d+")
   local match = matcher.search("abc123def")
   assert(match, "\\d+ should capture digits")
   assert(#match == 1, "Should find one match, got " .. tostring(#match))
   assert(match[1][1] == "123", "Digit capture should equal the numeric run, got " .. tostring(match[1]))
end

function testWordClass()
   local matcher = regex.new("(\\w+)")
   local results = matcher.search("mix_of words42")
   assert(results and #results >= 2, "search should capture multiple words")
   assert(results[1][1] == "mix_of", "Word class should include underscore")
   assert(results[2][1] == "words42", "Word class should include trailing digits")
end

function testWhitespaceClass()
   local matcher = regex.new("^foo\\s+bar$")
   assert(matcher.test("foo\t bar"), "\\s should consume tabs")
   assert(not matcher.test("foo bar baz"), "Anchors should enforce full match with whitespace class")
end

function testNegatedClass()
   local matcher = regex.new("[^aeiou]+")
   local match = matcher.match("strength")
   assert(match, "No match found for negated vowel class")
   assert(match[1] == "str", "Negated vowel class should consume consonant prefix, got " .. tostring(match[1]))
end

function testEscapedDot()
   local matcher = regex.new("a\\.b")
   assert(matcher.test("a.b"), "Escaped dot should match literal period")
   assert(not matcher.test("acb"), "Escaped dot should not behave as wildcard")
end

return {
   tests = {
      'testDigitClass',
      'testWordClass',
      'testWhitespaceClass',
      'testNegatedClass',
      'testEscapedDot'
   }
}
