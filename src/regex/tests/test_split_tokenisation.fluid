-- Splitting and tokenisation behaviour for regex.split

function testSimpleSplit()
   local matcher = regex.new(",\\s*")
   local result = matcher.split("apple, banana,carrot")
   assert(#result == 3, "Comma split should produce three tokens")
   assert(result[2] == "banana", "Whitespace should be trimmed by pattern")
end

function testConsecutiveDelimiters()
   local matcher = regex.new(",")
   local result = matcher.split("a,,b")
   assert(#result == 3, "Consecutive delimiters should yield empty field")
   assert(result[2] == "", "Empty field should be preserved between delimiters")
end

function testLeadingTrailingDelimiters()
   local matcher = regex.new("\\|")
   local result = matcher.split("|start|end|")
   assert(#result == 4, "Leading and trailing separators should generate empty tokens")
   assert(result[1] == "", "Leading separator should produce empty string")
   assert(result[4] == "", "Trailing separator should produce empty string")
end

function testWhitespaceSplit()
   local matcher = regex.new("\\s+")
   local result = matcher.split("line1\nline2\tline3")
   assert(#result == 3, "Whitespace split should separate newline and tab delimited tokens")
end

function testSplitContinuousFlag()
   local matcher = regex.new(",")
   local regular = matcher.split("a,b,c")
   local continuous = matcher.split("a,b,c", regex.CONTINUOUS)
   assert(#regular == 3, "Baseline split should return all parts")
   assert(#continuous == 1 and continuous[1] == "a,b,c", "CONTINUOUS flag should suppress matches away from start")
end

return {
   tests = {
      'testSimpleSplit',
      'testConsecutiveDelimiters',
      'testLeadingTrailingDelimiters',
      'testWhitespaceSplit',
      'testSplitContinuousFlag'
   }
}
