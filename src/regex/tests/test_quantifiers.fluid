-- Coverage for quantifiers, alternation precedence, and optional constructs

function testGreedyAndLazy()
   local greedy = regex.new("<.+>")
   local lazy = regex.new("<.+?>")
   local text = "<em>bold</em>"
   assert(greedy.match(text)[1] == "<em>bold</em>", "Greedy quantifier should consume closing tag")
   assert(lazy.match(text)[1] == "<em>", "Lazy quantifier should stop at first closing bracket")
end

function testBoundedQuantifier()
   local matcher = regex.new("^\\d{2,4}$")
   assert(matcher.test("42"), "Lower bound of range should pass")
   assert(matcher.test("1234"), "Upper bound of range should pass")
   assert(not matcher.test("12345"), "Values beyond upper bound should fail")
end

function testOptionalGroup()
   local matcher = regex.new("colou?r")
   assert(matcher.test("color"), "Optional group should allow American spelling")
   assert(matcher.test("colour"), "Optional group should allow British spelling")
end

function testAlternationPrecedence()
   local matcher = regex.new("(cat|dog)s?")
   assert(matcher.test("cats"), "Alternation should apply before suffix quantifier")
   assert(matcher.test("dog"), "Optional suffix should allow singular form")
   assert(not matcher.test("cater"), "Suffix beyond alternation should fail")
end

function testZeroLengthMatchHandling()
   local matcher = regex.new("a*")
   local result = matcher.match("bbb")
   assert(result and result[1] == "", "Zero length matches should be represented as empty strings")
end

return {
   tests = {
      'testGreedyAndLazy',
      'testBoundedQuantifier',
      'testOptionalGroup',
      'testAlternationPrecedence',
      'testZeroLengthMatchHandling'
   }
}
