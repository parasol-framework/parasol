--[[
Various HTTP examples that demonstrate how to GET, POST, etc.

Note: Network communications take place in the background once started.  In order to ensure that an HTTP operation
fully completes, it is crucial that the HTTP object remains in memory for the entire procedure.  In Fluid we can do
this by maintaining at least one reference to the object at all times and this will prevent it from being garbage
collected too early.
--]]

   require 'common'
   local hslib = require 'net/httpserver'
   include 'http'

   local glOutFile = 'temp:http-output.txt'
   local glSelf = obj.find('self')
   local glPath = glSelf.workingPath
   local SERVER_PORT = 18942

----------------------------------------------------------------------------------------------------------------------
-- Test GET, outputFile and stateChanged callback

function testGet()
   local content
   local proc = processing.new({ timeout = 10.0 })

   local http = obj.new('http', {
      src        = 'http://127.0.0.1:' .. SERVER_PORT .. '/test_http.fluid',
      method     = 'GET',
      outputFile = glOutFile,
      connectTimeout = 10,
      stateChanged = function(HTTP, State)
         if (State == HGS_COMPLETED) then
            content = file.readAll(glOutFile)
            print(string.format('%.80s [80 of %d bytes]', content, content:len()))
         end
         if (State == HGS_COMPLETED) or (State == HGS_TERMINATED) then
            proc.signal()
         end
      end
   })

   local err = http.acActivate()
   assert(err == ERR_Okay, "HTTP object failed to activate.")

   err = proc.sleep()
   assert(err == ERR_Okay, 'Processing failed: ' .. mSys.GetErrorMsg(err))
   if (http.error != ERR_Okay) then error('HTTP object returned error: ' .. mSys.GetErrorMsg(http.error)) end
   if (http.currentState != HGS_COMPLETED) then error('Expected HTTP state of COMPLETED not reached, got ' .. http.currentState) end
   assert(content, 'No content received.')
end

----------------------------------------------------------------------------------------------------------------------
-- curl -v -X POST http://httpbin.org/post -d "fname=smith&lname=jones"

function testPostString()
   local proc = processing.new({ timeout = 5.0 })

   local http = obj.new('http', {
      src        = 'http://httpbin.org/post',
      method     = 'post',
      flags      = HTF_NO_HEAD,
      outputFile = glOutFile,
      contentLength = -1,
      outgoing = function(HTTP, BufferSize)
         if (testPostStringCompleted) then error('This routine has been called a second time.') end
         print('Request for data received.')
         HTTP.acWrite('fname=smith&lname=jones')
         testPostStringCompleted = true
         check(ERR_Terminate)
      end,
      stateChanged = function(HTTP, State)
         if (State == HGS_COMPLETED) then
            print(file.readAll(glOutFile))
         end
         if (State == HGS_COMPLETED) or (State == HGS_TERMINATED) then
            proc.signal()
         end
      end
   })

   local err = http.acActivate()
   assert(err == ERR_Okay, "HTTP object failed to activate.")

   err = proc.sleep()
   assert(err == ERR_Okay, 'Processing failed: ' .. mSys.GetErrorMsg(err))
   if (http.error != ERR_Okay) then error('HTTP object returned error: ' .. mSys.GetErrorMsg(http.error)) end
   if (http.currentState != HGS_COMPLETED) then error('Expected HTTP state of COMPLETED not reached, got ' .. http.currentState) end
end

----------------------------------------------------------------------------------------------------------------------

function testPostStringFile()
   local proc = processing.new({ timeout = 5.0 })
   local body = 'fname=joe&lname=bloggs'

   local http = obj.new('http', {
      src        = 'http://httpbin.org/post',
      method     = 'post',
      contentType = 'text/plain',
      flags      = HTF_NO_HEAD,
      inputFile  = 'string:' .. body,
      size       = body:len(),
      stateChanged = function(HTTP, State)
         if (State == HGS_COMPLETED) or (State == HGS_TERMINATED) then
            proc.signal()
         end
      end,
      incoming = function(HTTP, Buffer)
         print(Buffer)
      end
   })

   local err = http.acActivate()
   assert(err == ERR_Okay, "HTTP object failed to activate.")

   err = proc.sleep()
   assert(err == ERR_Okay, 'Processing failed: ' .. mSys.GetErrorMsg(err))
   if (http.error != ERR_Okay) then error('HTTP object returned error: ' .. mSys.GetErrorMsg(http.error)) end
   if (http.currentState != HGS_COMPLETED) then error('Expected HTTP state of COMPLETED not reached, got ' .. http.currentState) end
end

-----------------------------------------------------------------------------------------------------------------------

function testSSLProxy()
   local proc = processing.new({ timeout = 5.0 })

   local http = obj.new('http', {
      src         = 'https://www.google.co.uk/',
      method      = 'get',
      outputFile  = glOutFile,
      proxyserver = 'localhost',
      proxyport   = '8080'
   })

   local err = http.acActivate()
   assert(err == ERR_Okay, 'HTTP activation failed: ' .. mSys.GetErrorMsg(err))

   err = proc.sleep(5.0)
   assert(err == ERR_Okay, 'Processing failed: ' .. mSys.GetErrorMsg(err))
end

----------------------------------------------------------------------------------------------------------------------

function testHTTPS()
   local content
   local proc = processing.new({ timeout = 5.0 })

   local http = obj.new('http', {
      src        = 'https://www.google.com',
      method     = 'get',
      outputFile = glOutFile,
      stateChanged = function(HTTP, State)
         if (State == HGS_COMPLETED) then
            content = file.readAll(glOutFile)
            print(string.format('%.80s [%d bytes]', content, content:len()))
         end
         if (State == HGS_COMPLETED) or (State == HGS_TERMINATED) then
            proc.signal()
         end
         return ERR_Okay
      end
   })

   local err = http.acActivate()
   assert(err == ERR_Okay, 'HTTP activation failed: ' .. mSys.GetErrorMsg(err))

   local err = proc.sleep(5.0)
   assert(content, 'No content received.')
   assert(err == ERR_Okay, 'Processing failed: ' .. mSys.GetErrorMsg(err))
end

----------------------------------------------------------------------------------------------------------------------
-- Making an HTTPS request to google.co.uk should cause a redirect to google.com, which should
-- all be handled in the background.

function testRedirectedHTTPS()
   local content
   local proc = processing.new({ timeout = 5.0 })

   local http = obj.new('http', {
      src        = 'https://www.google.co.uk',
      method     = 'get',
      outputFile = glOutFile,
      stateChanged = function(HTTP, State)
         if (State == HGS_COMPLETED) then
            content = file.readAll(glOutFile)
            print(string.format('%.80s [%d bytes]', content, content:len()))
         end
         if (State == HGS_COMPLETED) or (State == HGS_TERMINATED) then
            proc.signal()
         end
         return ERR_Okay
      end
   })

   local err = http.acActivate()
   assert(err == ERR_Okay, 'HTTP activation failed: ' .. mSys.GetErrorMsg(err))

   local err = proc.sleep(5.0)
   assert(err == ERR_Okay, 'Processing failed: ' .. mSys.GetErrorMsg(err))
   assert(content, 'No content received.')
end

----------------------------------------------------------------------------------------------------------------------

function testPHPPost()
   local proc = processing.new({ timeout = 5.0 })

   local http = obj.new('http', {
      src        = 'http://127.0.0.1/upload.php',
      method     = 'post',
      inputfile  = 'string:file=fred.txt&amp;contentsize=4&amp;content=ABCD',
      outputFile = glOutFile
   })

   http.acActivate()
   local err = proc.sleep(5)
   if (err == ERR_TimeOut) then error('Test timed-out.') end
end

function testUploadChunked()
   local proc = processing.new({ timeout = 5.0 })

   local http = obj.new('http', {
      src        = 'http://127.0.0.1/upload.php',
      method     = 'post',
      inputfile  = glPath .. 'test_http.fluid',
      outputFile = glOutFile
   })

   http.acActivate()
   local err = proc.sleep(5.0)
   if (err == ERR_TimeOut) then error('Test timed-out.') end
end

function testChunks()
   local proc = processing.new({ timeout = 5.0 })

   // Test chunking
   local http = obj.new('http', {
      src        = 'http://news.bbc.co.uk',
      method     = 'get',
      outputFile = glOutFile
   })

   http.acActivate()
   local err = proc.sleep(5.0)
   if (err == ERR_TimeOut) then error('Test timed-out.') end
end

function testDownload()
   local proc = processing.new({ timeout = 5.0 })

   // Test non-chunking
   local http = obj.new('http', {
      src        = 'http://www.parasol.ws/index.html',
      method     = 'get',
      outputFile = glOutFile
   })

   http.acActivate()
   local err = proc.sleep(5.0)
   if (err == ERR_TimeOut) then error('Test timed-out.') end
end

function testUpload()
   local proc = processing.new({ timeout = 5.0 })

   // Test uploading
   local http = obj.new('http', {
      src       = 'http://www.parasol.ws/dav/test-upload',
      method    = 'put',
      inputfile = glinFile
   })

   http.acActivate()
   local err = proc.sleep(5.0)
   if (err == ERR_TimeOut) then error('Test timed-out.') end
end

function testMultiPart()
   local proc = processing.new({ timeout = 5.0 })

   local boundary = '----------d6sXWGimDGTgb2GDuLZqbR'

   local http = obj.new('http', {
      src         = 'http://parasol.ws/tkr/upload.php',
      method      = 'post',
      outputFile  = glOutFile,
      flags       = HTF_NO_HEADER,
      contenttype = 'multipart/form-data; boundary=' .. boundary
   } )

   local str = ''
   local CRLF = string.char(13,10)
   local filepath = args('inFile')
   local filename = string.gsub(filepath, '.*[:/\\](.-)', '%1', 1)

   // Parameters

   msg('Building parameters')
   str = str .. '--' .. boundary .. CRLF
   str = str .. "Content-Disposition: form-data; name=\"method\"" .. CRLF .. CRLF
   str = str .. 'fileUpload' .. CRLF

   str = str .. '--' .. boundary .. CRLF
   str = str .. "Content-Disposition: form-data; name=\"workspace\"" .. CRLF .. CRLF
   str = str .. '1' .. CRLF

   // File header

   str = str .. '--' .. boundary .. CRLF
   str = str .. "Content-Disposition: form-data; name=\"file\"; filename=\"" .. filename .. "\"" .. CRLF
   str = str .. 'Content-Type: application/octet-stream' .. CRLF .. CRLF

   local headfile = obj.new('file', { src='temp:http-head', flags='WRITE|NEW' } )
   headfile.acWrite(str, str:len())

   local tailfile = obj.new('file', { src='temp:http-tail', flags='WRITE|NEW' } )
   str = CRLF .. '--' .. boundary .. '--' .. CRLF
   tailfile.acWrite(str, str:len())

   local srcfile = obj.new('file', { src=filepath, flags='READ' } )

   if (srcfile) then
      http.size = headfile.size + tailfile.size + srcfile.size
      http.inputfile = headfile.location .. '|' .. srcfile.location .. '|' .. tailfile.location
      http.acActivate()
   end

   headfile = nil
   tailfile = nil
   srcfile = nil

   http.detach()
   local err = proc.sleep(5.0)
   if (err == ERR_TimeOut) then error('Test timed-out.') end
end

----------------------------------------------------------------------------------------------------------------------
-- ipv6.google.com test-ipv6.com ipv6.he.net ipv6.cloudflare.com

function testIPV6()
   local proc = processing.new({ timeout = 10.0 })
   local content = ''

   local http = obj.new('http', {
      src        = 'http://ipv6.google.com/',
      method     = 'get',
      connectTimeout = 10,
      stateChanged = function(HTTP, State)
         if (State == HGS_COMPLETED) then
            print(string.format('%.80s [80 of %d bytes]', content, content:len()))
         end
         if (State == HGS_COMPLETED) or (State == HGS_TERMINATED) then
            proc.signal()
         end
      end,
      incoming = function(HTTP, Buffer)
         if (Buffer) then content = content .. Buffer end
      end
   })

   local err = http.acActivate()
   assert(err == ERR_Okay, "HTTP object failed to activate.")

   err = proc.sleep()
   assert(err == ERR_Okay, 'Processing failed: ' .. mSys.GetErrorMsg(err))
   if (http.error != ERR_Okay) then error('HTTP object returned error: ' .. mSys.GetErrorMsg(http.error)) end
   if (http.currentState != HGS_COMPLETED) then error('Expected HTTP state of COMPLETED not reached, got ' .. http.currentState) end

   if #content < 2048 then
       print('Response content:')
       print(content)
   else
       print('Response preview (first 500 chars):')
       print(string.sub(content, 1, 500) .. '...')
   end
end

----------------------------------------------------------------------------------------------------------------------

   return {
      tests = {
        'testPostString',
        'testGet',
        'testPostStringFile',
        'testHTTPS',
        'testRedirectedHTTPS',
        'testIPV6'
      },
      init = function(Path)
         glPath = Path

         glServer = hslib.start({
            port    = SERVER_PORT,
            folder  = glPath,
            verbose = false,
            routes = {
              { pattern = '/api/test',
                method = 'GET',
                handler = function(req, res)
                   res.json({ message = 'GET route works!' })
                end
              },
              { pattern = '/api/users/:id',
                method = 'POST',
                handler = function(req, res)
                   local userId = req.params.id
                   res.json({
                      message = 'User route works!',
                      userId = userId,
                      method = req.method
                   })
                end
               }
            }
         })
      end,
      cleanup = function()
      end
   }
