--[[
Various HTTP examples that demonstrate how to GET, POST, etc.

Note: Network communications take place in the background once started.  In order to ensure that an HTTP operation
fully completes, it is crucial that the HTTP object remains in memory for the entire procedure.  In Fluid we can do
this by maintaining at least one reference to the object at all times and this will prevent it from being garbage
collected too early.
--]]

   require 'common'
   local hslib = require 'net/httpserver'
   local json = require 'json'
   include 'http'

   local glOutFile = 'temp:http-output.txt'
   local SERVER_PORT = 18942

----------------------------------------------------------------------------------------------------------------------
-- Test GET, outputFile and stateChanged callback

function testGetLocal()
   local proc = processing.new({ timeout = 10.0 })
   local content = ''

   local http = obj.new('http', {
      src        = 'http://127.0.0.1:' .. SERVER_PORT .. '/test_http.fluid',
      method     = 'GET',
      connectTimeout = 10,
      incoming = function(HTTP, Buffer)
         content = content .. tostring(Buffer)
      end,
      stateChanged = function(HTTP, State)
         if (State == HGS_COMPLETED) or (State == HGS_TERMINATED) then
            proc.signal()
         end
      end
   })

   local err = http.acActivate()
   assert(err == ERR_Okay, "HTTP object failed to activate.")

   err = proc.sleep()
   assert(err == ERR_Okay, 'Processing failed: ' .. mSys.GetErrorMsg(err))
   if (http.error != ERR_Okay) then error('HTTP object returned error: ' .. mSys.GetErrorMsg(http.error)) end
   if (http.currentState != HGS_COMPLETED) then error('Expected HTTP state of COMPLETED not reached, got ' .. http.currentState) end
   assert(nz(content), 'No content received.')

   print(string.format('%.80s [80 of %d bytes]', content, content:len()))
end

----------------------------------------------------------------------------------------------------------------------
-- POST to a local server using chunking (contentLength == -1)

function testPostStringLocal()
   local proc = processing.new({ timeout = 5.0 })
   local content = ''
   local testPostStringCompleted
   local outgoing_body = 'fname=smith&lname=jones'

   local http = obj.new('http', {
      src        = 'http://127.0.0.1:' .. SERVER_PORT .. '/post',
      method     = 'post',
      flags      = HTF_NO_HEAD,
      contentLength = -1,
      incoming = function(HTTP, Buffer)
         content = content .. tostring(Buffer)
      end,
      outgoing = function(HTTP)
         if (testPostStringCompleted) then error('This routine has been called a second time.') end
         msg('Request for data received.')
         HTTP.acWrite(outgoing_body)
         testPostStringCompleted = true
         check(ERR_Terminate)
      end,
      stateChanged = function(HTTP, State)
         if (State == HGS_COMPLETED) or (State == HGS_TERMINATED) then
            proc.signal()
         end
      end
   })

   assert(http.acActivate() == ERR_Okay, "HTTP object failed to activate.")

   local err = proc.sleep()
   assert(err == ERR_Okay, 'Processing failed: ' .. mSys.GetErrorMsg(err))
   
   assert(http.error == ERR_Okay, 'HTTP object returned error: ' .. mSys.GetErrorMsg(http.error))
   assert(http.currentState == HGS_COMPLETED, 'Expected HTTP state of COMPLETED not reached, got ' .. http.currentState)
   assert(nz(content), 'No content received.')
   assert(http.status == 200, 'Unexpected HTTP status: ' .. http.status)
   local js_content = json.decode(content)
   assert(js_content.body == outgoing_body, 'Unexpected response: ' .. content)
end

----------------------------------------------------------------------------------------------------------------------
-- curl -v -X POST http://httpbin.org/post -d "fname=smith&lname=jones"
-- POST to an external server using chunking (contentLength == -1)

function testPostStringExt()
   local proc = processing.new({ timeout = 5.0 })
   local testPostStringCompleted
   local content = ''

   local http = obj.new('http', {
      src        = 'http://httpbin.org/post',
      method     = 'post',
      flags      = HTF_NO_HEAD,
      contentLength = -1,
      incoming = function(HTTP, Buffer)
         content = content .. tostring(Buffer)
      end,
      outgoing = function(HTTP)
         if (testPostStringCompleted) then error('This routine has been called a second time.') end
         msg('Request for data received.')
         HTTP.acWrite('fname=smith&lname=jones')
         testPostStringCompleted = true
         check(ERR_Terminate)
      end,
      stateChanged = function(HTTP, State)
         if (State == HGS_COMPLETED) or (State == HGS_TERMINATED) then
            proc.signal()
         end
      end
   })

   assert(http.acActivate() == ERR_Okay, "HTTP object failed to activate.")

   local err = proc.sleep()
   assert(err == ERR_Okay, 'Processing failed: ' .. mSys.GetErrorMsg(err))
   
   assert(http.error == ERR_Okay, 'HTTP object returned error: ' .. mSys.GetErrorMsg(http.error))
   assert(http.currentState == HGS_COMPLETED, 'Expected HTTP state of COMPLETED not reached, got ' .. http.currentState)
   assert(http.status == 200, 'Unexpected HTTP status: ' .. http.status)
   assert(nz(content), 'No content received.')

   local form = json.decode(content)
   assert(form, 'No JSON response received.')
   assert(form.form.fname == 'smith', 'Unexpected response: ' .. content)
end

----------------------------------------------------------------------------------------------------------------------
-- POST to a local server using a string body and a predefined size (no chunking)

function testPostStringFile()
   local proc = processing.new({ timeout = 5.0 })
   local outgoing_body = 'fname=joe&lname=bloggs'
   local content = ''

   local http = obj.new('http', {
      src        = 'http://127.0.0.1: ' .. SERVER_PORT .. '/post',
      method     = 'post',
      contentType = 'text/plain',
      flags      = HTF_NO_HEAD,
      inputFile  = 'string:' .. outgoing_body,
      size       = outgoing_body:len(),
      stateChanged = function(HTTP, State)
         if (State == HGS_COMPLETED) or (State == HGS_TERMINATED) then
            proc.signal()
         end
      end,
      incoming = function(HTTP, Buffer)
         content = content .. tostring(Buffer)
      end
   })

   assert(http.acActivate() == ERR_Okay, "HTTP object failed to activate.")

   local err = proc.sleep()
   assert(err == ERR_Okay, 'Processing failed: ' .. mSys.GetErrorMsg(err))

   assert(http.error == ERR_Okay, 'HTTP object returned error: ' .. mSys.GetErrorMsg(http.error))
   assert(http.currentState == HGS_COMPLETED, 'Expected HTTP state of COMPLETED not reached, got ' .. http.currentState)
   assert(http.status == 200, 'Unexpected HTTP status: ' .. http.status)

   local js_content = json.decode(content)
   assert(js_content.body == outgoing_body, 'Unexpected response: ' .. content)
end

-----------------------------------------------------------------------------------------------------------------------

function testSSLOverProxy()
   local proc = processing.new({ timeout = 5.0 })

   local http = obj.new('http', {
      src         = 'https://www.google.co.uk/',
      method      = 'get',
      outputFile  = glOutFile,
      proxyserver = 'localhost',
      proxyport   = '8080'
   })

   local err = http.acActivate()
   assert(err == ERR_Okay, 'HTTP activation failed: ' .. mSys.GetErrorMsg(err))

   err = proc.sleep(5.0)
   assert(err == ERR_Okay, 'Processing failed: ' .. mSys.GetErrorMsg(err))
end

----------------------------------------------------------------------------------------------------------------------

function testHTTPS()
   local content
   local proc = processing.new({ timeout = 5.0 })

   local http = obj.new('http', {
      src        = 'https://www.google.com',
      method     = 'get',
      outputFile = glOutFile,
      stateChanged = function(HTTP, State)
         if (State == HGS_COMPLETED) then
            msg('State changed to COMPLETED.')
         end
         if (State == HGS_COMPLETED) or (State == HGS_TERMINATED) then
            proc.signal()
         end
         return ERR_Okay
      end
   })

   assert(http.acActivate() == ERR_Okay, 'HTTP activation failed: ' .. mSys.GetErrorMsg(err))

   local err = proc.sleep(5.0)

   local content = file.readAll(glOutFile)
   print(string.format('%.80s [%d bytes]', content, content:len()))
   assert(content, 'No content received.')
   assert(err == ERR_Okay, 'Processing failed: ' .. mSys.GetErrorMsg(err))
end

----------------------------------------------------------------------------------------------------------------------
-- Making an HTTPS request to google.co.uk should cause a redirect to google.com, which should
-- all be handled in the background.

function testRedirectedHTTPS()
   local content
   local proc = processing.new({ timeout = 5.0 })

   local http = obj.new('http', {
      src        = 'https://www.google.co.uk',
      method     = 'get',
      outputFile = glOutFile,
      stateChanged = function(HTTP, State)
         if (State == HGS_COMPLETED) then
            content = file.readAll(glOutFile)
            print(string.format('%.80s [%d bytes]', content, content:len()))
         end
         if (State == HGS_COMPLETED) or (State == HGS_TERMINATED) then
            proc.signal()
         end
         return ERR_Okay
      end
   })

   local err = http.acActivate()
   assert(err == ERR_Okay, 'HTTP activation failed: ' .. mSys.GetErrorMsg(err))

   local err = proc.sleep(5.0)
   assert(err == ERR_Okay, 'Processing failed: ' .. mSys.GetErrorMsg(err))
   assert(content, 'No content received.')
end

----------------------------------------------------------------------------------------------------------------------

function testMultiPart()
   local proc = processing.new({ timeout = 5.0 })

   local boundary = '----------d6sXWGimDGTgb2GDuLZqbR'

   local http = obj.new('http', {
      src         = 'http://parasol.ws/tkr/upload.php',
      method      = 'post',
      outputFile  = glOutFile,
      flags       = HTF_NO_HEADER,
      contenttype = 'multipart/form-data; boundary=' .. boundary
   } )

   local str = ''
   local CRLF = string.char(13,10)
   local filepath = args('inFile')
   local filename = string.gsub(filepath, '.*[:/\\](.-)', '%1', 1)

   // Parameters

   msg('Building parameters')
   str = str .. '--' .. boundary .. CRLF
   str = str .. "Content-Disposition: form-data; name=\"method\"" .. CRLF .. CRLF
   str = str .. 'fileUpload' .. CRLF

   str = str .. '--' .. boundary .. CRLF
   str = str .. "Content-Disposition: form-data; name=\"workspace\"" .. CRLF .. CRLF
   str = str .. '1' .. CRLF

   // File header

   str = str .. '--' .. boundary .. CRLF
   str = str .. "Content-Disposition: form-data; name=\"file\"; filename=\"" .. filename .. "\"" .. CRLF
   str = str .. 'Content-Type: application/octet-stream' .. CRLF .. CRLF

   local headfile = obj.new('file', { src='temp:http-head', flags='WRITE|NEW' } )
   headfile.acWrite(str, str:len())

   local tailfile = obj.new('file', { src='temp:http-tail', flags='WRITE|NEW' } )
   str = CRLF .. '--' .. boundary .. '--' .. CRLF
   tailfile.acWrite(str, str:len())

   local srcfile = obj.new('file', { src=filepath, flags='READ' } )

   if (srcfile) then
      http.size = headfile.size + tailfile.size + srcfile.size
      http.inputfile = headfile.location .. '|' .. srcfile.location .. '|' .. tailfile.location
      http.acActivate()
   end

   headfile = nil
   tailfile = nil
   srcfile = nil

   local err = proc.sleep(5.0)
   if (err == ERR_TimeOut) then error('Test timed-out.') end
end

----------------------------------------------------------------------------------------------------------------------
-- ipv6.google.com test-ipv6.com ipv6.he.net ipv6.cloudflare.com

function testIPV6()
   local proc = processing.new({ timeout = 10.0 })
   local content = ''

   local http = obj.new('http', {
      src        = 'http://ipv6.google.com/',
      method     = 'get',
      connectTimeout = 10,
      stateChanged = function(HTTP, State)
         if (State == HGS_COMPLETED) then
            print(string.format('%.80s [80 of %d bytes]', content, content:len()))
         end
         if (State == HGS_COMPLETED) or (State == HGS_TERMINATED) then
            proc.signal()
         end
      end,
      incoming = function(HTTP, Buffer)
         if (Buffer) then content = content .. Buffer end
      end
   })

   local err = http.acActivate()
   assert(err == ERR_Okay, "HTTP object failed to activate.")

   err = proc.sleep()
   assert(err == ERR_Okay, 'Processing failed: ' .. mSys.GetErrorMsg(err))
   if (http.error != ERR_Okay) then error('HTTP object returned error: ' .. mSys.GetErrorMsg(http.error)) end
   if (http.currentState != HGS_COMPLETED) then error('Expected HTTP state of COMPLETED not reached, got ' .. http.currentState) end

   if #content < 2048 then
       print('Response content:')
       print(content)
   else
       print('Response preview (first 500 chars):')
       print(string.sub(content, 1, 500) .. '...')
   end
end

----------------------------------------------------------------------------------------------------------------------

   return {
      tests = {
        'testGetLocal',
        'testPostStringLocal',
        'testPostStringExt',
        'testPostStringFile',
        'testHTTPS',
        'testRedirectedHTTPS',
        'testIPV6'
      },
      init = function(Path)
         print('Serving files from ' .. Path)

         glServer = hslib.start({
            port    = SERVER_PORT,
            folder  = Path,
            verbose = true,
            routes = {
              { pattern = '/api/test',
                method = 'GET',
                handler = function(req, res)
                   res.json({ message = 'GET route works!' })
                end
              },
              { pattern = '/post',
                method = 'POST',
                handler = function(req, res)
                   -- Return the request data for testing
                   res.json({
                      message = 'Simple post works!',
                      body = req.body,
                      headers = req.headers
                   })
                end
               },
              { pattern = '/api/users/:id',
                method = 'POST',
                handler = function(req, res)
                   local userId = req.params.id
                   res.json({
                      message = 'User route works!',
                      userId = userId,
                      method = req.method
                   })
                end
               }
            }
         })
      end,
      cleanup = function()
         glServer.stop()
         mSys.DeleteFile(glOutFile)
      end
   }
