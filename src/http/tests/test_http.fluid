--[[
Various HTTP examples that demonstrate how to GET, POST, etc.

Note: Network communications take place in the background once started.  In order to ensure that an HTTP operation
fully completes, it is crucial that the HTTP object remains in memory for the entire procedure.  In Fluid we can do
this by maintaining at least one reference to the object at all times and this will prevent it from being garbage
collected too early.
--]]

   require 'common'
   local hslib = require 'net/httpserver'
   local json = require 'json'
   include 'http'

   local glOutFile = 'temp:http-output.txt'
   local SERVER_PORT = 18942

----------------------------------------------------------------------------------------------------------------------
-- Test GET, outputFile and stateChanged callback

function testGetLocal()
   local proc = processing.new({ timeout = 10.0 })
   local content = ''

   local http = obj.new('http', {
      src        = 'http://127.0.0.1:' .. SERVER_PORT .. '/test_http.fluid',
      method     = 'GET',
      connectTimeout = 10,
      incoming = function(HTTP, Buffer)
         content ..= tostring(Buffer)
      end,
      stateChanged = function(HTTP, State)
         if (State is HGS_COMPLETED) or (State is HGS_TERMINATED) then
            proc.signal()
         end
      end
   })

   local err = http.acActivate()
   assert(err is ERR_Okay, "HTTP object failed to activate.")

   err = proc.sleep()
   assert(err is ERR_Okay, 'Processing failed: ' .. mSys.GetErrorMsg(err))
   assert(http.error is ERR_Okay, 'HTTP object returned error: ' .. mSys.GetErrorMsg(http.error))
   assert(http.currentState is HGS_COMPLETED, 'Expected HTTP state of COMPLETED not reached, got ' .. http.currentState)
   assert(nz(content), 'No content received.')

   print(string.format('Received: %.80s [80 of %d bytes]', content, content:len()))
end

----------------------------------------------------------------------------------------------------------------------
-- POST to a local server using chunking (contentLength is -1)

function testPostStringLocal()
   local proc = processing.new({ timeout = 5.0 })
   local content = ''
   local testPostStringCompleted
   local outgoing_body = 'fname=smith&lname=jones'

   local http = obj.new('http', {
      src        = 'http://127.0.0.1:' .. SERVER_PORT .. '/post',
      method     = 'post',
      flags      = HTF_NO_HEAD,
      contentLength = -1,
      incoming = function(HTTP, Buffer)
         content ..= tostring(Buffer)
      end,
      outgoing = function(HTTP)
         assert(testPostStringCompleted != true, 'This routine has been called a second time.')
         msg('Request for data received.')
         HTTP.acWrite(outgoing_body)
         testPostStringCompleted = true
         check(ERR_Terminate)
      end,
      stateChanged = function(HTTP, State)
         if (State is HGS_COMPLETED) or (State is HGS_TERMINATED) then
            proc.signal()
         end
      end
   })

   assert(http.acActivate() is ERR_Okay, "HTTP object failed to activate.")

   local err = proc.sleep()
   assert(err is ERR_Okay, 'Processing failed: ' .. mSys.GetErrorMsg(err))

   assert(http.error is ERR_Okay, 'HTTP object returned error: ' .. mSys.GetErrorMsg(http.error))
   assert(http.currentState is HGS_COMPLETED, 'Expected HTTP state of COMPLETED not reached, got ' .. http.currentState)
   assert(nz(content), 'No content received.')
   assert(http.status is 200, 'Unexpected HTTP status: ' .. http.status)
   local js_content = json.decode(content)
   assert(js_content.body is outgoing_body, 'Unexpected response: ' .. content)
end

----------------------------------------------------------------------------------------------------------------------
-- curl -v -X POST http://httpbin.org/post -d "fname=smith&lname=jones"
-- POST to an external server using chunking (contentLength is -1)

function testPostStringExt()
   local proc = processing.new({ timeout = 5.0 })
   local testPostStringCompleted
   local content = ''

   local http = obj.new('http', {
      src        = 'http://httpbin.org/post',
      method     = 'post',
      flags      = HTF_NO_HEAD,
      contentLength = -1,
      incoming = function(HTTP, Buffer)
         content ..= tostring(Buffer)
      end,
      outgoing = function(HTTP)
         assert(testPostStringCompleted != true, 'This routine has been called a second time.')
         msg('Request for data received.')
         HTTP.acWrite('fname=smith&lname=jones')
         testPostStringCompleted = true
         check(ERR_Terminate)
      end,
      stateChanged = function(HTTP, State)
         if (State is HGS_COMPLETED) or (State is HGS_TERMINATED) then
            proc.signal()
         end
      end
   })

   assert(http.acActivate() is ERR_Okay, "HTTP object failed to activate.")

   local err = proc.sleep()

   if (http.status >= 500) then
      print('httpbin.org service unavailable; cannot perform test.')
      return
   end

   assert(err is ERR_Okay, 'Processing failed: ' .. mSys.GetErrorMsg(err))
   assert(http.error is ERR_Okay, 'HTTP object returned error: ' .. mSys.GetErrorMsg(http.error))
   assert(http.currentState is HGS_COMPLETED, 'Expected HTTP state of COMPLETED not reached, got ' .. http.currentState)
   assert(http.status is 200, 'Unexpected HTTP status: ' .. http.status)
   assert(nz(content), 'No content received.')

   local form = json.decode(content)
   assert(form, 'No JSON response received.')
   assert(form.form.fname is 'smith', 'Unexpected response: ' .. content)
end

----------------------------------------------------------------------------------------------------------------------
-- POST to a local server using a string body and a predefined size (no chunking)

function testPostStringFile()
   local proc = processing.new({ timeout = 5.0 })
   local outgoing_body = 'fname=joe&lname=bloggs'
   local content = ''

   local http = obj.new('http', {
      src        = 'http://127.0.0.1:' .. SERVER_PORT .. '/post',
      method     = 'post',
      contentType = 'text/plain',
      flags      = HTF_NO_HEAD,
      inputFile  = 'string:' .. outgoing_body,
      size       = outgoing_body:len(),
      stateChanged = function(HTTP, State)
         if (State is HGS_COMPLETED) or (State is HGS_TERMINATED) then
            proc.signal()
         end
      end,
      incoming = function(HTTP, Buffer)
         content ..= tostring(Buffer)
      end
   })

   assert(http.acActivate() is ERR_Okay, "HTTP object failed to activate.")

   local err = proc.sleep()
   assert(err is ERR_Okay, 'Processing failed: ' .. mSys.GetErrorMsg(err))

   assert(http.error is ERR_Okay, 'HTTP object returned error: ' .. mSys.GetErrorMsg(http.error))
   assert(http.currentState is HGS_COMPLETED, 'Expected HTTP state of COMPLETED not reached, got ' .. http.currentState)
   assert(http.status is 200, 'Unexpected HTTP status: ' .. http.status)

   local js_content = json.decode(content)
   assert(js_content.body is outgoing_body, 'Unexpected response in body: ' .. content)
end

-----------------------------------------------------------------------------------------------------------------------

function testSSLOverProxy()
   local proc = processing.new({ timeout = 5.0 })

   local http = obj.new('http', {
      src         = 'https://www.google.co.uk/',
      method      = 'get',
      outputFile  = glOutFile,
      proxyserver = 'localhost',
      proxyport   = '8080'
   })

   local err = http.acActivate()
   assert(err is ERR_Okay, 'HTTP activation failed: ' .. mSys.GetErrorMsg(err))

   err = proc.sleep(5.0)
   assert(err is ERR_Okay, 'Processing failed: ' .. mSys.GetErrorMsg(err))
end

----------------------------------------------------------------------------------------------------------------------
-- curl -v -X GET https://www.google.com

function testHTTPS()
   local content
   local proc = processing.new({ timeout = 5.0 })

   local http = obj.new('http', {
      src        = 'https://www.google.com',
      method     = 'get',
      outputFile = glOutFile,
      stateChanged = function(HTTP, State)
         if (State is HGS_COMPLETED) then
            msg('State changed to COMPLETED.')
         end
         if (State is HGS_COMPLETED) or (State is HGS_TERMINATED) then
            proc.signal()
         end
         return ERR_Okay
      end
   })

   assert(http.acActivate() is ERR_Okay, 'HTTP activation failed: ' .. mSys.GetErrorMsg(err))

   local err = proc.sleep(5.0)

   local content = file.readAll(glOutFile)
   print(string.format('%.80s [%d bytes]', content, content:len()))
   assert(content, 'No content received.')
   assert(err is ERR_Okay, 'Processing failed: ' .. mSys.GetErrorMsg(err))
end

----------------------------------------------------------------------------------------------------------------------
-- Making an HTTPS request to google.co.uk should cause a redirect to google.com, which should
-- all be handled in the background.

function testRedirectedHTTPS()
   local content
   local proc = processing.new({ timeout = 5.0 })

   local http = obj.new('http', {
      src        = 'https://www.google.co.uk',
      method     = 'get',
      outputFile = glOutFile,
      stateChanged = function(HTTP, State)
         if (State is HGS_COMPLETED) then
            content = file.readAll(glOutFile)
            print(string.format('%.80s [%d bytes]', content, content:len()))
         end
         if (State is HGS_COMPLETED) or (State is HGS_TERMINATED) then
            proc.signal()
         end
         return ERR_Okay
      end
   })

   local err = http.acActivate()
   assert(err is ERR_Okay, 'HTTP activation failed: ' .. mSys.GetErrorMsg(err))

   local err = proc.sleep(5.0)
   assert(err is ERR_Okay, 'Processing failed: ' .. mSys.GetErrorMsg(err))
   assert(content, 'No content received.')
end

----------------------------------------------------------------------------------------------------------------------

function testMultiPart()
   local proc = processing.new({ timeout = 5.0 })
   local content = ''
   local boundary = '----------d6sXWGimDGTgb2GDuLZqbR'

   local http = obj.new('http', {
      src         = 'http://127.0.0.1/upload',
      method      = 'post',
      outputFile  = glOutFile,
      flags       = HTF_NO_HEADER,
      contenttype = 'multipart/form-data; boundary=' .. boundary,
      incoming = function(HTTP, Buffer)
         content ..= tostring(Buffer)
      end
   } )

   local str = ''
   local CRLF = string.char(13,10)
   local filepath = args('inFile')
   local filename = string.gsub(filepath, '.*[:/\\](.-)', '%1', 1)

   // Parameters

   msg('Building parameters')
   str ..= '--' .. boundary .. CRLF
   str ..= "Content-Disposition: form-data; name=\"method\"" .. CRLF .. CRLF
   str ..= 'fileUpload' .. CRLF

   str ..= '--' .. boundary .. CRLF
   str ..= "Content-Disposition: form-data; name=\"workspace\"" .. CRLF .. CRLF
   str ..= '1' .. CRLF

   // File header

   str ..= '--' .. boundary .. CRLF
   str ..= "Content-Disposition: form-data; name=\"file\"; filename=\"" .. filename .. "\"" .. CRLF
   str ..= 'Content-Type: application/octet-stream' .. CRLF .. CRLF

   local headfile = obj.new('file', { src='temp:http-head', flags='WRITE|NEW' } )
   headfile.acWrite(str, str:len())

   local tailfile = obj.new('file', { src='temp:http-tail', flags='WRITE|NEW' } )
   str = CRLF .. '--' .. boundary .. '--' .. CRLF
   tailfile.acWrite(str, str:len())

   local srcfile = obj.new('file', { src=filepath, flags='READ' } )

   if (srcfile) then
      http.size = headfile.size + tailfile.size + srcfile.size
      http.inputfile = headfile.location .. '|' .. srcfile.location .. '|' .. tailfile.location
      http.acActivate()
   end

   headfile = nil
   tailfile = nil
   srcfile = nil

   assert(proc.sleep(5.0) != ERR_TimeOut, 'Test timed-out.')
end

----------------------------------------------------------------------------------------------------------------------
-- ipv6.google.com test-ipv6.com ipv6.he.net ipv6.cloudflare.com

function testIPV6()
   local proc = processing.new({ timeout = 10.0 })
   local content = ''

   local http = obj.new('http', {
      src        = 'http://ipv6.google.com/',
      method     = 'get',
      connectTimeout = 10,
      stateChanged = function(HTTP, State)
         if (State is HGS_COMPLETED) then
            print(string.format('%.80s [80 of %d bytes]', content, content:len()))
         end
         if (State is HGS_COMPLETED) or (State is HGS_TERMINATED) then
            proc.signal()
         end
      end,
      incoming = function(HTTP, Buffer)
         content ..= tostring(Buffer)
      end
   })

   local err = http.acActivate()
   assert(err is ERR_Okay, "HTTP object failed to activate.")

   err = proc.sleep()
   if (http.error is ERR_HostNotFound) then print('Unable to test, IPv6 name resolution failed.') return end
   assert(err is ERR_Okay, 'Processing failed: ' .. mSys.GetErrorMsg(err))
   assert(http.error is ERR_Okay, 'HTTP object returned error: ' .. mSys.GetErrorMsg(http.error))
   assert(http.currentState is HGS_COMPLETED, 'Expected HTTP state of COMPLETED not reached, got ' .. http.currentState)

   if #content < 2048 then
       print('Response content:')
       print(content)
   else
       print('Response preview (first 500 chars):')
       print(string.sub(content, 0, 499) .. '...')
   end
end

----------------------------------------------------------------------------------------------------------------------

   return {
      tests = {
        'testGetLocal',
        'testPostStringLocal',
        'testPostStringExt',
        'testPostStringFile',
        'testHTTPS',
        'testRedirectedHTTPS',
        'testIPV6'
      },
      init = function(Path)
         print('Serving files from ' .. Path)

         glServer = hslib.start({
            port    = SERVER_PORT,
            folder  = Path,
            verbose = true,
            routes = {
              { pattern = '/api/test',
                method = 'GET',
                handler = function(req, res)
                   res.json({ message = 'GET route works!' })
                end
              },
              { pattern = '/post',
                method = 'POST',
                handler = function(req, res)
                   -- Return the request data for testing
                   res.json({
                      message = 'Simple post works!',
                      body = req.body,
                      headers = req.headers
                   })
                end
               },
              { pattern = '/api/users/:id',
                method = 'POST',
                handler = function(req, res)
                   local userId = req.params.id
                   res.json({
                      message = 'User route works!',
                      userId = userId,
                      method = req.method
                   })
                end
               }
            }
         })
      end,
      cleanup = function()
         glServer.stop()
         mSys.DeleteFile(glOutFile)
      end
   }
