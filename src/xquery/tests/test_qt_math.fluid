-- W3C XQuery Test Suite - Math Functions
-- Tests from QT3_1_0/math folder

   include 'xml'
   require 'io/filesearch'

-----------------------------------------------------------------------------------------------------------------------
-- Helper to parse test XML and execute tests

local function runTest(TestPath)
   local xml = obj.new('xml', { path = TestPath })

   local err, testSetId = xml.mtSearch('/test-set')
   if err != ERR_Okay then
      error('Failed to find <test-set> in ' .. TestPath .. ': ' .. (xml.errorMsg or mSys.GetErrorMsg(err)))
   end

   local err, testSetName = xml.mtGetAttrib(testSetId, 'name')
   if err != ERR_Okay then
      testSetName = 'unknown'
   end

   local passed = 0
   local total_tests = 0

   local err, index = xml.mtSearch('//test-case', function(XML, TagID, Attrib)
      local err, test_name = xml.mtGetAttrib(TagID, 'name')
      if err != ERR_Okay then
         print('  SKIP: (unnamed test case)')
         return
      end

      -- Get the test query using XPath from the test-case
      local err, test_query = xml.mtEvaluate('//test-case[@name="' .. test_name .. '"]/test')
      if err != ERR_Okay or not nz(test_query) then
         print('  SKIP: ' .. test_name .. ' (no test query found)')
         return
      end

      print(test_name .. ': ' .. test_query)

      total_tests += 1

      -- Get expected result using XPath from the test-case

      local err, result_id = xml.mtSearch('//test-case[@name="' .. test_name .. '"]/result')
      if err != ERR_Okay then
         print('  SKIP: ' .. test_name .. ' (no result found)')
         return
      end

      -- Create a new XML context with math namespace for evaluation

      local testXml = obj.new('xml', {
         statement = '<?xml version="1.0"?><root xmlns:math="http://www.w3.org/2005/xpath-functions/math"/>'
      })

      local err, actual_result = testXml.mtEvaluate(test_query)
      if err != ERR_Okay then
         print('  FAIL: ' .. test_name .. ' (query error: ' .. mSys.GetErrorMsg(err) .. ')')
         return
      end

      local assert_eq, assert_empty, assert_string
      err, assert_eq = xml.mtEvaluate('//test-case[@name="' .. test_name .. '"]/result/assert-eq')
      if err != ERR_Okay then
         err, assert_empty = xml.mtEvaluate('//test-case[@name="' .. test_name .. '"]/result/assert-empty')
         if err != ERR_Okay then
            err, assert_string = xml.mtEvaluate('//test-case[@name="' .. test_name .. '"]/result/assert-string-value')
         end
      end

      local testPassed = false

      if assert_eq then -- assert-eq: exact equality
         -- Get the tag and extract content
         local err, assertTag = xml.mtGetTag(assertEqId)
         local expectedValue = ''
         if assertTag and assertTag.children then
            for _, child in ipairs(assertTag.children) do
               if child.attribs and child.attribs[1] and child.attribs[1].name is '' then
                  expectedValue = expectedValue .. (child.attribs[1].value or '')
               end
            end
         end

         -- Compare values (handle scientific notation)
         local actual = tostring(actual_result):gsub('%s+', '')
         local expected = tostring(expectedValue):gsub('%s+', '')

         -- For numeric comparison, convert to numbers if possible
         local actualNum = tonumber(actual)
         local expectedNum = tonumber(expected)

         if actualNum and expectedNum then
            -- Use epsilon comparison for floating point
            if math.abs(actualNum - expectedNum) < 1e-10 then
               testPassed = true
            end
         elseif actual is expected then
            testPassed = true
         end

         if testPassed then
            print('  PASS: ' .. test_name)
            passed = passed + 1
         else
            print('  FAIL: ' .. test_name .. ' (expected ' .. expected .. ', got ' .. actual .. ')')
         end
      elseif assert_empty then
         -- assert-empty: result should be empty sequence
         if not actual_result or actual_result is '' then
            print('  PASS: ' .. test_name)
            passed += 1
            testPassed = true
         else
            print('  FAIL: ' .. test_name .. ' (expected empty, got ' .. tostring(actual_result) .. ')')
         end

      elseif assert_string then
         -- assert-string-value: compare as strings
         -- Get the tag and extract content
         local err, assertTag = xml.mtGetTag(assertStringId)
         local expectedValue = ''
         if assertTag and assertTag.children then
            for _, child in ipairs(assertTag.children) do
               if child.attribs and child.attribs[1] and child.attribs[1].name is '' then
                  expectedValue = expectedValue .. (child.attribs[1].value or '')
               end
            end
         end

         local actual = tostring(actual_result)
         local expected = tostring(expectedValue)
         if actual is expected then
            print('  PASS: ' .. test_name)
            passed += 1
            testPassed = true
         else
            print('  FAIL: ' .. test_name .. ' (expected "' .. expected .. '", got "' .. actual .. '")')
         end
      else
         passed += 1
         print('  SKIP: ' .. test_name .. ' (unknown assertion type)')
      end
   end)

   assert(passed is total_tests, 'Passed ' .. passed .. ' of ' .. total_tests .. ' tests')
end

-----------------------------------------------------------------------------------------------------------------------

return {
   init = function(ScriptFolder)
      local math_folder = ScriptFolder .. 'QT3_1_0/math/'

      if mSys.AnalysePath(math_folder) != ERR_Okay then
         -- Assume the XQuery test package isn't installed on this machine
         print('Math folder not found at: ' .. math_folder)
         return
      end

      print('Searching for tests in: ' .. math_folder)

      local tests = { }

      file.search(math_folder, {
         nameFilter  = '%.xml$',
         nameWild = true,
         matchFeedback = function(Path, FileName)
            local func_name = FileName
            table.insert(tests, func_name)
            _G[func_name] = function()
               runTest(Path .. FileName)
            end
         end
      })

      return tests
   end
}
