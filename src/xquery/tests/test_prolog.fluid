-- XQuery prolog integration tests

   include 'xml'

-----------------------------------------------------------------------------------------------------------------------
-- User-defined functions declared in the prolog should execute during evaluation

function testUserDefinedFunction()
   local xq = obj.new('xquery', { statement = 'declare function local:square($x) { $x * $x }; local:square(5)' })
   assert(xq.acActivate() is ERR_Okay, 'Query execution failed: ' .. tostring(xq.errorMsg))
   assert(tonumber(xq.resultString) is 25, 'Prolog-defined function should return the squared result, got ' .. tostring(xq.resultString))

   local list = xq.functions
   assert(list, "Expected module functions to be accessible")
   local func_seen = false
   for k,v in pairs(list) do
      if (v is 'local:square') then func_seen = true end
   end
   assert(func_seen, "Module function 'local:square' not found in function list")

   local err, xstr = xq.mtInspectFunctions("local:square")
   assert(err is ERR_Okay, "Inspection of 'local:square' failed: " .. tostring(xq.errorMsg))
   print('Found: ' .. xstr)
   assert(string.find(xstr, "<name>local:square</name>"), "Inspection output should include function name")
end

-----------------------------------------------------------------------------------------------------------------------
-- Namespace declarations and prolog variables should participate in evaluation

function testNamespaceAndVariableDeclarations()
   local xml = obj.new('xml', {
      statement = '<root xmlns:ex="http://example.com/ns"><ex:item>Alpha</ex:item></root>'
   })

   local expr = 'declare namespace ex = "http://example.com/ns"; declare variable $ex:answer := 42; if ($ex:answer = 42 and string(/root/ex:item) = "Alpha") then "pass" else "fail"'
   local err, value = xml.mtEvaluate(expr)

   assert(value is 'pass', 'Prolog namespace and variable declarations should evaluate correctly, got ' .. tostring(value))
   assert(xml.errorMsg is nil or xml.errorMsg is '', 'Namespace and variable declarations should not record an error message, got ' .. tostring(xml.errorMsg))
end

-----------------------------------------------------------------------------------------------------------------------
-- Boundary-space preservation should retain lexical whitespace in direct element constructors

function testBoundarySpacePreservation()
   local xq = obj.new('xquery', { statement = 'declare boundary-space preserve; string(<a>  padded  </a>)' })
   local err = xq.acActivate()
   assert(xq.resultString is '  padded  ', 'Boundary-space preserve should retain surrounding whitespace, got ' .. tostring(xq.resultString))
end

function testBoundarySpacePreserveComputedText()
   local expr = table.concat({
      'declare boundary-space preserve;',
      'string(<a>{"  padded  "}</a>)'
   }, ' ')

   local xq = obj.new('xquery', { statement = expr })
   local err = xq.acActivate()
   assert(err is ERR_Okay, 'Query execution failed: ' .. tostring(xq.errorMsg))
   assert(xq.resultString is '  padded  ', 'Boundary-space preserve should retain whitespace from enclosed expressions, got ' .. tostring(xq.resultString))
end

function testBoundarySpaceStripRemoval()
   local xq = obj.new('xquery', { statement = 'string(<a>   </a>)' })
   local err = xq.acActivate()
   assert(err is ERR_Okay, 'Query execution failed: ' .. tostring(xq.errorMsg))
   assert(xq.resultString is '', 'Boundary-space strip should remove whitespace-only text, got ' .. tostring(xq.resultString))
end

function testBoundarySpaceStripComputedText()
   local xq = obj.new('xquery', { statement = 'string(<a>{"  padded  "}</a>)' })
   local err = xq.acActivate()
   assert(err is ERR_Okay, 'Query execution failed: ' .. tostring(xq.errorMsg))
   assert(xq.resultString is 'padded', 'Boundary-space strip should trim whitespace from enclosed expressions, got ' .. tostring(xq.resultString))
end

function testConstructionStripComputedWhitespace()
   local expr = table.concat({
      'declare construction strip;',
      'string(<a>{"   "}</a>)'
   }, ' ')

   local xq = obj.new('xquery', { statement = expr })
   local err = xq.acActivate()
   assert(err is ERR_Okay, 'Query execution failed: ' .. tostring(xq.errorMsg))
   assert(xq.resultString is '', 'Construction strip should remove whitespace-only computed text nodes, got ' .. tostring(xq.resultString))
end

function testConstructionPreserveComputedWhitespace()
   local expr = table.concat({
      'declare construction preserve;',
      'string(<a>{"   "}</a>)'
   }, ' ')

   local xq = obj.new('xquery', { statement = expr })
   local err = xq.acActivate()
   assert(err is ERR_Okay, 'Query execution failed: ' .. tostring(xq.errorMsg))
   assert(xq.resultString is '   ', 'Construction preserve should retain whitespace-only computed text nodes, got ' .. tostring(xq.resultString))
end

function testConstructionStripTextConstructorWhitespace()
   local expr = table.concat({
      'declare construction strip;',
      'string(element wrapper { text { "  padded  " } })'
   }, ' ')

   local xq = obj.new('xquery', { statement = expr })
   local err = xq.acActivate()
   assert(err is ERR_Okay, 'Query execution failed: ' .. tostring(xq.errorMsg))
   assert(xq.resultString is 'padded', 'Construction strip should trim text constructor content, got ' .. tostring(xq.resultString))
end

function testConstructionPreserveTextConstructorWhitespace()
   local expr = table.concat({
      'declare construction preserve;',
      'string(element wrapper { text { "  padded  " } })'
   }, ' ')

   local xq = obj.new('xquery', { statement = expr })
   local err = xq.acActivate()
   assert(err is ERR_Okay, 'Query execution failed: ' .. tostring(xq.errorMsg))
   assert(xq.resultString is '  padded  ', 'Construction preserve should retain text constructor whitespace, got ' .. tostring(xq.resultString))
end

-----------------------------------------------------------------------------------------------------------------------
-- Recursive functions declared in the prolog should resolve correctly

function testRecursiveFunction()
   local xq = obj.new('xquery', { statement = 'declare function local:factorial($n) { if ($n le 1) then 1 else $n * local:factorial($n - 1) }; local:factorial(5)' })
   local err = xq.acActivate()
   assert(err is ERR_Okay, 'Query execution failed: ' .. tostring(xq.errorMsg))
   local result = tonumber(xq.resultString)
   assert(result is 120, 'Recursive prolog function should compute factorial, got ' .. tostring(result))
   assert(xq.errorMsg is nil or xq.errorMsg is '', 'Recursive function evaluation should not record an error message, got ' .. tostring(xq.errorMsg))
end

-----------------------------------------------------------------------------------------------------------------------
-- Functions with the same QName but different arity should dispatch based on argument count

function testFunctionOverloadingByArity()
   local xq = obj.new('xquery', { statement = [[
declare function local:adder($a, $b) { $a + $b };
declare function local:adder($a, $b, $c) { $a + $b + $c };
concat(local:adder(2, 3), ":", local:adder(1, 2, 3))
]] })
   assert(xq.acActivate() is ERR_Okay, 'Query execution failed: ' .. tostring(xq.errorMsg))
   local value = xq.resultString
   assert(value is '5:6', 'Function overloading by arity should select the correct body, got ' .. tostring(value))
   assert(xq.errorMsg is nil or xq.errorMsg is '', 'Function overloading should not record an error message, got ' .. tostring(xq.errorMsg))

   local err, xstr = xq.mtInspectFunctions("local:*")
   assert(err is ERR_Okay, "Inspection of 'local:adder' failed: " .. tostring(xq.errorMsg))
   print('Found: ' .. xstr)
   assert(string.find(xstr, "<name>local:adder</name>"), "Inspection output should include function name")
end

-----------------------------------------------------------------------------------------------------------------------
-- Namespace prefixes declared on the document should remain accessible when compiling queries

function testNamespaceFallbackFromDocument()
   local xml = obj.new('xml', {
      statement = '<root xmlns:ns="urn:fallback"><ns:item>Alpha</ns:item></root>'
   })

   local err, value = xml.mtEvaluate('/root/ns:item')
   assert(value is 'Alpha', 'Document namespace prefixes should be available during evaluation, got ' .. tostring(value))
   assert(xml.errorMsg is nil or xml.errorMsg is '', 'Namespace fallback should not record an error message, got ' .. tostring(xml.errorMsg))
end

-----------------------------------------------------------------------------------------------------------------------
-- Dynamic bindings should shadow prolog variables of the same QName

function testVariableShadowing()
   local xq = obj.new('xquery', { statement = 'declare variable $local:value := "prolog"; let $local:value := "runtime" return $local:value' })
   local err = xq.acActivate()
   assert(err is ERR_Okay, 'Query execution failed: ' .. tostring(xq.errorMsg))
   assert(xq.resultString is 'runtime', 'Dynamic let binding should shadow prolog variable, got ' .. tostring(xq.resultString))
   assert(xq.errorMsg is nil or xq.errorMsg is '', 'Variable shadowing should not record an error message, got ' .. tostring(xq.errorMsg))
end

-----------------------------------------------------------------------------------------------------------------------
-- External variable declarations should surface explicit diagnostics

function testExternalVariableErrorHandling()
   local xq = obj.new('xquery', { statement = 'declare variable $local:missing external; $local:missing' })
   local err = xq.acActivate()
   local message = tostring(xq.errorMsg)
   assert(err != ERR_Okay, 'External variable declaration should fail during activation')
   assert(message is "External variable 'local:missing' is not supported.", 'External variable access should report a descriptive error, got ' .. message)
end

-----------------------------------------------------------------------------------------------------------------------
-- External function declarations should report missing implementation errors

function testExternalFunctionErrorHandling()
   local xq = obj.new('xquery', { statement = 'declare function local:provided($x) external; local:provided(1)' })
   local err = xq.acActivate()
   local message = tostring(xq.errorMsg)
   assert(err != ERR_Okay, 'External function declaration should fail during activation')
   assert(message is "External function 'local:provided' is not supported.", 'External function invocation should report a descriptive error, got ' .. message)
end

-----------------------------------------------------------------------------------------------------------------------
-- Module imports without an installed loader should emit a load-failure diagnostic

function testModuleImportDeclaration()
   local xq = obj.new('xquery', { statement = 'import module namespace math = "urn:math"; math:square(2)' })
   local err = xq.acActivate()
   local message = tostring(xq.errorMsg)
   assert(err != ERR_Okay, 'Module import should fail without loader')
   -- Loader now emits a structured error with code and attempted locations
   assert(string.find(message, 'XQST0059', 0, true)
      and string.find(message, 'Cannot load module for namespace', 0, true)
      and string.find(message, 'urn:math', 0, true),
      'Module import should record structural diagnostic, got ' .. message)
end

-----------------------------------------------------------------------------------------------------------------------
-- Default function namespace should canonicalise prolog function names

function testDefaultFunctionNamespaceNormalisation()
   local expr = table.concat({
      'declare namespace math = "urn:math";',
      'declare default function namespace "urn:math";',
      'declare function square($x) { $x * $x };',
      'concat(square(3), ":", math:square(4))'
   }, ' ')

   local xq = obj.new('xquery', { statement = expr })
   local err = xq.acActivate()
   assert(err is ERR_Okay, 'Query execution failed: ' .. tostring(xq.errorMsg))
   assert(xq.resultString is '9:16', 'Default function namespace should apply to prefixed and unprefixed calls, got ' .. tostring(xq.resultString))
   assert(xq.errorMsg is nil or xq.errorMsg is '', 'Default function namespace should not record an error, got ' .. tostring(xq.errorMsg))
end

-----------------------------------------------------------------------------------------------------------------------
-- Module import namespaces should be normalised for cache lookups

function testModuleImportNamespaceNormalisation()
   local xq = obj.new('xquery', { statement = 'import module namespace math = "urn:math\\library"; math:square(2)' })
   local err = xq.acActivate()
   local message = tostring(xq.errorMsg)
   assert(err != ERR_Okay, 'Module import with escaped namespace should fail without loader')
   assert(message is "Module 'urn:math/library' could not be loaded for function 'Q{urn:math/library}square'.", 'Module import namespaces should be normalised, got ' .. message)
end

-----------------------------------------------------------------------------------------------------------------------
-- User-defined functions with type annotations should parse without errors

function testFunctionTypeAnnotations()
   local xq = obj.new('xquery', { statement = 'declare function local:add($a as xs:integer, $b as xs:integer) as xs:integer { $a + $b }; local:add(10, 20)' })
   local err = xq.acActivate()
   assert(err is ERR_Okay, 'Query execution failed: ' .. tostring(xq.errorMsg))
   local result = tonumber(xq.resultString)
   assert(result is 30, 'Function with type annotations should execute correctly, got ' .. tostring(result))
   assert(xq.errorMsg is nil or xq.errorMsg is '', 'Function with type annotations should not record an error, got ' .. tostring(xq.errorMsg))
end

-----------------------------------------------------------------------------------------------------------------------
-- Multiple namespace declarations in prolog should be available during evaluation

function testMultipleNamespacesInProlog()
   local xml = obj.new('xml', {
      statement = '<root xmlns:a="urn:a" xmlns:b="urn:b"><a:item>A</a:item><b:item>B</b:item></root>'
   })

   local expr = 'declare namespace a = "urn:a"; declare namespace b = "urn:b"; concat(string(/root/a:item), ":", string(/root/b:item))'
   local err, value = xml.mtEvaluate(expr)
   assert(value is 'A:B', 'Multiple namespace declarations should work, got ' .. tostring(value))
   assert(xml.errorMsg is nil or xml.errorMsg is '', 'Multiple namespaces should not error, got ' .. tostring(xml.errorMsg))
end

-----------------------------------------------------------------------------------------------------------------------
-- Variable initialization expressions should evaluate correctly

function testVariableInitializerExpressions()
   local xq = obj.new('xquery', { statement = 'declare variable $x := 5; declare variable $y := $x * 2; $x + $y' })
   local err = xq.acActivate()
   assert(err is ERR_Okay, 'Query execution failed: ' .. tostring(xq.errorMsg))
   local value = tonumber(xq.resultString)
   assert(value is 15, 'Variable initialiser expressions should evaluate, got ' .. tostring(value))
   assert(xq.errorMsg is nil or xq.errorMsg is '', 'Variable initialisers should not error, got ' .. tostring(xq.errorMsg))
end

-----------------------------------------------------------------------------------------------------------------------
-- Default collation declaration should parse without errors (stored for future use)

function testDefaultCollationDeclaration()
   local xq = obj.new('xquery', { statement = 'declare default collation "http://www.w3.org/2005/xpath-functions/collation/codepoint"; "test"' })
   local err = xq.acActivate()
   assert(err is ERR_Okay, 'Query execution failed: ' .. tostring(xq.errorMsg))
   assert(xq.resultString is 'test', 'Default collation declaration should not affect evaluation, got ' .. tostring(xq.resultString))
   assert(xq.errorMsg is nil or xq.errorMsg is '', 'Default collation should not error, got ' .. tostring(xq.errorMsg))
end

function testDefaultCollationFunctionUsesProlog()
   local xq = obj.new('xquery', { statement = 'declare default collation "urn:custom"; default-collation()' })
   local err = xq.acActivate()
   assert(err is ERR_Okay, 'Query execution failed: ' .. tostring(xq.errorMsg))
   assert(xq.resultString is 'urn:custom', 'default-collation() should honour prolog declaration, got ' .. tostring(xq.resultString))
end

function testDecimalFormatDeclaration()
   local xq = obj.new('xquery', { statement = 'declare decimal-format local:df decimal-separator = "x"; "ok"' })
   local err = xq.acActivate()
   assert(err is ERR_Okay, 'Query execution failed: ' .. tostring(xq.errorMsg))
   assert(xq.resultString is 'ok', 'Decimal-format declaration should succeed, got ' .. tostring(xq.resultString))
   assert(xq.errorMsg is nil or xq.errorMsg is '', 'Decimal-format declaration should not error, got ' .. tostring(xq.errorMsg))
end

-----------------------------------------------------------------------------------------------------------------------
-- Construction mode declaration should parse correctly

function testConstructionModeDeclaration()
   local xq = obj.new('xquery', { statement = 'declare construction strip; string(<test>value</test>)' })
   local err = xq.acActivate()
   assert(err is ERR_Okay, 'Query execution failed: ' .. tostring(xq.errorMsg))
   assert(xq.resultString is 'value', 'Construction mode declaration should parse, got ' .. tostring(xq.resultString))
   assert(xq.errorMsg is nil or xq.errorMsg is '', 'Construction mode should not error, got ' .. tostring(xq.errorMsg))
end

function testConstructionStripTrimsComputedContent()
   local xq = obj.new('xquery', { statement = 'declare construction strip; string(<test>{ "  padded  " }</test>)' })
   local err = xq.acActivate()
   assert(err is ERR_Okay, 'Query execution failed: ' .. tostring(xq.errorMsg))
   assert(xq.resultString is 'padded', 'Construction strip should trim computed content, got ' .. tostring(xq.resultString))
end

function testConstructionPreserveRetainsWhitespace()
   local xq = obj.new('xquery', { statement = 'declare construction preserve; string(<test>{ "  padded  " }</test>)' })
   local err = xq.acActivate()
   assert(err is ERR_Okay, 'Query execution failed: ' .. tostring(xq.errorMsg))
   assert(xq.resultString is '  padded  ', 'Construction preserve should keep surrounding whitespace, got ' .. tostring(xq.resultString))
end

-----------------------------------------------------------------------------------------------------------------------
-- Function with zero parameters should work

function testZeroParameterFunction()
   local xq = obj.new('xquery', { statement = 'declare function local:getAnswer() { 42 }; local:getAnswer()' })
   local err = xq.acActivate()
   assert(err is ERR_Okay, 'Query execution failed: ' .. tostring(xq.errorMsg))
   assert(tonumber(xq.resultString) is 42, 'Zero-parameter function should work, got ' .. tostring(xq.resultString))
   assert(xq.errorMsg is nil or xq.errorMsg is '', 'Zero-parameter function should not error, got ' .. tostring(xq.errorMsg))
end

-----------------------------------------------------------------------------------------------------------------------
-- Function with many parameters should work

function testMultiParameterFunction()
   local xq = obj.new('xquery', { statement = 'declare function local:sum($a, $b, $c, $d, $e) { $a + $b + $c + $d + $e }; local:sum(1, 2, 3, 4, 5)' })
   local err = xq.acActivate()
   assert(err is ERR_Okay, 'Query execution failed: ' .. tostring(xq.errorMsg))
   assert(tonumber(xq.resultString) is 15, 'Multi-parameter function should work, got ' .. tostring(xq.resultString))
   assert(xq.errorMsg is nil or xq.errorMsg is '', 'Multi-parameter function should not error, got ' .. tostring(xq.errorMsg))
end

-----------------------------------------------------------------------------------------------------------------------
-- Prolog variables should initialize before use in expression

function testPrologVariableAvailability()
   local xq = obj.new('xquery', { statement = 'declare variable $pi := 3.14159; $pi * 100' })
   local err = xq.acActivate()
   assert(err is ERR_Okay, 'Query execution failed: ' .. tostring(xq.errorMsg))
   local value = tonumber(xq.resultString)
   assert(math.floor(value + 0.5) is 314, 'Prolog variable should be available, got ' .. tostring(value))
   assert(xq.errorMsg is nil or xq.errorMsg is '', 'Prolog variable should not error, got ' .. tostring(xq.errorMsg))
end

-----------------------------------------------------------------------------------------------------------------------
-- Function name collision with builtin should allow user-defined to be called with matching arity

function testFunctionNameCollisionResolution()
   -- Note: We cannot truly override built-in functions with single parameter since those exist
   -- So we test with a different arity where the user function should be selected
   local xq = obj.new('xquery', { statement = 'declare function local:count($x, $y) { "custom" }; local:count(1, 2)' })
   local err = xq.acActivate()
   assert(err is ERR_Okay, 'Query execution failed: ' .. tostring(xq.errorMsg))
   assert(xq.resultString is 'custom', 'User-defined function with different arity should be called, got ' .. tostring(xq.resultString))
   assert(xq.errorMsg is nil or xq.errorMsg is '', 'Function name resolution should work, got ' .. tostring(xq.errorMsg))
end

-----------------------------------------------------------------------------------------------------------------------
-- Prolog namespace should take precedence over document namespace with same prefix

function testNamespacePrecedence()
   local xml = obj.new('xml', {
      statement = '<root xmlns:ex="urn:document"><ex:item>doc-value</ex:item></root>'
   })

   -- Declare a prolog namespace that shadows the document namespace
   local expr = 'declare namespace ex = "urn:prolog"; string(/root/ex:item)'
   local err, value = xml.mtEvaluate(expr)
   -- This tests whether prolog namespace takes precedence
   assert(xml.errorMsg is nil or xml.errorMsg is '', 'Namespace precedence should be handled, got ' .. tostring(xml.errorMsg))
end

-----------------------------------------------------------------------------------------------------------------------
-- Multiple function declarations with same name but different arity should all be available

function testMultipleFunctionArities()
   local expr = 'declare function local:f($a) { "one" }; declare function local:f($a, $b) { "two" }; declare function local:f($a, $b, $c) { "three" }; concat(local:f(1), ":", local:f(1, 2), ":", local:f(1, 2, 3))'
   local xq = obj.new('xquery', { statement = expr })
   local err = xq.acActivate()
   assert(err is ERR_Okay, 'Query execution failed: ' .. tostring(xq.errorMsg))
   assert(xq.resultString is 'one:two:three', 'Multiple function arities should be available, got ' .. tostring(xq.resultString))
   assert(xq.errorMsg is nil or xq.errorMsg is '', 'Multiple function arities should not error, got ' .. tostring(xq.errorMsg))
end

-----------------------------------------------------------------------------------------------------------------------
-- Base URI declaration should parse (stored for future use)

function testBaseUriDeclaration()
   local xq = obj.new('xquery', { statement = 'declare base-uri "http://example.com/"; "ok"' })
   local err = xq.acActivate()
   assert(err is ERR_Okay, 'Query execution failed: ' .. tostring(xq.errorMsg))
   assert(xq.resultString is 'ok', 'Base URI declaration should parse, got ' .. tostring(xq.resultString))
   assert(xq.errorMsg is nil or xq.errorMsg is '', 'Base URI declaration should not error, got ' .. tostring(xq.errorMsg))
end

-----------------------------------------------------------------------------------------------------------------------
-- Ordering declaration should parse

function testOrderingDeclaration()
   local xq = obj.new('xquery', { statement = 'declare ordering ordered; (3, 1, 2)' })
   local err = xq.acActivate()
   assert(err is ERR_Okay, 'Query execution failed: ' .. tostring(xq.errorMsg))
   assert(xq.resultString != nil, 'Ordering declaration should parse')
   assert(xq.errorMsg is nil or xq.errorMsg is '', 'Ordering declaration should not error, got ' .. tostring(xq.errorMsg))
end

function testOrderingModeUnorderedSequence()
   local xml = obj.new('xml', { statement = '<root><a>Alpha</a><b>Beta</b></root>' })

   local expr = table.concat({
      'declare ordering unordered;',
      'let $seq := (/root/b, /root/a)',
      'return concat(string($seq[1]), ":", string($seq[2]))'
   }, ' ')

   local err, value = xml.mtEvaluate(expr)
   assert(value is 'Beta:Alpha', 'Ordering unordered should preserve evaluation sequence, got ' .. tostring(value))
end

function testOrderingModeUnorderedUnion()
   local xml = obj.new('xml', { statement = '<root><a>Alpha</a><b>Beta</b></root>' })

   local expr = table.concat({
      'declare ordering unordered;',
      'let $u := ((/root/b) union (/root/a))',
      'return concat(string($u[1]), ":", string($u[2]))'
   }, ' ')

   local err, value = xml.mtEvaluate(expr)
   assert(value is 'Beta:Alpha', 'Ordering unordered should preserve union branch order, got ' .. tostring(value))
end

function testOrderingModeUnorderedIntersect()
   local xml = obj.new('xml', { statement = '<root><a>Alpha</a><b>Beta</b></root>' })

   local expr = table.concat({
      'declare ordering unordered;',
      'let $inter := ((/root/b, /root/a) intersect (/root/a | /root/b))',
      'return concat(string($inter[1]), ":", string($inter[2]))'
   }, ' ')

   local err, value = xml.mtEvaluate(expr)
   assert(value is 'Beta:Alpha', 'Ordering unordered should retain left operand order for intersect, got ' .. tostring(value))
end

function testOrderingModeUnorderedExcept()
   local xml = obj.new('xml', { statement = '<root><a>Alpha</a><b>Beta</b><c>Gamma</c></root>' })

   local expr = table.concat({
      'declare ordering unordered;',
      'let $exc := ((/root/c, /root/a, /root/b) except (/root/a))',
      'return concat(string($exc[1]), ":", string($exc[2]))'
   }, ' ')

   local err, value = xml.mtEvaluate(expr)
   assert(value is 'Gamma:Beta', 'Ordering unordered should respect operand order for except, got ' .. tostring(value))
end

function testDefaultEmptyOrderGreatest()
   local expr = table.concat({
      'let $seq := (for $x in ("b", "", "a")',
      'order by if ($x = "") then () else $x',
      'return if ($x = "") then "empty" else $x)',
      'return concat($seq[1], ":", $seq[2], ":", $seq[3])'
   }, ' ')

   local xq = obj.new('xquery', { statement = expr })
   local err = xq.acActivate()
   assert(err is ERR_Okay, 'Query execution failed: ' .. tostring(xq.errorMsg))
   assert(xq.resultString is 'a:b:empty', 'Default empty order should treat empties as greatest, got ' .. tostring(xq.resultString))
end

function testEmptyOrderLeastPlacement()
   local expr = table.concat({
      'declare default order empty least;',
      'let $seq := (for $x in ("b", "", "a")',
      'order by if ($x = "") then () else $x',
      'return if ($x = "") then "empty" else $x)',
      'return concat($seq[1], ":", $seq[2], ":", $seq[3])'
   }, ' ')

   local xq = obj.new('xquery', { statement = expr })
   local err = xq.acActivate()
   assert(err is ERR_Okay, 'Query execution failed: ' .. tostring(xq.errorMsg))
   assert(xq.resultString is 'empty:a:b', 'Empty least should place empties first, got ' .. tostring(xq.resultString))
end

-----------------------------------------------------------------------------------------------------------------------
-- Copy-namespaces declaration should parse

function testCopyNamespacesDeclaration()
   local xq = obj.new('xquery', { statement = 'declare copy-namespaces preserve, inherit; "ok"' })
   local err = xq.acActivate()
   assert(err is ERR_Okay, 'Query execution failed: ' .. tostring(xq.errorMsg))
   assert(xq.resultString is 'ok', 'Copy-namespaces declaration should parse, got ' .. tostring(xq.resultString))
   assert(xq.errorMsg is nil or xq.errorMsg is '', 'Copy-namespaces should not error, got ' .. tostring(xq.errorMsg))
end

-----------------------------------------------------------------------------------------------------------------------
-- Queries without prolog should still work

function testQueryWithoutProlog()
   local xml = obj.new('xml', {
      statement = '<root><item>test</item></root>'
   })

   local err, value = xml.mtEvaluate('string(/root/item)')
   assert(value is 'test', 'Query without prolog should work, got ' .. tostring(value))
   assert(xml.errorMsg is nil or xml.errorMsg is '', 'Query without prolog should not error, got ' .. tostring(xml.errorMsg))
end

-----------------------------------------------------------------------------------------------------------------------
-- ERROR HANDLING TESTS
-- These tests enforce W3C XQuery 3.0 specification rules for duplicate declarations
-----------------------------------------------------------------------------------------------------------------------
-- W3C XQuery 3.0 XQST0033: Duplicate namespace prefix declarations must raise static error

function testDuplicateNamespaceDeclaration()
   local ex = catch(function() -- Compilation failure expected
      obj.new('xquery', { statement = 'declare namespace ex = "urn:first"; declare namespace ex = "urn:second"; "test"' })
   end)
   assert(ex, 'W3C XQuery 3.0 XQST0033: Duplicate namespace prefix declaration must raise static error')
end

-----------------------------------------------------------------------------------------------------------------------
-- W3C XQuery 3.0 XQST0049: Duplicate variable declarations must raise static error

function testDuplicateVariableDeclaration()
   local ex = catch(function() -- Compilation failure expected
      obj.new('xquery', { statement = 'declare variable $x := 1; declare variable $x := 2; $x' })
   end)
   assert(ex, 'W3C XQuery 3.0 XQST0049: Duplicate variable declaration must raise static error')
end

-----------------------------------------------------------------------------------------------------------------------
-- W3C XQuery 3.0 XQST0034: Duplicate function declarations with same signature must raise static error

function testDuplicateFunctionDeclaration()
   local ex = catch(function() -- Compilation failure expected
      obj.new('xquery', { statement = 'declare function local:f($x) { $x }; declare function local:f($y) { $y * 2 }; local:f(5)' })
   end)
   assert(ex, 'W3C XQuery 3.0 XQST0034: Duplicate function declaration must raise static error')
end

-----------------------------------------------------------------------------------------------------------------------
-- W3C XQuery 3.0 XQST0032: Duplicate base-uri declarations must raise static error

function testDuplicateBaseUriDeclaration()
   local ex = catch(function() -- Compilation failure expected
      obj.new('xquery', { statement = 'declare base-uri "http://example.com/"; declare base-uri "http://other.com/"; "test"' })
   end)
   assert(ex, 'W3C XQuery 3.0 XQST0032: Duplicate base-uri declaration must raise static error')
end

-----------------------------------------------------------------------------------------------------------------------
-- W3C XQuery 3.0 XQST0038: Duplicate default collation declarations must raise static error

function testDuplicateDefaultCollationDeclaration()
   local ex = catch(function() -- Compilation failure expected
      obj.new('xquery', { statement = 'declare default collation "http://example.com/collation1"; declare default collation "http://example.com/collation2"; "test"' })
   end)
   assert(ex, 'W3C XQuery 3.0 XQST0038: Duplicate default collation declaration must raise static error')
end

-----------------------------------------------------------------------------------------------------------------------
-- W3C XQuery 3.0 XQST0068: Duplicate boundary-space declarations must raise static error

function testDuplicateBoundarySpaceDeclaration()
   local ex = catch(function() -- Compilation failure expected
      obj.new('xquery', { statement = 'declare boundary-space preserve; declare boundary-space strip; "test"' })
   end)
   assert(ex, 'W3C XQuery 3.0 XQST0068: Duplicate boundary-space declaration must raise static error')
end

-----------------------------------------------------------------------------------------------------------------------
-- W3C XQuery 3.0 XQST0067: Duplicate construction mode declarations must raise static error

function testDuplicateConstructionModeDeclaration()
   local ex = catch(function() -- Compilation failure expected
      obj.new('xquery', { statement = 'declare construction preserve; declare construction strip; "test"' })
   end)
   assert(ex, 'W3C XQuery 3.0 XQST0067: Duplicate construction mode declaration must raise static error')
end

-----------------------------------------------------------------------------------------------------------------------
-- W3C XQuery 3.0 XQST0065: Duplicate ordering mode declarations must raise static error

function testDuplicateOrderingModeDeclaration()
   local ex = catch(function() -- Compilation failure expected
      obj.new('xquery', { statement = 'declare ordering ordered; declare ordering unordered; "test"' })
   end)
   assert(ex, 'W3C XQuery 3.0 XQST0065: Duplicate ordering mode declaration must raise static error')
end

-----------------------------------------------------------------------------------------------------------------------
-- W3C XQuery 3.0 XQST0069: Duplicate default empty order declarations must raise static error

function testDuplicateEmptyOrderDeclaration()
   local ex = catch(function() -- Compilation failure expected
      obj.new('xquery', { statement = 'declare default order empty greatest; declare default order empty least; "test"' })
   end)
   assert(ex, 'W3C XQuery 3.0 XQST0069: Duplicate default empty order declaration must raise static error')
end

-----------------------------------------------------------------------------------------------------------------------
-- W3C XQuery 3.0 XQST0055: Duplicate copy-namespaces declarations must raise static error

function testDuplicateCopyNamespacesDeclaration()
   local ex = catch(function() -- Compilation failure expected
      obj.new('xquery', { statement = 'declare copy-namespaces preserve, inherit; declare copy-namespaces no-preserve, no-inherit; "test"' })
   end)
   assert(ex, 'W3C XQuery 3.0 XQST0055: Duplicate copy-namespaces declaration must raise static error')
end

-----------------------------------------------------------------------------------------------------------------------
-- W3C XQuery 3.0 XQST0111: Duplicate decimal-format declarations must raise static error

function testDuplicateDecimalFormatDeclaration()
   local ex = catch(function() -- Compilation failure expected
      obj.new('xquery', { statement = 'declare decimal-format local:df decimal-separator = "."; declare decimal-format local:df grouping-separator = ","; "test"' })
   end)
   assert(ex, 'W3C XQuery 3.0 XQST0111: Duplicate decimal-format declaration must raise static error')
end

-----------------------------------------------------------------------------------------------------------------------
-- W3C XQuery 3.0 XQST0039: Duplicate parameter names in function must raise static error

function testDuplicateParameterNames()
   local ex = catch(function() -- Compilation failure expected
      obj.new('xquery', { statement = 'declare function local:bad($x, $x) { $x }; local:bad(1, 2)' })
   end)
   assert(ex, 'W3C XQuery 3.0 XQST0039: Duplicate parameter names must raise static error')
end

-----------------------------------------------------------------------------------------------------------------------
-- Invalid prolog syntax: missing semicolon should report error

function testInvalidPrologSyntaxMissingSemicolon()
   local ex = catch(function() -- Compilation failure expected
      local xq = obj.new('xquery', { statement = 'declare variable $x := 5 declare variable $y := 10; $x + $y' })
      local err = xq.acActivate()
   end)
   assert(ex, 'Missing semicolon should report a syntax error')
end

-----------------------------------------------------------------------------------------------------------------------
-- Invalid prolog syntax: malformed function declaration

function testInvalidPrologSyntaxMalformedFunction()
   local ex = catch(function() -- Compilation failure expected
      local xq = obj.new('xquery', { statement = 'declare function local:bad { "missing params" }; local:bad()' })
      local err = xq.acActivate()
   end)
   assert(ex, 'Malformed function declaration should report a syntax error')
end

-----------------------------------------------------------------------------------------------------------------------
-- Invalid prolog syntax: incomplete namespace declaration

function testInvalidPrologSyntaxIncompleteNamespace()
   local ex = catch(function() -- Compilation failure expected
      obj.new('xquery', { statement = 'declare namespace ex; "test"' })
   end)
   assert(ex, 'Incomplete namespace declaration should report a syntax error')
end

-----------------------------------------------------------------------------------------------------------------------
-- Invalid prolog syntax: missing variable initializer for non-external variable

function testInvalidPrologSyntaxMissingInitializer()
   local ex = catch(function() -- Compilation failure expected
      obj.new('xquery', { statement = 'declare variable $x; $x' })
   end)
   assert(ex, 'Variable declaration without initializer or external keyword should report an error')
end

-----------------------------------------------------------------------------------------------------------------------
-- Function call with wrong number of parameters (too few)

function testFunctionCallTooFewParameters()
   local ex = catch(function() -- Compilation failure expected
      local xq = obj.new('xquery', { statement = 'declare function local:add($a, $b) { $a + $b }; local:add(5)' })
      xq.acActivate()
   end)
   assert(ex, 'Function call with too few parameters should raise a static error')
end

-----------------------------------------------------------------------------------------------------------------------
-- Function call with wrong number of parameters (too many)

function testFunctionCallTooManyParameters()
   local ex = catch(function() -- Compilation failure expected
      local xq = obj.new('xquery', { statement = 'declare function local:square($x) { $x * $x }; local:square(5, 10)' })
      xq.acActivate()
   end)
   assert(ex, 'Function call with too many parameters should raise a static error')
end

-----------------------------------------------------------------------------------------------------------------------
-- Type annotation parsing: complex sequence types should parse without errors

function testComplexTypeAnnotationParsing()
   local xq = obj.new('xquery', { statement = 'declare function local:process($items as xs:string*) as xs:integer { count($items) }; local:process(("a", "b", "c"))' })
   local err = xq.acActivate()
   assert(err is ERR_Okay, 'Query execution failed: ' .. tostring(xq.errorMsg))
   assert(tonumber(xq.resultString) is 3, 'Function with sequence type annotation should work, got ' .. tostring(xq.resultString))
   assert(xq.errorMsg is nil or xq.errorMsg is '', 'Complex type annotations should parse, got ' .. tostring(xq.errorMsg))
end

-----------------------------------------------------------------------------------------------------------------------
-- Type annotation parsing: optional types should parse

function testOptionalTypeAnnotationParsing()
   local xq = obj.new('xquery', { statement = 'declare function local:maybe($x as xs:string?) as xs:boolean { exists($x) }; local:maybe("test")' })
   local err = xq.acActivate()
   assert(err is ERR_Okay, 'Query execution failed: ' .. tostring(xq.errorMsg))
   assert(xq.resultString is 'true', 'Function with optional type annotation should work, got ' .. tostring(xq.resultString))
   assert(xq.errorMsg is nil or xq.errorMsg is '', 'Optional type annotations should parse, got ' .. tostring(xq.errorMsg))
end

-----------------------------------------------------------------------------------------------------------------------
-- Type annotation parsing: element and node types should parse

function testElementTypeAnnotationParsing()
   local xq = obj.new('xquery', { statement = 'declare function local:check($n as node()) as xs:boolean { true() }; local:check(<test/>)' })
   local err = xq.acActivate()
   assert(err is ERR_Okay, 'Query execution failed: ' .. tostring(xq.errorMsg))
   assert(xq.resultString is 'true', 'Function with node type annotation should work, got ' .. tostring(xq.resultString))
   assert(xq.errorMsg is nil or xq.errorMsg is '', 'Node type annotations should parse, got ' .. tostring(xq.errorMsg))
end

-----------------------------------------------------------------------------------------------------------------------
-- Invalid boundary-space value should report an error

function testInvalidBoundarySpaceValue()
   local ex = catch(function() -- Compilation failure expected
      obj.new('xquery', { statement = 'declare boundary-space invalid; "test"' })
   end)
   assert(ex, 'Invalid boundary-space value should report an error')
end

-----------------------------------------------------------------------------------------------------------------------
-- Invalid construction mode value should report an error

function testInvalidConstructionModeValue()
   local ex = catch(function() -- Compilation failure expected
      obj.new('xquery', { statement = 'declare construction invalid; "test"' })
   end)
   assert(ex, 'Invalid construction mode value should report an error')
end

-----------------------------------------------------------------------------------------------------------------------
-- Invalid ordering mode value should report an error

function testInvalidOrderingModeValue()
   local ex = catch(function() -- Compilation failure expected
      obj.new('xquery', { statement = 'declare ordering invalid; "test"' })
   end)
   assert(ex, 'Invalid ordering mode value should report an error')
end

-----------------------------------------------------------------------------------------------------------------------
-- Invalid empty order value should report an error

function testInvalidEmptyOrderValue()
   local ex = catch(function() -- Compilation failure expected
      obj.new('xquery', { statement = 'declare default order empty invalid; "test"' })
   end)
   assert(ex, 'Invalid empty order value should report an error')
end

-----------------------------------------------------------------------------------------------------------------------
-- Invalid copy-namespaces values should report an error

function testInvalidCopyNamespacesValue()
   local ex = catch(function() -- Compilation failure expected
      obj.new('xquery', { statement = 'declare copy-namespaces invalid, inherit; "test"' })
   end)
   assert(ex, 'Invalid copy-namespaces value should report an error')
end

-----------------------------------------------------------------------------------------------------------------------
-- Accessing undeclared variable should report an error

function testUndeclaredVariableAccess()
   local ex = catch(function() -- Compilation failure expected
      local xq = obj.new('xquery', { statement = '$undeclared' })
      xq.acActivate()
   end)
   assert(ex, 'Accessing undeclared variable should report a static error')
end

-----------------------------------------------------------------------------------------------------------------------
-- Calling undeclared function should report an error

function testUndeclaredFunctionCall()
   local ex = catch(function() -- Compilation failure expected
      local xq = obj.new('xquery', { statement = 'local:undeclared(42)' })
      xq.acActivate()
   end)
   assert(ex, 'Accessing undeclared function should report a static error')
end

-----------------------------------------------------------------------------------------------------------------------
-- Function with invalid QName (missing prefix binding) should report an error

function testFunctionInvalidQName()
   -- This may succeed if the parser accepts unbound prefixes, or may fail.
   -- The important thing is it shouldn't crash
   local xq = obj.new('xquery', { statement = 'declare function unbound:func($x) { $x }; unbound:func(1)' })
   xq.acActivate()
end

-----------------------------------------------------------------------------------------------------------------------
-- Variable with invalid QName (missing prefix binding) should report an error

function testVariableInvalidQName()
   -- This may succeed if the parser accepts unbound prefixes, or may fail
   -- The important thing is it shouldn't crash
   local xq = obj.new('xquery', { statement = 'declare variable $unbound:var := 5; $unbound:var' })
   xq.acActivate()
end

-----------------------------------------------------------------------------------------------------------------------
-- Decimal format with invalid property should be handled

function testDecimalFormatInvalidProperty()
   local ex = catch(function()
      obj.new('xquery', { statement = 'declare decimal-format local:df invalid-prop = "x"; "ok"' })
   end)
   assert(ex, 'Invalid decimal format property should fail to compile.')
end

-----------------------------------------------------------------------------------------------------------------------
-- Empty prolog (just semicolons) should not cause errors

function testEmptyProlog()
   local xq = obj.new('xquery', { statement = ';;; "test"' })
   local err = xq.acActivate()
   if (err is ERR_Okay) then
      assert(xq.resultString is 'test', 'Empty prolog statements should evaluate successfully when accepted, got ' .. tostring(xq.resultString))
   else
      assert(xq.errorMsg and xq.errorMsg != '', 'Empty prolog statements should be handled')
   end
end

-----------------------------------------------------------------------------------------------------------------------
-- Function body with syntax error should report clear error

function testFunctionBodySyntaxError()
   local xq = obj.new('xquery', { statement = 'declare function local:bad($x) { $x + }; local:bad(5)' })
   local err = xq.acActivate()
   assert(err != ERR_Okay and xq.errorMsg and xq.errorMsg != '',
      'Function body with syntax error should report an error')
end

-----------------------------------------------------------------------------------------------------------------------
-- Variable initializer with syntax error should report clear error

function testVariableInitializerSyntaxError()
   local xq = obj.new('xquery', { statement = 'declare variable $x := 5 +; $x' })
   local err = xq.acActivate()
   assert(err != ERR_Okay and xq.errorMsg and xq.errorMsg != '',
      'Variable initializer with syntax error should report an error')
end

-----------------------------------------------------------------------------------------------------------------------

return {
   tests = {
      testUserDefinedFunction, testNamespaceAndVariableDeclarations, testBoundarySpacePreservation,
      testBoundarySpacePreserveComputedText, testBoundarySpaceStripRemoval,
      testConstructionStripComputedWhitespace, testConstructionPreserveComputedWhitespace,
      testConstructionStripTextConstructorWhitespace, testConstructionPreserveTextConstructorWhitespace,
      testRecursiveFunction, testFunctionOverloadingByArity, testNamespaceFallbackFromDocument,
      testVariableShadowing, testExternalVariableErrorHandling, testExternalFunctionErrorHandling,
      testModuleImportDeclaration, testFunctionTypeAnnotations, testMultipleNamespacesInProlog,
      testVariableInitializerExpressions, testDefaultCollationDeclaration, testDefaultCollationFunctionUsesProlog,
      testDecimalFormatDeclaration, testConstructionModeDeclaration,
      testConstructionStripTrimsComputedContent, testConstructionPreserveRetainsWhitespace,
      testZeroParameterFunction, testMultiParameterFunction, testPrologVariableAvailability,
      testFunctionNameCollisionResolution, testNamespacePrecedence, testMultipleFunctionArities,
      testBaseUriDeclaration, testOrderingDeclaration, testOrderingModeUnorderedSequence,
      testOrderingModeUnorderedUnion, testOrderingModeUnorderedIntersect, testOrderingModeUnorderedExcept,
      testDefaultEmptyOrderGreatest, testEmptyOrderLeastPlacement, testCopyNamespacesDeclaration,
      testQueryWithoutProlog,
      -- W3C XQuery 3.0 duplicate declaration error tests (XQST00xx)
      testDuplicateNamespaceDeclaration, testDuplicateVariableDeclaration, testDuplicateFunctionDeclaration,
      testDuplicateBaseUriDeclaration, testDuplicateDefaultCollationDeclaration,
      testDuplicateBoundarySpaceDeclaration, testDuplicateConstructionModeDeclaration,
      testDuplicateOrderingModeDeclaration, testDuplicateEmptyOrderDeclaration,
      testDuplicateCopyNamespacesDeclaration, testDuplicateDecimalFormatDeclaration,
      testDuplicateParameterNames,
      -- Other error handling tests
      testInvalidPrologSyntaxMissingSemicolon, testInvalidPrologSyntaxMalformedFunction,
      testInvalidPrologSyntaxIncompleteNamespace, testInvalidPrologSyntaxMissingInitializer,
      testFunctionCallTooFewParameters, testFunctionCallTooManyParameters,
      testComplexTypeAnnotationParsing, testOptionalTypeAnnotationParsing, testElementTypeAnnotationParsing,
      testInvalidBoundarySpaceValue, testInvalidConstructionModeValue, testInvalidOrderingModeValue,
      testInvalidEmptyOrderValue, testInvalidCopyNamespacesValue,
      testUndeclaredVariableAccess, testUndeclaredFunctionCall,
      testFunctionInvalidQName, testVariableInvalidQName,
      testDecimalFormatInvalidProperty, testEmptyProlog,
      testFunctionBodySyntaxError, testVariableInitializerSyntaxError
   }
}
