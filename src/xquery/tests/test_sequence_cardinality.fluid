-- Regression tests for sequence item counting on atomic sequences
-- Ensures node-set sequences that carry atomic items via string values or override
-- are counted correctly for treat-as, instance-of, cast, castable, and typeswitch.

   include 'xml'

-----------------------------------------------------------------------------------------------------------------------
-- TYPESWITCH over data() should match xs:string when a single atomic item is present

function testTypeswitchDataString()
   local xml = obj.new("xml", { statement = '<root><s>hello</s></root>' })

   local query = [[
      typeswitch(data(/root/s/text()))
         case $s as xs:string return "matched"
         default return "nope"
   ]]

   local err, result = xml.mtEvaluate(query)
   assert(err == ERR_Okay, "typeswitch over data() should evaluate: " .. mSys.GetErrorMsg(err))
   assert(result == "matched", "typeswitch should match xs:string case, got: " .. nz(result, 'NIL'))
end

-----------------------------------------------------------------------------------------------------------------------
-- treat as / instance of on data() sequence with a single atomic item

function testTreatAndInstanceOnData()
   local xml = obj.new("xml", { statement = '<root><n>42</n></root>' })

   local err1, result1 = xml.mtEvaluate('data(/root/n/text()) treat as xs:string')
   assert(err1 == ERR_Okay, "treat as xs:string should succeed on data() result: " .. mSys.GetErrorMsg(err1))

   local err2, result2 = xml.mtEvaluate('data(/root/n/text()) instance of xs:string')
   assert(err2 == ERR_Okay and result2 == "true", "data() result should be instance of xs:string, got: " .. nz(result2, 'NIL'))
end

-----------------------------------------------------------------------------------------------------------------------
-- cast and castable on data() sequences

function testCastAndCastableOnData()
   local xml = obj.new("xml", { statement = '<root><n>123</n><s>abc</s></root>' })

   local err1, result1 = xml.mtEvaluate('data(/root/n/text()) cast as xs:string')
   assert(err1 == ERR_Okay and result1 == "123", "cast to xs:string should return '123', got: " .. nz(result1, 'NIL'))

   local err2, result2 = xml.mtEvaluate('data(/root/n/text()) castable as xs:integer')
   assert(err2 == ERR_Okay and result2 == "true", "numeric data() should be castable as xs:integer")

   local err3, result3 = xml.mtEvaluate('data(/root/s/text()) castable as xs:integer')
   assert(err3 == ERR_Okay and result3 == "false", "non-numeric data() should not be castable as xs:integer")
end

-----------------------------------------------------------------------------------------------------------------------
-- Attribute value via data() must also count as one item

function testAttributeDataCardinality()
   local xml = obj.new("xml", { statement = '<root val="yes"/>' })

   local err1, result1 = xml.mtEvaluate('data(/root/@val) instance of xs:string')
   assert(err1 == ERR_Okay and result1 == "true", "attribute data() should be xs:string")

   local err2, result2 = xml.mtEvaluate([[typeswitch(data(/root/@val))
      case $s as xs:string return "ok"
      default return "bad"]])
   assert(err2 == ERR_Okay and result2 == "ok", "typeswitch over attribute data() should match xs:string")
end

-----------------------------------------------------------------------------------------------------------------------

-- Optional vs one-or-more cardinality on empty data()

function testTreatOptionalEmptyData()
   local xml = obj.new("xml", { statement = '<root/>' })
   local err, result = xml.mtEvaluate('data(()) treat as xs:string?')
   assert(err == ERR_Okay, "treat as xs:string? should accept empty data(): " .. mSys.GetErrorMsg(err))
end

function testTreatOneOrMoreEmptyData()
   local xml = obj.new("xml", { statement = '<root/>' })
   local err, result = xml.mtEvaluate('data(()) treat as xs:string+')
   assert(err != ERR_Okay, "treat as xs:string+ should reject empty data()")
end

-----------------------------------------------------------------------------------------------------------------------

return {
   tests = {
      'testTypeswitchDataString',
      'testTreatAndInstanceOnData',
      'testCastAndCastableOnData',
      'testAttributeDataCardinality',
      -- Cardinality with empty sequences
      'testTreatOptionalEmptyData',
      'testTreatOneOrMoreEmptyData',
   },
   init = function(ScriptFolder)
   end,
   cleanup = function()
   end
}
