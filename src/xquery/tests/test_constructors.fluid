-- XPath constructor evaluation tests

   include 'xml'

-----------------------------------------------------------------------------------------------------------------------
-- Direct element constructors should evaluate expressions inside tags and attributes

function testDirectConstructorEvaluation()
   local xml = obj.new("xml", { statement = '<root price="10"><item>5</item></root>' })

   local err, attributeValue = xml.mtEvaluate('string((<result price="{/root/@price}">{/root/item/text()}</result>)/@price)')
   assert(attributeValue == '10', 'Attribute value template should resolve to 10, got ' .. nz(attributeValue, 'NIL'))

   local err, elementString = xml.mtEvaluate('string((<result>{/root/item/text()}</result>)[1])')
   assert(elementString == '5', 'Element content should expose inner text, got ' .. nz(elementString, 'NIL'))

   local err, doubled = xml.mtEvaluate('string((<result><double>{/root/@price * 2}</double></result>)/double)')
   assert(doubled == '20', 'Nested constructor should evaluate arithmetic content, got ' .. nz(doubled, 'NIL'))
end

-----------------------------------------------------------------------------------------------------------------------
-- Direct constructors should preserve literal whitespace inside element content

function testDirectConstructorWhitespace()
   local xq = obj.new('xquery', { statement = 'string(<a>hello world</a>)' })
   local err = xq.acActivate()

   assert(xq.resultString == 'hello world', 'Direct constructor should preserve single spaces, got ' .. tostring(xq.resultString))

   xq.statement = 'string(<a>  padded  </a>)'
   xq.acActivate()
   assert(xq.resultString == '  padded  ', 'Direct constructor should retain leading and trailing spaces, got ' .. tostring(xq.resultString))

   xq.statement = [[string(<a>line 1
   line 2</a>)]]
   xq.acActivate()
   assert(xq.resultString == "line 1\n   line 2", 'Direct constructor should keep newline indentation, got ' .. tostring(xq.resultString))
end

-----------------------------------------------------------------------------------------------------------------------
-- Computed constructors should honour dynamic names and content expressions

function testComputedConstructors()
   local xml = obj.new("xml", { statement = '<root price="10"/>' })

   local err, elementName = xml.mtEvaluate('local-name(element summary { /root/@price })')
   assert(elementName == 'summary', 'Computed element should adopt supplied lexical name, got ' .. nz(elementName, 'NIL'))

   local err, elementContent = xml.mtEvaluate('string(element summary { /root/@price * 3 })')
   assert(elementContent == '30', 'Computed element should evaluate numeric expressions, got ' .. nz(elementContent, 'NIL'))

   local err, attributeValue = xml.mtEvaluate('string(element wrapper { attribute cost { /root/@price } }/@cost)')
   assert(attributeValue == '10', 'Computed attribute should expose evaluated value, got ' .. nz(attributeValue, 'NIL'))
end

-----------------------------------------------------------------------------------------------------------------------
-- Text, comment, and processing-instruction constructors should produce textual nodes

function testNonElementConstructors()
   local xml = obj.new("xml", { statement = '<root price="10"/>' })

   local err, textValue = xml.mtEvaluate('string(text { /root/@price })')
   assert(textValue == '10', 'Text constructor should convert attribute content to text, got ' .. nz(textValue, 'NIL'))

   local err, commentValue = xml.mtEvaluate('string(comment { "note" })')
   assert(commentValue == 'note', 'Comment constructor should return its content, got ' .. nz(commentValue, 'NIL'))

   local err, piName = xml.mtEvaluate('name(processing-instruction target { "data" })')
   assert(piName == 'target', 'Processing-instruction should expose its target name, got ' .. nz(piName, 'NIL'))

   local err, piContent = xml.mtEvaluate('string(processing-instruction target { "data" })')
   assert(piContent == 'data', 'Processing-instruction should preserve its content, got ' .. nz(piContent, 'NIL'))

   local err = xml.mtFindTag('processing-instruction target { "bad?>data" }')
   assert(err != ERR_Okay, 'Processing-instruction content containing ?> should be rejected')
end

-----------------------------------------------------------------------------------------------------------------------
-- Document constructors should wrap sequences into a standalone document node

function testDocumentConstructor()
   local xq = obj.new('xquery', { statement = 'count((document { <a/>, <b/> })/node())' })
   local err = xq.acActivate()

   local childCount = tonumber(xq.resultString)
   assert(childCount == 2, 'Document constructor should expose two child nodes, got ' .. tostring(childCount))

   xq.statement = 'name(((document { <root/> })/node())[1])'
   local err = xq.acActivate()
   assert(xq.resultString == 'root', 'Document constructor should retain child element names, got ' .. tostring(xq.resultString))
end

-----------------------------------------------------------------------------------------------------------------------
-- Attribute and sequence content should merge correctly inside constructors

function testConstructorAttributeSequences()
   local xq = obj.new('xquery', { statement = 'count(element wrapper { (attribute first { "1" }, attribute second { "2" }), element child { "value" } }/@*)' })
   assert(xq.acActivate() == ERR_Okay, 'XQuery execution failed.')

   local mergedCount = tonumber(xq.resultString)
   assert(mergedCount == 2, 'Element constructor should merge attribute sequences into the result, got ' .. tostring(mergedCount))

   xq.statement = 'string(element wrapper { (attribute first { "1" }, attribute second { "2" }), element child { "value" } }/@second)'
   assert(xq.acActivate() == ERR_Okay, 'XQuery execution failed.')
   assert(xq.resultString == '2', 'Element constructor should preserve attribute values from sequences, got ' .. tostring(xq.resultString))

   xq.statement = 'name((element wrapper { (attribute first { "1" }, attribute second { "2" }), element child { "value" } }/node())[1])'
   assert(xq.acActivate() == ERR_Okay, 'XQuery execution failed.')
   assert(xq.resultString == 'child', 'Element constructor should retain subsequent child nodes after attributes, got ' .. tostring(xq.resultString))

   xq.statement = 'string((let $attrs := (attribute id { "main" }, attribute role { "admin" }) return element wrapper { $attrs, text { "ready" } })/@role)'
   assert(xq.acActivate() == ERR_Okay, 'XQuery execution failed.')
   assert(xq.resultString == 'admin', 'Element constructor should append dynamic attribute sequences before content, got ' .. tostring(xq.resultString))

   xq.statement = 'string((let $attrs := (attribute id { "main" }) return element wrapper { $attrs, text { "ready" }, "!" })/text()[1])'
   assert(xq.acActivate() == ERR_Okay, 'XQuery execution failed.')
   assert(xq.resultString == 'ready', 'Element constructor should keep constructed text content before atomic values, got ' .. tostring(xq.resultString))

   xq.statement = 'string((let $attrs := (attribute id { "main" }) return element wrapper { $attrs, text { "ready" }, "!" })/text()[2])'
   assert(xq.acActivate() == ERR_Okay, 'XQuery execution failed.')
   assert(xq.resultString == '!', 'Element constructor should append atomic values as subsequent text nodes, got ' .. tostring(xq.resultString))

   xq.statement = 'concat((let $attrs := (attribute id { "main" }) return element wrapper { $attrs, text { "ready" }, "!" })/text()[1], (let $attrs := (attribute id { "main" }) return element wrapper { $attrs, text { "ready" }, "!" })/text()[2])'
   assert(xq.acActivate() == ERR_Okay, 'XQuery execution failed.')
   assert(xq.resultString == 'ready!', 'Element constructor should preserve text node ordering when combined explicitly, got ' .. tostring(xq.resultString))
end

-----------------------------------------------------------------------------------------------------------------------

return {
   tests = {
      'testDirectConstructorEvaluation', 'testDirectConstructorWhitespace', 'testComputedConstructors',
      'testNonElementConstructors', 'testDocumentConstructor',
      'testConstructorAttributeSequences'
   }
}
