-- XPath 2.0 date and time helper tests

   include 'xml'

-----------------------------------------------------------------------------------------------------------------------
-- Validate component extraction across dateTime, date and time values

function testDateTimeExtraction()
   local xml = obj.new("xml", {
      statement = '<root>'
         .. '<item id="dt" value="2024-03-15T09:30:00.5+05:30"/>'
         .. '<item id="date" value="2024-03-15-05:00"/>'
         .. '<item id="time" value="14:45:30.25-03:00"/>'
         .. '</root>'
   })

   local errDateTime, nodeDateTime = xml.mtSearch('/root/item[@id = "dt"'
      .. ' and year-from-dateTime(@value) = 2024'
      .. ' and month-from-dateTime(@value) = 3'
      .. ' and day-from-dateTime(@value) = 15'
      .. ' and hours-from-dateTime(@value) = 9'
      .. ' and minutes-from-dateTime(@value) = 30'
      .. ' and round(seconds-from-dateTime(@value) * 10) = 5'
      .. ' and timezone-from-dateTime(@value) = "PT5H30M"]')
   assert(errDateTime is ERR_Okay and nodeDateTime != nil,
      'dateTime component helpers should expose calendar fields and timezone offsets')

   local errDate, nodeDate = xml.mtSearch('/root/item[@id = "date"'
      .. ' and year-from-date(@value) = 2024'
      .. ' and month-from-date(@value) = 3'
      .. ' and day-from-date(@value) = 15'
      .. ' and timezone-from-date(@value) = "-PT5H"]')
   assert(errDate is ERR_Okay and nodeDate != nil,
      'date component helpers should expose calendar fields and signed timezone offsets')

   local errTime, nodeTime = xml.mtSearch('/root/item[@id = "time"'
      .. ' and hours-from-time(@value) = 14'
      .. ' and minutes-from-time(@value) = 45'
      .. ' and round(seconds-from-time(@value) * 100) = 3025'
      .. ' and timezone-from-time(@value) = "-PT3H"]')
   assert(errTime is ERR_Okay and nodeTime != nil,
      'time component helpers should decode time-of-day fields including fractional seconds and timezones')
end

-----------------------------------------------------------------------------------------------------------------------
-- Validate timezone adjustment helpers and constructor utilities

function testDateTimeAdjustment()
   local xml = obj.new("xml", { statement = '<root />' })

   local err, adjustedUtc = xml.mtEvaluate("adjust-dateTime-to-timezone('2023-01-01T12:00:00+02:00', 'PT0S')")
   assert(adjustedUtc is '2023-01-01T10:00:00Z',
      'adjust-dateTime-to-timezone() should translate instants to the requested timezone, got: ' .. nz(adjustedUtc,'NIL'))

   local err, adjustedForward = xml.mtEvaluate("adjust-dateTime-to-timezone('2023-01-01T12:00:00', 'PT3H')")
   assert(adjustedForward is '2023-01-01T15:00:00+03:00',
      'dateTime adjustment should adopt the target offset when none is provided on the source value')

   local err, adjustedDate = xml.mtEvaluate("adjust-date-to-timezone('2023-01-01+02:00', 'PT0S')")
   assert(adjustedDate is '2022-12-31Z',
      'adjust-date-to-timezone() should shift calendar days when timezone changes cross midnight')

   local err, adjustedTime = xml.mtEvaluate("adjust-time-to-timezone('12:00:00+02:00', 'PT0S')")
   assert(adjustedTime is '10:00:00Z',
      'adjust-time-to-timezone() should convert clock times between offsets')

   local err, constructed = xml.mtEvaluate("dateTime('2023-12-25', '10:15:30Z')")
   assert(constructed is '2023-12-25T10:15:30Z',
      'dateTime() should combine xs:date and xs:time values into a canonical xs:dateTime string')

   local err, implicit = xml.mtEvaluate('implicit-timezone()')
   assert(implicit is 'PT0S', 'implicit-timezone() should reflect the engine default timezone offset')
end

-----------------------------------------------------------------------------------------------------------------------
-- Validate constructor canonicalisation for date/time values and IEEE lexical tokens

function testConstructorTimezoneNormalisation()
   local xml = obj.new("xml", { statement = '<root />' })

   local err, canonicalDate = xml.mtEvaluate("xs:date('2024-01-02+00:00')")
   assert(err is ERR_Okay, 'xs:date should accept +00:00 offsets: ' .. mSys.GetErrorMsg(err))
   assert(canonicalDate is '2024-01-02Z', 'xs:date should emit Z for zero offset, got: ' .. nz(canonicalDate, 'NIL'))

   local err, canonicalTime = xml.mtEvaluate("xs:time('12:30:00-00:00')")
   assert(err is ERR_Okay, 'xs:time should accept -00:00 offsets: ' .. mSys.GetErrorMsg(err))
   assert(canonicalTime is '12:30:00Z', 'xs:time should normalise zero offset to Z, got: ' .. nz(canonicalTime, 'NIL'))

   local err, canonicalDateTime = xml.mtEvaluate("xs:dateTime('2024-01-02T12:30:45+00:00')")
   assert(err is ERR_Okay, 'xs:dateTime should accept +00:00 offsets: ' .. mSys.GetErrorMsg(err))
   assert(canonicalDateTime is '2024-01-02T12:30:45Z', 'xs:dateTime should normalise zero offset to Z, got: ' .. nz(canonicalDateTime, 'NIL'))

   local err, projectedDate = xml.mtEvaluate("xs:date(xs:dateTime('2024-05-01T06:30:00+00:00'))")
   assert(err is ERR_Okay, 'xs:date should accept xs:dateTime operands: ' .. mSys.GetErrorMsg(err))
   assert(projectedDate is '2024-05-01Z', 'xs:date from dateTime should preserve timezone, got: ' .. nz(projectedDate, 'NIL'))

   local err, projectedTime = xml.mtEvaluate("xs:time(xs:dateTime('2024-05-01T06:30:00+00:00'))")
   assert(err is ERR_Okay, 'xs:time should accept xs:dateTime operands: ' .. mSys.GetErrorMsg(err))
   assert(projectedTime is '06:30:00Z', 'xs:time from dateTime should preserve timezone, got: ' .. nz(projectedTime, 'NIL'))

   local err, infValue = xml.mtEvaluate("xs:double('INF')")
   assert(err is ERR_Okay, 'xs:double should accept INF token: ' .. mSys.GetErrorMsg(err))
   assert(infValue is 'Infinity', 'xs:double("INF") should return Infinity, got: ' .. nz(infValue, 'NIL'))

   local err, negInfValue = xml.mtEvaluate("xs:double('-INF')")
   assert(err is ERR_Okay, 'xs:double should accept -INF token: ' .. mSys.GetErrorMsg(err))
   assert(negInfValue is '-Infinity', 'xs:double("-INF") should return -Infinity, got: ' .. nz(negInfValue, 'NIL'))

   local err, nanValue = xml.mtEvaluate("xs:double('NaN')")
   assert(err is ERR_Okay, 'xs:double should accept NaN token: ' .. mSys.GetErrorMsg(err))
   assert(nanValue is 'NaN', 'xs:double("NaN") should return NaN, got: ' .. nz(nanValue, 'NIL'))
end

-----------------------------------------------------------------------------------------------------------------------

return {
   tests = {
      'testDateTimeExtraction',
      'testDateTimeAdjustment',
      'testConstructorTimezoneNormalisation'
   },
   init = function(ScriptFolder)
   end,
   cleanup = function()
   end
}
