-- Comprehensive tests for XPath 2.0 Type and Range Expressions
-- Tests the following constructs:
-- * cast expression - explicit type conversion
-- * castable expression - test conversion feasibility
-- * treat as expression - runtime type assertion
-- * instance of expression - type conformance testing
-- * typeswitch expression - type-based control flow
-- * to range operator - integer sequence generation

   include 'xml'

-----------------------------------------------------------------------------------------------------------------------
-- CAST EXPRESSION TESTS

-- Test basic cast to string
function testCastToString()
   local xml = obj.new("xml", { statement = '<root/>' })

   local err, result = xml.mtEvaluate('42 cast as xs:string')
   assert(err == ERR_Okay, "Cast to string should succeed: " .. mSys.GetErrorMsg(err))
   assert(result == "42", "Cast to string should return '42', got: " .. result)
end

-- Test basic cast to decimal
function testCastToDecimal()
   local xml = obj.new("xml", { statement = '<root/>' })

   local err, result = xml.mtEvaluate('"123.45" cast as xs:decimal')
   assert(err == ERR_Okay, "Cast to decimal should succeed: " .. mSys.GetErrorMsg(err))
   assert(tonumber(result) == 123.45, "Cast to decimal should return 123.45, got: " .. result)
end

-- Test basic cast to integer
function testCastToInteger()
   local xml = obj.new("xml", { statement = '<root/>' })

   local err, result = xml.mtEvaluate('"456" cast as xs:integer')
   assert(err == ERR_Okay, "Cast to integer should succeed: " .. mSys.GetErrorMsg(err))
   assert(tonumber(result) == 456, "Cast to integer should return 456, got: " .. result)
end

-- Test basic cast to boolean
function testCastToBoolean()
   local xml = obj.new("xml", { statement = '<root/>' })

   local err, result = xml.mtEvaluate('"true" cast as xs:boolean')
   assert(err == ERR_Okay, "Cast to boolean should succeed: " .. mSys.GetErrorMsg(err))
   assert(result == "true", "Cast to boolean should return true, got: " .. result)

   local err2, result2 = xml.mtEvaluate('"0" cast as xs:boolean')
   assert(err2 == ERR_Okay, "Cast '0' to boolean should succeed")
   assert(result2 == "false", "Cast '0' to boolean should return false, got: " .. result2)
end

-- Test basic cast to date
function testCastToDate()
   local xml = obj.new("xml", { statement = '<root/>' })

   local err, result = xml.mtEvaluate('"2025-10-22" cast as xs:date')
   assert(err == ERR_Okay, "Cast to date should succeed: " .. mSys.GetErrorMsg(err))
   assert(result == "2025-10-22", "Cast to date should preserve format, got: " .. result)
end

-- Test cast to dateTime
function testCastToDateTime()
   local xml = obj.new("xml", { statement = '<root/>' })

   local err, result = xml.mtEvaluate('"2025-10-22T14:30:00" cast as xs:dateTime')
   assert(err == ERR_Okay, "Cast to dateTime should succeed: " .. mSys.GetErrorMsg(err))
end

-- Test invalid cast should raise XPTY0004 error
function testCastInvalidConversion()
   local xml = obj.new("xml", { statement = '<root/>' })

   -- Try to cast non-numeric string to integer
   local err, result = xml.mtEvaluate('"abc" cast as xs:integer')
   assert(err != ERR_Okay, "Invalid cast should fail with error code")
   -- Should raise XPTY0004 or similar error
end

-- Test cast with empty sequence
function testCastEmptySequence()
   local xml = obj.new("xml", { statement = '<root/>' })

   -- Empty sequence cannot be cast (should raise error)
   local err, result = xml.mtEvaluate('() cast as xs:string')
   assert(err != ERR_Okay, "Cast of empty sequence should fail")
end

-- Test cast from attribute value
function testCastFromAttribute()
   local xml = obj.new("xml", { statement = '<root price="99.99"/>' })

   local err, result = xml.mtEvaluate('/root/@price cast as xs:decimal')
   assert(err == ERR_Okay, "Cast from attribute should succeed: " .. mSys.GetErrorMsg(err))
   assert(tonumber(result) == 99.99, "Cast from attribute should return 99.99, got: " .. result)
end

-- Test cast from element text
function testCastFromElement()
   local xml = obj.new("xml", { statement = '<root><count>42</count></root>' })

   local err, result = xml.mtEvaluate('/root/count/text() cast as xs:integer')
   assert(err == ERR_Okay, "Cast from element text should succeed: " .. mSys.GetErrorMsg(err))
   assert(tonumber(result) == 42, "Cast from element should return 42, got: " .. result)
end

-----------------------------------------------------------------------------------------------------------------------
-- CASTABLE EXPRESSION TESTS

-- Test basic castable to string (always true for atomic values)
function testCastableToString()
   local xml = obj.new("xml", { statement = '<root/>' })

   local err, result = xml.mtEvaluate('42 castable as xs:string')
   assert(err == ERR_Okay, "Castable to string should succeed: " .. mSys.GetErrorMsg(err))
   assert(result == "true", "42 should be castable to string, got: " .. result)
end

-- Test castable with valid numeric conversion
function testCastableValidNumeric()
   local xml = obj.new("xml", { statement = '<root/>' })

   local err, result = xml.mtEvaluate('"123" castable as xs:integer')
   assert(err == ERR_Okay, "Castable check should succeed: " .. mSys.GetErrorMsg(err))
   assert(result == "true", "'123' should be castable to integer, got: " .. result)
end

-- Test castable with invalid numeric conversion
function testCastableInvalidNumeric()
   local xml = obj.new("xml", { statement = '<root/>' })

   local err, result = xml.mtEvaluate('"abc" castable as xs:integer')
   assert(err == ERR_Okay, "Castable check should succeed: " .. mSys.GetErrorMsg(err))
   assert(result == "false", "'abc' should not be castable to integer, got: " .. result)
end

-- Test castable with valid date
function testCastableValidDate()
   local xml = obj.new("xml", { statement = '<root/>' })

   local err, result = xml.mtEvaluate('"2025-10-22" castable as xs:date')
   assert(err == ERR_Okay, "Castable to date should succeed: " .. mSys.GetErrorMsg(err))
   assert(result == "true", "Valid date string should be castable, got: " .. result)
end

-- Test castable with invalid date
function testCastableInvalidDate()
   local xml = obj.new("xml", { statement = '<root/>' })

   local err, result = xml.mtEvaluate('"not-a-date" castable as xs:date')
   assert(err == ERR_Okay, "Castable check should succeed: " .. mSys.GetErrorMsg(err))
   assert(result == "false", "Invalid date should not be castable, got: " .. result)
end

-- Test castable with boolean
function testCastableBoolean()
   local xml = obj.new("xml", { statement = '<root/>' })

   local err, result = xml.mtEvaluate('"true" castable as xs:boolean')
   assert(err == ERR_Okay, "Castable to boolean should succeed")
   assert(result == "true", "'true' should be castable to boolean, got: " .. result)

   local err2, result2 = xml.mtEvaluate('"maybe" castable as xs:boolean')
   assert(err2 == ERR_Okay, "Castable check should succeed")
   assert(result2 == "false", "'maybe' should not be castable to boolean, got: " .. result2)
end

-- Test castable with empty sequence
function testCastableEmptySequence()
   local xml = obj.new("xml", { statement = '<root/>' })

   local err, result = xml.mtEvaluate('() castable as xs:string')
   assert(err == ERR_Okay, "Castable with empty sequence should succeed")
   assert(result == "false", "Empty sequence should not be castable, got: " .. result)
end

-- Test castable from attribute
function testCastableFromAttribute()
   local xml = obj.new("xml", { statement = '<root value="123.45"/>' })

   local err, result = xml.mtEvaluate('/root/@value castable as xs:decimal')
   assert(err == ERR_Okay, "Castable from attribute should succeed: " .. mSys.GetErrorMsg(err))
   assert(result == "true", "Numeric attribute should be castable to decimal, got: " .. result)
end

-----------------------------------------------------------------------------------------------------------------------
-- TREAT AS EXPRESSION TESTS

-- Test treat as with matching type
function testTreatAsMatchingType()
   local xml = obj.new("xml", { statement = '<root/>' })

   local err, result = xml.mtEvaluate('42 treat as xs:integer')
   assert(err == ERR_Okay, "Treat as matching type should succeed: " .. mSys.GetErrorMsg(err))
   assert(tonumber(result) == 42, "Treat as should return 42, got: " .. result)
end

-- Test treat as with string
function testTreatAsString()
   local xml = obj.new("xml", { statement = '<root/>' })

   local err, result = xml.mtEvaluate('"hello" treat as xs:string')
   assert(err == ERR_Okay, "Treat as string should succeed: " .. mSys.GetErrorMsg(err))
   assert(result == "hello", "Treat as should return 'hello', got: " .. result)
end

-- Test treat as with mismatched type (should raise XPTY0004)
function testTreatAsMismatchedType()
   local xml = obj.new("xml", { statement = '<root/>' })

   -- Try to treat string as integer without conversion
   local err, result = xml.mtEvaluate('"abc" treat as xs:integer')
   assert(err != ERR_Okay, "Treat as with mismatched type should fail with XPTY0004")
end

-- Test treat as with occurrence indicator ?
function testTreatAsOptional()
   local xml = obj.new("xml", { statement = '<root/>' })

   -- Single value treated as optional
   local err, result = xml.mtEvaluate('42 treat as xs:integer?')
   assert(err == ERR_Okay, "Treat as optional should succeed: " .. mSys.GetErrorMsg(err))

   -- Empty sequence treated as optional
   local err2, result2 = xml.mtEvaluate('() treat as xs:integer?')
   assert(err2 == ERR_Okay, "Empty sequence with ? should succeed: " .. mSys.GetErrorMsg(err2))
end

-- Test treat as with occurrence indicator +
function testTreatAsOneOrMore()
   local xml = obj.new("xml", { statement = '<root><item>1</item><item>2</item></root>' })

   -- Multiple items treated as one-or-more
   local err, result = xml.mtEvaluate('data(/root/item/text()) treat as xs:string+')
   assert(err == ERR_Okay, "Treat as one-or-more should succeed: " .. mSys.GetErrorMsg(err))

   -- Empty sequence should fail with +
   local err2, result2 = xml.mtEvaluate('() treat as xs:string+')
   assert(err2 != ERR_Okay, "Empty sequence with + should fail")
end

-- Test treat as with occurrence indicator *
function testTreatAsZeroOrMore()
   local xml = obj.new("xml", { statement = '<root/>' })

   -- Empty sequence treated as zero-or-more
   local err, result = xml.mtEvaluate('() treat as xs:integer*')
   assert(err == ERR_Okay, "Empty sequence with * should succeed: " .. mSys.GetErrorMsg(err))

   -- Multiple items treated as zero-or-more
   local err2, result2 = xml.mtEvaluate('(1, 2, 3) treat as xs:integer*')
   assert(err2 == ERR_Okay, "Multiple items with * should succeed: " .. mSys.GetErrorMsg(err2))
end

-- Test treat as with element sequence
function testTreatAsElementSequence()
   local xml = obj.new("xml", { statement = '<root><child/></root>' })

   local err, result = xml.mtEvaluate('/root/child treat as element()')
   assert(err == ERR_Okay, "Treat as element should succeed: " .. mSys.GetErrorMsg(err))
end

-----------------------------------------------------------------------------------------------------------------------
-- INSTANCE OF EXPRESSION TESTS

-- Test instance of with matching primitive type
function testInstanceOfInteger()
   local xml = obj.new("xml", { statement = '<root/>' })

   local err, result = xml.mtEvaluate('42 instance of xs:integer')
   assert(err == ERR_Okay, "Instance of check should succeed: " .. mSys.GetErrorMsg(err))
   assert(result == "true", "42 should be instance of xs:integer, got: " .. result)
end

-- Test instance of with non-matching primitive type
function testInstanceOfNonMatchingType()
   local xml = obj.new("xml", { statement = '<root/>' })

   local err, result = xml.mtEvaluate('"hello" instance of xs:integer')
   assert(err == ERR_Okay, "Instance of check should succeed: " .. mSys.GetErrorMsg(err))
   assert(result == "false", "String should not be instance of xs:integer, got: " .. result)
end

-- Test instance of with string type
function testInstanceOfString()
   local xml = obj.new("xml", { statement = '<root/>' })

   local err, result = xml.mtEvaluate('"hello" instance of xs:string')
   assert(err == ERR_Okay, "Instance of string should succeed: " .. mSys.GetErrorMsg(err))
   assert(result == "true", "String should be instance of xs:string, got: " .. result)
end

-- Test instance of with boolean type
function testInstanceOfBoolean()
   local xml = obj.new("xml", { statement = '<root/>' })

   local err, result = xml.mtEvaluate('true() instance of xs:boolean')
   assert(err == ERR_Okay, "Instance of boolean should succeed: " .. mSys.GetErrorMsg(err))
   assert(result == "true", "true() should be instance of xs:boolean, got: " .. result)
end

-- Regression: atomic sequences must not satisfy node() tests
function testInstanceOfNodeWithAtomicSequence()
   local xml = obj.new("xml", { statement = '<root attr="v">text</root>' })

   -- Purely atomic sequence should not be instance of node()
   local err, result = xml.mtEvaluate('(1, 2) instance of node()')
   assert(err == ERR_Okay, "Instance of node() on atomic sequence should evaluate: " .. mSys.GetErrorMsg(err))
   assert(result == "false", "(1, 2) must not satisfy node(), got: " .. nz(result, 'NIL'))

   -- Control checks: real nodes should satisfy node()
   local err2, result2 = xml.mtEvaluate('/root/text() instance of node()')
   assert(err2 == ERR_Okay and result2 == "true", "text() should satisfy node(), got: " .. nz(result2, 'NIL'))

   local err3, result3 = xml.mtEvaluate('/root/@attr instance of node()')
   assert(err3 == ERR_Okay and result3 == "true", "@attr should satisfy node(), got: " .. nz(result3, 'NIL'))
end

-- Test instance of with occurrence indicator ?
function testInstanceOfOptional()
   local xml = obj.new("xml", { statement = '<root/>' })

   -- Single value is instance of optional type
   local err, result = xml.mtEvaluate('42 instance of xs:integer?')
   assert(err == ERR_Okay, "Instance of optional should succeed: " .. mSys.GetErrorMsg(err))
   assert(result == "true", "Single value should match xs:integer?, got: " .. result)

   -- Empty sequence is instance of optional type
   local err2, result2 = xml.mtEvaluate('() instance of xs:integer?')
   assert(err2 == ERR_Okay, "Empty sequence instance check should succeed")
   assert(result2 == "true", "Empty sequence should match xs:integer?, got: " .. result2)

   -- Multiple values do not match optional (exactly zero or one)
   local err3, result3 = xml.mtEvaluate('(1, 2) instance of xs:integer?')
   assert(err3 == ERR_Okay, "Multiple values instance check should succeed")
   assert(result3 == "false", "Multiple values should not match xs:integer?, got: " .. result3)
end

-- Test instance of with occurrence indicator +
function testInstanceOfOneOrMore()
   local xml = obj.new("xml", { statement = '<root/>' })

   -- Single value matches one-or-more
   local err, result = xml.mtEvaluate('42 instance of xs:integer+')
   assert(err == ERR_Okay, "Instance of one-or-more should succeed: " .. mSys.GetErrorMsg(err))
   assert(result == "true", "Single value should match xs:integer+, got: " .. result)

   -- Multiple values match one-or-more
   local err2, result2 = xml.mtEvaluate('(1, 2, 3) instance of xs:integer+')
   assert(err2 == ERR_Okay, "Multiple values instance check should succeed")
   assert(result2 == "true", "Multiple values should match xs:integer+, got: " .. result2)

   -- Empty sequence does not match one-or-more
   local err3, result3 = xml.mtEvaluate('() instance of xs:integer+')
   assert(err3 == ERR_Okay, "Empty sequence instance check should succeed")
   assert(result3 == "false", "Empty sequence should not match xs:integer+, got: " .. result3)
end

-- Test instance of with occurrence indicator *
function testInstanceOfZeroOrMore()
   local xml = obj.new("xml", { statement = '<root/>' })

   -- Empty sequence matches zero-or-more
   local err, result = xml.mtEvaluate('() instance of xs:integer*')
   assert(err == ERR_Okay, "Instance of zero-or-more should succeed: " .. mSys.GetErrorMsg(err))
   assert(result == "true", "Empty sequence should match xs:integer*, got: " .. result)

   -- Single value matches zero-or-more
   local err2, result2 = xml.mtEvaluate('42 instance of xs:integer*')
   assert(err2 == ERR_Okay, "Single value instance check should succeed")
   assert(result2 == "true", "Single value should match xs:integer*, got: " .. result2)

   -- Multiple values match zero-or-more
   local err3, result3 = xml.mtEvaluate('(1, 2, 3) instance of xs:integer*')
   assert(err3 == ERR_Okay, "Multiple values instance check should succeed")
   assert(result3 == "true", "Multiple values should match xs:integer*, got: " .. result3)
end

-- Test instance of with element type
function testInstanceOfElement()
   local xml = obj.new("xml", { statement = '<root><child/></root>' })

   local err, result = xml.mtEvaluate('/root/child instance of element()')
   assert(err == ERR_Okay, "Instance of element should succeed: " .. mSys.GetErrorMsg(err))
   assert(result == "true", "Element should be instance of element(), got: " .. result)

   -- Attribute is not an element
   local err2, result2 = xml.mtEvaluate('/root/@* instance of element()')
   assert(err2 == ERR_Okay, "Attribute instance check should succeed")
   -- Empty result or false expected
end

-- Test instance of with attribute type
function testInstanceOfAttribute()
   local xml = obj.new("xml", { statement = '<root name="test"/>' })

   local err, result = xml.mtEvaluate('/root/@name instance of attribute()')
   assert(err == ERR_Okay, "Instance of attribute should succeed: " .. mSys.GetErrorMsg(err))
   assert(result == "true", "Attribute should be instance of attribute(), got: " .. result)
end

-- Test instance of with text type
function testInstanceOfText()
   local xml = obj.new("xml", { statement = '<root>text content</root>' })

   local err, result = xml.mtEvaluate('/root/text() instance of text()')
   assert(err == ERR_Okay, "Instance of text should succeed: " .. mSys.GetErrorMsg(err))
   assert(result == "true", "Text node should be instance of text(), got: " .. result)
end

-----------------------------------------------------------------------------------------------------------------------
-- TYPESWITCH EXPRESSION TESTS

-- Test basic typeswitch with integer
function testTypeswitchInteger()
   local xml = obj.new("xml", { statement = '<root/>' })

   local query = [[
      typeswitch(42)
         case $i as xs:integer return "integer"
         case $s as xs:string return "string"
         default return "other"
   ]]

   local err, result = xml.mtEvaluate(query)
   assert(err == ERR_Okay, "Typeswitch should succeed: " .. mSys.GetErrorMsg(err))
   assert(result == "integer", "Should match integer case, got: " .. result)
end

-- Test typeswitch with string
function testTypeswitchString()
   local xml = obj.new("xml", { statement = '<root/>' })

   local query = [[
      typeswitch("hello")
         case $i as xs:integer return "integer"
         case $s as xs:string return "string"
         default return "other"
   ]]

   local err, result = xml.mtEvaluate(query)
   assert(err == ERR_Okay, "Typeswitch should succeed: " .. mSys.GetErrorMsg(err))
   assert(result == "string", "Should match string case, got: " .. result)
end

-- Test typeswitch with default case
function testTypeswitchDefault()
   local xml = obj.new("xml", { statement = '<root/>' })

   local query = [[
      typeswitch(true())
         case $i as xs:integer return "integer"
         case $s as xs:string return "string"
         default return "boolean"
   ]]

   local err, result = xml.mtEvaluate(query)
   assert(err == ERR_Okay, "Typeswitch should succeed: " .. mSys.GetErrorMsg(err))
   assert(result == "boolean", "Should match default case, got: " .. result)
end

-- Test typeswitch with variable binding
function testTypeswitchVariableBinding()
   local xml = obj.new("xml", { statement = '<root/>' })

   local query = [[
      typeswitch(42)
         case $i as xs:integer return $i * 2
         default return 0
   ]]

   local err, result = xml.mtEvaluate(query)
   assert(err == ERR_Okay, "Typeswitch with variable should succeed: " .. mSys.GetErrorMsg(err))
   assert(tonumber(result) == 84, "Should use bound variable, got: " .. result)
end

-- Test typeswitch with multiple cases
function testTypeswitchMultipleCases()
   local xml = obj.new("xml", { statement = '<root/>' })

   local query = [[
      typeswitch("test")
         case $i as xs:integer return "int"
         case $d as xs:decimal return "decimal"
         case $s as xs:string return "str"
         case $b as xs:boolean return "bool"
         default return "other"
   ]]

   local err, result = xml.mtEvaluate(query)
   assert(err == ERR_Okay, "Typeswitch with multiple cases should succeed: " .. mSys.GetErrorMsg(err))
   assert(result == "str", "Should match string case, got: " .. result)
end

-- Test typeswitch first-match-wins behavior
function testTypeswitchFirstMatchWins()
   local xml = obj.new("xml", { statement = '<root/>' })

   -- If integer matches multiple types, first should win
   local query = [[
      typeswitch(42)
         case $n as xs:decimal return "decimal"
         case $i as xs:integer return "integer"
         default return "other"
   ]]

   local err, result = xml.mtEvaluate(query)
   assert(err == ERR_Okay, "Typeswitch should succeed: " .. mSys.GetErrorMsg(err))
   -- Should match based on subtype hierarchy
end

-- Test typeswitch with element nodes
function testTypeswitchElement()
   local xml = obj.new("xml", { statement = '<root><child>value</child></root>' })

   local query = [[
      typeswitch(/root/child)
         case $e as element() return "element"
         case $t as text() return "text"
         default return "other"
   ]]

   local err, result = xml.mtEvaluate(query)
   assert(err == ERR_Okay, "Typeswitch with element should succeed: " .. mSys.GetErrorMsg(err))
   assert(result == "element", "Should match element case, got: " .. result)
end

-- Test typeswitch with occurrence indicators
function testTypeswitchOccurrenceIndicators()
   local xml = obj.new("xml", { statement = '<root/>' })

   -- Test optional type
   local query1 = [[
      typeswitch(())
         case $i as xs:integer? return "optional-int"
         default return "other"
   ]]

   local err, result = xml.mtEvaluate(query1)
   assert(err == ERR_Okay, "Typeswitch with optional should succeed: " .. mSys.GetErrorMsg(err))

   -- Test one-or-more type
   local query2 = [[
      typeswitch((1, 2, 3))
         case $i as xs:integer+ return "one-or-more"
         default return "other"
   ]]

   local err2, result2 = xml.mtEvaluate(query2)
   assert(err2 == ERR_Okay, "Typeswitch with one-or-more should succeed: " .. mSys.GetErrorMsg(err2))
   assert(result2 == "one-or-more", "Should match one-or-more case, got: " .. result2)
end

-----------------------------------------------------------------------------------------------------------------------
-- TO RANGE OPERATOR TESTS

-- Test basic range generation
function testRangeBasic()
   local xml = obj.new("xml", { statement = '<root/>' })

   local err, result = xml.mtEvaluate('1 to 5')
   assert(err == ERR_Okay, "Range operator should succeed: " .. mSys.GetErrorMsg(err))
   -- Result should be sequence: 1 2 3 4 5
   assert(string.find(result, "1"), "Range should contain 1")
   assert(string.find(result, "5"), "Range should contain 5")
end

-- Test range with count
function testRangeCount()
   local xml = obj.new("xml", { statement = '<root/>' })

   local err, result = xml.mtEvaluate('count(1 to 10)')
   assert(err == ERR_Okay, "Range count should succeed: " .. mSys.GetErrorMsg(err))
   assert(tonumber(result) == 10, "Range 1 to 10 should have 10 elements, got: " .. result)
end

-- Test range with single element
function testRangeSingleElement()
   local xml = obj.new("xml", { statement = '<root/>' })

   local err, result = xml.mtEvaluate('count(5 to 5)')
   assert(err == ERR_Okay, "Single element range should succeed: " .. mSys.GetErrorMsg(err))
   assert(tonumber(result) == 1, "Range 5 to 5 should have 1 element, got: " .. result)
end

-- Test empty range (end < start)
function testRangeEmpty()
   local xml = obj.new("xml", { statement = '<root/>' })

   local err, result = xml.mtEvaluate('count(10 to 5)')
   assert(err == ERR_Okay, "Empty range should succeed: " .. mSys.GetErrorMsg(err))
   assert(tonumber(result) == 0, "Range 10 to 5 should be empty, got: " .. result)
end

-- Test range with negative numbers
function testRangeNegative()
   local xml = obj.new("xml", { statement = '<root/>' })

   local err, result = xml.mtEvaluate('count(-5 to 5)')
   assert(err == ERR_Okay, "Negative range should succeed: " .. mSys.GetErrorMsg(err))
   assert(tonumber(result) == 11, "Range -5 to 5 should have 11 elements, got: " .. result)
end

-- Test range with zero
function testRangeZero()
   local xml = obj.new("xml", { statement = '<root/>' })

   local err, result = xml.mtEvaluate('count(0 to 10)')
   assert(err == ERR_Okay, "Range from zero should succeed: " .. mSys.GetErrorMsg(err))
   assert(tonumber(result) == 11, "Range 0 to 10 should have 11 elements, got: " .. result)
end

-- Test large range (with safeguards)
function testRangeLarge()
   local xml = obj.new("xml", { statement = '<root/>' })

   local err, result = xml.mtEvaluate('count(1 to 1000)')
   assert(err == ERR_Okay, "Large range should succeed: " .. mSys.GetErrorMsg(err))
   assert(tonumber(result) == 1000, "Range 1 to 1000 should have 1000 elements, got: " .. result)
end

-- Test range in for expression
function testRangeInFor()
   local xml = obj.new("xml", { statement = '<root/>' })

   local query = 'sum(for $i in 1 to 5 return $i)'

   local err, result = xml.mtEvaluate(query)
   assert(err == ERR_Okay, "Range in for expression should succeed: " .. mSys.GetErrorMsg(err))
   assert(tonumber(result) == 15, "Sum of 1 to 5 should be 15, got: " .. result)
end

-- Test range with position predicates
function testRangeWithPredicates()
   local xml = obj.new("xml", { statement = '<root/>' })

   local err, result = xml.mtEvaluate('(1 to 10)[5]')
   assert(err == ERR_Okay, "Range with predicate should succeed: " .. mSys.GetErrorMsg(err))
   assert(tonumber(result) == 5, "Fifth element of range should be 5, got: " .. result)
end

-- Test range with arithmetic
function testRangeWithArithmetic()
   local xml = obj.new("xml", { statement = '<root/>' })

   local err, result = xml.mtEvaluate('count(1 to (5 + 5))')
   assert(err == ERR_Okay, "Range with arithmetic should succeed: " .. mSys.GetErrorMsg(err))
   assert(tonumber(result) == 10, "Range should evaluate arithmetic, got: " .. result)
end

-- Test range with non-integer values (should handle or error)
function testRangeNonInteger()
   local xml = obj.new("xml", { statement = '<root/>' })

   -- XPath 2.0 spec: operands to 'to' must be integers
   local err, result = xml.mtEvaluate('1.5 to 5.5')
   -- Should either truncate to integers or raise error
   assert(err != ERR_Okay or result, "Range with non-integers should handle gracefully")
end

-----------------------------------------------------------------------------------------------------------------------
-- COMBINED EXPRESSION TESTS

-- Test cast with range
function testCastWithRange()
   local xml = obj.new("xml", { statement = '<root/>' })

   local err, result = xml.mtEvaluate('count(for $i in 1 to 5 return $i cast as xs:string)')
   assert(err == ERR_Okay, "Cast with range should succeed: " .. mSys.GetErrorMsg(err))
   assert(tonumber(result) == 5, "Should cast all range elements, got: " .. result)
end

-- Test instance of with typeswitch
function testInstanceOfWithTypeswitch()
   local xml = obj.new("xml", { statement = '<root/>' })

   local query = [[
      let $val := 42
      return if ($val instance of xs:integer) then
         typeswitch($val)
            case $i as xs:integer return $i * 2
            default return 0
      else 0
   ]]

   local err, result = xml.mtEvaluate(query)
   assert(err == ERR_Okay, "Combined instance of and typeswitch should succeed: " .. mSys.GetErrorMsg(err))
end

-- Test castable in conditional
function testCastableInConditional()
   local xml = obj.new("xml", { statement = '<root value="123"/>' })

   local query = [[
      if (/root/@value castable as xs:integer) then
         /root/@value cast as xs:integer
      else
         0
   ]]

   local err, result = xml.mtEvaluate(query)
   assert(err == ERR_Okay, "Castable in conditional should succeed: " .. mSys.GetErrorMsg(err))
   assert(tonumber(result) == 123, "Should cast valid value, got: " .. result)
end

-- Test treat as with range sequence
function testTreatAsWithRange()
   local xml = obj.new("xml", { statement = '<root/>' })

   local err, result = xml.mtEvaluate('(1 to 5) treat as xs:integer+')
   assert(err == ERR_Okay, "Treat as with range should succeed: " .. mSys.GetErrorMsg(err))
end

-----------------------------------------------------------------------------------------------------------------------
-- Constructor error tests

function testConstructorUnknownType()
   local xml = obj.new('xml', { statement = '<root/>' })

   local err = xml.mtEvaluate('xs:notAType("42")')
   assert(err != ERR_Okay, 'Unknown constructor type should raise XPST0051')

   local message = string.lower(nz(xml.errorMsg, ''))
   assert(string.find(message, 'xpst0051', 1, true),
      'Error message should include XPST0051 for unknown constructor types, got ' .. message)
end

function testConstructorUnboundPrefix()
   local xml = obj.new('xml', { statement = '<root/>' })

   local err = xml.mtEvaluate('abc:decimal("7")')
   assert(err != ERR_Okay, 'Constructor with unbound prefix should raise XPST0081')

   local message = string.lower(nz(xml.errorMsg, ''))
   assert(string.find(message, 'xpst0081', 1, true),
      'Error message should include XPST0081 for missing namespace bindings, got ' .. message)
end

-----------------------------------------------------------------------------------------------------------------------
-- Constructor metadata propagation through cast/treat expressions

function testConstructorCastChaining()
   local xml = obj.new('xml', { statement = '<root/>' })

   local err, castDateTime = xml.mtEvaluate("let $value := xs:dateTime('2024-05-01T06:30:00+02:00') "
      .. "return string($value cast as xs:dateTime)")
   assert(err == ERR_Okay, 'Casting constructor results to the same type should succeed: ' .. mSys.GetErrorMsg(err))
   assert(castDateTime == '2024-05-01T06:30:00+02:00',
      'Casting xs:dateTime results should preserve canonical lexical forms, got: ' .. nz(castDateTime, 'NIL'))

   local err2, castDate = xml.mtEvaluate("let $value := xs:date(xs:dateTime('2024-05-01T06:30:00+02:00')) "
      .. "return string($value cast as xs:date)")
   assert(err2 == ERR_Okay, 'xs:date values should remain castable to xs:date: ' .. mSys.GetErrorMsg(err2))
   assert(castDate == '2024-05-01+02:00',
      'Casting xs:date projections should retain their timezone component, got: ' .. nz(castDate, 'NIL'))
end

function testConstructorTreatAsChaining()
   local xml = obj.new('xml', { statement = '<root/>' })

   local err, treatDuration = xml.mtEvaluate("let $value := xs:duration('P2DT3H4M') "
      .. "return ($value treat as xs:duration) instance of xs:duration")
   assert(err == ERR_Okay, 'Treating constructor duration values as xs:duration should succeed: ' .. mSys.GetErrorMsg(err))
   assert(treatDuration == 'true',
      'Treat as expression should preserve xs:duration annotations, got: ' .. nz(treatDuration, 'NIL'))

   local err2, treatQName = xml.mtEvaluate("declare namespace p='http://example.com/ns'; "
      .. "let $value := xs:QName('p:local') return ($value treat as xs:QName) instance of xs:QName")
   assert(err2 == ERR_Okay, 'Treating xs:QName constructor values should succeed when prefixes are bound: ' .. mSys.GetErrorMsg(err2))
   assert(treatQName == 'true', 'Treat as should preserve xs:QName typing, got: ' .. nz(treatQName, 'NIL'))
end

-----------------------------------------------------------------------------------------------------------------------

return {
   tests = {
      -- Cast expression tests
      'testCastToString', 'testCastToDecimal', 'testCastToInteger', 'testCastToBoolean',
      'testCastToDate', 'testCastToDateTime', 'testCastInvalidConversion', 'testCastEmptySequence',
      'testCastFromAttribute', 'testCastFromElement',

      -- Castable expression tests
      'testCastableToString', 'testCastableValidNumeric', 'testCastableInvalidNumeric',
      'testCastableValidDate', 'testCastableInvalidDate', 'testCastableBoolean',
      'testCastableEmptySequence', 'testCastableFromAttribute',

      -- Treat as expression tests
      'testTreatAsMatchingType', 'testTreatAsString', 'testTreatAsMismatchedType',
      'testTreatAsOptional', 'testTreatAsOneOrMore', 'testTreatAsZeroOrMore',
      'testTreatAsElementSequence',

      -- Instance of expression tests
      'testInstanceOfInteger', 'testInstanceOfNonMatchingType', 'testInstanceOfString',
      'testInstanceOfBoolean', 'testInstanceOfOptional', 'testInstanceOfOneOrMore',
      'testInstanceOfZeroOrMore', 'testInstanceOfElement', 'testInstanceOfAttribute',
      'testInstanceOfText',

      -- Typeswitch expression tests
      'testTypeswitchInteger', 'testTypeswitchString', 'testTypeswitchDefault',
      'testTypeswitchVariableBinding', 'testTypeswitchMultipleCases', 'testTypeswitchFirstMatchWins',
      'testTypeswitchElement', 'testTypeswitchOccurrenceIndicators',

      -- To range operator tests
      'testRangeBasic', 'testRangeCount', 'testRangeSingleElement', 'testRangeEmpty',
      'testRangeNegative', 'testRangeZero', 'testRangeLarge', 'testRangeInFor',
      'testRangeWithPredicates', 'testRangeWithArithmetic', 'testRangeNonInteger',

      -- Combined expression tests
      'testCastWithRange', 'testInstanceOfWithTypeswitch', 'testCastableInConditional',
      'testTreatAsWithRange',

      -- Constructor chaining tests
      'testConstructorCastChaining', 'testConstructorTreatAsChaining',

      -- Constructor error tests
      'testConstructorUnknownType', 'testConstructorUnboundPrefix'
   },
   init = function(ScriptFolder)
      -- No global initialization needed
   end,
   cleanup = function()
      -- No cleanup needed
   end
}
