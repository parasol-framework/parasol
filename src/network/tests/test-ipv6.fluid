-- IPv6 Support Test Suite
--
-- This test verifies the IPv6 functionality in the Network module including:
-- - IPv6 address parsing and conversion
-- - IPv6 client connections
-- - IPv6 server binding and dual-stack support
-- - DNS resolution for IPv6 addresses

   require 'common'
   include 'network'

   mNet = mod.load('network')

local glPort = 8089

------------------------------------------------------------------------------------------------------------------------
-- Test IPv6 address parsing and conversion

function testIPv6AddressParsing()
   print('Testing IPv6 address parsing and conversion...')

   local addresses = {
      '::1',                                  -- IPv6 loopback
      '2001:db8::1',                          -- Standard IPv6
      'fe80::1%lo0',                          -- Link-local (simplified)
      '::ffff:192.0.2.1',                     -- IPv4-mapped IPv6
      '2001:0db8:85a3:0000:0000:8a2e:0370:7334' -- Full IPv6
   }

   for i, addr_str in ipairs(addresses) do
      print('  Testing address: ' .. addr_str)

      -- Skip link-local with interface identifier for now
      if not string.find(addr_str, '%%') then
         local addr = struct.new('IPAddress')
         local err = mNet.StrToAddress(addr_str, addr)

         if err == ERR_Okay then
            print('    Parsed successfully as ' .. ((addr.type == IPADDR_V6) and 'IPv6' or 'IPv4'))

            -- Test conversion back to string
            local result_str = mNet.AddressToStr(addr)
            if result_str then
               print('    ✓ Converted back to: ' .. result_str)
            else
               print('    ✗ Failed to convert back to string')
            end
         else
            print('    ✗ Failed to parse ' .. addr_str .. ': ' .. mSys.GetErrorMsg(err))
         end
      else
         print('    - Skipping link-local with interface identifier')
      end
   end

   print('IPv6 address parsing test completed!')
end

------------------------------------------------------------------------------------------------------------------------
-- Test IPv6 server binding and dual-stack support

function testIPv6ServerBinding()
   local proc = processing.new({ timeout = 10.0 })
   local server_ready = false
   local client_connected = false

   print('Testing IPv6 server binding and dual-stack support...')

   -- Create IPv6 server
   local server = obj.new('netsocket', {
      name = 'IPv6TestServer',
      port = glPort,
      flags = NSF_SERVER,
      feedback = function(Socket, Client, State)
         print('[Server] State change: ' .. State)
         if State == NTC_CONNECTED and Client then
            print('[Server] Client connected from IPv6 server')
            client_connected = true
            proc.signal()
         end
      end,
      incoming = function(Socket, Client)
         if Client then
            local buffer = string.rep('\\0', 256)
            local err, bytes = Client.acRead(buffer, string.len(buffer))
            if err == ERR_Okay and bytes > 0 then
               local message = string.sub(buffer, 1, bytes)
               print('[Server] Received from client: ' .. message)

               -- Echo back
               Client.acWrite('IPv6 Server Echo: ' .. message, string.len('IPv6 Server Echo: ' .. message))
            end
         end
         return ERR_Okay
      end
   })

   server_ready = true
   print('[Server] IPv6 server bound successfully on port ' .. glPort)

   -- Test connecting with IPv6 loopback
   processing.sleep(1) -- Small delay for server to be ready

   local client = obj.new('netsocket', {
      name = 'IPv6TestClient',
      feedback = function(Socket, Client, State)
         print('[Client] State: ' .. State)
         if State == NTC_CONNECTED then
            print('[Client] Connected to IPv6 server')
            Socket.acWrite('Hello IPv6 World!', string.len('Hello IPv6 World!'))
         end
      end,
      incoming = function(Socket, Client)
         local buffer = string.rep('\\0', 256)
         local err, bytes = Socket.acRead(buffer, string.len(buffer))
         if err == ERR_Okay and bytes > 0 then
            local response = string.sub(buffer, 1, bytes)
            print('[Client] Received response: ' .. response)
            proc.signal()
         end
         return ERR_Okay
      end
   })

   -- Try IPv6 loopback connection
   local err = client.mtConnect('::1', glPort)
   if err != ERR_Okay then
      print('[Client] IPv6 loopback connection failed, trying IPv4: ' .. mSys.GetErrorMsg(err))
      -- Fallback to IPv4 to test dual-stack
      err = client.mtConnect('127.0.0.1', glPort)
      assert(err == ERR_Okay, '[Client] IPv4 fallback connection failed: ' .. mSys.GetErrorMsg(err))
   end

   local err = proc.sleep()
   assert(err == ERR_Okay, 'IPv6 server test failed: ' .. mSys.GetErrorMsg(err))
   assert(server_ready, 'Server was not ready')

   print('IPv6 server binding test completed successfully!')
end

------------------------------------------------------------------------------------------------------------------------
-- Test IPv6 DNS resolution

function testIPv6DNSResolution()
   local proc = processing.new({ timeout = 8.0 })
   local resolution_complete = false

   print('Testing IPv6 DNS resolution...')

   local lookup = obj.new('netlookup', {
      callback = function(Lookup, Error)
         local addresses = Lookup.addresses
         if (Error == ERR_Okay) and addresses then
            print('[DNS] Resolved ' .. nz(Lookup.hostName,'NIL') .. ' to ' .. #addresses .. ' addresses:')
            for i, addr in ipairs(addresses) do
               local addr_str = mNet.AddressToStr(addr)
               local type_str = (addr.type == IPADDR_V6) and 'IPv6' or 'IPv4'
               print('  ' .. i .. '. ' .. (addr_str or 'unknown') .. ' (' .. type_str .. ')')
            end
         else
            print('[DNS] Resolution failed: ' .. mSys.GetErrorMsg(Error))
         end

         resolution_complete = true
         proc.signal()
      end
   })

   -- Test resolving a hostname that should have both IPv4 and IPv6 addresses
   local err = lookup.mtResolveName('dns.google')
   if err == ERR_Okay then
      local err = proc.sleep()
      assert(err == ERR_Okay, 'DNS resolution test failed: ' .. mSys.GetErrorMsg(err))
      assert(resolution_complete, 'DNS resolution did not complete')
   else
      print('[DNS] Failed to start resolution: ' .. mSys.GetErrorMsg(err))
   end

   print('IPv6 DNS resolution test completed!')
end

------------------------------------------------------------------------------------------------------------------------
-- Test IPv6 address utility functions

function testIPv6Utilities()
   print('Testing IPv6 utility functions...')

   -- Test various IPv6 address formats
   local test_cases = {
      { addr = '::1', expected_type = IPADDR_V6, desc = 'loopback' },
      { addr = '127.0.0.1', expected_type = IPADDR_V4, desc = 'IPv4 loopback' },
      { addr = '2001:db8::1', expected_type = IPADDR_V6, desc = 'standard IPv6' },
      { addr = '::ffff:192.0.2.1', expected_type = IPADDR_V6, desc = 'IPv4-mapped IPv6' }
   }

   for i, test in ipairs(test_cases) do
      print('  Testing ' .. test.desc .. ': ' .. test.addr)

      local addr = struct.new('IPAddress')
      local err = mNet.StrToAddress(test.addr, addr)

      if err == ERR_Okay then
         if addr.type == test.expected_type then
            print('    Correctly identified as ' .. ((addr.type == IPADDR_V6) and 'IPv6' or 'IPv4'))

            -- Test round-trip conversion
            local converted = mNet.AddressToStr(addr)
            if converted then
               print('    ✓ Round-trip conversion: ' .. converted)
            else
               print('    ✗ Round-trip conversion failed')
            end
         else
            print('    ✗ Incorrect type identification')
         end
      else
         print('    ✗ Failed to parse: ' .. mSys.GetErrorMsg(err))
      end
   end

   print('IPv6 utilities test completed!')
end

------------------------------------------------------------------------------------------------------------------------

   return {
      tests = {
         'testIPv6AddressParsing',
         'testIPv6Utilities',
         'testIPv6DNSResolution',
         'testIPv6ServerBinding'
      }
   }
