--[[
SSL Communication Test

This test verifies SSL-enabled network communications using the NSF::SSL flag.
Tests include:
- SSL server socket creation and certificate handling
- SSL client connection establishment and handshake
- Encrypted data transfer verification
- SSL-specific error conditions and recovery
- Certificate validation scenarios
- SSL state transitions (NTC_CONNECTING_SSL)
- Cross-platform SSL implementation testing
- SSL connection termination and cleanup

Note: These tests require SSL support to be compiled into the Network module.
If SSL is not available, tests will be skipped with appropriate messages.
--]]

   include 'network'

   glPort = 8305
   glSSLSupported = false
   glSSLTestData = 'SECRET_SSL_MESSAGE_123'

function printableState(State)
   if (State == NTC_CONNECTED) then return 'CONNECTED'
   elseif (State == NTC_CONNECTING) then return 'CONNECTING'
   elseif (State == NTC_DISCONNECTED) then return 'DISCONNECTED'
   elseif (State == NTC_HANDSHAKING) then return 'HANDSHAKING'
   else return tostring(State) end
end

-----------------------------------------------------------------------------------------------------------------------

function checkSSLSupport()
   -- Test if SSL support is available by attempting to create SSL socket
   local test_socket = obj.new('netsocket', {
      name = 'SSLSupportTest',
      port = glPort,
      flags = 'SERVER|SSL'
   })

   if (test_socket) then
      if (test_socket.error == ERR_Okay) then
         glSSLSupported = true
         msg('[SSL] SSL support detected and available')
      else
         msg('[SSL] SSL socket creation failed: ' .. mSys.GetErrorMsg(test_socket.error))
         msg('[SSL] SSL tests will be skipped')
      end
      test_socket = nil
      collectgarbage()
   else
      msg('[SSL] SSL socket creation returned nil - SSL not supported')
      msg('[SSL] SSL tests will be skipped')
   end

   return glSSLSupported
end

-----------------------------------------------------------------------------------------------------------------------

function testBasicSSLCommunication()
   if (not glSSLSupported) then return end

   local proc = processing.new({ timeout = 5.0 })
   local ssl_handshake_complete = false
   local ssl_data_received = false

   glPort = glPort + 1

   print('Testing basic SSL communication...')

   local ssl_server = obj.new('netsocket', {
      name = 'SSLTestServer',
      feedback = function(Socket, Client, State)
         msg('[SSL Server] Client state: ' .. printableState(State))

         assert(Client, 'Client parameter is empty')

         if (State == NTC_CONNECTING_SSL) then
            msg('[SSL Server] SSL handshake in progress...')

         elseif (State == NTC_CONNECTED) then
            msg('[SSL Server] SSL handshake completed, client connected securely')
            ssl_handshake_complete = true

            -- Send encrypted test message
            msg('[SSL Server] Sending encrypted message...')
            local err, len = Client.acWrite(glSSLTestData)
            if (err == ERR_Okay) then
               msg('[SSL Server] Encrypted message sent successfully')
            else
               error('[SSL Server] Failed to send encrypted message: ' .. mSys.GetErrorMsg(err))
            end

         elseif (State == NTC_DISCONNECTED) then
            msg('[SSL Server] SSL client disconnected')
            if (ssl_handshake_complete and ssl_data_received) then
               proc.signal()
            end
         end
      end,
      incoming = function(Socket, Client)
         local buffer = string.alloc(1024)
         local err, read_len = Client.acRead(buffer)

         if (err == ERR_Okay) then
            if read_len == 0 then 
               msg('Received incoming data notification with no data to read.')
            --   raise(ERR_Terminate)
            end

            local emsg = buffer:sub(1, read_len)
            msg('[SSL Server] Received encrypted message: "' .. emsg .. '"')

            -- Verify message integrity over SSL
            if (string.match(emsg, 'SSL_ECHO:' .. glSSLTestData)) then
               msg('[SSL Server] SSL message integrity verified!')
               ssl_data_received = true
               Socket.mtDisconnectSocket(Client)
            else
               error('[SSL Server] SSL message integrity check failed. Got: "' .. emsg .. '"')
            end
         elseif (err == ERR_Disconnected) then
            raise(ERR_Terminate)
         else
            error('[SSL Server] SSL read error: ' .. mSys.GetErrorMsg(err))
         end
      end,
      port = glPort,
      flags = 'SERVER|SSL|SSL_NO_VERIFY'
   })

   assert(ssl_server, 'Failed to create SSL server socket')
   assert(ssl_server.error == ERR_Okay, 'SSL server error: ' .. mSys.GetErrorMsg(ssl_server.error))

   local ssl_client = obj.new('netsocket', {
      name = 'SSLTestClient',
      feedback = function(Socket, State)
         msg('[SSL Client] Connection state: ' .. printableState(State))

         if (State == NTC_CONNECTING_SSL) then
            msg('[SSL Client] Performing SSL handshake...')

         elseif (State == NTC_CONNECTED) then
            msg('[SSL Client] SSL connection established successfully')

         elseif (State == NTC_DISCONNECTED) then
            msg('[SSL Client] SSL connection closed')
         end
      end,
      incoming = function(Socket)
         local buffer = string.alloc(1024)
         local err, read_len = Socket.acRead(buffer)

         if (err == ERR_Okay) then
            if read_len == 0 then 
               print('Received incoming data notification with no data to read.')
               raise(ERR_Terminate)
            end

            local emsg = buffer:sub(1, read_len)
            msg('[SSL Client] Received encrypted message: ' .. nz(emsg,'NIL'))

            -- Echo back the message to verify bidirectional SSL
            local echo_msg = 'SSL_ECHO:' .. emsg
            msg('[SSL Client] Sending encrypted echo...')
            local err, len = Socket.acWrite(echo_msg)
            if (err == ERR_Okay) then
               msg('[SSL Client] Encrypted echo sent successfully')
            else
               error('[SSL Client] Failed to send encrypted echo: ' .. mSys.GetErrorMsg(err))
            end
         elseif (err == ERR_Disconnected) then
            raise(ERR_Terminate)
         else
            error('[SSL Client] SSL read error: ' .. mSys.GetErrorMsg(err))
         end
      end,
      flags = 'SSL|SSL_NO_VERIFY'
   })

   assert(ssl_client, 'Failed to create SSL client socket')

   msg('[SSL Client] Connecting to SSL server...')
   local err = ssl_client.mtConnect('127.0.0.1', glPort)
   assert(err == ERR_Okay, 'SSL client connection failed: ' .. mSys.GetErrorMsg(err))

   local err = proc.sleep()
   assert(err == ERR_Okay, 'SSL communication test failed: ' .. mSys.GetErrorMsg(err))

   assert(ssl_handshake_complete, 'SSL handshake did not complete')
   assert(ssl_data_received, 'SSL data exchange did not complete')

   print('Basic SSL communication test completed successfully!')
end

-----------------------------------------------------------------------------------------------------------------------

function testSSLStateTransitions()
   if (not glSSLSupported) then return end

   local proc = processing.new({ timeout = 5.0 })
   local state_sequence = {}
   local ssl_handshake_complete = false
   local data_exchange_complete = false

   print('Testing SSL connection state transitions...')

   glPort = glPort + 1

   local ssl_server = obj.new('netsocket', {
      name = 'SSLStateServer',
      feedback = function(Socket, Client, State)
         table.insert(state_sequence, 'SERVER:' .. printableState(State))
         msg('[SSL Server] State transition: ' .. printableState(State) .. ' (' .. mSys.GetErrorMsg(Socket.error) .. ')')

         if (State == NTC_CONNECTED) then
            msg('[SSL Server] SSL handshake completed successfully!')
            ssl_handshake_complete = true
            -- Send test message
            msg('[SSL Server] Sending test message...')
            local err, len = Client.acWrite('SSL_STATE_TEST_COMPLETE')
            if (err != ERR_Okay) then
               error('[SSL Server] Failed to send message: ' .. mSys.GetErrorMsg(err))
            else
               msg('[SSL Server] Message sent successfully')
            end
         elseif (State == NTC_DISCONNECTED) then
            if (ssl_handshake_complete and data_exchange_complete) then
               msg('[SSL Server] Test completed successfully')
            elseif (ssl_handshake_complete) then
               msg('[SSL Server] Handshake completed but data exchange failed')
            else
               msg('[SSL Server] Connection failed before handshake completion')
            end
            proc.signal()
         end
      end,
      incoming = function(Socket, Client)
         msg('[SSL Server] Incoming data callback triggered')
         local buffer = string.alloc(1024)
         local err, read_len = Client.acRead(buffer)
         if (err == ERR_Okay) then
            local emsg = buffer:sub(1, read_len)
            msg('[SSL Server] Received: ' .. emsg)
            data_exchange_complete = true
            Socket.mtDisconnectSocket(Client)
         elseif (err != ERR_Disconnected) then
            error('[SSL Server] Read error: ' .. mSys.GetErrorMsg(err))
         end
      end,
      port = glPort,
      flags = 'SERVER|SSL|SSL_NO_VERIFY'
   })

   local ssl_client = obj.new('netsocket', {
      name = 'SSLStateClient',
      feedback = function(Socket, State)
         table.insert(state_sequence, 'CLIENT:' .. printableState(State))
         print('[SSL Client] State transition: ' .. printableState(State))
         if (State == NTC_DISCONNECTED) then
            proc.signal()
         end
      end,
      incoming = function(Socket)
         print('[SSL Client] Incoming data callback triggered')
         local buffer = string.alloc(1024)
         local err, read_len = Socket.acRead(buffer)
         if (err == ERR_Okay) then
            local emsg = buffer:sub(1, read_len)
            print('[SSL Client] Received: ' .. emsg)
            print('[SSL Client] Sending acknowledgment...')
            local err, len = Socket.acWrite('SSL_STATES_VERIFIED')
            if (err != ERR_Okay) then
               error('[SSL Client] Failed to send acknowledgment: ' .. mSys.GetErrorMsg(err))
            else
               print('[SSL Client] Acknowledgment sent successfully')
            end
         elseif (err != ERR_Disconnected) then
            error('[SSL Client] Read error: ' .. mSys.GetErrorMsg(err))
         end
      end,
      flags = 'SSL|SSL_NO_VERIFY'
   })

   print('[SSL Client] Initiating connection...')
   ssl_client.mtConnect('127.0.0.1', glPort)

   local err = proc.sleep()
   assert(err == ERR_Okay, 'sleep() returned ' ..  mSys.GetErrorMsg(err))

   -- Always print the state sequence for debugging
   print('SSL State Sequence:')
   for i, state in ipairs(state_sequence) do
      print('  ' .. i .. '. ' .. state)
   end

   -- Check if we got a connected state
   local server_connected
   local client_connected

   for i, state in ipairs(state_sequence) do
      if (string.match(state, 'SERVER:CONNECTED')) then
         server_connected = true
      end
      if (string.match(state, 'CLIENT:CONNECTED')) then
         client_connected = true
      end
   end

   if (not server_connected) then
      error('Server never reached CONNECTED state - SSL handshake failed')
   end

   if (not client_connected) then
      error('Client never reached CONNECTED state - SSL handshake failed')
   end
end

-----------------------------------------------------------------------------------------------------------------------

function testSSLDataIntegrity()
   if (not glSSLSupported) then return end

   local proc = processing.new({ timeout = 10.0 })
   local test_messages = {
      'Binary data: ' .. string.char(0, 1, 2, 3, 255, 254, 253),
      string.rep('Large SSL message ', 500), -- ~9KB message
      'Special chars: àáâãäåæçèéêë',
      'JSON: {"encrypted": true, "secure": "data"}',
      'Empty message test: '
   }
   local messages_verified = 0

   print('Testing SSL data integrity with various message types...')

   glPort = glPort + 1

   local msgIndex = 1
   local ssl_server = obj.new('netsocket', {
      name = 'SSLIntegrityServer',
      feedback = function(Socket, Client, State)
         if (State == NTC_CONNECTED) then
            -- Send first test message
            local emsg = test_messages[msgIndex]
            print('[SSL Server] Sending message ' .. msgIndex .. ' (' .. #emsg .. ' bytes)')
            Client.acWrite(emsg)
         end
      end,
      incoming = function(Socket, Client)
         local buffer = string.alloc(10240) -- Large buffer for big messages
         local err, read_len = Client.acRead(buffer)

         if (err == ERR_Okay) then
            local received = buffer:sub(1, read_len)
            local expected = test_messages[msgIndex]

            print('[SSL Server] Received echo ' .. msgIndex .. ' (' .. read_len .. ' bytes)')

            if (received == expected) then
               print('[SSL Server] Message ' .. msgIndex .. ' integrity verified!')
               messages_verified = messages_verified + 1

               msgIndex = msgIndex + 1
               if (msgIndex <= #test_messages) then
                  -- Send next message
                  local next_msg = test_messages[msgIndex]
                  print('[SSL Server] Sending message ' .. msgIndex .. ' (' .. #next_msg .. ' bytes)')
                  Client.acWrite(next_msg)
               else
                  print('[SSL Server] All messages verified successfully!')
                  proc.signal()
               end
            else
               error('[SSL Server] Message integrity failed for message ' .. msgIndex)
            end
         end
      end,
      port = glPort,
      flags = 'SERVER|SSL'
   })

   local ssl_client = obj.new('netsocket', {
      name = 'SSLIntegrityClient',
      incoming = function(Socket)
         local buffer = string.alloc(10240)
         local err, read_len = Socket.acRead(buffer)

         if (err == ERR_Okay) then
            local emsg = buffer:sub(1, read_len)
            print('[SSL Client] Received message (' .. read_len .. ' bytes), echoing back...')

            -- Echo back exactly what was received
            local err, len = Socket.acWrite(emsg)
            assert(err == ERR_Okay, 'Failed to echo SSL message: ' .. mSys.GetErrorMsg(err))
         end
      end,
      flags = 'SSL|SSL_NO_VERIFY'
   })

   ssl_client.mtConnect('127.0.0.1', glPort)

   local err = proc.sleep()
   assert(err == ERR_Okay, 'SSL data integrity test failed: ' .. mSys.GetErrorMsg(err))

   assert(messages_verified == #test_messages,
      'Not all messages verified. Expected: ' .. #test_messages .. ', Verified: ' .. messages_verified)

   print('SSL data integrity test completed successfully!')
   print('Verified ' .. messages_verified .. ' different message types over SSL')
end

-----------------------------------------------------------------------------------------------------------------------

function testHTTPSConnection()
   if (not glSSLSupported) then return end

   local proc = processing.new({ timeout = 15.0 })
   local connection_established = false
   local data_received = false
   local page_content = ""
   local response_complete = false
   local SITE = 'www.google.com' --'www.v6.facebook.com'

   print('Testing HTTPS connection to ' .. SITE .. '...')

   local https_client = obj.new('netsocket', {
      name = 'HTTPSGoogleClient',
      feedback = function(Socket, State)
         print('[HTTPS Client] Connection state: ' .. printableState(State))

         if (State == NTC_CONNECTING_SSL) then
            print('[HTTPS Client] Performing SSL handshake with ' .. SITE .. '...')

         elseif (State == NTC_CONNECTED) then
            print('[HTTPS Client] SSL connection to ' .. SITE .. ' established successfully')
            connection_established = true

            -- Send HTTP GET request for the index page
            local http_request = "GET / HTTP/1.1\r\nHost: " .. SITE .. "\r\nConnection: close\r\nUser-Agent: Parasol-SSL-Test\r\n\r\n"
            print('[HTTPS Client] Sending HTTP GET request...')
            local err, len = Socket.acWrite(http_request)
            if (err != ERR_Okay) then
               error('[HTTPS Client] Failed to send HTTP request: ' .. mSys.GetErrorMsg(err))
            else
               print('[HTTPS Client] HTTP request sent successfully')
            end

         elseif (State == NTC_DISCONNECTED) then
            print('[HTTPS Client] HTTPS connection closed')
            response_complete = true

            -- Try to read any remaining data before disconnection
            if (connection_established and not data_received) then
               print('[HTTPS Client] Attempting final data read...')
               local buffer = string.alloc(8192)
               local err, read_len = Socket.acRead(buffer)
               if (err == ERR_Okay and read_len > 0) then
                  local chunk = buffer:sub(1, read_len)
                  page_content = page_content .. chunk
                  print('[HTTPS Client] Read ' .. read_len .. ' bytes during disconnect (total: ' .. #page_content .. ')')
                  data_received = true
               end
            end

            proc.signal()
            raise(ERR_Terminate)
         end
      end,
      incoming = function(Socket)
         local buffer = string.alloc(8192)
         local err, read_len = Socket.acRead(buffer)

         if (err == ERR_Okay) then
            if read_len == 0 then 
               print('Received incoming data notification with no data to read.')
               raise(ERR_Terminate)
            end

            local chunk = buffer:sub(1, read_len)
            page_content = page_content .. chunk
            print('[HTTPS Client] Received ' .. read_len .. ' bytes from ' .. SITE .. ' (total: ' .. #page_content .. ')')
            data_received = true

            -- Check if we got the full response header
            if (not response_complete and string.match(page_content, 'HTTP/%d%.%d')) then
               print('[HTTPS Client] HTTP response header received')
            end

         elseif (err == ERR_Disconnected) then
            print('[HTTPS Client] Server closed connection after sending data')
            response_complete = true
            if (#page_content > 0) then
               data_received = true
            end
            proc.signal()
            raise(ERR_Terminate)
         else
            print('[HTTPS Client] HTTPS read error: ' .. mSys.GetErrorMsg(err))
            raise(ERR_Terminate)
         end
      end,
      flags = 'SSL'
   })

   assert(https_client, 'Failed to create HTTPS client socket')

   print('[HTTPS Client] Connecting to ' .. SITE .. ':443...')
   local err = https_client.mtConnect(SITE, 443)
   assert(err == ERR_Okay, 'HTTPS client connection failed: ' .. mSys.GetErrorMsg(err))

   local err = proc.sleep()

   -- Don't fail if timeout occurred but we got some response
   if (err == ERR_TimeOut) then
      print('[HTTPS Client] Test timed out, checking if we received data...')
      if (connection_established and data_received and #page_content > 0) then
         print('[HTTPS Client] Timeout but data was received - acceptable for this test')
      else
         assert(false, 'HTTPS connection test timed out without receiving data')
      end
   elseif (err != ERR_Okay) then
      assert(false, 'HTTPS connection test failed: ' .. mSys.GetErrorMsg(err))
   end

   assert(connection_established, 'HTTPS connection was not established')
   assert(data_received, 'No data was received from ' .. SITE)
   assert(#page_content > 0, 'Index page content is empty')

   -- Verify we received a proper HTTP response
   if (string.match(page_content, 'HTTP/%d%.%d') and
       (string.match(page_content, '200 OK') or string.match(page_content, '301') or
        string.match(page_content, '302') or string.match(page_content, '404'))) then
      print('[HTTPS Client] Received valid HTTP response (' .. #page_content .. ' bytes total)')
      print('HTTPS connection to ' .. SITE .. ' test completed successfully!')
   else
      print('[HTTPS Client] Response content preview: ' .. string.sub(page_content, 1, 200))
      error('Invalid HTTP response received from ' .. SITE)
   end
end

-----------------------------------------------------------------------------------------------------------------------

   return {
      tests = {
         'testBasicSSLCommunication',
         'testSSLStateTransitions',
         'testSSLDataIntegrity',
         'testHTTPSConnection'
      },
      init = function()
         glSSLSupported = false
         checkSSLSupport()
      end
   }