--[[
SSL Communication Test

This test suite verifies SSL-enabled network communications using the NSF_SSL flag.

Tests include:
- SSL server socket creation and certificate handling
- SSL client connection establishment and handshake
- Encrypted data transfer verification
- SSL-specific error conditions and recovery
- Certificate validation scenarios
- SSL state transitions (NTC_HANDSHAKING)
- Cross-platform SSL implementation testing
- SSL connection termination and cleanup

Note: These tests require SSL support to be compiled into the Network module.
If SSL is not available, tests will be skipped with appropriate messages.
--]]

   include 'network'

   if not mNet then mNet = mod.load('network') end

   glPort = 21605
   glSSLSupported = false
   glSSLTestData = 'SECRET_SSL_MESSAGE_123'

function printableState(State)
   if (State == NTC_CONNECTED) then return 'CONNECTED'
   elseif (State == NTC_DISCONNECTED) then return 'DISCONNECTED'
   elseif (State == NTC_HANDSHAKING) then return 'HANDSHAKING'
   else return tostring(State) end
end

-----------------------------------------------------------------------------------------------------------------------

function checkSSLSupport()
   -- Test if SSL support is available by attempting to create SSL socket
   local test_socket = obj.new('netsocket', {
      name = 'SSLSupportTest',
      port = glPort,
      flags = 'SERVER|SSL'
   })

   if (test_socket) then
      if (test_socket.error == ERR_Okay) then
         glSSLSupported = true
         msg('[SSL] SSL support detected and available')
      else
         msg('[SSL] SSL socket creation failed: ' .. mSys.GetErrorMsg(test_socket.error))
         msg('[SSL] SSL tests will be skipped')
      end
      test_socket = nil
      collectgarbage()
   else
      msg('[SSL] SSL socket creation returned nil - SSL not supported')
      msg('[SSL] SSL tests will be skipped')
   end

   return glSSLSupported
end

-----------------------------------------------------------------------------------------------------------------------
-- Simple localised connectivity test between server and client.  The client manually enables the SSL handshake
-- with SetSSL().

function testBasicSSLCommunication()
   if (not glSSLSupported) then return end

   local proc = processing.new({ timeout = 5.0 })
   local ssl_handshake_complete = false
   local ssl_data_received = false

   glPort = glPort + 1

   local ssl_server = obj.new('netsocket', {
      name = 'server',
      feedback = function(Socket, Client, State)
         msg('[Server] Client state: ' .. printableState(State))

         assert(Client, 'Client parameter is empty')

         if (State == NTC_HANDSHAKING) then
            msg('[Server] SSL handshake in progress...')

         elseif (State == NTC_CONNECTED) then
            msg('[Server] SSL handshake completed, client connected securely')
            ssl_handshake_complete = true

            -- Send encrypted test message
            msg('[Server] Sending encrypted message to client...')
            local err, len = Client.acWrite(glSSLTestData)
            if (err == ERR_Okay) then
               msg('[Server] Encrypted message sent successfully')
            else
               error('[Server] Failed to send encrypted message: ' .. mSys.GetErrorMsg(err))
            end

         elseif (State == NTC_DISCONNECTED) then
            msg('[Server] SSL client disconnected')
            if (ssl_handshake_complete and ssl_data_received) then
               proc.signal()
            end
         end
      end,
      incoming = function(Socket, Client)
         local buffer = string.alloc(1024)
         local err, read_len = Client.acRead(buffer)

         if (err == ERR_Okay) then
            if read_len == 0 then
               error('Received incoming data notification with no data to read.')
            end

            local emsg = buffer:sub(1, read_len)
            msg('[Server] Received encrypted message of ' .. read_len .. ' bytes: "' .. nz(emsg,'NIL') .. '"')

            -- Verify message integrity over SSL
            if (string.match(emsg, 'SSL_ECHO:' .. glSSLTestData)) then
               msg('[Server] SSL message integrity verified!')
               ssl_data_received = true
               Socket.mtDisconnectSocket(Client)
            else
               error('[Server] SSL message integrity check failed. Got: "' .. emsg .. '"')
            end
         elseif (err == ERR_Disconnected) then
            raise(ERR_Terminate)
         else
            error('[Server] SSL read error: ' .. mSys.GetErrorMsg(err))
         end
      end,
      port = glPort,
      flags = 'SERVER|SSL'
   })

   assert(ssl_server, 'Failed to create SSL server socket')
   assert(ssl_server.error == ERR_Okay, 'SSL server error: ' .. mSys.GetErrorMsg(ssl_server.error))

   local ssl_client = obj.new('netsocket', {
      name = 'client',
      feedback = function(Socket, State)
         msg('[Client] Connection state: ' .. printableState(State))

         if (State == NTC_HANDSHAKING) then
            msg('[Client] Performing SSL handshake...')

         elseif (State == NTC_CONNECTED) then
            msg('[Client] SSL connection established successfully')

            -- Convert the socket to SSL using SetSSL
            local err = mNet.SetSSL(Socket, "EnableSSL")
         elseif (State == NTC_DISCONNECTED) then
            msg('[Client] SSL connection closed')
         end
      end,
      incoming = function(Socket)
         local buffer = string.alloc(1024)
         local err, read_len = Socket.acRead(buffer)

         if (err == ERR_Okay) then
            if read_len == 0 then
               error('Received incoming data notification with no data to read.')
            end

            local emsg = buffer:sub(1, read_len)
            msg('[Client] Received encrypted message of ' .. read_len .. ' bytes: "' .. nz(emsg,'NIL') .. '"')

            -- Echo back the message to verify bidirectional SSL
            local echo_msg = 'SSL_ECHO:' .. emsg
            msg('[Client] Sending encrypted echo...')
            local err, len = Socket.acWrite(echo_msg)
            if (err == ERR_Okay) then
               msg('[Client] Encrypted echo sent successfully')
            else
               error('[Client] Failed to send encrypted echo: ' .. mSys.GetErrorMsg(err))
            end
         elseif (err == ERR_Disconnected) then
            raise(ERR_Terminate)
         else
            error('[Client] SSL read error: ' .. mSys.GetErrorMsg(err))
         end
      end,
      flags = 'DISABLE_SERVER_VERIFY'
   })

   assert(ssl_client, 'Failed to create SSL client socket')

   msg('[Client] Connecting to SSL server...')
   local err = ssl_client.mtConnect('127.0.0.1', glPort)
   assert(err == ERR_Okay, 'SSL client connection failed: ' .. mSys.GetErrorMsg(err))

   local err = proc.sleep()
   assert(err == ERR_Okay, 'SSL communication test failed: ' .. mSys.GetErrorMsg(err))

   assert(ssl_handshake_complete, 'SSL handshake did not complete')
   assert(ssl_data_received, 'SSL data exchange did not complete')
end

-----------------------------------------------------------------------------------------------------------------------

function testSSLStateTransitions()
   if (not glSSLSupported) then return end

   local proc = processing.new({ timeout = 5.0 })
   local state_sequence = {}
   local ssl_handshake_complete = false
   local data_exchange_complete = false

   glPort = glPort + 1

   local ssl_server = obj.new('netsocket', {
      name = 'SSLStateServer',
      feedback = function(Socket, Client, State)
         table.insert(state_sequence, 'SERVER:' .. printableState(State))
         msg('[Server] State transition: ' .. printableState(State) .. ' (' .. mSys.GetErrorMsg(Socket.error) .. ')')

         if (State == NTC_CONNECTED) then
            msg('[Server] SSL handshake completed successfully!')
            ssl_handshake_complete = true
            -- Send test message
            msg('[Server] Sending test message...')
            local err, len = Client.acWrite('SSL_STATE_TEST_COMPLETE')
            if (err != ERR_Okay) then
               error('[Server] Failed to send message: ' .. mSys.GetErrorMsg(err))
            else
               msg('[Server] Message sent successfully')
            end
         elseif (State == NTC_DISCONNECTED) then
            if (ssl_handshake_complete and data_exchange_complete) then
               msg('[Server] Test completed successfully')
            elseif (ssl_handshake_complete) then
               msg('[Server] Handshake completed but data exchange failed')
            else
               msg('[Server] Connection failed before handshake completion')
            end
            proc.signal()
         end
      end,
      incoming = function(Socket, Client)
         msg('[Server] Incoming data callback triggered')
         local buffer = string.alloc(1024)
         local err, read_len = Client.acRead(buffer)
         if (err == ERR_Okay) then
            local emsg = buffer:sub(1, read_len)
            msg('[Server] Received: ' .. emsg)
            data_exchange_complete = true
            Socket.mtDisconnectSocket(Client)
         elseif (err != ERR_Disconnected) then
            error('[Server] Read error: ' .. mSys.GetErrorMsg(err))
         end
      end,
      port = glPort,
      flags = 'SERVER|SSL'
   })

   local ssl_client = obj.new('netsocket', {
      name = 'SSLStateClient',
      feedback = function(Socket, State)
         table.insert(state_sequence, 'CLIENT:' .. printableState(State))
         print('[Client] State transition: ' .. printableState(State))
         if (State == NTC_DISCONNECTED) then
            proc.signal()
         end
      end,
      incoming = function(Socket)
         print('[Client] Incoming data callback triggered')
         local buffer = string.alloc(1024)
         local err, read_len = Socket.acRead(buffer)
         if (err == ERR_Okay) then
            local emsg = buffer:sub(1, read_len)
            print('[Client] Received: ' .. emsg)
            print('[Client] Sending acknowledgment...')
            local err, len = Socket.acWrite('SSL_STATES_VERIFIED')
            if (err != ERR_Okay) then
               error('[Client] Failed to send acknowledgment: ' .. mSys.GetErrorMsg(err))
            else
               print('[Client] Acknowledgment sent successfully')
            end
         elseif (err != ERR_Disconnected) then
            error('[Client] Read error: ' .. mSys.GetErrorMsg(err))
         end
      end,
      flags = 'SSL|DISABLE_SERVER_VERIFY'
   })

   msg('[Client] Initiating connection...')
   ssl_client.mtConnect('127.0.0.1', glPort)

   local err = proc.sleep()
   assert(err == ERR_Okay, 'sleep() returned ' ..  mSys.GetErrorMsg(err))

   -- Always print the state sequence for debugging
   print('SSL State Sequence:')
   for i, state in ipairs(state_sequence) do
      print('  ' .. i .. '. ' .. state)
   end

   -- Check if we got a connected state
   local server_connected
   local client_connected

   for i, state in ipairs(state_sequence) do
      if (string.match(state, 'SERVER:CONNECTED')) then
         server_connected = true
      end
      if (string.match(state, 'CLIENT:CONNECTED')) then
         client_connected = true
      end
   end

   if (not server_connected) then
      error('Server never reached CONNECTED state - SSL handshake failed')
   end

   if (not client_connected) then
      error('Client never reached CONNECTED state - SSL handshake failed')
   end
end

-----------------------------------------------------------------------------------------------------------------------

function testSSLDataIntegrity()
   if (not glSSLSupported) then return end

   local proc = processing.new({ timeout = 3.0 })
   local test_messages = {
      'Binary data: ' .. string.char(0, 1, 2, 3, 255, 254, 253),
      string.rep('Large SSL message ', 500), -- ~9KB message
      'Special chars: àáâãäåæçèéêë',
      'JSON: {"encrypted": true, "secure": "data"}',
      'Empty message test: '
   }
   local messages_verified = 0

   glPort = glPort + 1

   local msgIndex = 1
   local ssl_server = obj.new('netsocket', {
      name = 'SSLIntegrityServer',
      feedback = function(Socket, Client, State)
         if (State == NTC_CONNECTED) then
            -- Send first test message
            local emsg = test_messages[msgIndex]
            print('[Server] Sending message ' .. msgIndex .. ' (' .. #emsg .. ' bytes)')
            Client.acWrite(emsg)
         end
      end,
      incoming = function(Socket, Client)
         local buffer = string.alloc(10240) -- Large buffer for big messages
         local err, read_len = Client.acRead(buffer)

         if (err == ERR_Okay) then
            local received = buffer:sub(1, read_len)
            local expected = test_messages[msgIndex]

            print('[Server] Received echo ' .. msgIndex .. ' (' .. read_len .. ' bytes)')

            if (received == expected) then
               print('[Server] Message ' .. msgIndex .. ' integrity verified!')
               messages_verified = messages_verified + 1

               msgIndex = msgIndex + 1
               if (msgIndex <= #test_messages) then
                  -- Send next message
                  local next_msg = test_messages[msgIndex]
                  print('[Server] Sending message ' .. msgIndex .. ' (' .. #next_msg .. ' bytes)')
                  Client.acWrite(next_msg)
               else
                  print('[Server] All messages verified successfully!')
                  proc.signal()
               end
            else
               error('[Server] Message integrity failed for message ' .. msgIndex)
            end
         end
      end,
      port = glPort,
      flags = 'SERVER|SSL'
   })

   local ssl_client = obj.new('netsocket', {
      name = 'SSLIntegrityClient',
      incoming = function(Socket)
         local buffer = string.alloc(10240)
         local err, read_len = Socket.acRead(buffer)

         if (err == ERR_Okay) then
            local emsg = buffer:sub(1, read_len)
            print('[Client] Received message (' .. read_len .. ' bytes), echoing back...')

            -- Echo back exactly what was received
            local err, len = Socket.acWrite(emsg)
            assert(err == ERR_Okay, 'Failed to echo SSL message: ' .. mSys.GetErrorMsg(err))
         end
      end,
      flags = 'SSL|DISABLE_SERVER_VERIFY'
   })

   ssl_client.mtConnect('127.0.0.1', glPort)

   local err = proc.sleep()
   assert(err == ERR_Okay, 'SSL data integrity test failed: ' .. mSys.GetErrorMsg(err))

   assert(messages_verified == #test_messages,
      'Not all messages verified. Expected: ' .. #test_messages .. ', Verified: ' .. messages_verified)
end

-----------------------------------------------------------------------------------------------------------------------

function testHTTPSConnection()
   if (not glSSLSupported) then return end

   local proc = processing.new({ timeout = 5.0 })
   local connection_established = false
   local data_received = false
   local page_content = ""
   local response_complete = false
   local SITE = 'www.google.com' --'www.v6.facebook.com'
   local chunks_received = 0
   local start_time = mSys.PreciseTime()
   local connection_time = 0
   local expected_content_length = 0
   local headers_complete = false

   print('Testing HTTPS connection to ' .. SITE .. '...')

   local https_client = obj.new('netsocket', {
      name = 'HTTPSGoogleClient',
      feedback = function(Socket, State)
         print('Connection state: ' .. printableState(State))

         if (State == NTC_HANDSHAKING) then
            print('Performing SSL handshake with ' .. SITE .. '...')

         elseif (State == NTC_CONNECTED) then
            connection_time = mSys.PreciseTime()
            print('SSL connection to ' .. SITE .. ' established successfully in ' ..
                  string.format("%.3f", (connection_time - start_time) / 1000000.0) .. ' seconds')
            connection_established = true

            -- Send HTTP GET request for the index page
            local http_request = "GET / HTTP/1.1\r\nHost: " .. SITE .. "\r\nConnection: close\r\nUser-Agent: Parasol-SSL-Test\r\n\r\n"
            print('Sending HTTP GET request...')
            local err, len = Socket.acWrite(http_request)
            if (err != ERR_Okay) then
               error('Failed to send HTTP request: ' .. mSys.GetErrorMsg(err))
            else
               print('HTTP request sent successfully (' .. len .. ' bytes)')
            end

         elseif (State == NTC_DISCONNECTED) then
            print('HTTPS connection closed')
            response_complete = true

            -- Try to read any remaining data before disconnection
            if (connection_established and not data_received) then
               print('Attempting final data read...')
               local buffer = string.alloc(8192)
               local err, read_len = Socket.acRead(buffer)
               if (err == ERR_Okay and read_len > 0) then
                  local chunk = buffer:sub(1, read_len)
                  page_content = page_content .. chunk
                  print('Read ' .. read_len .. ' bytes during disconnect (total: ' .. #page_content .. ')')
                  data_received = true
               end
            end

            proc.signal()
            raise(ERR_Terminate)
         end
      end,
      incoming = function(Socket)
         local current_time = mSys.PreciseTime()
         local elapsed = string.format("%.3f", (current_time - start_time) / 1000000.0)
         local callback_total = 0

         -- Read all available data in this callback
         while true do
            local buffer = string.alloc(8192)
            local err, read_len = Socket.acRead(buffer)

            if (err == ERR_Okay) then
               if read_len == 0 then -- No more data available right now
                  error('Received incoming data notification with no data to read.')
               end

               chunks_received = chunks_received + 1
               callback_total = callback_total + read_len
               local chunk = buffer:sub(1, read_len)
               page_content = page_content .. chunk

               print('Chunk ' .. chunks_received .. ' received: ' .. read_len .. ' bytes from ' ..
                     SITE .. ' at ' .. elapsed .. 's (total: ' .. #page_content .. ' bytes)')
               data_received = true

               -- Parse headers if not done yet
               if (not headers_complete and string.match(page_content, '\r\n\r\n')) then
                  headers_complete = true
                  local headers = string.match(page_content, '(.-)\r\n\r\n')
                  print('HTTP headers received (' .. #headers .. ' bytes)')

                  -- Extract Content-Length if present
                  local content_length = string.match(headers, 'Content%-Length:%s*(%d+)')
                  if content_length then
                     expected_content_length = tonumber(content_length)
                     print('Content-Length: ' .. expected_content_length .. ' bytes')
                  else
                     print('No Content-Length header found (chunked encoding?)')
                  end
               end

               -- Check if we got the full response header
               if (not response_complete and string.match(page_content, 'HTTP/%d%.%d')) then
                  print('HTTP response status line received')
               end
            elseif (err == ERR_Disconnected) then
               print('Server closed connection after sending data')
               response_complete = true
               if #page_content > 0 then data_received = true end
               proc.signal()
               raise(ERR_Terminate)
            else
               print('HTTPS read error: ' .. mSys.GetErrorMsg(err))
               raise(ERR_Terminate)
            end
         end

         if callback_total > 0 then
            print('Incoming callback processed ' .. callback_total .. ' bytes total in this call')
         end
      end,
      flags = 'SSL'
   })

   assert(https_client, 'Failed to create HTTPS client socket')

   print('Connecting to ' .. SITE .. ':443...')
   local err = https_client.mtConnect(SITE, 443)
   assert(err == ERR_Okay, 'HTTPS client connection failed: ' .. mSys.GetErrorMsg(err))

   local err = proc.sleep()

   -- Don't fail if timeout occurred but we got some response
   if (err == ERR_TimeOut) then
      print('Test timed out, checking if we received data...')
      if (connection_established and data_received and #page_content > 0) then
         print('Timeout but data was received - acceptable for this test')
      else
         error('HTTPS connection test timed out without receiving data')
      end
   elseif (err != ERR_Okay) then
      error('HTTPS connection test failed: ' .. mSys.GetErrorMsg(err))
   end

   assert(connection_established, 'HTTPS connection was not established')
   assert(data_received, 'No data was received from the HTTPS server')
   assert(#page_content != 0, 'Index page content is empty')

   local final_time = mSys.PreciseTime()
   local total_duration = string.format("%.3f", (final_time - start_time) / 1000000.0)
   print('Received ' .. chunks_received .. ' chunks, ' .. #page_content .. ' total bytes')

   if expected_content_length > 0 then
      local content_start = string.find(page_content, '\r\n\r\n')
      if content_start then
         local actual_content_length = #page_content - content_start - 3
         print('Body length: ' .. actual_content_length .. ' bytes (expected: ' .. expected_content_length .. ')')
         if actual_content_length < expected_content_length then
            print('WARNING: Incomplete response - missing ' .. (expected_content_length - actual_content_length) .. ' bytes')
         end
      end
   end

   if (string.match(page_content, 'HTTP/%d%.%d') and
       (string.match(page_content, '200 OK') or string.match(page_content, '301') or
        string.match(page_content, '302') or string.match(page_content, '404'))) then
      print('Received valid HTTP response (' .. #page_content .. ' bytes total)')

      if #page_content < 2048 then
         print('Response content:')
         print(page_content)
      else
         print('Response preview (first 500 chars):')
         print(string.sub(page_content, 1, 500) .. '...')
      end
   else
      print('Response content preview: ' .. string.sub(page_content, 1, 200))
      error('Invalid HTTP response received from ' .. SITE)
   end
end

-----------------------------------------------------------------------------------------------------------------------

function testCustomCertificate()
   if (not glSSLSupported) then return end

   local proc = processing.new({ timeout = 10.0 })
   local custom_cert_test_complete = false
   local handshake_successful = false
   local CERT_PATH = 'config:ssl/localhost.p12'

   glPort = glPort + 1

   if (mSys.AnalysePath(CERT_PATH) != ERR_Okay) then
      print('Test certificate not installed, skipping test...')
      return
   end

   -- Test with localhost.p12 certificate if available
   local ssl_server = obj.new('netsocket', {
      name = 'CustomCertServer',
      sslCertificate = CERT_PATH,
      feedback = function(Socket, Client, State)
         msg('[Server] State: ' .. printableState(State))

         if (State == NTC_CONNECTED) then
            handshake_successful = true
            msg('[Server] SSL handshake with custom certificate successful!')

            -- Send confirmation message
            local err, len = Client.acWrite('CUSTOM_CERT_CONFIRMED')
            if (err == ERR_Okay) then
               msg('[Server] Custom certificate test message sent')
            else
               error('[Server] Failed to send test message: ' .. mSys.GetErrorMsg(err))
            end

         elseif (State == NTC_DISCONNECTED) then
            if not (handshake_successful and custom_cert_test_complete) then
               msg('Disconnected before test was completed.')
            end
            proc.signal()
         end
      end,
      incoming = function(Socket, Client)
         local buffer = string.alloc(1024)
         local err, read_len = Client.acRead(buffer)
         if (err == ERR_Okay) then
            local message = buffer:sub(1, read_len)
            msg('[Server] Received: ' .. message)
            custom_cert_test_complete = true
            Socket.mtDisconnectSocket(Client)
         end
      end,
      port = glPort,
      flags = 'SERVER|SSL'
   })

   if (not ssl_server) then
      error('Failed to create custom certificate SSL server')
   end

   local ssl_client = obj.new('netsocket', {
      name = 'CustomCertClient',
      feedback = function(Socket, State)
         msg('[Client] State: ' .. printableState(State))

         if (State == NTC_CONNECTED) then
            msg('Connected to custom certificate server')

            local err, len = Socket.acWrite('CLIENT_RESPONSE')
            if (err == ERR_Okay) then
               msg('Response sent to custom cert server')
            else
               error('Failed to send response: ' .. mSys.GetErrorMsg(err))
            end
         end
      end,
      flags = 'SSL|DISABLE_SERVER_VERIFY'  -- Use no-verify for test certificate
   })

   if (not ssl_client) then
      error('Failed to create custom certificate SSL client')
   end

   local err = ssl_client.mtConnect('127.0.0.1', glPort)
   if (err != ERR_Okay) then
      error('Failed to initiate connection to custom cert server: ' .. mSys.GetErrorMsg(err))
   end

   msg('[Custom Cert] Connecting to custom certificate server...')

   local err = proc.sleep()
   assert(err == ERR_Okay, 'Custom certificate test failed: ' .. mSys.GetErrorMsg(err))
   assert(handshake_successful, 'Custom certificate SSL handshake failed')
end

-----------------------------------------------------------------------------------------------------------------------

   return {
      tests = {
         'testBasicSSLCommunication',
         'testSSLStateTransitions',
         'testSSLDataIntegrity',
         'testCustomCertificate',
         'testHTTPSConnection'
      },
      init = function()
         glSSLSupported = false
         checkSSLSupport()
      end
   }