-- Tests for advanced XML features and flag combinations

   include 'xml'

-----------------------------------------------------------------------------------------------------------------------
-- Test XML parsing flags

function testParsingFlags()
   local xmlWithComments = '<root><!-- Comment --><child/></root>'

   -- Test with comment inclusion
   local xml1 = obj.new("xml", {
      statement = xmlWithComments,
      flags = XMF_INCLUDE_COMMENTS
   })
   -- Comments should be preserved when flag is set

   -- Test with comment stripping (default)
   local xml2 = obj.new("xml", { statement = xmlWithComments })
   assert(xml2.tags[0].children[0].attribs[0].name is "child", "Comments should be stripped by default")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test whitespace handling

function testWhitespaceHandling()
   local xmlWithWhitespace = '<root>  \n  <child>  content  </child>  \n  </root>'

   -- Test with whitespace inclusion
   local xml1 = obj.new("xml", {
      statement = xmlWithWhitespace,
      flags = XMF_INCLUDE_WHITESPACE
   })
   -- Whitespace should be preserved

   -- Test default whitespace handling
   local xml2 = obj.new("xml", { statement = xmlWithWhitespace })
   assert(xml2.tags[0].children[0].attribs[0].name is "child", "Child should be found despite whitespace")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test content stripping

function testContentStripping()
   local xmlWithContent = '<root><element>Text content</element><empty/></root>'

   -- Test with content stripping
   local xml = obj.new("xml", {
      statement = xmlWithContent,
      flags = XMF_STRIP_CONTENT
   })

   -- Content should be stripped, only element structure preserved
   assert(xml.tags[0].children[0].attribs[0].name is "element", "Element structure should remain")
   assert(#xml.tags[0].children[0].children is 0, "Content should be stripped")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test header stripping

function testHeaderStripping()
   local xmlWithHeaders = '<?xml version="1.0"?><!DOCTYPE root><root><child/></root>'

   -- Test with header stripping
   local xml = obj.new("xml", {
      statement = xmlWithHeaders,
      flags = XMF_STRIP_HEADERS
   })

   -- Should only have the root element, no processing instructions
   assert(xml.tags[0].attribs[0].name is "root", "Root element should be preserved")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test well-formed validation

function testWellFormedValidation()
   local malformedXML = '<root><unclosed><proper/></root>'

   -- Test without well-formed flag (should parse loosely)
   local xml1 = obj.new("xml", { statement = malformedXML })
   -- Should parse in loose mode

   -- Test with well-formed flag (should reject)
   local ex, xml2 = catch(function() return obj.new("xml", {
      statement = malformedXML,
      flags = XMF_WELL_FORMED
   }) end)

   assert(ex.code != ERR_Okay, "Should reject malformed XML in well-formed mode")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test entity parsing

function testEntityParsing()
   local xmlWithEntities = [[<!DOCTYPE root PUBLIC "-//Example//DTD Example//EN" "http://example.com/example.dtd" [
      <!ENTITY % base "value">
      <!ENTITY test "%base; and more">
      <!NOTATION icon SYSTEM "viewer">
   ]>
   <root>&test;</root>]]

   -- Test with entity parsing enabled
   local xml = obj.new("xml", {
      statement = xmlWithEntities,
      flags = XMF_PARSE_ENTITY
   })

   assert(xml.docType is 'root', 'Document type field should be populated')
   assert(xml.publicID is '-//Example//DTD Example//EN', 'Public identifier should match declaration')
   assert(xml.systemID is 'http://example.com/example.dtd', 'System identifier should match declaration')

   local err, entityValue = xml.mtGetEntity('test')
   assert(err is ERR_Okay and entityValue is 'value and more', 'Parsed entity should resolve parameter entities')

   local notationErr, notationValue = xml.mtGetNotation('icon')
   assert(notationErr is ERR_Okay and notationValue is 'viewer', 'Notation lookup should return the system identifier')

   local err, resolved = xml.mtEvaluate('string(/root)')
   assert(resolved is 'value and more', 'Entity references should be expanded in content')
end

-----------------------------------------------------------------------------------------------------------------------
-- Test standalone declaration handling

function testStandalonePreventsExternalDTD()
   local standaloneXML = [[<?xml version="1.0" standalone="yes"?>
<!DOCTYPE root SYSTEM "http://example.com/example.dtd">
<root><child/></root>]]

   local xml = obj.new("xml", {
      statement = standaloneXML,
      flags = XMF_PARSE_ENTITY
   })

   assert(bit.band(xml.flags, XMF_STANDALONE) != 0, 'Standalone declaration should set XMF_STANDALONE flag')
   assert(xml.systemID is nil, 'System identifier should not be retained for standalone documents')
   assert(xml.publicID is nil, 'Public identifier should not be retained for standalone documents')
   assert(xml.docType is 'root', 'Document type should still be captured for standalone documents')
end

-----------------------------------------------------------------------------------------------------------------------
-- Test no-escape mode

function testNoEscapeMode()
   local xmlWithEscapes = '<root attr="&lt;&gt;">&amp;content&amp;</root>'

   -- Test with escaping (default)
   local xml1 = obj.new("xml", { statement = xmlWithEscapes })
   -- Escapes should be processed

   -- Test without escaping
   local xml2 = obj.new("xml", {
      statement = xmlWithEscapes,
      flags = XMF_NO_ESCAPE
   })
   -- Escapes should be left as-is
end

-----------------------------------------------------------------------------------------------------------------------
-- Test sorting with various flags

function testSortingFlags()
   local xml = obj.new("xml", {
      statement = '<root><item sort="z">Z item</item><item sort="a">A item</item><item sort="m">M item</item></root>'
   })

   -- Test ascending sort
   local err = xml.mtSort('/root', 'item', XSF_NIL)
   assert(err is ERR_Okay, "Ascending sort should succeed")

   -- Test descending sort
   local err = xml.mtSort('/root', 'item', XSF_DESC)
   assert(err is ERR_Okay, "Descending sort should succeed")

   -- Test sort with check sort flag
   local err = xml.mtSort('/root', 'item', XSF_CHECK_SORT)
   assert(err is ERR_Okay, "Sort with check flag should succeed")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test serialisation flags

function testSerialisationFlags()
   local xml = obj.new("xml", {
      statement = '<root><child attr="value">Content</child></root>'
   })

   -- Test readable serialisation
   local err, readable = xml.mtSerialise(0, bit.bor(XMF_READABLE, XMF_INCLUDE_SIBLINGS))
   assert(err is ERR_Okay, "Readable serialisation should succeed")
   assert(string.find(readable, '\n'), "Readable format should include newlines")

   -- Test compact serialisation
   local err, compact = xml.mtSerialise(0, XMF_INCLUDE_SIBLINGS)
   assert(err is ERR_Okay, "Compact serialisation should succeed")

   -- Test omit tags serialisation
   local err, content = xml.mtSerialise(0, bit.bor(XMF_OMIT_TAGS, XMF_INCLUDE_SIBLINGS))
   assert(err is ERR_Okay, "Content-only serialisation should succeed")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test GetContent vs deep content extraction

function testContentExtraction()
   local xml = obj.new("xml", {
      statement = '<root>Before <em>emphasized</em> after <strong>strong</strong> end</root>'
   })

   local rootId = xml.tags[0].id

   -- Test shallow content extraction
   local buffer = string.alloc(1000)
   local err = xml.mtGetContent(rootId, buffer)
   assert(err is ERR_Okay, "Shallow content extraction should succeed")
   assert(string.find(buffer, "Before"), "Should include direct text")
   assert(string.find(buffer, "after"), "Should include direct text")
   assert(string.find(buffer, "end"), "Should include direct text")

   -- Test deep content extraction via mtEvaluate
   local err, deepContent = xml.mtEvaluate('string(/root)')
   assert(string.find(deepContent, "emphasized"), "Deep extraction should include nested content")
   assert(string.find(deepContent, "strong"), "Deep extraction should include nested content")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test Count method vs count

function testCountMethods()
   local xml = obj.new("xml", {
      statement = '<root><section><item/><item/></section><section><item/><item/><item/></section></root>'
   })

   -- Test count: mtEvaluate
   local err, keyCount = xml.mtEvaluate('count(//item)')
   assert(tonumber(keyCount) is 5, "Should count all items: got " .. keyCount)

   -- Test specific path count
   local err, sectionCount = xml.mtEvaluate('count(/root/section[1]/item)')
   assert(tonumber(sectionCount) is 2, "Should count items in first section only, got " .. sectionCount)
end

-----------------------------------------------------------------------------------------------------------------------
-- Test Filter method

function testFilterMethod()
   local xml = obj.new("xml", {
      statement = '<root><keep><target>Keep this</target><child/></keep><remove><target>Remove this</target></remove></root>'
   })

   -- Filter to keep only the first 'keep' section
   local err = xml.mtFilter('/root/keep')
   assert(err is ERR_Okay, "Filter should succeed")

   -- Should now only have the filtered content
   local tags = xml.tags
   assert(#tags is 1, "Should have only 1 root element after filter")
   assert(tags[0].attribs[0].name is "keep", "Root should be the filtered element")
   assert(tags[0].children[0].attribs[0].name is "target", "Children should be preserved")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test RemoveXPath with attribute removal

function testRemoveXPathAttributes()
   local xml = obj.new("xml", {
      statement = '<root><item id="1" name="first" type="test"/><item id="2" name="second"/></root>'
   })

   -- Remove specific attribute from all items
   local err = xml.mtRemoveXPath('//item/@type', 0)
   assert(err is ERR_Okay, "Attribute removal should succeed")

   -- Verify attribute was removed using a fresh lookup
   local err, itemId = xml.mtSearch('/root/item[@id="1"]')
   assert(err is ERR_Okay, "Should be able to locate the first item after removal")

   local attrErr, value = xml.mtGetAttrib(itemId, 'type')
   assert(attrErr is ERR_Search, "Type attribute should be removed by mtRemoveXPath: " .. mSys.GetErrorMsg(attrErr))

   -- Verify other attributes remain
   local nameErr, nameValue = xml.mtGetAttrib(itemId, 'name')
   assert(nameErr is ERR_Okay and nameValue is "first", "Other attributes should remain")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test exists() function

function testExists()
   local xml = obj.new("xml", {
      statement = '<root><empty attrib="value" blank=""/><withContent>Some text</withContent><whitespaceOnly>   \n\t  </whitespaceOnly></root>'
   })

   local err, emptyExists = xml.mtEvaluate('exists(/root/empty/text())')
   assert(emptyExists is "false", "exists() on text() should report no content, got: " .. emptyExists)

   local err, emptyExists = xml.mtEvaluate('exists(/root/empty)')
   assert(emptyExists is "true", "Targeted empty element exists, got: " .. emptyExists)

   local err, elementExists = xml.mtEvaluate('exists(/root/withContent)')
   assert(elementExists is "true", "Element with content should report element exists, got: " .. elementExists)

   local err, attribExists = xml.mtEvaluate('exists(/root/empty/@attrib)')
   assert(attribExists is "true", "Targeted attrib element exists, got: " .. attribExists)

   local err, attribExists = xml.mtEvaluate('exists(/root/empty/@blank)')
   assert(attribExists is "true", "Targeted blank element exists, got: " .. attribExists)

   local err, attribExists = xml.mtEvaluate('exists(/root/empty/@doesnotexist)')
   assert(attribExists is "false", "Unexpected result for non-existant attribute, got: " .. attribExists)

   local err, attribExists = xml.mtEvaluate('exists(string(/root/empty/@blank))')
   assert(attribExists is "true", "Expected true because @blank exists, despite being empty.  Got: " .. attribExists)

   -- Test element with only whitespace
   local err, whitespaceExists = xml.mtEvaluate('boolean(normalize-space(/root/whitespaceOnly))')
   assert(whitespaceExists is "false", "Normalised whitespace should report no content, got: " .. whitespaceExists)
end

-----------------------------------------------------------------------------------------------------------------------

return {
   tests = {
      'testParsingFlags', 'testWhitespaceHandling', 'testContentStripping', 'testHeaderStripping',
      'testWellFormedValidation', 'testEntityParsing', 'testStandalonePreventsExternalDTD', 'testNoEscapeMode', 'testSortingFlags',
      'testSerialisationFlags', 'testContentExtraction', 'testCountMethods', 'testFilterMethod',
      'testRemoveXPathAttributes', 'testExists'
   },
   init = function(ScriptFolder)
      -- No global init needed for these tests
   end,
   cleanup = function()
      -- No cleanup needed
   end
}
