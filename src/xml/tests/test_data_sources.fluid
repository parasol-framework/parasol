-- Tests for different XML data source methods

@AfterAll function cleanup()
   -- Clean up any remaining test files
   mSys.DeleteFile('temp:test_xml_path.xml')
   mSys.DeleteFile('temp:test_switch.xml')
end

-----------------------------------------------------------------------------------------------------------------------
-- Test loading from file path

@Test(priority=1) function testPathLoading()
   -- Create a temporary XML file for testing
   local testXML = '<?xml version="1.0"?><testRoot><testChild>Path content</testChild></testRoot>'
   local file = obj.new('file', { path = 'temp:test_xml_path.xml', flags = 'WRITE|NEW' })
   file.acWrite(testXML)
   file = nil

   -- Load XML from file path
   local xml = obj.new("xml", { path = 'temp:test_xml_path.xml', flags = XMF_STRIP_HEADERS })
   local tags = xml.tags
   assert(tags, "XML should load from file path")
   assert(tags[1].attribs[0].name is "testRoot", "Root tag should be testRoot; got " .. nz(tags[0].attribs[0].name, 'NIL'))
   assert(tags[1].children[0].children[0].attribs[0].value is "Path content", "Content should be preserved")

   collectgarbage()
   mSys.DeleteFile('temp:test_xml_path.xml')
end

-----------------------------------------------------------------------------------------------------------------------
-- Test loading from object source

@Test(priority=2) function testObjectSource()
   -- Create a memory object with XML content
   local testXML = '<sourceRoot><sourceChild>Object content</sourceChild></sourceRoot>'
   local memory = obj.new('file', { flags = 'READ|WRITE|NEW|BUFFER' })
   memory.acWrite(testXML)
   memory.acSeek(0, SEEK_SET)

   -- Load XML from object source
   local xml = obj.new("xml", { source = memory })
   local tags = xml.tags
   assert(tags, "XML should load from object source")
   assert(tags[0].attribs[0].name is "sourceRoot", "Root tag should be sourceRoot")
   assert(tags[0].children[0].children[0].attribs[0].value is "Object content", "Content should be preserved")

   memory = nil
end

-----------------------------------------------------------------------------------------------------------------------
-- Test string: path prefix

@Test(priority=3) function testStringPathPrefix()
   local testXML = '<stringRoot><stringChild>String path content</stringChild></stringRoot>'

   -- Use string: prefix to treat path as XML content
   local xml = obj.new("xml", { path = 'string:' .. testXML })
   local tags = xml.tags
   assert(tags, "string: prefix should parse XML content")
   assert(tags[0].attribs[0].name is "stringRoot", "Root tag should be stringRoot")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test DataFeed action

@Test(priority=4) function testDataFeed()
   local xml = obj.new("xml", { statement = '<root><existing>Original</existing></root>' })

   -- Feed additional XML data
   local err = xml.acDataFeed(nil, DATA_XML, '<added>New content</added>')
   assert(err is ERR_Okay, "DataFeed should succeed")

   local tags = xml.tags
   assert(#tags is 2, "Should have 2 root-level elements after DataFeed")
   assert(tags[1].attribs[0].name is "added", "Added element should be present")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test DataFeed with empty XML

@Test(priority=5) function testDataFeedEmpty()
   local xml = obj.new("xml") -- Start with empty XML

   -- Feed XML data to empty object
   local err = xml.acDataFeed(nil, DATA_XML, '<first>First element</first>')
   assert(err is ERR_Okay, "DataFeed to empty XML should succeed")

   local tags = xml.tags
   assert(tags and #tags is 1, "Should have 1 element after first DataFeed")

   -- Feed more data
   local err = xml.acDataFeed(nil, DATA_XML, '<second>Second element</second>')
   assert(err is ERR_Okay, "Second DataFeed should succeed")

   tags = xml.tags
   assert(#tags is 2, "Should have 2 elements after second DataFeed")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test reloading from different sources

@Test(priority=6) function testSourceSwitching()
   -- Start with statement
   local xml = obj.new("xml", { statement = '<initial>Statement content</initial>' })
   assert(xml.tags[0].attribs[0].name is "initial", "Initial load should work")

   -- Switch to different statement
   xml.statement = '<switched>New statement</switched>'
   assert(xml.tags[0].attribs[0].name is "switched", "Statement switching should work")

   -- Create file for path switching
   local fileXML = '<pathSwitched>Path content</pathSwitched>'
   local file = obj.new('file', { path = 'temp:test_switch.xml', flags = 'WRITE|NEW' })
   file.acWrite(fileXML)
   file = nil

   -- Switch to path
   xml.path = 'temp:test_switch.xml'
   assert(xml.tags[0].attribs[0].name is "pathSwitched", "Path switching should work")

   collectgarbage()
   mSys.DeleteFile('temp:test_switch.xml')
end

-----------------------------------------------------------------------------------------------------------------------
-- Test loading large files

@Test(priority=7) function testLargeFileLoading()
   -- Generate large XML content
   local parts = {'<largeRoot>'}
   for i = 0, 499 do
      table.insert(parts, '<item id="' .. i .. '">Content for item ' .. i .. '</item>')
   end
   table.insert(parts, '</largeRoot>')
   local largeXML = table.concat(parts)

   -- Load large file
   local xml = obj.new("xml", { statement = largeXML })
   assert(xml.tags, "Large XML file should load")
   assert(#xml.tags[0].children is 500, "All 500 items should be loaded")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test invalid file handling

@Test(priority=8) function testInvalidFileHandling()
   -- Try to load non-existent file

   local ex, xml = catch(function() return obj.new("xml", { path = 'temp:nonexistent.xml' }) end)
   assert(xml is nil, "Should report error for non-existent file")

   -- Try to parse invalid XML content.  Throwing an exception is considered acceptable if content is unparseable
   catch(function()
      local xml2 = obj.new("xml", { statement = 'This is not valid XML content' })
      assert(xml2.parseError != ERR_Okay, "Should report error for invalid XML")
   end)
end
