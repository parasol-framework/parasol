-- Comprehensive error handling and edge case tests

   include 'xml'

-----------------------------------------------------------------------------------------------------------------------
-- Test malformed XML handling

function testMalformedXML()
   -- Test unclosed tags
   local xml = obj.new("xml", { flags = XMF_WELL_FORMED })
   local err = xml.setKey("Statement", "<root><unclosed></root>")
   assert(err != ERR_Okay, "Should reject unclosed tags in well-formed mode")

   -- Test invalid characters in tag names
   local xml2 = obj.new("xml")
   local err = xml2.setKey("Statement", "<123invalid>content</123invalid>")
   -- Should still parse in loose mode but may generate warnings
end

-----------------------------------------------------------------------------------------------------------------------
-- Test empty XML document

function testEmptyDocument()
   local xml = obj.new("xml", { statement = "" })
   assert(not xml.tags or #xml.tags == 0, "Empty document should have no tags")

   -- Test whitespace-only document
   catch(function()
      local xml2 = obj.new("xml", { statement = "   \n\t  " })
      assert(not xml2.tags or #xml2.tags == 0, "Whitespace-only document should have no tags")
   end) -- Raising an exception because there is no data to parse is acceptable
end

-----------------------------------------------------------------------------------------------------------------------
-- Test very large XML documents

function testLargeDocument()
   -- Generate a large XML document
   local parts = {'<root>'}
   for i = 1, 1000 do
      table.insert(parts, '<item id="' .. i .. '">Content ' .. i .. '</item>')
   end
   table.insert(parts, '</root>')
   local largeXML = table.concat(parts)

   local xml = obj.new("xml", { statement = largeXML })
   assert(xml.tags, "Large document should parse successfully")
   assert(#xml.tags[1].children == 1000, "All 1000 items should be parsed")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test invalid method parameters

function testInvalidParameters()
   local xml = obj.new("xml", {
      statement = '<root><child id="test"/></root>'
   })

   -- Test invalid tag ID
   local err, value = xml.mtGetAttrib(99999, 'id')
   assert(err == ERR_NotFound, "Should return NotFound for invalid tag ID")

   -- Test nil XPath
   local err, result = xml.mtFindTag(nil)
   assert(err == ERR_NullArgs, "Should return NullArgs for nil XPath")

   -- Test empty XPath
   local err, result = xml.mtFindTag("")
   assert(err != ERR_Okay, "Should fail for empty XPath")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test readonly mode

function testReadOnlyMode()
   local xml = obj.new("xml", {
      statement = '<root><child/></root>',
      readOnly = true
   })

   local rootId = xml.tags[1].id

   -- Attempt to modify readonly XML
   local err = xml.mtSetAttrib(rootId, XMS_NEW, 'newattr', 'value')
   assert(err == ERR_ReadOnly, "Should reject modifications in readonly mode")

   local err, newId = xml.mtInsertXML(rootId, XMI_CHILD, '<newchild/>')
   assert(err == ERR_ReadOnly, "Should reject insertions in readonly mode")

   local err = xml.mtRemoveTag(rootId, 1)
   assert(err == ERR_ReadOnly, "Should reject removals in readonly mode")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test namespace handling

function testNamespaceHandling()
   local xml = obj.new("xml", {
      statement = '<root xmlns:ns="http://example.com"><ns:child ns:attr="value"/></root>'
   })

   -- Namespaces should be preserved as part of tag/attribute names
   assert(xml.tags, "Namespace XML should parse")

   local err, nsId = xml.mtFindTag('/root/ns:child')
   if err == ERR_Okay then
      local err, value = xml.mtGetAttrib(nsId, 'ns:attr')
      assert(err == ERR_Okay and value == "value", "Namespace attribute not preserved")
   end
end

-----------------------------------------------------------------------------------------------------------------------
-- Test special characters and encoding

function testSpecialCharacters()
   local xml = obj.new("xml", {
      statement = '<root attr="&lt;&gt;&amp;&quot;">&lt;special&gt; &amp; content</root>'
   })

   assert(xml.tags, "XML with escaped characters should parse")

   local rootId = xml.tags[1].id
   local err, attrValue = xml.mtGetAttrib(rootId, 'attr')
   assert(err == ERR_Okay, "Should retrieve escaped attribute")
   -- Note: Values should be unescaped after parsing
end

-----------------------------------------------------------------------------------------------------------------------
-- Test concurrent access (if supported)

function testConcurrentAccess()
   local xml = obj.new("xml", {
      statement = '<root><item>1</item><item>2</item><item>3</item></root>',
      readOnly = true  -- Readonly for safe concurrent access
   })

   -- Multiple FindTag operations should work safely
   local count1 = 0
   local err1, result1 = xml.mtFindTag('/root/item', function(XML, TagID, Attrib)
      count1 = count1 + 1
   end)

   local count2 = 0
   local err2, result2 = xml.mtFindTag('//item', function(XML, TagID, Attrib)
      count2 = count2 + 1
   end)

   assert(count1 == 3 and count2 == 3, "Concurrent access should work correctly")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test memory limits and cleanup

function testMemoryHandling()
   -- Test creating and destroying many XML objects
   for i = 1, 100 do
      local xml = obj.new("xml", {
         statement = '<root><data>' .. string.rep("x", 1000) .. '</data></root>'
      })
   end
end

-----------------------------------------------------------------------------------------------------------------------
-- Test XPath edge cases

function testXPathEdgeCases()
   local xml = obj.new("xml", {
      statement = '<root><item name="test[1]"/><item name="test@attr"/></root>'
   })

   -- Test escaping special XPath characters in attribute values
   local err, id = xml.mtFindTag('/root/item[@name="test[1]"]')
   -- This may or may not work depending on XPath implementation

   -- Test very long XPath expressions
   local longPath = '/root' .. string.rep('/item', 50)
   local err, result = xml.mtFindTag(longPath)
   assert(err == ERR_Search, "Should fail gracefully for invalid long paths")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test serialization edge cases

function testSerializationEdgeCases()
   local xml = obj.new("xml", {
      statement = '<root><empty/><cdata><![CDATA[Special <content>]]></cdata></root>'
   })

   -- Test serialization of various node types
   local err, serialized = xml.mtSerialise(0, XMF_INCLUDE_SIBLINGS)
   assert(err == ERR_Okay, "Serialization should succeed")
   assert(string.len(serialized) > 0, "Serialized string should not be empty")

   -- Test partial serialization
   local childId = xml.tags[1].children[1].id
   local err, partialSerialized = xml.mtSerialise(childId, 0)
   assert(err == ERR_Okay, "Partial serialization should succeed")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test performance with deep nesting

function testDeepNesting()
   -- Create deeply nested XML
   local parts = {}
   local depth = 100

   for i = 1, depth do
      table.insert(parts, '<level' .. i .. '>')
   end
   table.insert(parts, 'Deep content')
   for i = depth, 1, -1 do
      table.insert(parts, '</level' .. i .. '>')
   end

   local deepXML = table.concat(parts)
   local xml = obj.new("xml", { statement = deepXML })

   assert(xml.tags, "Deep nesting should parse successfully")

   -- Test deep XPath navigation
   local deepPath = '/level1'
   for i = 2, depth do
      deepPath = deepPath .. '/level' .. i
   end

   local err, deepId = xml.mtFindTag(deepPath)
   assert(err == ERR_Okay, "Deep XPath should succeed")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test attribute limits

function testAttributeLimits()
   -- Create element with many attributes
   local parts = {'<root'}
   for i = 1, 100 do
      table.insert(parts, ' attr' .. i .. '="value' .. i .. '"')
   end
   table.insert(parts, '/>')

   local manyAttrsXML = table.concat(parts)
   local xml = obj.new("xml", { statement = manyAttrsXML })

   assert(xml.tags, "Many attributes should parse successfully")

   local rootId = xml.tags[1].id
   local err, value = xml.mtGetAttrib(rootId, 'attr50')
   assert(err == ERR_Okay and value == 'value50', "Middle attribute should be accessible")
end

-----------------------------------------------------------------------------------------------------------------------

return {
   tests = {
      'testMalformedXML', 'testEmptyDocument', 'testLargeDocument', 'testInvalidParameters',
      'testReadOnlyMode', 'testNamespaceHandling', 'testSpecialCharacters', 'testConcurrentAccess',
      'testMemoryHandling', 'testXPathEdgeCases', 'testSerializationEdgeCases', 'testDeepNesting',
      'testAttributeLimits'
   }
}