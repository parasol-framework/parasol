-- Core XPath query tests

   include 'xml'

-----------------------------------------------------------------------------------------------------------------------
-- Test basic XPath navigation

function testBasicXPath()
   local xml = obj.new("xml", {
      statement = '<root><level1><level2><target>Found</target></level2></level1></root>'
   })

   -- Test absolute path
   local err, targetId = xml.mtFindTag('/root/level1/level2/target')
   assert(err == ERR_Okay, "Failed to find target with absolute path: " .. mSys.GetErrorMsg(err))

   local err, tag = xml.mtGetTag(targetId)
   assert(err == ERR_Okay, "Failed to get target tag")
   assert(tag.children[1].attribs[1].value == "Found", "Target content incorrect")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test attribute matching with [@attribute] syntax

function testAttributeMatching()
   local xml = obj.new("xml", {
      statement = '<root><item type="book" title="Guide"/><item type="magazine" title="News"/><item type="book" title="Manual"/></root>'
   })

   -- Find items with type="book"
   local bookCount = 0
   local err, index = xml.mtFindTag('/root/item[@type="book"]', function(XML, TagID, Attrib)
      bookCount = bookCount + 1
      local err, tag = xml.mtGetTag(TagID)
      assert(err == ERR_Okay, "Failed to get book tag")

      local err, typeValue = xml.mtGetAttrib(TagID, 'type')
      assert(err == ERR_Okay and typeValue == "book", "Book type attribute incorrect")
   end)

   assert(bookCount == 2, "Expected 2 books, found " .. bookCount)
end

-----------------------------------------------------------------------------------------------------------------------
-- Test attribute existence predicate [@attr] and wildcard attribute name [@*="value"]

function testAttributePredicateExistence()
   local xml = obj.new("xml", {
      statement = '<root><section title="Test" note="alpha"/><section/><section title="Other"/></root>'
   })

   -- Existence predicate
   local err, id = xml.mtFindTag('/root/section[@title]')
   assert(err == ERR_Okay, "Attribute existence predicate should find a section with title")

   -- Non-existing attribute should not match
   err, id = xml.mtFindTag('/root/section[@missing]')
   assert(err != ERR_Okay, "Missing attribute existence should not match")

   -- Wildcard attribute name matches any attribute with given value
   err, id = xml.mtFindTag('/root/section[@*="alpha"]')
   assert(err == ERR_Okay, "Wildcard attribute name should match any attribute with value")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test indexed access with [position] syntax

function testIndexedAccess()
   local xml = obj.new("xml", {
      statement = '<root><item>First</item><item>Second</item><item>Third</item></root>'
   })

   -- Test first item (1-based indexing)
   local err, firstId = xml.mtFindTag('/root/item[1]')
   assert(err == ERR_Okay, "Failed to find first item: " .. mSys.GetErrorMsg(err))

   local err, tag = xml.mtGetTag(firstId)
   assert(err == ERR_Okay, "Failed to get first tag")
   assert(tag.children[1].attribs[1].value == "First", "First item content incorrect")

   -- Test third item
   local err, thirdId = xml.mtFindTag('/root/item[3]')
   assert(err == ERR_Okay, "Failed to find third item: " .. mSys.GetErrorMsg(err))

   local err, tag = xml.mtGetTag(thirdId)
   assert(err == ERR_Okay, "Failed to get third tag")
   assert(tag.children[1].attribs[1].value == "Third", "Third item content incorrect")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test deep scanning with double-slash (//) syntax

function testDeepScanning()
   local xml = obj.new("xml", {
      statement = '<root><section><subsection><target id="1"/></subsection></section><othersection><target id="2"/></othersection></root>'
   })

   -- Find all target elements anywhere in document
   local targetCount = 0
   local foundIds = {}
   local err, index = xml.mtFindTag('//target', function(XML, TagID, Attrib)
      targetCount = targetCount + 1
      local err, idValue = xml.mtGetAttrib(TagID, 'id')
      assert(err == ERR_Okay, "Failed to get target id")
      table.insert(foundIds, idValue)
   end)

   assert(targetCount == 2, "Expected 2 targets, found " .. targetCount)
   assert(table.contains(foundIds, "1") and table.contains(foundIds, "2"), "Target IDs not found correctly")
end

-----------------------------------------------------------------------------------------------------------------------
-- Ensure deep scan mid-path currently fails gracefully: /root//target

function testDeepScanMidPath()
   local xml = obj.new("xml", {
      statement = '<root><section><subsection><target id="a"/></subsection></section><othersection><target id="b"/></othersection></root>'
   })

   local err, id = xml.mtFindTag('/root//target')
   assert(err == ERR_Okay, "/root//target failed")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test wildcard matching with * syntax

function testWildcardMatching()
   local xml = obj.new("xml", {
      statement = '<root><item1/><item2/><item3/><other/></root>'
   })

   -- Find all children of root
   local childCount = 0
   local err, index = xml.mtFindTag('/root/*', function(XML, TagID, Attrib)
      childCount = childCount + 1
   end)

   assert(childCount == 4, "Expected 4 children, found " .. childCount)
end

-----------------------------------------------------------------------------------------------------------------------
-- Test content matching (Parasol extension)

function testContentMatching()
   local xml = obj.new("xml", {
      statement = '<root><item>apple</item><item>banana</item><item>apple pie</item></root>'
   })

   -- Find items containing "apple"
   local appleCount = 0
   local err, index = xml.mtFindTag('/root/item[=apple]', function(XML, TagID, Attrib)
      appleCount = appleCount + 1
   end)

   assert(appleCount >= 1, "Expected at least 1 apple item, found " .. appleCount)

   -- Wildcard content match

   appleCount = 0
   err, index = xml.mtFindTag('/root/item[=apple*]', function(XML, TagID, Attrib)
      appleCount = appleCount + 1
   end)
   assert(appleCount == 2, "Wildcard content matching should find 2 items, found " .. appleCount)

   -- Square bracket predicates should also support content equality
   local bananaErr, bananaId = xml.mtFindTag('/root/item[=banana]')
   assert(bananaErr == ERR_Okay, "[=value] predicate should locate the banana item")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test attribute extraction with @ syntax

function testAttributeExtraction()
   local xml = obj.new("xml", {
      statement = '<root><book title="Guide" author="Smith"/></root>'
   })

   -- Extract title attribute value
   local err, bookId = xml.mtFindTag('/root/book')
   assert(err == ERR_Okay, "Should locate the book element for attribute extraction")

   local titleErr, titleValue = xml.mtGetAttrib(bookId, 'title')
   assert(titleErr == ERR_Okay and titleValue == "Guide", "Title attribute extraction failed")

   -- Extract author attribute value
   local authorErr, authorValue = xml.mtGetAttrib(bookId, 'author')
   assert(authorErr == ERR_Okay and authorValue == "Smith", "Author attribute extraction failed")

   -- Wildcard attribute name in predicate: matches any attribute value
   local err, id = xml.mtFindTag('/root/book[@*="Smith"]')
   assert(err == ERR_Okay, "Wildcard attribute name predicate should match on any attribute")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test count operations

function testCountOperations()
   local xml = obj.new("xml", {
      statement = '<root><section><item/><item/><item/></section><section><item/></section></root>'
   })

   -- Count all items
   local totalItems = tonumber(xml.getKey('count://item'))
   assert(totalItems == 4, "Expected 4 total items, got " .. totalItems)

   -- Count items in first section
   local firstSectionItems = tonumber(xml.getKey('count:/root/section[1]/item'))
   assert(firstSectionItems == 3, "Expected 3 items in first section, got " .. firstSectionItems)
end

-----------------------------------------------------------------------------------------------------------------------
-- Test exists operations

function testExistsOperations()
   local xml = obj.new("xml", {
      statement = '<root><section title="Test"><item/></section></root>'
   })

   -- Test element existence via XPath lookup
   local err, sectionId = xml.mtFindTag('/root/section')
   assert(err == ERR_Okay, "Section should exist")

   local missingErr, missingId = xml.mtFindTag('/root/missing')
   assert(missingErr != ERR_Okay, "Missing element should not exist")

   -- Test attribute existence
   local titleErr, titleValue = xml.mtGetAttrib(sectionId, 'title')
   assert(titleErr == ERR_Okay and titleValue == "Test", "Title attribute should exist")

   local missingAttrErr, missingAttrValue = xml.mtGetAttrib(sectionId, 'missing')
   assert(missingAttrErr == ERR_NotFound, "Missing attribute should not exist")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test content extraction operations

function testContentExtraction()
   local xml = obj.new("xml", {
      statement = '<root><section>Direct content <em>emphasized</em> more content</section></root>'
   })

   -- Test immediate content extraction (excludes nested tags)
   local immediateContent = xml.getKey('/root/section')
   assert(string.find(immediateContent, "Direct content"), "Immediate content not extracted")
   assert(string.find(immediateContent, "more content"), "Trailing content not extracted")

   -- Test deep content extraction
   local deepContent = xml.getKey('content:/root/section')
   assert(string.find(deepContent, "emphasized"), "Deep content not extracted")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test extract operations (XML serialization)

function testExtractOperations()
   local xml = obj.new("xml", {
      statement = '<root><section><item id="1">Content</item></section></root>'
   })

   -- Extract XML for specific element
   local extractedXML = xml.getKey('extract:/root/section/item')
   assert(string.find(extractedXML, 'id="1"'), "Extracted XML is missing attributes: " .. nz(extractedXML,'NIL'))
   assert(string.find(extractedXML, "Content"), "Extracted XML is missing content" .. nz(extractedXML,'NIL'))
end

-----------------------------------------------------------------------------------------------------------------------
-- Test complex XPath expressions

function testComplexExpressions()
   local xml = obj.new("xml", {
      statement = '<root><products><product category="electronics" price="100"/><product category="books" price="20"/><product category="electronics" price="50"/></products></root>'
   })

   -- Find electronics products
   local electronicsCount = 0
   local err, index = xml.mtFindTag('/root/products/product[@category="electronics"]', function(XML, TagID, Attrib)
      electronicsCount = electronicsCount + 1
   end)

   assert(electronicsCount == 2, "Expected 2 electronics products, found " .. electronicsCount)
end

-----------------------------------------------------------------------------------------------------------------------
-- Test namespace support (XPath 1.0 feature)

function testNamespaceSupport()
   local xml = obj.new("xml", {
      statement = '<root xmlns:book="http://books.com" xmlns:mag="http://magazines.com"><book:item title="Guide"/><mag:item title="News"/></root>'
   })

   -- Test namespace-aware matching (currently supported)
   local bookCount = 0
   local err, index = xml.mtFindTag('/root/book:item', function(XML, TagID, Attrib)
      bookCount = bookCount + 1
   end)

   if err == ERR_Okay then
      assert(bookCount >= 0, "Namespace matching should work or gracefully fail")
   end
end

-----------------------------------------------------------------------------------------------------------------------
-- Regression: prefixed node steps should resolve correctly

function testNamespacePrefixedSteps()
   local xml = obj.new("xml", {
      statement = '<root xmlns:book="http://books.com"><book:item title="Guide"/></root>'
   })

   local err, tagId = xml.mtFindTag('/root/book:item')
   assert(err == ERR_Okay, "Prefixed node steps should locate namespaced elements (bug: parser drops local name)")

   local err, title = xml.mtGetAttrib(tagId, 'title')
   assert(err == ERR_Okay and title == 'Guide', "Namespaced element should remain addressable by prefix")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test attribute wildcard matching

function testAttributeWildcards()
   local xml = obj.new("xml", {
      statement = '<root><item type="book" title="Guide"/><item type="magazine" title="News"/></root>'
   })

   -- Test wildcard in attribute values (currently supported in string-based evaluator when available)
   local err, itemId = xml.mtFindTag('/root/item[@type="bo*"]')
   if err == ERR_Okay then
      local attrErr, typeValue = xml.mtGetAttrib(itemId, 'type')
      assert(attrErr == ERR_Okay and typeValue == "book", "Wildcard attribute predicate should return the matching node")
   else
      assert(err == ERR_Search, "Wildcard attribute predicates should fail gracefully when not implemented")
   end

   -- Attribute existence without a value should be accepted
   local existsErr, existsId = xml.mtFindTag('/root/item[@title]')
   assert(existsErr == ERR_Okay, "Attribute existence predicate [@title] should succeed")

   -- Attribute name wildcards (@*) should match any attribute name using the provided pattern
   local nameWildErr, titledId = xml.mtFindTag('/root/item[@*="Gu*"]')
   if nameWildErr == ERR_Okay then
      local _, titleValue = xml.mtGetAttrib(titledId, 'title')
      assert(titleValue == "Guide", "Wildcard name predicate should still point at the correct node")
   else
      assert(nameWildErr == ERR_Search, "Attribute name wildcard should fall back to a search error when unsupported")
   end
end

-----------------------------------------------------------------------------------------------------------------------
-- Regression: Function predicates should receive node-set arguments

function testFunctionPredicateNodeSets()
   local xml = obj.new("xml", {
      statement = '<root><item/><item/><item/></root>'
   })

   local err, rootId = xml.mtFindTag('/root[count(item)=3]')
   assert(err == ERR_Okay, "count(item)=3 predicate should evaluate with node-set arguments (bug: identifiers become literals)")

   local err, result = xml.mtFindTag('/root[count(item)=2]')
   assert(err == ERR_Search, "count(item)=2 predicate should not match when the function result is false")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test XPath 1.0 functions

function testXPathFunctions()
   local xml = obj.new("xml", {
      statement = '<root><item>1</item><item>2</item><item>3</item></root>'
   })

   local err, itemId = xml.mtFindTag('/root/item[position()=2]')
   assert(err == ERR_Okay, "/root/item[position()=2] failed")

   err, itemId = xml.mtFindTag('/root/item[position()=last()]')
   assert(err == ERR_Okay, "/root/item[position()=last()] failed")

   err, itemId = xml.mtFindTag('/root/item[last()]')
   assert(err == ERR_Okay, "last() predicate should select the final item")
   local err2, lastTag = xml.mtGetTag(itemId)
   assert(err2 == ERR_Okay and lastTag.children[1].attribs[1].value == '3', "last() predicate should locate the third entry")

   err, itemId = xml.mtFindTag('/root[count(item)>2]')
   assert(err == ERR_Okay, "count(item)>2 should succeed when AST evaluation is active")
   assert(itemId != 0, "count(item)>2 should return a valid node identifier")

   local err, itemId = xml.mtFindTag('/root/item[text()="2"]')
   assert(err == ERR_Okay, 'text()="2" failed')
end

-----------------------------------------------------------------------------------------------------------------------
-- Regression: Numeric position predicates should honour requested index

function testNumericPositionPredicates()
   local xml = obj.new("xml", {
      statement = '<root><item>First</item><item>Second</item><item>Third</item></root>'
   })

   local err, secondId = xml.mtFindTag('/root/item[2]')
   assert(err == ERR_Okay, "item[2] should return the second node (bug: predicate currently hard-codes index==1)")

   local err, tag = xml.mtGetTag(secondId)
   assert(err == ERR_Okay and tag.children[1].attribs[1].value == 'Second', "item[2] should locate the 'Second' entry")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test XPath 1.0 boolean operators

function testBooleanOperators()
   local xml = obj.new("xml", {
      statement = '<root><product price="100" category="electronics"/><product price="50" category="books"/></root>'
   })

   local err, productId = xml.mtFindTag('/root/product[@price="100" and @category="electronics"]')
   assert(err == ERR_Okay, "'and' operator should locate the product with matching price and category")
   local err2, category = xml.mtGetAttrib(productId, 'category')
   assert(err2 == ERR_Okay and category == 'electronics', "'and' operator should return the electronics product")

   err, productId = xml.mtFindTag('/root/product[@category="books" or @category="electronics"]')
   assert(err == ERR_Okay, "'or' operator should locate a matching product")
   err2, category = xml.mtGetAttrib(productId, 'category')
   assert(err2 == ERR_Okay and category == 'electronics', "'or' operator should prioritise the first matching product")

   err, productId = xml.mtFindTag('/root/product[not(@category="books")]')
   assert(err == ERR_Okay, "'not()' should exclude the books category and return the electronics product")
end

-----------------------------------------------------------------------------------------------------------------------

return {
   tests = {
      'testBasicXPath', 'testAttributeMatching', 'testAttributePredicateExistence',
      'testIndexedAccess', 'testDeepScanning', 'testDeepScanMidPath',
      'testWildcardMatching', 'testContentMatching', 'testAttributeExtraction',
      'testCountOperations', 'testExistsOperations', 'testContentExtraction',
      'testExtractOperations', 'testComplexExpressions', 'testNamespaceSupport',
      'testNamespacePrefixedSteps', 'testAttributeWildcards',
      'testFunctionPredicateNodeSets', 'testXPathFunctions',
      'testNumericPositionPredicates', 'testBooleanOperators'
   },
   init = function(ScriptFolder)
      table.contains = function(table, element)
         for _, value in pairs(table) do
            if value == element then return true end
         end
         return false
      end
   end,
   cleanup = function()
   end
}
