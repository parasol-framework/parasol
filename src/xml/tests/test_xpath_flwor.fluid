-- Phase 4 FLWOR and LET stabilisation tests

   include 'xml'

-----------------------------------------------------------------------------------------------------------------------
-- Basic LET expressions should evaluate arithmetic results

function testLetSimpleArithmetic()
   local xml = obj.new("xml", { statement = '<root/>' })
   local result = tonumber(xml.getKey('let $price := 10.99 return $price * 1.1'))
   assert(result and math.abs(result - 12.089) < 0.0001,
      'Let expression should scale numeric values, got ' .. tostring(result))
end

-----------------------------------------------------------------------------------------------------------------------
-- Multiple bindings should be available inside the return clause

function testLetMultipleBindings()
   local xml = obj.new("xml", { statement = '<root/>' })
   local result = tonumber(xml.getKey('let $a := 5, $b := 10 return $a + $b'))
   assert(result and math.abs(result - 15.0) < 0.0001,
      'Let expression should expose all bound variables, got ' .. tostring(result))
end

-----------------------------------------------------------------------------------------------------------------------
-- LET expressions can combine node lookups with arithmetic

function testLetDocumentComputation()
   local xml = obj.new("xml", {
      statement = '<catalog>' ..
                  '<book id="bk-1" price="25"/>' ..
                  '<book id="bk-2" price="45"/>' ..
                  '</catalog>'
   })

   local result = tonumber(xml.getKey('let $tax := 0.08 return number(/catalog/book[@price > 20][1]/@price) * (1 + $tax)'))
   assert(result and math.abs(result - 27.0) < 0.0001,
      'Let expression should compute taxed pricing, got ' .. tostring(result))
end

-----------------------------------------------------------------------------------------------------------------------
-- Invalid LET syntax should report descriptive parser errors

function testLetSyntaxErrors()
   local xml = obj.new("xml", { statement = '<root><value/></root>' })

   local err = xml.mtFindTag('let $a return $a')
   assert(err == ERR_Syntax, 'Missing assignment should be a syntax error, got ' .. mSys.GetErrorMsg(err))
   local message = nz(xml.ErrorMsg, '')
   assert(string.find(message, "Expected ':=' in let binding", 1, true),
      'Error message should reference missing :=, got ' .. message)

   local err2 = xml.mtFindTag('let $a := return 5')
   assert(err2 == ERR_Syntax, 'Missing expression should be a syntax error, got ' .. mSys.GetErrorMsg(err2))
   local message2 = nz(xml.ErrorMsg, '')
   assert(string.find(message2, "Expected expression after ':=' in let binding", 1, true),
      'Error message should reference missing binding expression, got ' .. message2)
end

-----------------------------------------------------------------------------------------------------------------------
-- FLWOR return expressions that yield scalars should produce actionable diagnostics

function testFlworNonNodeReturnError()
   local xml = obj.new("xml", {
      statement = '<library>' ..
                  '<book id="a" genre="fiction" price="39"/>' ..
                  '<book id="b" genre="reference" price="55"/>' ..
                  '</library>'
   })

   local err = xml.mtFindTag('for $book in /library/book let $discounted := number($book/@price) * 0.9 return $discounted')
   assert(err != ERR_Okay, 'Numeric FLWOR return should be rejected')
   local message = nz(xml.errorMsg, '')
   assert(string.find(message, 'return expressions must yield node-sets', 1, true),
      'FLWOR error message should describe node-set requirement, got ' .. message)
end

-----------------------------------------------------------------------------------------------------------------------
-- Repeated FLWOR evaluations should remain stable and performant

function testFlworRepeatedEvaluationConsistency()
   local xml = obj.new("xml", {
      statement = '<library>' ..
                  '<book id="a" genre="fiction"/>' ..
                  '<book id="b" genre="reference"/>' ..
                  '<book id="c" genre="fiction"/>' ..
                  '</library>'
   })

   for iteration = 1, 25 do
      local collected = {}
      local err = xml.mtFindTag('for $book in /library/book let $genre := $book/@genre return $book[$genre = "fiction"]',
         function(XML, TagID)
            local errAttr, idValue = xml.mtGetAttrib(TagID, 'id')
            assert(errAttr == ERR_Okay,
               'Iteration ' .. iteration .. ' should resolve id attribute: ' .. mSys.GetErrorMsg(errAttr))
            table.insert(collected, idValue)
         end)

      assert(err == ERR_Okay, 'Iteration ' .. iteration .. ' should evaluate successfully: ' .. mSys.GetErrorMsg(err))
      table.sort(collected)
      assert(#collected == 2 and collected[1] == 'a' and collected[2] == 'c',
         'Iteration ' .. iteration .. ' should yield consistent fiction ids, got ' .. table.concat(collected, ','))
   end
end

-----------------------------------------------------------------------------------------------------------------------
return {
   tests = {
      'testLetSimpleArithmetic', 'testLetMultipleBindings', 'testLetDocumentComputation',
      'testLetSyntaxErrors', 'testFlworNonNodeReturnError', 'testFlworRepeatedEvaluationConsistency'
   }
}
