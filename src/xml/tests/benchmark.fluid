-- XML/XPath Performance Benchmark Suite
-- Designed to measure and compare the performance of XPath queries on large XML documents
--
-- Features:
-- * Warmup phase to eliminate cold-start effects
-- * Triple iteration counts for more reliable measurements
-- * Progressive output showing test progress and individual results

include 'xml'

local glXML = nil
local benchmarkResults = {}
local fastestResults = {}
local totalTests = 0
local passedTests = 0

local glSelf = obj.find('self')
local glPath = glSelf.workingPath

-----------------------------------------------------------------------------------------------------------------------
-- Utility functions for benchmarking

function performWarmup(func, warmupIterations)
   -- Warmup phase to eliminate cold-start effects and optimize caches
   warmupIterations = warmupIterations or 50
   for i = 1, warmupIterations do
      func()
   end
end

function measureTime(func, iterations)
   local bestTime = math.huge
   local totalMicroseconds = 0

   for i = 1, iterations do
      local startTime = mSys.PreciseTime()
      func()
      local endTime = mSys.PreciseTime()
      local iterTime = endTime - startTime
      totalMicroseconds = totalMicroseconds + iterTime
      if iterTime < bestTime then
         bestTime = iterTime
      end
   end

   local avgMicroseconds = totalMicroseconds / iterations
   -- Convert to milliseconds for display
   return avgMicroseconds, totalMicroseconds, bestTime
end

function benchmarkTest(testName, testFunc, iterations)
   iterations = iterations or 300  -- Tripled from 100 to 300

   print(string.format('  Running: %-30s (%d iterations)', testName, iterations))

   local success, errorMsg = pcall(function()
      -- Perform warmup to eliminate cold-start effects
      local warmupIterations = math.max(10, iterations / 10)
      performWarmup(testFunc, warmupIterations)

      -- Actual benchmark measurement
      local avgTime, totalTime, bestTime = measureTime(testFunc, iterations)
      benchmarkResults[testName] = { avgTime = avgTime, totalTime = totalTime, bestTime = bestTime, iterations = iterations }
      fastestResults[testName] = bestTime
      passedTests = passedTests + 1
   end)

   if not success then
      print('    ERROR: ' .. errorMsg)
      benchmarkResults[testName] = -1
      fastestResults[testName] = -1
   else
      local result = benchmarkResults[testName]
   end

   totalTests = totalTests + 1
end

-----------------------------------------------------------------------------------------------------------------------
-- Basic XPath Navigation Benchmarks

function benchmarkBasicNavigation()
   local err, id = glXML.mtFindTag('/catalog/categories/category[1]/products/product[1]')
   assert(err == ERR_Okay, "Basic navigation failed")
end

function benchmarkAttributeMatching()
   local err, id = glXML.mtFindTag('/catalog/categories/category[@name="electronics"]')
   assert(err == ERR_Okay, "Attribute matching failed")
end

function benchmarkDeepScanning()
   local count = 0
   local err, id = glXML.mtFindTag('//product[@price>500]', function(XML, TagID, Attrib)
      count = count + 1
   end)
   assert(err == ERR_Okay, "Deep scanning failed")
end

function benchmarkWildcardMatching()
   local count = 0
   local err, id = glXML.mtFindTag('/catalog/categories/*', function(XML, TagID, Attrib)
      count = count + 1
   end)
   assert(err == ERR_Okay, "Wildcard matching failed")
end

-----------------------------------------------------------------------------------------------------------------------
-- Complex Predicate Benchmarks

function benchmarkNumericComparisons()
   local err, id = glXML.mtFindTag('//product[@price>=100 and @price<=1000]')
   assert(err == ERR_Okay, "Numeric comparisons failed")
end

function benchmarkFunctionPredicates()
   local err, id = glXML.mtFindTag('/catalog/categories/category[count(products/product)>10]')
   assert(err == ERR_Okay, "Function predicates failed")
end

function benchmarkStringFunctions()
   local err, id = glXML.mtFindTag('//product[contains(@name,"Pro")]')
   assert(err == ERR_Okay, "String function failed")
end

function benchmarkPositionFunctions()
   local err, id = glXML.mtFindTag('//category/products/product[position()=last()]')
   assert(err == ERR_Okay, "Position function failed")
end

-----------------------------------------------------------------------------------------------------------------------
-- Advanced XPath Features Benchmarks

function benchmarkAxesTraversal()
   local err, id = glXML.mtFindTag('//product[@id="prod-1"]/ancestor::category[@name]')
   assert(err == ERR_Okay, "Axes traversal failed")
end

function benchmarkUnionOperations()
   local count = 0
   local err, id = glXML.mtFindTag('//category[@name="electronics"] | //category[@name="clothing"]', function(XML, TagID, Attrib)
      count = count + 1
   end)
   assert(err == ERR_Okay, "Union operations failed")
end

function benchmarkComplexPredicates()
   local err, id = glXML.mtFindTag('//product[@price>100 and @instock="true" and contains(@name,"Ultra")]')
   assert(err == ERR_Okay, "Complex predicates failed, got " .. mSys.GetErrorMsg(err))
end

function benchmarkNestedFunctions()
   local err, id = glXML.mtFindTag('//category[string-length(@name)>5 and count(products/product)>=3]')
   assert(err == ERR_Okay, "Nested functions failed")
end

-----------------------------------------------------------------------------------------------------------------------
-- Large Document Scanning Benchmarks

function benchmarkLargeDeepScan()
   local count = 0
   local err, id = glXML.mtFindTag('//product', function(XML, TagID, Attrib)
      count = count + 1
   end)
   assert(err == ERR_Okay, "Large deep scan failed")
end

function benchmarkAttributeScanning()
   local count = 0
   local err, id = glXML.mtFindTag('//@price', function(XML, TagID, Attrib)
      count = count + 1
   end)
   assert(err == ERR_Okay, "Attribute scanning failed")
end

function benchmarkConditionalCounting()
   local totalProducts = tonumber(glXML.getKey('count://product'))
   assert(totalProducts > 0, "Conditional counting failed")
end

-----------------------------------------------------------------------------------------------------------------------
-- XPath Function Library Benchmarks

function benchmarkStringManipulation()
   local err, id = glXML.mtFindTag('//product[starts-with(@name,"Ultra") and substring(@name,1,5)="Ultra"]')
   assert(err == ERR_Okay, "String manipulation failed")
end

function benchmarkNumericFunctions()
   local err, id = glXML.mtFindTag('//product[floor(@price div 100) = 12]')
   assert(err == ERR_Okay, "Numeric functions failed, got " .. mSys.GetErrorMsg(err))
end

function benchmarkBooleanLogic()
   local err, id = glXML.mtFindTag('//product[@instock="true" and not(@discontinued="true")]')
   assert(err == ERR_Okay, "Boolean logic failed")
end

function benchmarkComplexExpressions()
   local err, id = glXML.mtFindTag('//product[@price * 0.5 > 70 and position() mod 2 = 0]')
   assert(err == ERR_Okay, "Complex expressions failed, got " .. mSys.GetErrorMsg(err))
end

-----------------------------------------------------------------------------------------------------------------------
-- Content and Structure Benchmarks

function benchmarkContentExtraction()
   local content = glXML.getKey('content://product[@id="prod-1"]')
   assert(content, "Content extraction failed")
end

function benchmarkTextNodeAccess()
   local err, id = glXML.mtFindTag('//product/description[text()="High-performance device"]')
   assert(err == ERR_Okay, "Text node access failed")
end

function benchmarkMixedContentTraversal()
   local count = 0
   local err, id = glXML.mtFindTag('//category[products/product and @name]', function(XML, TagID, Attrib)
      count = count + 1
   end)
   assert(err == ERR_Okay, "Mixed content traversal failed")
end

-----------------------------------------------------------------------------------------------------------------------
-- Performance Comparison Tests

function benchmarkSimpleVsComplexPaths()
   -- Simple path
   local err1, id1 = glXML.mtFindTag('/catalog/categories/category[1]')
   assert(err1 == ERR_Okay, "Simple path failed")

   -- Complex equivalent path
   local err2, id2 = glXML.mtFindTag('/catalog/descendant::categories/child::category[position()=1]')
   assert(err2 == ERR_Okay, "Complex path failed")
end

function benchmarkIndexedVsPredicateAccess()
   -- Indexed access
   local err1, id1 = glXML.mtFindTag('//product[5]')
   assert(err1 == ERR_Okay, "Indexed access failed")

   -- Predicate equivalent
   local err2, id2 = glXML.mtFindTag('//product[position()=5]')
   assert(err2 == ERR_Okay, "Predicate access failed")
end

-----------------------------------------------------------------------------------------------------------------------
-- Initialisation and main benchmark runner

   print('=== XML/XPath Performance Benchmark Suite ===')
   print('')

   print('Loading benchmark data...')

   local dataFile = glPath .. 'benchmark_data.xml'

   glXML = obj.new("xml", { path = dataFile })

   local err = processing.task().set('Priority', 20)  -- Highest priority

   print('Benchmark data loaded successfully')
   print('Document root: ' .. nz(glXML.getKey('/catalog/@name'), 'Unknown'))
   print('Total products: ' .. nz(glXML.getKey('count://product'), '0'))
   print('')

   print('=== 1. Basic Navigation Tests ===')
   benchmarkTest('Basic Navigation', benchmarkBasicNavigation, 3000)
   benchmarkTest('Attribute Matching', benchmarkAttributeMatching, 3000)
   benchmarkTest('Wildcard Matching', benchmarkWildcardMatching, 1500)

   print('')
   print('=== 2. Deep Scanning Tests ===')
   benchmarkTest('Deep Scanning', benchmarkDeepScanning, 300)
   benchmarkTest('Large Deep Scan', benchmarkLargeDeepScan, 150)
   benchmarkTest('Attribute Scanning', benchmarkAttributeScanning, 300)

   print('')
   print('=== 3. Predicate and Function Tests ===')
   benchmarkTest('Numeric Comparisons', benchmarkNumericComparisons, 1500)
   benchmarkTest('Function Predicates', benchmarkFunctionPredicates, 600)
   benchmarkTest('String Functions', benchmarkStringFunctions, 900)
   benchmarkTest('Position Functions', benchmarkPositionFunctions, 900)

   print('')
   print('=== 4. Advanced XPath Features ===')
   benchmarkTest('Axes Traversal', benchmarkAxesTraversal, 600)
   benchmarkTest('Union Operations', benchmarkUnionOperations, 300)
   benchmarkTest('Complex Predicates', benchmarkComplexPredicates, 600)
   benchmarkTest('Nested Functions', benchmarkNestedFunctions, 600)

   print('')
   print('=== 5. Function Library Tests ===')
   benchmarkTest('String Manipulation', benchmarkStringManipulation, 900)
   benchmarkTest('Numeric Functions', benchmarkNumericFunctions, 900)
   benchmarkTest('Boolean Logic', benchmarkBooleanLogic, 1200)
   benchmarkTest('Complex Expressions', benchmarkComplexExpressions, 600)

   print('')
   print('=== 6. Content Access Tests ===')
   benchmarkTest('Content Extraction', benchmarkContentExtraction, 1500)
   benchmarkTest('Text Node Access', benchmarkTextNodeAccess, 900)
   benchmarkTest('Mixed Content Traversal', benchmarkMixedContentTraversal, 600)
   benchmarkTest('Conditional Counting', benchmarkConditionalCounting, 900)

   print('')
   print('=== 7. Performance Comparison Tests ===')
   benchmarkTest('Simple vs Complex Paths', benchmarkSimpleVsComplexPaths, 1500)
   benchmarkTest('Indexed vs Predicate Access', benchmarkIndexedVsPredicateAccess, 1500)

   -- Print summary
   print('')
   print('=== Benchmark Results Summary ===')
   print('Tests completed: ' .. passedTests .. '/' .. totalTests)
   print('')

   -- Sort results by name
   local sortedResults = {}
   for testName, result in pairs(benchmarkResults) do
      if result ~= -1 then
         table.insert(sortedResults, {
            name = testName,
            avgTime = result.avgTime,
            totalTime = result.totalTime,
            bestTime = result.bestTime,
            iterations = result.iterations
         })
      end
   end

   table.sort(sortedResults, function(a, b) return a.name < b.name end)

   local grandTotalTime = 0
   local fastestGrandTotal = 0
   for i, result in ipairs(sortedResults) do
      print(string.format('%2d. %-25s %dus/iter (%dms total, %dus fastest, %d iters)',
         i, result.name, result.avgTime, result.totalTime/1000, result.bestTime, result.iterations))
      grandTotalTime = grandTotalTime + result.totalTime
      fastestGrandTotal = fastestGrandTotal + result.bestTime
   end

   print('')
   local grandTotalSeconds = grandTotalTime / 1000000.0
   local fastestGrandTotalUS = fastestGrandTotal
   local avgPerTest = grandTotalTime / #sortedResults
   local fastestAvgPerTest = fastestGrandTotal / #sortedResults

   print(string.format('Grand total benchmark time: %8.3fs (average per test: %6.3fms)',
      grandTotalSeconds, avgPerTest))
   print(string.format('Fastest-only grand total:   %dus (average fastest: %dus)',
      fastestGrandTotalUS, fastestAvgPerTest))

   print('')
   print('Failed tests:')
   local failedCount = 0
   for testName, result in pairs(benchmarkResults) do
      if result == -1 then
         print('  - ' .. testName)
         failedCount = failedCount + 1
      end
   end

   if failedCount == 0 then
      print('  None - all tests passed!')
   end

   print('')
   print('Benchmark completed.')
