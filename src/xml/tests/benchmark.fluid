-- XML/XPath Performance Benchmark Suite
-- Designed to measure and compare the performance of XPath queries on large XML documents
--
-- Features:
-- * Warmup phase to eliminate cold-start effects
-- * Triple iteration counts for more reliable measurements
-- * Progressive output showing test progress and individual results

   include 'xml'
   require 'common'

   local glXML = nil
   local benchmarkResults = {}
   local fastestResults = {}
   local totalTests = 0
   local passedTests = 0

   local glSelf = obj.find('self')
   local glPath = glSelf.workingPath

-----------------------------------------------------------------------------------------------------------------------
-- Utility functions for benchmarking

function performWarmup(func, warmupIterations)
   -- Warmup phase to eliminate cold-start effects and optimize caches
   warmupIterations = warmupIterations or 50
   for i = 1, warmupIterations do
      func()
   end
end

function measureTime(func, iterations)
   local bestTime = math.huge
   local totalMicroseconds = 0

   for i = 1, iterations do
      local startTime = mSys.PreciseTime()
      func()
      local endTime = mSys.PreciseTime()
      local iterTime = endTime - startTime
      totalMicroseconds = totalMicroseconds + iterTime
      if iterTime < bestTime then
         bestTime = iterTime
      end
   end

   local avgMicroseconds = totalMicroseconds / iterations
   -- Convert to milliseconds for display
   return avgMicroseconds, totalMicroseconds, bestTime
end

function benchmarkTest(testName, testFunc, iterations)
   iterations = iterations or 300  -- Tripled from 100 to 300

   print(string.format('  Running: %-30s (%d iterations)', testName, iterations))

   local success, errorMsg = pcall(function()
      -- Perform warmup to eliminate cold-start effects
      local warmupIterations = math.max(10, iterations / 10)
      performWarmup(testFunc, warmupIterations)

      -- Actual benchmark measurement
      local avgTime, totalTime, bestTime = measureTime(testFunc, iterations)
      benchmarkResults[testName] = { avgTime = avgTime, totalTime = totalTime, bestTime = bestTime, iterations = iterations }
      fastestResults[testName] = bestTime
      passedTests = passedTests + 1
   end)

   if not success then
      print('    ERROR: ' .. errorMsg)
      benchmarkResults[testName] = -1
      fastestResults[testName] = -1
   else
      local result = benchmarkResults[testName]
   end

   totalTests = totalTests + 1
end

-----------------------------------------------------------------------------------------------------------------------
-- Basic XPath Navigation Benchmarks

function benchmarkBasicNavigation()
   local err, id = glXML.mtSearch('/catalog/categories/category[1]/products/product[1]')
   assert(err == ERR_Okay, "Basic navigation failed")
end

function benchmarkAttributeMatching()
   local err, id = glXML.mtSearch('/catalog/categories/category[@name="electronics"]')
   assert(err == ERR_Okay, "Attribute matching failed")
end

function benchmarkDeepScanning()
   local count = 0
   local err, id = glXML.mtSearch('//product[@price>500]', function(XML, TagID, Attrib)
      count = count + 1
   end)
   assert(err == ERR_Okay, "Deep scanning failed")
end

function benchmarkWildcardMatching()
   local count = 0
   local err, id = glXML.mtSearch('/catalog/categories/*', function(XML, TagID, Attrib)
      count = count + 1
   end)
   assert(err == ERR_Okay, "Wildcard matching failed")
end

-----------------------------------------------------------------------------------------------------------------------
-- Complex Predicate Benchmarks

function benchmarkNumericComparisons()
   local err, id = glXML.mtSearch('//product[@price>=100 and @price<=1000]')
   assert(err == ERR_Okay, "Numeric comparisons failed")
end

function benchmarkFunctionPredicates()
   local err, id = glXML.mtSearch('/catalog/categories/category[count(products/product)>10]')
   assert(err == ERR_Okay, "Function predicates failed")
end

function benchmarkStringFunctions()
   local err, id = glXML.mtSearch('//product[contains(@name,"Pro")]')
   assert(err == ERR_Okay, "String function failed")
end

function benchmarkPositionFunctions()
   local err, id = glXML.mtSearch('//category/products/product[position()=last()]')
   assert(err == ERR_Okay, "Position function failed")
end

-----------------------------------------------------------------------------------------------------------------------
-- Advanced XPath Features Benchmarks

function benchmarkAxesTraversal()
   local err, id = glXML.mtSearch('//product[@id="prod-1"]/ancestor::category[@name]')
   assert(err == ERR_Okay, "Axes traversal failed")
end

function benchmarkUnionOperations()
   local count = 0
   local err, id = glXML.mtSearch('//category[@name="electronics"] | //category[@name="clothing"]', function(XML, TagID, Attrib)
      count = count + 1
   end)
   assert(err == ERR_Okay, "Union operations failed")
end

function benchmarkComplexPredicates()
   local err, id = glXML.mtSearch('//product[@price>100 and @instock="true" and contains(@name,"Ultra")]')
   assert(err == ERR_Okay, "Complex predicates failed, got " .. mSys.GetErrorMsg(err))
end

function benchmarkNestedFunctions()
   local err, id = glXML.mtSearch('//category[string-length(@name)>5 and count(products/product)>=3]')
   assert(err == ERR_Okay, "Nested functions failed")
end

-----------------------------------------------------------------------------------------------------------------------
-- Large Document Scanning Benchmarks

function benchmarkLargeDeepScan()
   local count = 0
   local err, id = glXML.mtSearch('//product', function(XML, TagID, Attrib)
      count = count + 1
   end)
   assert(err == ERR_Okay, "Large deep scan failed")
end

function benchmarkAttributeScanning()
   local count = 0
   local err, id = glXML.mtSearch('//@price', function(XML, TagID, Attrib)
      count = count + 1
   end)
   assert(err == ERR_Okay, "Attribute scanning failed")
end

function benchmarkConditionalCounting()
   local err, num = glXML.mtEvaluate('count(//product)')
   local totalProducts = tonumber(num)
   assert(totalProducts > 0, "Conditional counting failed")
end

-----------------------------------------------------------------------------------------------------------------------
-- XPath Function Library Benchmarks

function benchmarkStringManipulation()
   local err, id = glXML.mtSearch('//product[starts-with(@name,"Ultra") and substring(@name,1,5)="Ultra"]')
   assert(err == ERR_Okay, "String manipulation failed")
end

function benchmarkNumericFunctions()
   local err, id = glXML.mtSearch('//product[floor(@price div 100) = 12]')
   assert(err == ERR_Okay, "Numeric functions failed, got " .. mSys.GetErrorMsg(err))
end

function benchmarkBooleanLogic()
   local err, id = glXML.mtSearch('//product[@instock="true" and not(@discontinued="true")]')
   assert(err == ERR_Okay, "Boolean logic failed")
end

function benchmarkComplexExpressions()
   local err, id = glXML.mtSearch('//product[@price * 0.5 > 70 and position() mod 2 = 0]')
   assert(err == ERR_Okay, "Complex expressions failed, got " .. mSys.GetErrorMsg(err))
end

-----------------------------------------------------------------------------------------------------------------------
-- Content and Structure Benchmarks

function benchmarkContentExtraction()
   local content = glXML.mtEvaluate('string(//product[@id="prod-1"])')
   assert(content, "Content extraction failed")
end

function benchmarkTextNodeAccess()
   local err, id = glXML.mtSearch('//product/description[text()="High-performance device"]')
   assert(err == ERR_Okay, "Text node access failed")
end

function benchmarkMixedContentTraversal()
   local count = 0
   local err, id = glXML.mtSearch('//category[products/product and @name]', function(XML, TagID, Attrib)
      count = count + 1
   end)
   assert(err == ERR_Okay, "Mixed content traversal failed")
end

-----------------------------------------------------------------------------------------------------------------------
-- Performance Comparison Tests

function benchmarkSimpleVsComplexPaths()
   -- Simple path
   local err1, id1 = glXML.mtSearch('/catalog/categories/category[1]')
   assert(err1 == ERR_Okay, "Simple path failed")

   -- Complex equivalent path
   local err2, id2 = glXML.mtSearch('/catalog/descendant::categories/child::category[position()=1]')
   assert(err2 == ERR_Okay, "Complex path failed")
end

function benchmarkIndexedVsPredicateAccess()
   -- Indexed access
   local err1, id1 = glXML.mtSearch('//product[5]')
   assert(err1 == ERR_Okay, "Indexed access failed")

   -- Predicate equivalent
   local err2, id2 = glXML.mtSearch('//product[position()=5]')
   assert(err2 == ERR_Okay, "Predicate access failed")
end

-----------------------------------------------------------------------------------------------------------------------

function benchmarkFlworSimpleFor()
   local err, val = glXML.mtEvaluate([[for $p in //product return $p/@id]])
   assert(err == ERR_Okay, 'FLWOR simple for failed')
end

function benchmarkFlworOrderBy()
   local err, val = glXML.mtEvaluate([[for $p in //product order by number($p/@price) return $p]])
   assert(err == ERR_Okay, 'FLWOR order by failed')
end

function benchmarkFlworGroupBy()
   local err, val = glXML.mtEvaluate([[for $p in //category/products/product group by $c := ../@name return $c]])
   assert(err == ERR_Okay, 'FLWOR group by failed')
end

-----------------------------------------------------------------------------------------------------------------------

function benchmarkPrologManyFunctions()
   local prolog = [[
      declare function local:f0() { 0 };
      declare function local:f1() { 1 };
      declare function local:f2() { 2 };
      declare function local:f3() { 3 };
      declare function local:f4() { 4 };
      declare function local:f5() { 5 };
      declare function local:f6() { 6 };
      declare function local:f7() { 7 };
      declare function local:f8() { 8 };
      declare function local:f9() { 9 };
   ]]
   local err, val = glXML.mtEvaluate(prolog .. 'local:f7()')
   assert(err == ERR_Okay, 'Prolog many functions failed')
end

function benchmarkPrologArityLookup()
   local prolog = [[
      declare function local:sum($a as xs:integer) as xs:integer { $a };
      declare function local:sum($a as xs:integer, $b as xs:integer) as xs:integer { $a + $b };
      declare function local:sum($a as xs:integer, $b as xs:integer, $c as xs:integer) as xs:integer { $a + $b + $c };
   ]]
   local err, val = glXML.mtEvaluate(prolog .. 'local:sum(1,2,3)')
   assert(err == ERR_Okay, 'Prolog arity lookup failed')
end

function benchmarkPrologQNameNormalization()
   local prolog = [[
      declare default function namespace "http://example.com/test";
      declare function local:noop() { () };
   ]]
   local err, val = glXML.mtEvaluate(prolog .. 'local:noop()')
   assert(err == ERR_Okay, 'Prolog QName normalization failed')
end

-----------------------------------------------------------------------------------------------------------------------

function benchmarkTokenLongArithmetic()
   local expr = '('
   for i = 1, 200 do
      if i > 1 then expr = expr .. ' + ' end
      expr = expr .. tostring(i)
   end
   expr = expr .. ')'
   local err, val = glXML.mtEvaluate(expr)
   assert(err == ERR_Okay, 'Token long arithmetic failed')
end

function benchmarkTokenNestedFunctions()
   local expr = 'upper-case(lower-case(translate("TheQuickBrownFoxJumpsOverTheLazyDog", "aeiou", "12345")))'
   local err, val = glXML.mtEvaluate(expr)
   assert(err == ERR_Okay, 'Token nested functions failed')
end

function benchmarkTokenLongPath()
   local parts = {}
   for i = 1, 60 do table.insert(parts, 'catalog') end
   local path = '/' .. table.concat(parts, '/')
   local err, val = glXML.mtEvaluate(path)
   assert(err == ERR_Okay, 'Token long path failed')
end

-----------------------------------------------------------------------------------------------------------------------

function benchmarkAxisDescendantDeep()
   local err, id = glXML.mtSearch('descendant-or-self::node()')
   assert(err == ERR_Okay, 'Axis descendant-or-self failed')
end

function benchmarkAxisFollowing()
   local err, id = glXML.mtSearch('/catalog/categories/category[1]/following::node()')
   assert(err == ERR_Okay, 'Axis following failed')
end

function benchmarkAxisPreceding()
   local err, id = glXML.mtSearch('/catalog/categories/category[last()]/preceding::node()')
   assert(err == ERR_Okay, 'Axis preceding failed')
end

-----------------------------------------------------------------------------------------------------------------------

local glContent

function benchmarkParsing()
   if not glContent then
      glContent = file.readAll(glPath .. 'benchmark_data.xml')
   end
   glXML.statement = glContent
end

-----------------------------------------------------------------------------------------------------------------------
-- Initialisation and main benchmark runner

   print('=== XML/XPath Performance Benchmark Suite ===')
   print('')

   print('Loading benchmark data...')

   local dataFile = glPath .. 'benchmark_data.xml'

   glXML = obj.new("xml", { path = dataFile })
   glQuery = obj.new('xquery', { })

   local err = processing.task().set('Priority', 20)  -- Highest priority

   print('Benchmark data loaded successfully')
   local err, cat_name = glXML.mtEvaluate('/catalog/@name')
   local err, product_count = glXML.mtEvaluate('count(//product)')
   print('Document root: ' .. nz(cat_name, 'Unknown'))
   print('Total products: ' .. nz(product_count, '0'))
   print('')

   print('=== 1. Basic Navigation Tests ===')
   benchmarkTest('Basic Navigation', benchmarkBasicNavigation, 3000)
   benchmarkTest('Attribute Matching', benchmarkAttributeMatching, 3000)
   benchmarkTest('Wildcard Matching', benchmarkWildcardMatching, 1500)

   print('')
   print('=== 2. Deep Scanning Tests ===')
   benchmarkTest('Deep Scanning', benchmarkDeepScanning, 300)
   benchmarkTest('Large Deep Scan', benchmarkLargeDeepScan, 150)
   benchmarkTest('Attribute Scanning', benchmarkAttributeScanning, 300)

   print('')
   print('=== 3. Predicate and Function Tests ===')
   benchmarkTest('Numeric Comparisons', benchmarkNumericComparisons, 1500)
   benchmarkTest('Function Predicates', benchmarkFunctionPredicates, 600)
   benchmarkTest('String Functions', benchmarkStringFunctions, 900)
   benchmarkTest('Position Functions', benchmarkPositionFunctions, 900)

   print('')
   print('=== 4. Advanced XPath Features ===')
   benchmarkTest('Axes Traversal', benchmarkAxesTraversal, 600)
   benchmarkTest('Union Operations', benchmarkUnionOperations, 300)
   benchmarkTest('Complex Predicates', benchmarkComplexPredicates, 600)
   benchmarkTest('Nested Functions', benchmarkNestedFunctions, 600)

   print('')
   print('=== 5. Function Library Tests ===')
   benchmarkTest('String Manipulation', benchmarkStringManipulation, 900)
   benchmarkTest('Numeric Functions', benchmarkNumericFunctions, 900)
   benchmarkTest('Boolean Logic', benchmarkBooleanLogic, 1200)
   benchmarkTest('Complex Expressions', benchmarkComplexExpressions, 600)

   print('')
   print('=== 6. Content Access Tests ===')
   benchmarkTest('Content Extraction', benchmarkContentExtraction, 1500)
   benchmarkTest('Text Node Access', benchmarkTextNodeAccess, 900)
   benchmarkTest('Mixed Content Traversal', benchmarkMixedContentTraversal, 600)
   benchmarkTest('Conditional Counting', benchmarkConditionalCounting, 900)

   print('')
   print('=== 7. Performance Comparison Tests ===')
   benchmarkTest('Simple vs Complex Paths', benchmarkSimpleVsComplexPaths, 1500)
   benchmarkTest('Indexed vs Predicate Access', benchmarkIndexedVsPredicateAccess, 1500)

   print('')
   print('=== 8. Parsing Tests ===')
   benchmarkTest('Parse XML File', benchmarkParsing, 600)

   print('')
   print('=== 9. XQuery FLWOR Benchmarks ===')

   benchmarkTest('FLWOR Simple For', benchmarkFlworSimpleFor, 4000)
   benchmarkTest('FLWOR Order By', benchmarkFlworOrderBy, 2000)
   benchmarkTest('FLWOR Group By', benchmarkFlworGroupBy, 2000)

   print('')
   print('=== 10. Prolog / Function Lookup Benchmarks ===')

   benchmarkTest('Prolog Many Functions', benchmarkPrologManyFunctions, 1400)
   benchmarkTest('Prolog Arity Lookup', benchmarkPrologArityLookup, 1600)
   benchmarkTest('Prolog QName Normalise', benchmarkPrologQNameNormalization, 1600)

   print('')
   print('=== 11. Tokeniser / Parse Benchmarks ===')

   benchmarkTest('Token Long Arithmetic', benchmarkTokenLongArithmetic, 2000)
   benchmarkTest('Token Nested Functions', benchmarkTokenNestedFunctions, 6000)
   benchmarkTest('Token Long Path', benchmarkTokenLongPath, 2000)

   print('')
   print('=== 12. Axis Stress Tests ===')

   benchmarkTest('Axis Descendant Deep', benchmarkAxisDescendantDeep, 2000)
   benchmarkTest('Axis Following', benchmarkAxisFollowing, 2000)
   benchmarkTest('Axis Preceding', benchmarkAxisPreceding, 2000)

   -- Print summary
   print('')
   print('=== Benchmark Results Summary ===')
   print('Tests completed: ' .. passedTests .. '/' .. totalTests)
   print('')

   -- Sort results by name
   local sortedResults = {}
   for testName, result in pairs(benchmarkResults) do
      if result != -1 then
         table.insert(sortedResults, {
            name = testName,
            avgTime = result.avgTime,
            totalTime = result.totalTime,
            bestTime = result.bestTime,
            iterations = result.iterations
         })
      end
   end

   table.sort(sortedResults, function(a, b) return a.name < b.name end)

   local grandTotalTime = 0
   local fastestGrandTotal = 0
   for i, result in ipairs(sortedResults) do
      print(string.format('%2d. %-25s %dus/iter (%dms total, %dus fastest, %d iters)',
         i, result.name, result.avgTime, result.totalTime/1000, result.bestTime, result.iterations))
      grandTotalTime = grandTotalTime + result.totalTime
      fastestGrandTotal = fastestGrandTotal + result.bestTime
   end

   print('')
   local grandTotalSeconds = grandTotalTime / 1000000.0
   local fastestGrandTotalUS = fastestGrandTotal
   local avgPerTest = grandTotalTime / #sortedResults
   local fastestAvgPerTest = fastestGrandTotal / #sortedResults

   print(string.format('Grand total benchmark time: %8.3fs (average per test: %6.3fms)', grandTotalSeconds, avgPerTest))
   print(string.format('Fastest-only grand total:   %dus (average fastest: %dus)', fastestGrandTotalUS, fastestAvgPerTest))

   print('')
   print('Failed tests:')
   local failedCount = 0
   for testName, result in pairs(benchmarkResults) do
      if result == -1 then
         print('  - ' .. testName)
         failedCount = failedCount + 1
      end
   end

   if failedCount == 0 then
      print('  None - all tests passed!')
   end

   print('')
   print('Benchmark completed.')
