-- XML/XPath Performance Benchmark Suite
-- Designed to measure and compare the performance of XPath queries on large XML documents
--
-- Features:
-- * Warmup phase to eliminate cold-start effects
-- * Triple iteration counts for more reliable measurements
-- * Progressive output showing test progress and individual results

   include 'xml'
   require 'common'

   local glXML = nil
   local glXQuery = obj.new('xquery', { })
   local benchmarkResults = {}
   local fastestResults = {}
   local totalTests = 0
   local passedTests = 0

   local glSelf = obj.find('self')
   local glPath = glSelf.workingPath

-----------------------------------------------------------------------------------------------------------------------
-- Utility functions for benchmarking

function performWarmup(func, warmupIterations)
   -- Warmup phase to eliminate cold-start effects and optimize caches
   warmupIterations = warmupIterations or 50
   for i = 1, warmupIterations do
      func()
   end
end

function measureTime(func, iterations)
   local bestTime = math.huge
   local totalMicroseconds = 0

   for i = 1, iterations do
      local startTime = mSys.PreciseTime()
      func()
      local endTime = mSys.PreciseTime()
      local iterTime = endTime - startTime
      totalMicroseconds = totalMicroseconds + iterTime
      if iterTime < bestTime then
         bestTime = iterTime
      end
   end

   local avgMicroseconds = totalMicroseconds / iterations
   -- Convert to milliseconds for display
   return avgMicroseconds, totalMicroseconds, bestTime
end

function benchmarkTest(testName, testFunc, iterations)
   iterations = iterations or 300  -- Tripled from 100 to 300

   print(string.format('  Running: %-30s (%d iterations)', testName, iterations))

   local success, errorMsg = pcall(function()
      -- Perform warmup to eliminate cold-start effects
      local warmupIterations = math.max(10, iterations / 10)
      performWarmup(testFunc, warmupIterations)

      -- Actual benchmark measurement
      local avgTime, totalTime, bestTime = measureTime(testFunc, iterations)
      benchmarkResults[testName] = { avgTime = avgTime, totalTime = totalTime, bestTime = bestTime, iterations = iterations, heapAllocations = glXQuery.heapAllocations }
      fastestResults[testName] = bestTime
      passedTests = passedTests + 1
   end)

   if not success then
      print('    ERROR: ' .. errorMsg)
      benchmarkResults[testName] = -1
      fastestResults[testName] = -1
   else
      local result = benchmarkResults[testName]
   end

   totalTests = totalTests + 1
end

-----------------------------------------------------------------------------------------------------------------------
-- Basic XPath Navigation Benchmarks

function benchmarkBasicNavigation()
   local err, id = glXML.mtSearch('/catalog/categories/category[1]/products/product[1]')
   assert(err == ERR_Okay, "Basic navigation failed")
end

function benchmarkAttributeMatching()
   local err, id = glXML.mtSearch('/catalog/categories/category[@name="electronics"]')
   assert(err == ERR_Okay, "Attribute matching failed")
end

function benchmarkDeepScanning()
   local count = 0
   local err, id = glXML.mtSearch('//product[@price>500]', function(XML, TagID, Attrib)
      count = count + 1
   end)
   assert(err == ERR_Okay, "Deep scanning failed")
end

function benchmarkWildcardMatching()
   local count = 0
   local err, id = glXML.mtSearch('/catalog/categories/*', function(XML, TagID, Attrib)
      count = count + 1
   end)
   assert(err == ERR_Okay, "Wildcard matching failed")
end

-----------------------------------------------------------------------------------------------------------------------
-- Complex Predicate Benchmarks

function benchmarkNumericComparisons()
   local err, id = glXML.mtSearch('//product[@price>=100 and @price<=1000]')
   assert(err == ERR_Okay, "Numeric comparisons failed")
end

function benchmarkFunctionPredicates()
   local err, id = glXML.mtSearch('/catalog/categories/category[count(products/product)>10]')
   assert(err == ERR_Okay, "Function predicates failed")
end

function benchmarkStringFunctions()
   local err, id = glXML.mtSearch('//product[contains(@name,"Pro")]')
   assert(err == ERR_Okay, "String function failed")
end

function benchmarkPositionFunctions()
   local err, id = glXML.mtSearch('//category/products/product[position()=last()]')
   assert(err == ERR_Okay, "Position function failed")
end

-----------------------------------------------------------------------------------------------------------------------
-- Advanced XPath Features Benchmarks

function benchmarkAxesTraversal()
   local err, id = glXML.mtSearch('//product[@id="prod-1"]/ancestor::category[@name]')
   assert(err == ERR_Okay, "Axes traversal failed")
end

function benchmarkUnionOperations()
   local count = 0
   local err, id = glXML.mtSearch('//category[@name="electronics"] | //category[@name="clothing"]', function(XML, TagID, Attrib)
      count = count + 1
   end)
   assert(err == ERR_Okay, "Union operations failed")
end

function benchmarkComplexPredicates()
   local err, id = glXML.mtSearch('//product[@price>100 and @instock="true" and contains(@name,"Ultra")]')
   assert(err == ERR_Okay, "Complex predicates failed, got " .. mSys.GetErrorMsg(err))
end

function benchmarkNestedFunctions()
   local err, id = glXML.mtSearch('//category[string-length(@name)>5 and count(products/product)>=3]')
   assert(err == ERR_Okay, "Nested functions failed")
end

-----------------------------------------------------------------------------------------------------------------------
-- Large Document Scanning Benchmarks

function benchmarkLargeDeepScan()
   local count = 0
   local err, id = glXML.mtSearch('//product', function(XML, TagID, Attrib)
      count = count + 1
   end)
   assert(err == ERR_Okay, "Large deep scan failed")
end

function benchmarkAttributeScanning()
   local count = 0
   local err, id = glXML.mtSearch('//@price', function(XML, TagID, Attrib)
      count = count + 1
   end)
   assert(err == ERR_Okay, "Attribute scanning failed")
end

function benchmarkConditionalCounting()
   local err, num = glXML.mtEvaluate('count(//product)')
   local totalProducts = tonumber(num)
   assert(totalProducts > 0, "Conditional counting failed")
end

-----------------------------------------------------------------------------------------------------------------------
-- XPath Function Library Benchmarks

function benchmarkStringManipulation()
   local err, id = glXML.mtSearch('//product[starts-with(@name,"Ultra") and substring(@name,1,5)="Ultra"]')
   assert(err == ERR_Okay, "String manipulation failed")
end

function benchmarkNumericFunctions()
   local err, id = glXML.mtSearch('//product[floor(@price div 100) = 12]')
   assert(err == ERR_Okay, "Numeric functions failed, got " .. mSys.GetErrorMsg(err))
end

function benchmarkBooleanLogic()
   local err, id = glXML.mtSearch('//product[@instock="true" and not(@discontinued="true")]')
   assert(err == ERR_Okay, "Boolean logic failed")
end

function benchmarkComplexExpressions()
   local err, id = glXML.mtSearch('//product[@price * 0.5 > 70 and position() mod 2 = 0]')
   assert(err == ERR_Okay, "Complex expressions failed, got " .. mSys.GetErrorMsg(err))
end

-----------------------------------------------------------------------------------------------------------------------
-- Content and Structure Benchmarks

function benchmarkContentExtraction()
   local content = glXML.mtEvaluate('string(//product[@id="prod-1"])')
   assert(content, "Content extraction failed")
end

function benchmarkTextNodeAccess()
   local err, id = glXML.mtSearch('//product/description[text()="High-performance device"]')
   assert(err == ERR_Okay, "Text node access failed")
end

function benchmarkMixedContentTraversal()
   local count = 0
   local err, id = glXML.mtSearch('//category[products/product and @name]', function(XML, TagID, Attrib)
      count = count + 1
   end)
   assert(err == ERR_Okay, "Mixed content traversal failed")
end

-----------------------------------------------------------------------------------------------------------------------
-- Performance Comparison Tests

function benchmarkSimpleVsComplexPaths()
   -- Simple path
   local err1, id1 = glXML.mtSearch('/catalog/categories/category[1]')
   assert(err1 == ERR_Okay, "Simple path failed")

   -- Complex equivalent path
   local err2, id2 = glXML.mtSearch('/catalog/descendant::categories/child::category[position()=1]')
   assert(err2 == ERR_Okay, "Complex path failed")
end

function benchmarkIndexedVsPredicateAccess()
   -- Indexed access
   local err1, id1 = glXML.mtSearch('//product[5]')
   assert(err1 == ERR_Okay, "Indexed access failed")

   -- Predicate equivalent
   local err2, id2 = glXML.mtSearch('//product[position()=5]')
   assert(err2 == ERR_Okay, "Predicate access failed")
end

-----------------------------------------------------------------------------------------------------------------------

function benchmarkFlworSimpleFor()
   local err, val = glXML.mtEvaluate([[for $p in //product return $p/@id]])
   assert(err == ERR_Okay, 'FLWOR simple for failed')
end

function benchmarkFlworOrderBy()
   local err, val = glXML.mtEvaluate([[for $p in //product order by number($p/@price) return $p]])
   assert(err == ERR_Okay, 'FLWOR order by failed')
end

function benchmarkFlworGroupBy()
   local err, val = glXML.mtEvaluate([[for $p in //category/products/product group by $c := ../@name return $c]])
   assert(err == ERR_Okay, 'FLWOR group by failed')
end

-----------------------------------------------------------------------------------------------------------------------

function benchmarkPrologManyFunctions()
   local prolog = [[
      declare function local:f0() { 0 };
      declare function local:f1() { 1 };
      declare function local:f2() { 2 };
      declare function local:f3() { 3 };
      declare function local:f4() { 4 };
      declare function local:f5() { 5 };
      declare function local:f6() { 6 };
      declare function local:f7() { 7 };
      declare function local:f8() { 8 };
      declare function local:f9() { 9 };
   ]]
   local err, val = glXML.mtEvaluate(prolog .. 'local:f7()')
   assert(err == ERR_Okay, 'Prolog many functions failed')
end

function benchmarkPrologArityLookup()
   local prolog = [[
      declare function local:sum($a as xs:integer) as xs:integer { $a };
      declare function local:sum($a as xs:integer, $b as xs:integer) as xs:integer { $a + $b };
      declare function local:sum($a as xs:integer, $b as xs:integer, $c as xs:integer) as xs:integer { $a + $b + $c };
   ]]
   local err, val = glXML.mtEvaluate(prolog .. 'local:sum(1,2,3)')
   assert(err == ERR_Okay, 'Prolog arity lookup failed')
end

function benchmarkPrologQNameNormalization()
   local prolog = [[
      declare default function namespace "http://example.com/test";
      declare function local:noop() { () };
   ]]
   local err, val = glXML.mtEvaluate(prolog .. 'local:noop()')
   assert(err == ERR_Okay, 'Prolog QName normalization failed')
end

-----------------------------------------------------------------------------------------------------------------------

function benchmarkTokenLongArithmetic()
   local expr = '('
   for i = 1, 50 do
      if i > 1 then expr = expr .. ' + ' end
      expr = expr .. tostring(i)
   end
   expr = expr .. ')'
   local err, val = glXML.mtEvaluate(expr)
   assert(err == ERR_Okay, 'Token long arithmetic failed')
end

function benchmarkTokenNestedFunctions()
   local expr = 'upper-case(lower-case(translate("TheQuickBrownFoxJumpsOverTheLazyDog", "aeiou", "12345")))'
   local err, val = glXML.mtEvaluate(expr)
   assert(err == ERR_Okay, 'Token nested functions failed')
end

function benchmarkTokenLongPath()
   local parts = {}
   for i = 1, 60 do table.insert(parts, 'catalog') end
   local path = '/' .. table.concat(parts, '/')
   local err, val = glXML.mtEvaluate(path)
   assert(err == ERR_Okay, 'Token long path failed')
end

-----------------------------------------------------------------------------------------------------------------------

function benchmarkAxisDescendantDeep()
   local err, id = glXML.mtSearch('descendant-or-self::node()')
   assert(err == ERR_Okay, 'Axis descendant-or-self failed')
end

function benchmarkAxisFollowing()
   local err, id = glXML.mtSearch('/catalog/categories/category[1]/following::node()')
   assert(err == ERR_Okay, 'Axis following failed')
end

function benchmarkAxisPreceding()
   local err, id = glXML.mtSearch('/catalog/categories/category[last()]/preceding::node()')
   assert(err == ERR_Okay, 'Axis preceding failed')
end

-----------------------------------------------------------------------------------------------------------------------

local glContent

function benchmarkParsing()
   if not glContent then
      glContent = file.readAll(glPath .. 'benchmark_data.xml')
   end
   glXML.statement = glContent
end

-----------------------------------------------------------------------------------------------------------------------
-- Initialisation and main benchmark runner

   print('=== XML/XPath Performance Benchmark Suite ===')
   print('')

   print('Loading benchmark data...')

   local dataFile = glPath .. 'benchmark_data.xml'

   glXML = obj.new("xml", { path = dataFile })
   glQuery = obj.new('xquery', { })

   local err = processing.task().set('Priority', 20)  -- Highest priority

   print('Benchmark data loaded successfully')
   local err, cat_name = glXML.mtEvaluate('/catalog/@name')
   local err, product_count = glXML.mtEvaluate('count(//product)')
   print('Document root: ' .. nz(cat_name, 'Unknown'))
   print('Total products: ' .. nz(product_count, '0'))
   print('')

   local benchmarks = {
      {
         groupName = 'Basic Navigation',
         tests = {
            { name = 'Basic Navigation', test = benchmarkBasicNavigation, iter = 3000 },
            { name = 'Attribute Matching', test = benchmarkAttributeMatching, iter = 3000 },
            { name = 'Wildcard Matching', test = benchmarkWildcardMatching, iter = 1500 }
         }
      },
      {
         groupName = 'Deep Scanning',
         tests = {
            { name = 'Deep Scanning', test = benchmarkDeepScanning, iter = 300 },
            { name = 'Large Deep Scan', test = benchmarkLargeDeepScan, iter = 150 },
            { name = 'Attribute Scanning', test = benchmarkAttributeScanning, iter = 300 }
         }
      },
      {
         groupName = 'Predicate and Function',
         tests = {
            { name = 'Numeric Comparisons', test = benchmarkNumericComparisons, iter = 1500 },
            { name = 'Function Predicates', test = benchmarkFunctionPredicates, iter = 600 },
            { name = 'String Functions', test = benchmarkStringFunctions, iter = 900 },
            { name = 'Position Functions', test = benchmarkPositionFunctions, iter = 900 }
         }
      },
      {
         groupName = 'Advanced XPath Features',
         tests = {
            { name = 'Axes Traversal', test = benchmarkAxesTraversal, iter = 600 },
            { name = 'Union Operations', test = benchmarkUnionOperations, iter = 300 },
            { name = 'Complex Predicates', test = benchmarkComplexPredicates, iter = 600 },
            { name = 'Nested Functions', test = benchmarkNestedFunctions, iter = 600 }
         }
      },
      {
         groupName = 'Function Library',
         tests = {
            { name = 'String Manipulation', test = benchmarkStringManipulation, iter = 900 },
            { name = 'Numeric Functions', test = benchmarkNumericFunctions, iter = 900 },
            { name = 'Boolean Logic', test = benchmarkBooleanLogic, iter = 1200 },
            { name = 'Complex Expressions', test = benchmarkComplexExpressions, iter = 600 }
         }
      },
      {
         groupName = 'Content Access',
         tests = {
            { name = 'Content Extraction', test = benchmarkContentExtraction, iter = 1500 },
            { name = 'Text Node Access', test = benchmarkTextNodeAccess, iter = 900 },
            { name = 'Mixed Content Traversal', test = benchmarkMixedContentTraversal, iter = 600 },
            { name = 'Conditional Counting', test = benchmarkConditionalCounting, iter = 900 }
         }
      },
      {
         groupName = 'Performance Comparison',
         tests = {
            { name = 'Simple vs Complex Paths', test = benchmarkSimpleVsComplexPaths, iter = 1500 },
            { name = 'Indexed vs Predicate Access', test = benchmarkIndexedVsPredicateAccess, iter = 1500 }
         }
      },
      {
         groupName = 'Parsing',
         tests = {
            { name = 'Parse XML File', test = benchmarkParsing, iter = 600 }
         }
      },
      {
         groupName = 'XQuery FLWOR Benchmarks',
         tests = {
            { name = 'FLWOR Simple For', test = benchmarkFlworSimpleFor, iter = 4000 },
            { name = 'FLWOR Order By', test = benchmarkFlworOrderBy, iter = 2000 },
            { name = 'FLWOR Group By', test = benchmarkFlworGroupBy, iter = 2000 }
         }
      },
      {
         groupName = 'Prolog / Function Lookup Benchmarks',
         tests = {
            { name = 'Prolog Many Functions', test = benchmarkPrologManyFunctions, iter = 1400 },
            { name = 'Prolog Arity Lookup', test = benchmarkPrologArityLookup, iter = 1600 },
            { name = 'Prolog QName Normalise', test = benchmarkPrologQNameNormalization, iter = 1600 }
         }
      },
      {
         groupName = 'Tokeniser / Parse Benchmarks',
         tests = {
            { name = 'Token Long Arithmetic', test = benchmarkTokenLongArithmetic, iter = 2000 },
            { name = 'Token Nested Functions', test = benchmarkTokenNestedFunctions, iter = 6000 },
            { name = 'Token Long Path', test = benchmarkTokenLongPath, iter = 2000 }
         }
      },
      {
         groupName = 'Axis Stress',
         tests = {
            { name = 'Axis Descendant Deep', test = benchmarkAxisDescendantDeep, iter = 2000 },
            { name = 'Axis Following', test = benchmarkAxisFollowing, iter = 2000 },
            { name = 'Axis Preceding', test = benchmarkAxisPreceding, iter = 2000 }
         }
      }
   }

   for i, group in ipairs(benchmarks) do
      print('=== ' .. i .. '. ' .. group.groupName .. ' Tests ===')
      print('')
      for t, test in ipairs(group.tests) do
         benchmarkTest(test.name, test.test, test.iter)
      end
   end

   print('')
   print('=== Benchmark Results Summary ===')
   print('Tests completed: ' .. passedTests .. '/' .. totalTests)
   print('')

   -- Sort results by name
   local sortedResults = {}
   for testName, result in pairs(benchmarkResults) do
      if result != -1 then
         table.insert(sortedResults, {
            name = testName,
            avgTime = result.avgTime,
            totalTime = result.totalTime,
            bestTime = result.bestTime,
            iterations = result.iterations,
            heapAllocations = nz(result.heapAllocations, 0)
         })
      end
   end

   table.sort(sortedResults, function(a, b) return a.name < b.name end)

   local grandTotalTime = 0
   local fastestGrandTotal = 0
   for i, result in ipairs(sortedResults) do
      print(string.format('%2d. %-25s %dus/iter (%dms total, %dus fastest, %d iters, %d allocations)',
         i, result.name, result.avgTime, result.totalTime/1000, result.bestTime, result.iterations, result.heapAllocations))
      grandTotalTime = grandTotalTime + result.totalTime
      fastestGrandTotal = fastestGrandTotal + result.bestTime
   end

   print('')
   local grandTotalSeconds = grandTotalTime / 1000000.0
   local fastestGrandTotalUS = fastestGrandTotal
   local avgPerTest = grandTotalTime / #sortedResults
   local fastestAvgPerTest = fastestGrandTotal / #sortedResults

   print(string.format('Grand total benchmark time: %8.3fs (average per test: %6.3fms)', grandTotalSeconds, avgPerTest))
   print(string.format('Fastest-only grand total:   %dus (average fastest: %dus)', fastestGrandTotalUS, fastestAvgPerTest))

   print('')
   print('Failed tests:')
   local failedCount = 0
   for testName, result in pairs(benchmarkResults) do
      if result == -1 then
         print('  - ' .. testName)
         failedCount = failedCount + 1
      end
   end

   if failedCount == 0 then
      print('  None - all tests passed!')
   end

   print('')
   print('Benchmark completed.')
