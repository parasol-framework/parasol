-- XPath constructor evaluation tests

   include 'xml'

-----------------------------------------------------------------------------------------------------------------------
-- Direct element constructors should evaluate expressions inside tags and attributes

function testDirectConstructorEvaluation()
   local xml = obj.new("xml", { statement = '<root price="10"><item>5</item></root>' })

   local attributeValue = xml.getKey('string((<result price="{/root/@price}">{/root/item/text()}</result>)/@price)')
   assert(attributeValue == '10', 'Attribute value template should resolve to 10, got ' .. nz(attributeValue, 'NIL'))

   local elementString = xml.getKey('string((<result>{/root/item/text()}</result>)[1])')
   assert(elementString == '5', 'Element content should expose inner text, got ' .. nz(elementString, 'NIL'))

   local doubled = xml.getKey('string((<result><double>{/root/@price * 2}</double></result>)/double)')
   assert(doubled == '20', 'Nested constructor should evaluate arithmetic content, got ' .. nz(doubled, 'NIL'))
end

-----------------------------------------------------------------------------------------------------------------------
-- Computed constructors should honour dynamic names and content expressions

function testComputedConstructors()
   local xml = obj.new("xml", { statement = '<root price="10"/>' })

   local elementName = xml.getKey('local-name(element summary { /root/@price })')
   assert(elementName == 'summary', 'Computed element should adopt supplied lexical name, got ' .. nz(elementName, 'NIL'))

   local elementContent = xml.getKey('string(element summary { /root/@price * 3 })')
   assert(elementContent == '30', 'Computed element should evaluate numeric expressions, got ' .. nz(elementContent, 'NIL'))

   local attributeValue = xml.getKey('string(element wrapper { attribute cost { /root/@price } }/@cost)')
   assert(attributeValue == '10', 'Computed attribute should expose evaluated value, got ' .. nz(attributeValue, 'NIL'))
end

-----------------------------------------------------------------------------------------------------------------------
-- Text, comment, and processing-instruction constructors should produce textual nodes

function testNonElementConstructors()
   local xml = obj.new("xml", { statement = '<root price="10"/>' })

   local textValue = xml.getKey('string(text { /root/@price })')
   assert(textValue == '10', 'Text constructor should convert attribute content to text, got ' .. nz(textValue, 'NIL'))

   local commentValue = xml.getKey('string(comment { "note" })')
   assert(commentValue == 'note', 'Comment constructor should return its content, got ' .. nz(commentValue, 'NIL'))

   local piName = xml.getKey('name(processing-instruction target { "data" })')
   assert(piName == 'target', 'Processing-instruction should expose its target name, got ' .. nz(piName, 'NIL'))

   local piContent = xml.getKey('string(processing-instruction target { "data" })')
   assert(piContent == 'data', 'Processing-instruction should preserve its content, got ' .. nz(piContent, 'NIL'))

   local err = xml.mtFindTag('processing-instruction target { "bad?>data" }')
   assert(err != ERR_Okay, 'Processing-instruction content containing ?> should be rejected')
end

-----------------------------------------------------------------------------------------------------------------------
-- Document constructors should wrap sequences into a standalone document node

function testDocumentConstructor()
   local xml = obj.new("xml", { statement = '<root/>' })

   local childCount = tonumber(xml.getKey('count((document { <a/>, <b/> })/node())'))
   assert(childCount == 2, 'Document constructor should expose two child nodes, got ' .. tostring(childCount))

   local firstName = xml.getKey('name(((document { <root/> })/node())[1])')
   assert(firstName == 'root', 'Document constructor should retain child element names, got ' .. nz(firstName, 'NIL'))
end

-----------------------------------------------------------------------------------------------------------------------
-- Attribute and sequence content should merge correctly inside constructors

function testConstructorAttributeSequences()
   local xml = obj.new("xml", { statement = '<root/>' })

   local mergedCount = tonumber(xml.getKey('count(element wrapper { (attribute first { "1" }, attribute second { "2" }), element child { "value" } }/@*)'))
   assert(mergedCount == 2, 'Element constructor should merge attribute sequences into the result, got ' .. tostring(mergedCount))

   local mergedAttr = xml.getKey('string(element wrapper { (attribute first { "1" }, attribute second { "2" }), element child { "value" } }/@second)')
   assert(mergedAttr == '2', 'Element constructor should preserve attribute values from sequences, got ' .. nz(mergedAttr, 'NIL'))

   local firstChild = xml.getKey('name((element wrapper { (attribute first { "1" }, attribute second { "2" }), element child { "value" } }/node())[1])')
   assert(firstChild == 'child', 'Element constructor should retain subsequent child nodes after attributes, got ' .. nz(firstChild, 'NIL'))

   local dynamicAttr = xml.getKey('string((let $attrs := (attribute id { "main" }, attribute role { "admin" }) return element wrapper { $attrs, text { "ready" } })/@role)')
   assert(dynamicAttr == 'admin', 'Element constructor should append dynamic attribute sequences before content, got ' .. nz(dynamicAttr, 'NIL'))

   local firstText = xml.getKey('string((let $attrs := (attribute id { "main" }) return element wrapper { $attrs, text { "ready" }, "!" })/text()[1])')
   assert(firstText == 'ready', 'Element constructor should keep constructed text content before atomic values, got ' .. nz(firstText, 'NIL'))

   local secondText = xml.getKey('string((let $attrs := (attribute id { "main" }) return element wrapper { $attrs, text { "ready" }, "!" })/text()[2])')
   assert(secondText == '!', 'Element constructor should append atomic values as subsequent text nodes, got ' .. nz(secondText, 'NIL'))

   local combinedText = xml.getKey('concat((let $attrs := (attribute id { "main" }) return element wrapper { $attrs, text { "ready" }, "!" })/text()[1], (let $attrs := (attribute id { "main" }) return element wrapper { $attrs, text { "ready" }, "!" })/text()[2])')
   assert(combinedText == 'ready!', 'Element constructor should preserve text node ordering when combined explicitly, got ' .. nz(combinedText, 'NIL'))
end

-----------------------------------------------------------------------------------------------------------------------

return {
   tests = {
      'testDirectConstructorEvaluation', 'testComputedConstructors',
      'testNonElementConstructors', 'testDocumentConstructor',
      'testConstructorAttributeSequences'
   }
}
