-- XPath axis coverage tests

   include 'xml'

-----------------------------------------------------------------------------------------------------------------------
-- Test parent axis (..) navigation

function testParentAxisNavigation()
   local xml = obj.new("xml", {
      statement = '<root><section id="1"><item id="a"/><item id="b"/></section><section id="2"><item id="c"/></section></root>'
   })

   -- Test parent navigation (currently supported)
   local err, parentId = xml.mtFindTag('/root/section/item[@id="a"]/..')
   if err == ERR_Okay then
      local err, sectionId = xml.mtGetAttrib(parentId, 'id')
      assert(err == ERR_Okay and sectionId == "1", "Parent navigation should return section with id=1")
   end
end

-----------------------------------------------------------------------------------------------------------------------
-- Test XPath 1.0 axes

function testXPathAxes()
   local xml = obj.new("xml", {
      statement = '<root><section><item id="1"/><item id="2"/></section><other><item id="3"/></other></root>'
   })

   -- Test following-sibling axis returns the next item in document order
   local err, itemId = xml.mtFindTag('/root/section/item[@id="1"]/following-sibling::item')
   assert(err == ERR_Okay, "following-sibling axis should locate the next sibling item: " .. mSys.GetErrorMsg(err))
   local err2, siblingId = xml.mtGetAttrib(itemId, 'id')
   assert(err2 == ERR_Okay and siblingId == '2', "following-sibling::item should return id=2")

   -- Test preceding-sibling axis returns the previous sibling
   err, itemId = xml.mtFindTag('/root/section/item[@id="2"]/preceding-sibling::item')
   assert(err == ERR_Okay, "preceding-sibling axis should locate the previous sibling item: " .. mSys.GetErrorMsg(err))
   err2, siblingId = xml.mtGetAttrib(itemId, 'id')
   assert(err2 == ERR_Okay and siblingId == '1', "preceding-sibling::item should return id=1")

   -- Test ancestor axis resolves back to the document root
   local errRoot, rootId = xml.mtFindTag('/root')
   assert(errRoot == ERR_Okay, "Should be able to resolve /root for ancestor comparison")
   err, itemId = xml.mtFindTag('/root/section/item/ancestor::root')
   assert(err == ERR_Okay, "ancestor axis should resolve to the document root: " .. mSys.GetErrorMsg(err))
   assert(itemId == rootId, "ancestor::root should return the root tag identifier")

   -- Test descendant axis traverses nested branches
   err, itemId = xml.mtFindTag('/root/descendant::item[@id="3"]')
   assert(err == ERR_Okay, "descendant axis should locate nested descendants: " .. mSys.GetErrorMsg(err))
   err2, siblingId = xml.mtGetAttrib(itemId, 'id')
   assert(err2 == ERR_Okay and siblingId == '3', "descendant::item[@id=\"3\"] should return id=3")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test XPath 1.0 union operator

function testAttributeAxisHandling()
   local xml = obj.new("xml", {
      statement = '<root><item id="one" category="fiction" data-extra="x"/></root>'
   })

   local attrValue = xml.getKey('/root/item/@category')
   assert(attrValue == 'fiction', '@category should retrieve the category attribute value, got ' .. nz(attrValue, 'NIL'))

   attrValue = xml.getKey('/root/item/attribute::category')
   assert(attrValue == 'fiction', 'attribute::category should expose the same value as @category, got ' .. nz(attrValue, 'NIL'))

   local attributeNames = {}
   local err = xml.mtFindTag('/root/item/attribute::*', function(XML, TagID, Attrib)
      table.insert(attributeNames, Attrib)
   end)
   assert(err == ERR_Okay, 'attribute::* should enumerate attribute nodes: ' .. mSys.GetErrorMsg(err))

   local foundCategory, foundId = false, false
   for index = 1, #attributeNames do
      if attributeNames[index] == 'category' then foundCategory = true end
      if attributeNames[index] == 'id' then foundId = true end
   end

   assert(foundCategory, 'attribute::* should include the category attribute name')
   assert(foundId, 'attribute::* should include the id attribute name')

   local errAttr = xml.mtFindTag('/root/item/@*[starts-with(name(), "data")]')
   assert(errAttr == ERR_Okay, '@* should support function predicates on attribute names: ' .. mSys.GetErrorMsg(errAttr))

   attrValue = xml.getKey('/root/item/@*[starts-with(name(), "data")]')
   assert(attrValue == 'x', 'starts-with(name()) should retrieve the data-extra attribute value, got ' .. nz(attrValue, 'NIL'))
end

-----------------------------------------------------------------------------------------------------------------------
-- Regression: Attribute axis steps should support parent and ancestor navigation

function testAttributeAxisContinuation()
   local xml = obj.new("xml", {
      statement = '<root>' ..
                  '<section id="section-1"><item id="item-a"/></section>' ..
                  '<section id="section-2"><item id="item-b" code="branch"/></section>' ..
                  '</root>'
   })

   local errItem, itemId = xml.mtFindTag('//@id/parent::*[@id="item-b"]')
   assert(errItem == ERR_Okay, 'Parent axis should resolve owning element from attribute context: ' .. mSys.GetErrorMsg(errItem))

   local errAttrib, value = xml.mtGetAttrib(itemId, 'id')
   assert(errAttrib == ERR_Okay and value == 'item-b', 'Attribute parent navigation should locate id="item-b", got ' .. nz(value, 'NIL'))

   local errSection, sectionId = xml.mtFindTag('//@code/ancestor::section[@id="section-2"]')
   assert(errSection == ERR_Okay, 'Ancestor axis should operate on attribute contexts: ' .. mSys.GetErrorMsg(errSection))

   local errSectionAttrib, sectionValue = xml.mtGetAttrib(sectionId, 'id')
   assert(errSectionAttrib == ERR_Okay and sectionValue == 'section-2', 'Ancestor traversal from attribute should reach section-2, got ' .. nz(sectionValue, 'NIL'))
end

-----------------------------------------------------------------------------------------------------------------------
-- Test XPath 1.0 union operator

function testUnionOperator()
   local xml = obj.new("xml", {
      statement = '<root><section><item/></section><other><item/></other></root>'
   })

   assert(xml.mtFindTag('/root/section/item | /root/other/item') == ERR_Okay)
end

-----------------------------------------------------------------------------------------------------------------------
-- Regression: Text nodes participate in axes per XPath 1.0

function testTextNodeAxes()
   local xml = obj.new("xml", {
      statement = '<root><a>First</a> Second <b>Third</b></root>'
   })

   local err, textId = xml.mtFindTag('/root/a/following-sibling::text()')
   assert(err == ERR_Okay, 'Text nodes should appear on the following-sibling axis')

   local errTag, textTag = xml.mtGetTag(textId)
   assert(errTag == ERR_Okay and textTag.attribs[1].value == ' Second ',
      'Whitespace in text nodes should be preserved when navigating axes, got ' .. nz(textTag.attribs[1].value, 'NIL'))

   err, textId = xml.mtFindTag('/root/descendant::text()')
   assert(err == ERR_Okay, 'Descendant axis should include text nodes produced by element content')

   err, textId = xml.mtFindTag('/root/b/preceding-sibling::text()')
   assert(err == ERR_Okay, 'Text nodes should also be available via preceding-sibling axis')

   errTag, textTag = xml.mtGetTag(textId)
   assert(errTag == ERR_Okay and textTag.attribs[1].value == ' Second ',
      'preceding-sibling::text() should expose the whitespace-preserved node, got ' .. nz(textTag.attribs[1].value, 'NIL'))
end

-----------------------------------------------------------------------------------------------------------------------
-- XPath 1.0 comment() node test

function testCommentNodeType()
   local xml = obj.new("xml", {
      statement = '<root><!-- marker --><item>Value</item><!-- trailer --></root>', flags = XMF_INCLUDE_COMMENTS
   })

   local err, commentId = xml.mtFindTag('/root/comment()')
   assert(err == ERR_Okay, 'comment() node test should locate the first comment, err=' .. mSys.GetErrorMsg(err))

   local errTag, commentTag = xml.mtGetTag(commentId)
   assert(errTag == ERR_Okay and commentTag.attribs[1].value == ' marker ',
       'comment() should expose the comment content, got ' .. nz(commentTag.attribs[1].value, 'NIL'))

   err, commentId = xml.mtFindTag('/root/item/following-sibling::comment()')
   assert(err == ERR_Okay, 'comment() on following-sibling axis should locate subsequent comments, err=' .. mSys.GetErrorMsg(err))

   errTag, commentTag = xml.mtGetTag(commentId)
   assert(errTag == ERR_Okay and commentTag.attribs[1].value == ' trailer ',
       'following-sibling::comment() should expose trailing comment, got ' .. nz(commentTag.attribs[1].value, 'NIL'))
end

-----------------------------------------------------------------------------------------------------------------------
-- XPath 1.0 processing-instruction() node test

function testProcessingInstructionNodeType()
   local xml = obj.new("xml", {
      statement = '<root><?target data?><item/><?other pi?></root>'
   })

   local err, piId = xml.mtFindTag('/root/processing-instruction()')
   assert(err == ERR_Okay, 'processing-instruction() should locate the first PI node, err=' .. mSys.GetErrorMsg(err))

   local piErr, piTag = xml.mtGetTag(piId)
   assert(piErr == ERR_Okay and piTag.attribs[1].name == '?target', 'processing-instruction() should expose the PI target name')

   err, piId = xml.mtFindTag('/root/processing-instruction("target")')
   assert(err == ERR_Okay, 'processing-instruction("target") should filter by target name, err=' .. mSys.GetErrorMsg(err))

   piErr, piTag = xml.mtGetTag(piId)
   assert(piErr == ERR_Okay and piTag.attribs[1].name == '?target', 'processing-instruction("target") should return the matching PI node')
end

-----------------------------------------------------------------------------------------------------------------------
-- XPath 1.0 node() test

function testGenericNodeType()
   local xml = obj.new("xml", {
      statement = '<root><child/><other/></root>'
   })

   local err, nodeId = xml.mtFindTag('/root/node()')
   assert(err == ERR_Okay, 'node() node test should match any node type at the document root, err=' .. mSys.GetErrorMsg(err))

   err, nodeId = xml.mtFindTag('/root/child/following-sibling::node()')
   assert(err == ERR_Okay, 'following-sibling::node() should match subsequent sibling nodes, err=' .. mSys.GetErrorMsg(err))
end

-----------------------------------------------------------------------------------------------------------------------
-- XPath 1.0 namespace axis (NOT YET SUPPORTED)

function testNamespaceAxis()
   local xml = obj.new("xml", {
      statement = '<root xmlns:ns="http://example.com/ns"><ns:item/></root>'
   })

   local err, nsId = xml.mtFindTag('/root/namespace::*')
   assert(err != ERR_Okay, 'namespace::* axis should remain unsupported, err=' .. mSys.GetErrorMsg(err))

   err, nsId = xml.mtFindTag('/root/namespace::ns')
   assert(err != ERR_Okay, 'namespace::ns should remain unsupported, err=' .. mSys.GetErrorMsg(err))
end

-----------------------------------------------------------------------------------------------------------------------
-- Test Phase 5: XPath Axes

function testXPathForwardAxes()
   local xml = obj.new("xml", {
      statement = [[
         <library>
            <fiction>
               <book id="1" title="1984">George Orwell</book>
               <book id="2" title="Brave New World">Aldous Huxley</book>
               <review rating="5">Excellent dystopian novel</review>
            </fiction>
            <technical>
               <book id="3" title="Clean Code">Robert Martin</book>
               <book id="4" title="Design Patterns">Gang of Four</book>
               <guide type="tutorial">Getting Started</guide>
            </technical>
            <archive>
               <old-book year="1950">Classic Literature</old-book>
            </archive>
         </library>
      ]]
   })

   -- Test child axis (default axis)
   local childCount = 0
   local err, id = xml.mtFindTag('/library/fiction/book', function(XML, TagID, Attrib)
      childCount = childCount + 1
   end)
   assert(err == ERR_Okay, "Child axis should work (default axis)")
   assert(childCount == 2, "Should find 2 books in fiction section, found " .. childCount)

   -- Test explicit child axis
   childCount = 0
   err, id = xml.mtFindTag('/library/child::fiction/child::book', function(XML, TagID, Attrib)
      childCount = childCount + 1
   end)
   assert(err == ERR_Okay, "Explicit child axis should iterate children correctly: " .. mSys.GetErrorMsg(err))
   assert(childCount == 2, "child::book should still find the two fiction books, found " .. childCount)

   -- Test descendant axis (all descendants)
   local descendantCount = 0
   err, id = xml.mtFindTag('/library/descendant::book', function(XML, TagID, Attrib)
      descendantCount = descendantCount + 1
   end)
   assert(err == ERR_Okay, "descendant::book should traverse the entire subtree: " .. mSys.GetErrorMsg(err))
   assert(descendantCount == 4, "Descendant axis should find all 4 books, found " .. descendantCount)

   -- Test following-sibling axis between top-level sections
   local errTech, technicalId = xml.mtFindTag('/library/technical')
   assert(errTech == ERR_Okay, "Should resolve /library/technical for comparison")

   err, id = xml.mtFindTag('/library/fiction/following-sibling::technical')
   assert(err == ERR_Okay, "following-sibling axis should locate the technical section: " .. mSys.GetErrorMsg(err))
   assert(id == technicalId, "following-sibling::technical should resolve to the technical section id")

   -- Test following axis to find nodes later in document order
   err, id = xml.mtFindTag('/library/fiction/book[@id="2"]/following::guide')
   assert(err == ERR_Okay, "following axis should locate guide nodes later in the document: " .. mSys.GetErrorMsg(err))
   local err2, guideType = xml.mtGetAttrib(id, 'type')
   assert(err2 == ERR_Okay and guideType == 'tutorial', "following::guide should return the tutorial guide element")
end

function testXPathReverseAxes()
   local xml = obj.new("xml", {
      statement = [[
         <root>
            <section id="1">
               <chapter id="1.1">
                  <paragraph id="1.1.1">First paragraph</paragraph>
                  <paragraph id="1.1.2">Second paragraph</paragraph>
               </chapter>
               <chapter id="1.2">
                  <paragraph id="1.2.1">Third paragraph</paragraph>
               </chapter>
            </section>
            <section id="2">
               <chapter id="2.1">
                  <paragraph id="2.1.1">Fourth paragraph</paragraph>
               </chapter>
            </section>
         </root>
      ]]
   })

   -- Test parent axis (.. syntax already works)
   local err, parentId = xml.mtFindTag('/root/section/chapter[@id="1.1"]/..')
   assert(err == ERR_Okay, "Parent axis via .. should return the owning section: " .. mSys.GetErrorMsg(err))
   local err2, sectionId = xml.mtGetAttrib(parentId, 'id')
   assert(err2 == ERR_Okay and sectionId == '1', "Parent axis should land on the section with id=1")

   -- Test explicit parent axis
   err, parentId = xml.mtFindTag('/root/section/chapter/parent::section')
   assert(err == ERR_Okay, "Explicit parent axis should resolve to the enclosing section: " .. mSys.GetErrorMsg(err))
   err2, sectionId = xml.mtGetAttrib(parentId, 'id')
   assert(err2 == ERR_Okay and (sectionId == '1' or sectionId == '2'), "parent::section should return a valid section node")

   -- Test ancestor axis
   local errRoot, rootId = xml.mtFindTag('/root')
   assert(errRoot == ERR_Okay, "Should resolve /root for ancestor comparison")
   err, ancestorId = xml.mtFindTag('/root/section/chapter/paragraph/ancestor::root')
   assert(err == ERR_Okay, "Ancestor axis should climb to the document root: " .. mSys.GetErrorMsg(err))
   assert(ancestorId == rootId, "ancestor::root should return the root tag identifier")

   -- Test preceding-sibling axis
   err, siblingId = xml.mtFindTag('/root/section/chapter[2]/preceding-sibling::chapter')
   assert(err == ERR_Okay, "preceding-sibling::chapter should locate the prior chapter: " .. mSys.GetErrorMsg(err))
   local err3, siblingChapter = xml.mtGetAttrib(siblingId, 'id')
   assert(err3 == ERR_Okay and siblingChapter == '1.1', "preceding-sibling::chapter should return chapter 1.1")

   -- Test preceding axis (reverse document order)
   err, siblingId = xml.mtFindTag('/root/section/chapter[2]/paragraph/preceding::paragraph')
   assert(err == ERR_Okay, "preceding::paragraph should return earlier paragraphs: " .. mSys.GetErrorMsg(err))
   local err4, precedingParagraph = xml.mtGetAttrib(siblingId, 'id')
   assert(err4 == ERR_Okay and precedingParagraph == '1.1.2', "preceding::paragraph should return the nearest preceding paragraph")
end

function testAncestorOrSelfAxis()
   local xml = obj.new("xml", {
      statement = [[
         <root>
            <section id="outer">
               <section id="inner">
                  <item id="leaf"/>
               </section>
            </section>
         </root>
      ]]
   })

   local err, nodeId = xml.mtFindTag('/root/section/section/item/ancestor-or-self::section[@id="inner"]')
   assert(err == ERR_Okay, 'ancestor-or-self::section should include the nearest ancestor: ' .. mSys.GetErrorMsg(err))
   local err2, attrValue = xml.mtGetAttrib(nodeId, 'id')
   assert(err2 == ERR_Okay and attrValue == 'inner', 'ancestor-or-self::section should return the inner section node')

   err, nodeId = xml.mtFindTag('/root/section/section/item/ancestor-or-self::section[@id="outer"]')
   assert(err == ERR_Okay, 'ancestor-or-self::section should climb to the outer ancestor: ' .. mSys.GetErrorMsg(err))
   err2, attrValue = xml.mtGetAttrib(nodeId, 'id')
   assert(err2 == ERR_Okay and attrValue == 'outer', 'ancestor-or-self::section should locate the outer section node')

   err, nodeId = xml.mtFindTag('/root/section/section/ancestor-or-self::section[@id="inner"]')
   assert(err == ERR_Okay, 'ancestor-or-self should include the context node itself: ' .. mSys.GetErrorMsg(err))
   err2, attrValue = xml.mtGetAttrib(nodeId, 'id')
   assert(err2 == ERR_Okay and attrValue == 'inner', 'ancestor-or-self::section should treat the current section as a match')
end

function testXPathAxisCombinations()
   local xml = obj.new("xml", {
      statement = [[
         <document>
            <header>
               <title>Document Title</title>
               <meta name="author">John Doe</meta>
            </header>
            <body>
               <section class="intro">
                  <p>Introduction paragraph</p>
                  <p>Second intro paragraph</p>
               </section>
               <section class="content">
                  <p>Main content paragraph</p>
                  <aside>Side note</aside>
               </section>
            </body>
            <footer>
               <p>Footer content</p>
            </footer>
         </document>
      ]]
   })

   -- Test self axis
   local err, bodyId = xml.mtFindTag('/document/body')
   assert(err == ERR_Okay, "Should resolve /document/body for self-axis comparison")

   local errSelf, selfId = xml.mtFindTag('/document/body/self::body')
   assert(errSelf == ERR_Okay, "self::body should reference the current context node: " .. mSys.GetErrorMsg(errSelf))
   assert(selfId == bodyId, "self::body should return the same identifier as /document/body")

   -- Test attribute lookups via @ syntax in combination with descendant scans
   local metaErr, metaId = xml.mtFindTag('/document/header/meta')
   assert(metaErr == ERR_Okay, "Meta element should be reachable for attribute verification")
   local attrErr, metaAttr = xml.mtGetAttrib(metaId, 'name')
   assert(attrErr == ERR_Okay and metaAttr == 'author', "Attribute extraction should work inside mixed axis queries")

   local attrExistsErr, attrExistsId = xml.mtFindTag('/document/header/meta[@name]')
   assert(attrExistsErr == ERR_Okay, "[@name] predicate should be honoured during combined axis tests")

   -- Test complex axis combinations
   -- Find all paragraphs that are descendants of sections
   local paragraphCount = 0
   err, id = xml.mtFindTag('/document/body/section//p', function(XML, TagID, Attrib)
      paragraphCount = paragraphCount + 1
   end)
   assert(err == ERR_Okay, "Deep scanning should work for paragraph descendants")
   assert(paragraphCount == 3, "Should find 3 paragraphs in sections, found " .. paragraphCount)

   -- Combine following-sibling and descendant axes to locate the aside element
   err, id = xml.mtFindTag('/document/body/section[@class="intro"]/following-sibling::section/descendant::aside')
   assert(err == ERR_Okay, "following-sibling::section/descendant::aside should locate the aside element: " .. mSys.GetErrorMsg(err))

   -- Verify ancestor axes in combination with descendant-or-self
   local errAncestor = xml.mtFindTag('/document/body/section[@class="content"]/aside/ancestor::body')
   assert(errAncestor == ERR_Okay, "ancestor::body should reach the body element from the aside")

   err, id = xml.mtFindTag('/document/body/section[@class="content"]/descendant-or-self::section')
   assert(err == ERR_Okay, "descendant-or-self::section should include the current section node")
end

-----------------------------------------------------------------------------------------------------------------------

function testSiblingFilteringForNumericPredicates()
   local xml = obj.new("xml", {
      statement = '<root><b/><a id="first"/><a id="second"/></root>'
   })

   local err, secondId = xml.mtFindTag('/root/a[2]')
   assert(err == ERR_Okay, 'XPath [2] should select the second <a> node: ' .. mSys.GetErrorMsg(err))

   local err2, value = xml.mtGetAttrib(secondId, 'id')
   assert(err2 == ERR_Okay and value == 'second', 'Second <a> should have been matched')
end

-----------------------------------------------------------------------------------------------------------------------

return {
   tests = {
      'testParentAxisNavigation', 'testXPathAxes', 'testAttributeAxisHandling', 'testAttributeAxisContinuation',
      'testUnionOperator', 'testTextNodeAxes',
      'testCommentNodeType', 'testProcessingInstructionNodeType',
      'testGenericNodeType', 'testNamespaceAxis',
      'testXPathForwardAxes', 'testXPathReverseAxes', 'testAncestorOrSelfAxis',
      'testXPathAxisCombinations', 'testSiblingFilteringForNumericPredicates'
   },
   init = function(ScriptFolder)
   end,
   cleanup = function()
   end
}
