-- Advanced XPath path lookup and edge case tests

   include 'xml'

-----------------------------------------------------------------------------------------------------------------------
-- Deeply nested path traversal combining multiple predicates and steps

function testDeeplyNestedPathTraversal()
   local xml = obj.new("xml", {
      statement = '<catalog><category name="fiction"><series name="modern"><book author="Smith"><chapter num="1"><section><paragraph>Intro</paragraph></section></chapter><chapter num="2"><section><paragraph>Body</paragraph><paragraph>Middle</paragraph></section></chapter><chapter num="3"><section><paragraph>Conclusion</paragraph></section></chapter></book></series></category></catalog>'
   })

   local err, tagId = xml.mtFindTag('/catalog/category[@name="fiction"]/series[@name="modern"]/book[@author="Smith"]/chapter[last()]/section/paragraph[position()=1]')
   assert(err == ERR_Okay, 'last() combined with position() should locate the first paragraph of the last chapter: ' .. mSys.GetErrorMsg(err))

   local content = xml.getKey('/catalog/category[@name="fiction"]/series[@name="modern"]/book[@author="Smith"]/chapter[last()]/section/paragraph[position()=1]')
   assert(content == 'Conclusion', 'Paragraph content should be "Conclusion", got ' .. nz(content, 'NIL'))
end

-----------------------------------------------------------------------------------------------------------------------
-- Edge case: sequential predicates mixing numeric and functional tests

function testSequentialPredicateEvaluation()
   local xml = obj.new("xml", {
      statement = '<data><entry type="record" priority="1"/><entry type="record" priority="2"/><entry type="log" priority="3"/><entry type="record" priority="4"/><entry type="record" priority="5"/></data>'
   })

   local err, tagId = xml.mtFindTag('/data/entry[@type="record"][position()=last()]')
   assert(err == ERR_Okay, 'Sequential predicates should allow position()=last() evaluation: ' .. mSys.GetErrorMsg(err))

   local errAttr, priority = xml.mtGetAttrib(tagId, 'priority')
   assert(errAttr == ERR_Okay and priority == '5', 'Expected the final record entry priority to be 5, got ' .. nz(priority, 'NIL'))
end

-----------------------------------------------------------------------------------------------------------------------
-- Edge case: navigating relative to the current node using .// patterns

function testRelativeCurrentNodeTraversal()
   local xml = obj.new("xml", {
      statement = '<root><section id="alpha"><item id="x"/><group><item id="y"/></group></section><section id="beta"><group><item id="z"/><item id="target"/></group></section></root>'
   })

   local err, sectionId = xml.mtFindTag('/root/section[./group/item[@id="target"]]')
   assert(err == ERR_Okay, 'Predicate using ./group should evaluate relative to the current node: ' .. mSys.GetErrorMsg(err))

   local errAttr, sectionName = xml.mtGetAttrib(sectionId, 'id')
   assert(errAttr == ERR_Okay and sectionName == 'beta', 'Expected the section containing the target item to be beta, got ' .. nz(sectionName, 'NIL'))

   local errItem, itemId = xml.mtFindTag('/root/section[@id="beta"]//item[@id="target"]')
   assert(errItem == ERR_Okay, '// should descend from the matched section to find the nested target item: ' .. mSys.GetErrorMsg(errItem))
end

-----------------------------------------------------------------------------------------------------------------------
-- Edge case: ensuring failed lookups return error codes cleanly

function testMissingPathError()
   local xml = obj.new("xml", {
      statement = '<root><item id="1"/><item id="2"/></root>'
   })

   local err, tagId = xml.mtFindTag('/root/item[@id="3"]')
   assert(err != ERR_Okay, 'Non-existent predicate matches should produce an error result, got ' .. mSys.GetErrorMsg(err))
   assert(tagId == nil or tagId == 0, 'No tag identifier should be returned when the lookup fails, got ' .. tagId)
end

-----------------------------------------------------------------------------------------------------------------------
-- Complex descendant traversal mixing attribute and element access

function testDescendantAxisAttributeAccess()
   local xml = obj.new("xml", {
      statement = '<root category="library"><branch name="east"><shelf code="A"><book id="1">Intro</book></shelf></branch><branch name="west"><shelf code="B"><book id="2">Advanced</book></shelf></branch></root>'
   })

   local category = xml.getKey('//branch[@name="west"]/../@category')
   assert(category == 'library', 'Using .. from a descendant selection should expose the ancestor attribute value, got ' .. nz(category, 'NIL'))

   local err, tagId = xml.mtFindTag('//branch[@name="west"]/shelf[@code="B"]/book[text()="Advanced"]')
   assert(err == ERR_Okay, 'Complex descendant traversal should locate the advanced book entry: ' .. mSys.GetErrorMsg(err))
end

-----------------------------------------------------------------------------------------------------------------------
-- Conditional expressions should select the correct branch

function testConditionalIfExpression()
   local xml = obj.new("xml", {
      statement = '<root><item id="a">Alpha</item><item id="b">Beta</item></root>'
   })

   local chosen = xml.getKey('if (/root/item[@id="a"]) then /root/item[@id="a"] else /root/item[@id="b"]')
   assert(chosen == 'Alpha', 'If expression should return Alpha branch when predicate succeeds, got ' .. nz(chosen, 'NIL'))

   local fallback = xml.getKey('if (/root/item[@id="missing"]) then /root/item[@id="a"] else /root/item[@id="b"]')
   assert(fallback == 'Beta', 'If expression should evaluate else branch when condition fails, got ' .. nz(fallback, 'NIL'))
end

-----------------------------------------------------------------------------------------------------------------------
-- For expressions should iterate sequences and aggregate node results

function testForExpressionNodeAggregation()
   local xml = obj.new("xml", {
      statement = '<root><group name="one"><item id="a">Alpha</item><item id="b">Beta</item></group><group name="two"><item id="c">Gamma</item></group></root>'
   })

   local collected = {}
   local err, index = xml.mtFindTag('for $g in /root/group return $g/item', function(XML, TagID, Attrib)
      local errAttr, idValue = xml.mtGetAttrib(TagID, 'id')
      assert(errAttr == ERR_Okay, 'For expression callback should resolve item id: ' .. mSys.GetErrorMsg(errAttr))
      table.insert(collected, idValue)
   end)

   assert(err == ERR_Okay, 'For expression evaluation should succeed: ' .. mSys.GetErrorMsg(err))
   assert(#collected == 3, 'For expression should yield three items, got ' .. #collected)

   table.sort(collected)
   assert(collected[1] == 'a' and collected[2] == 'b' and collected[3] == 'c', 'For expression should gather all item identifiers, got ' .. table.concat(collected, ','))
end

-----------------------------------------------------------------------------------------------------------------------
-- Quantified expressions should evaluate boolean logic correctly

function testQuantifiedExpressions()
   local xml = obj.new("xml", {
      statement = '<root><group name="alpha"><item id="a" class="one"/><item id="b" class="two"/></group><group name="beta"><item id="c" class="beta"/></group></root>'
   })

   local someResult = xml.getKey('if (some $g in /root/group satisfies $g/@name = "beta") then "yes" else "no"')
   assert(someResult == 'yes', 'Quantified some expression should detect the beta group, got ' .. nz(someResult, 'NIL'))

   local everyResult = xml.getKey('if (every $item in /root/group[@name="alpha"]/item satisfies @class = "one") then "all" else "mixed"')
   assert(everyResult == 'mixed', 'Quantified every expression should detect mixed class values, got ' .. nz(everyResult, 'NIL'))

   local nestedResult = xml.getKey('if (some $g in /root/group, $item in $g/item satisfies $item/@id = "c") then "found" else "missing"')
   assert(nestedResult == 'found', 'Nested quantified expression should locate item c, got ' .. nz(nestedResult, 'NIL'))
end

-----------------------------------------------------------------------------------------------------------------------
-- For expressions with multiple bindings should iterate nested sequences

function testForExpressionMultipleBindings()
   local xml = obj.new("xml", {
      statement = '<root><group name="one"><item id="a" class="one"/><item id="b" class="two"/></group><group name="two"><item id="c" class="two"/><item id="d" class="one"/></group></root>'
   })

   local matched = {}
   local err = xml.mtFindTag('for $group in /root/group, $item in $group/item[@class=$group/@name] return $item', function(XML, TagID)
      local errAttr, idValue = xml.mtGetAttrib(TagID, 'id')
      assert(errAttr == ERR_Okay, 'Multi-binding for expression callback should resolve item id: ' .. mSys.GetErrorMsg(errAttr))
      table.insert(matched, idValue)
   end)

   assert(err == ERR_Okay, 'Multi-binding for expression evaluation should succeed: ' .. mSys.GetErrorMsg(err))
   table.sort(matched)
   assert(#matched == 2 and matched[1] == 'a' and matched[2] == 'c', 'Multi-binding for expression should filter matching ids, got ' .. table.concat(matched, ','))
end

-----------------------------------------------------------------------------------------------------------------------
return {
   tests = {
      'testDeeplyNestedPathTraversal', 'testSequentialPredicateEvaluation', 'testRelativeCurrentNodeTraversal',
      'testMissingPathError', 'testDescendantAxisAttributeAccess', 'testConditionalIfExpression', 'testForExpressionNodeAggregation',
      'testQuantifiedExpressions', 'testForExpressionMultipleBindings'
   }
}
