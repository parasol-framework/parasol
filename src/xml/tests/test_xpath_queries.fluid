-- Comprehensive XPath query tests

   include 'xml'

-----------------------------------------------------------------------------------------------------------------------
-- Test basic XPath navigation

function testBasicXPath()
   local xml = obj.new("xml", {
      statement = '<root><level1><level2><target>Found</target></level2></level1></root>'
   })

   -- Test absolute path
   local err, targetId = xml.mtFindTag('/root/level1/level2/target')
   assert(err == ERR_Okay, "Failed to find target with absolute path: " .. mSys.GetErrorMsg(err))

   local err, tag = xml.mtGetTag(targetId)
   assert(err == ERR_Okay, "Failed to get target tag")
   assert(tag.children[1].attribs[1].value == "Found", "Target content incorrect")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test attribute matching with [@attribute] syntax

function testAttributeMatching()
   local xml = obj.new("xml", {
      statement = '<root><item type="book" title="Guide"/><item type="magazine" title="News"/><item type="book" title="Manual"/></root>'
   })

   -- Find items with type="book"
   local bookCount = 0
   local err, index = xml.mtFindTag('/root/item[@type="book"]', function(XML, TagID, Attrib)
      bookCount = bookCount + 1
      local err, tag = xml.mtGetTag(TagID)
      assert(err == ERR_Okay, "Failed to get book tag")

      local err, typeValue = xml.mtGetAttrib(TagID, 'type')
      assert(err == ERR_Okay and typeValue == "book", "Book type attribute incorrect")
   end)

   assert(bookCount == 2, "Expected 2 books, found " .. bookCount)
end

-----------------------------------------------------------------------------------------------------------------------
-- Test attribute existence predicate [@attr] and wildcard attribute name [@*="value"]

function testAttributePredicateExistence()
   local xml = obj.new("xml", {
      statement = '<root><section title="Test" note="alpha"/><section/><section title="Other"/></root>'
   })

   -- Existence predicate
   local err, id = xml.mtFindTag('/root/section[@title]')
   assert(err == ERR_Okay, "Attribute existence predicate should find a section with title")

   -- Non-existing attribute should not match
   err, id = xml.mtFindTag('/root/section[@missing]')
   assert(err != ERR_Okay, "Missing attribute existence should not match")

   -- Wildcard attribute name matches any attribute with given value
   err, id = xml.mtFindTag('/root/section[@*="alpha"]')
   assert(err == ERR_Okay, "Wildcard attribute name should match any attribute with value")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test indexed access with [position] syntax

function testIndexedAccess()
   local xml = obj.new("xml", {
      statement = '<root><item>First</item><item>Second</item><item>Third</item></root>'
   })

   -- Test first item (1-based indexing)
   local err, firstId = xml.mtFindTag('/root/item[1]')
   assert(err == ERR_Okay, "Failed to find first item: " .. mSys.GetErrorMsg(err))

   local err, tag = xml.mtGetTag(firstId)
   assert(err == ERR_Okay, "Failed to get first tag")
   assert(tag.children[1].attribs[1].value == "First", "First item content incorrect")

   -- Test third item
   local err, thirdId = xml.mtFindTag('/root/item[3]')
   assert(err == ERR_Okay, "Failed to find third item: " .. mSys.GetErrorMsg(err))

   local err, tag = xml.mtGetTag(thirdId)
   assert(err == ERR_Okay, "Failed to get third tag")
   assert(tag.children[1].attribs[1].value == "Third", "Third item content incorrect")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test deep scanning with double-slash (//) syntax

function testDeepScanning()
   local xml = obj.new("xml", {
      statement = '<root><section><subsection><target id="1"/></subsection></section><othersection><target id="2"/></othersection></root>'
   })

   -- Find all target elements anywhere in document
   local targetCount = 0
   local foundIds = {}
   local err, index = xml.mtFindTag('//target', function(XML, TagID, Attrib)
      targetCount = targetCount + 1
      local err, idValue = xml.mtGetAttrib(TagID, 'id')
      assert(err == ERR_Okay, "Failed to get target id")
      table.insert(foundIds, idValue)
   end)

   assert(targetCount == 2, "Expected 2 targets, found " .. targetCount)
   assert(table.contains(foundIds, "1") and table.contains(foundIds, "2"), "Target IDs not found correctly")
end

-- Ensure deep scan mid-path currently fails gracefully: /root//target

function testDeepScanMidPath()
   local xml = obj.new("xml", {
      statement = '<root><section><subsection><target id="a"/></subsection></section><othersection><target id="b"/></othersection></root>'
   })

   local err, id = xml.mtFindTag('/root//target')
   assert(err == ERR_Okay, "/root//target failed")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test wildcard matching with * syntax

function testWildcardMatching()
   local xml = obj.new("xml", {
      statement = '<root><item1/><item2/><item3/><other/></root>'
   })

   -- Find all children of root
   local childCount = 0
   local err, index = xml.mtFindTag('/root/*', function(XML, TagID, Attrib)
      childCount = childCount + 1
   end)

   assert(childCount == 4, "Expected 4 children, found " .. childCount)
end

-----------------------------------------------------------------------------------------------------------------------
-- Test content matching (Parasol extension)

function testContentMatching()
   local xml = obj.new("xml", {
      statement = '<root><item>apple</item><item>banana</item><item>apple pie</item></root>'
   })

   -- Find items containing "apple"
   local appleCount = 0
   local err, index = xml.mtFindTag('/root/item(=apple)', function(XML, TagID, Attrib)
      appleCount = appleCount + 1
   end)

   assert(appleCount >= 1, "Expected at least 1 apple item, found " .. appleCount)

   -- Wildcard content match

   appleCount = 0
   err, index = xml.mtFindTag('/root/item[=apple*]', function(XML, TagID, Attrib)
      appleCount = appleCount + 1
   end)
   assert(appleCount == 2, "Wildcard content matching should find 2 items, found " .. appleCount)

   -- Square bracket predicates should also support content equality
   local bananaErr, bananaId = xml.mtFindTag('/root/item[=banana]')
   assert(bananaErr == ERR_Okay, "[=value] predicate should locate the banana item")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test attribute extraction with @ syntax

function testAttributeExtraction()
   local xml = obj.new("xml", {
      statement = '<root><book title="Guide" author="Smith"/></root>'
   })

   -- Extract title attribute value
   local titleValue = xml.getKey('/root/book/@title')
   assert(titleValue == "Guide", "Title attribute extraction failed")

   -- Extract author attribute value
   local authorValue = xml.getKey('/root/book/@author')
   assert(authorValue == "Smith", "Author attribute extraction failed")

   -- Wildcard attribute name in predicate: matches any attribute value
   local err, id = xml.mtFindTag('/root/book[@*="Smith"]')
   assert(err == ERR_Okay, "Wildcard attribute name predicate should match on any attribute")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test count operations

function testCountOperations()
   local xml = obj.new("xml", {
      statement = '<root><section><item/><item/><item/></section><section><item/></section></root>'
   })

   -- Count all items
   local totalItems = tonumber(xml.getKey('count://item'))
   assert(totalItems == 4, "Expected 4 total items, got " .. totalItems)

   -- Count items in first section
   local firstSectionItems = tonumber(xml.getKey('count:/root/section[1]/item'))
   assert(firstSectionItems == 3, "Expected 3 items in first section, got " .. firstSectionItems)
end

-----------------------------------------------------------------------------------------------------------------------
-- Test exists operations

function testExistsOperations()
   local xml = obj.new("xml", {
      statement = '<root><section title="Test"><item/></section></root>'
   })

   -- Test element existence
   local sectionExists = xml.getKey('exists:/root/section')
   assert(sectionExists == "1", "Section should exist")

   local missingExists = xml.getKey('exists:/root/missing')
   assert(missingExists == "0", "Missing element should not exist")

   -- Test attribute existence
   local titleExists = xml.getKey('exists:/root/section/@title')
   assert(titleExists == "1", "Title attribute should exist")

   local missingAttrExists = xml.getKey('exists:/root/section/@missing')
   assert(missingAttrExists == "0", "Missing attribute should not exist")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test content extraction operations

function testContentExtraction()
   local xml = obj.new("xml", {
      statement = '<root><section>Direct content <em>emphasized</em> more content</section></root>'
   })

   -- Test immediate content extraction (excludes nested tags)
   local immediateContent = xml.getKey('/root/section')
   assert(string.find(immediateContent, "Direct content"), "Immediate content not extracted")
   assert(string.find(immediateContent, "more content"), "Trailing content not extracted")

   -- Test deep content extraction
   local deepContent = xml.getKey('content:/root/section')
   assert(string.find(deepContent, "emphasized"), "Deep content not extracted")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test extract operations (XML serialization)

function testExtractOperations()
   local xml = obj.new("xml", {
      statement = '<root><section><item id="1">Content</item></section></root>'
   })

   -- Extract XML for specific element
   local extractedXML = xml.getKey('extract:/root/section/item')
   assert(string.find(extractedXML, 'id="1"'), "Extracted XML is missing attributes: " .. nz(extractedXML,'NIL'))
   assert(string.find(extractedXML, "Content"), "Extracted XML is missing content" .. nz(extractedXML,'NIL'))
end

-----------------------------------------------------------------------------------------------------------------------
-- Test complex XPath expressions

function testComplexExpressions()
   local xml = obj.new("xml", {
      statement = '<root><products><product category="electronics" price="100"/><product category="books" price="20"/><product category="electronics" price="50"/></products></root>'
   })

   -- Find electronics products
   local electronicsCount = 0
   local err, index = xml.mtFindTag('/root/products/product[@category="electronics"]', function(XML, TagID, Attrib)
      electronicsCount = electronicsCount + 1
   end)

   assert(electronicsCount == 2, "Expected 2 electronics products, found " .. electronicsCount)
end

-----------------------------------------------------------------------------------------------------------------------
-- Test namespace support (XPath 1.0 feature)

function testNamespaceSupport()
   local xml = obj.new("xml", {
      statement = '<root xmlns:book="http://books.com" xmlns:mag="http://magazines.com"><book:item title="Guide"/><mag:item title="News"/></root>'
   })

   -- Test namespace-aware matching (currently supported)
   local bookCount = 0
   local err, index = xml.mtFindTag('/root/book:item', function(XML, TagID, Attrib)
      bookCount = bookCount + 1
   end)

   if err == ERR_Okay then
      assert(bookCount >= 0, "Namespace matching should work or gracefully fail")
   end
end

-----------------------------------------------------------------------------------------------------------------------
-- Regression: prefixed node steps should resolve correctly

function testNamespacePrefixedSteps()
   local xml = obj.new("xml", {
      statement = '<root xmlns:book="http://books.com"><book:item title="Guide"/></root>'
   })

   local err, tagId = xml.mtFindTag('/root/book:item')
   assert(err == ERR_Okay, "Prefixed node steps should locate namespaced elements (bug: parser drops local name)")

   local err, title = xml.mtGetAttrib(tagId, 'title')
   assert(err == ERR_Okay and title == 'Guide', "Namespaced element should remain addressable by prefix")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test parent axis (..) navigation

function testParentAxisNavigation()
   local xml = obj.new("xml", {
      statement = '<root><section id="1"><item id="a"/><item id="b"/></section><section id="2"><item id="c"/></section></root>'
   })

   -- Test parent navigation (currently supported)
   local err, parentId = xml.mtFindTag('/root/section/item[@id="a"]/..')
   if err == ERR_Okay then
      local err, sectionId = xml.mtGetAttrib(parentId, 'id')
      assert(err == ERR_Okay and sectionId == "1", "Parent navigation should return section with id=1")
   end
end

-----------------------------------------------------------------------------------------------------------------------
-- Test attribute wildcard matching

function testAttributeWildcards()
   local xml = obj.new("xml", {
      statement = '<root><item type="book" title="Guide"/><item type="magazine" title="News"/></root>'
   })

   -- Test wildcard in attribute values (currently supported in string-based evaluator when available)
   local err, itemId = xml.mtFindTag('/root/item[@type="bo*"]')
   if err == ERR_Okay then
      local attrErr, typeValue = xml.mtGetAttrib(itemId, 'type')
      assert(attrErr == ERR_Okay and typeValue == "book", "Wildcard attribute predicate should return the matching node")
   else
      assert(err == ERR_Search, "Wildcard attribute predicates should fail gracefully when not implemented")
   end

   -- Attribute existence without a value should be accepted
   local existsErr, existsId = xml.mtFindTag('/root/item[@title]')
   assert(existsErr == ERR_Okay, "Attribute existence predicate [@title] should succeed")

   -- Attribute name wildcards (@*) should match any attribute name using the provided pattern
   local nameWildErr, titledId = xml.mtFindTag('/root/item[@*="Gu*"]')
   if nameWildErr == ERR_Okay then
      local _, titleValue = xml.mtGetAttrib(titledId, 'title')
      assert(titleValue == "Guide", "Wildcard name predicate should still point at the correct node")
   else
      assert(nameWildErr == ERR_Search, "Attribute name wildcard should fall back to a search error when unsupported")
   end
end

-----------------------------------------------------------------------------------------------------------------------
-- Regression: Function predicates should receive node-set arguments

function testFunctionPredicateNodeSets()
   local xml = obj.new("xml", {
      statement = '<root><item/><item/><item/></root>'
   })

   local err, rootId = xml.mtFindTag('/root[count(item)=3]')
   assert(err == ERR_Okay, "count(item)=3 predicate should evaluate with node-set arguments (bug: identifiers become literals)")

   local err, result = xml.mtFindTag('/root[count(item)=2]')
   assert(err == ERR_Search, "count(item)=2 predicate should not match when the function result is false")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test XPath 1.0 functions

function testXPathFunctions()
   local xml = obj.new("xml", {
      statement = '<root><item>1</item><item>2</item><item>3</item></root>'
   })

   local err, itemId = xml.mtFindTag('/root/item[position()=2]')
   assert(err == ERR_Okay, "/root/item[position()=2] failed")

   err, itemId = xml.mtFindTag('/root/item[position()=last()]')
   assert(err == ERR_Okay, "/root/item[position()=last()] failed")

   err, itemId = xml.mtFindTag('/root/item[last()]')
   assert(err == ERR_Okay, "last() predicate should select the final item")
   local err2, lastTag = xml.mtGetTag(itemId)
   assert(err2 == ERR_Okay and lastTag.children[1].attribs[1].value == '3', "last() predicate should locate the third entry")

   err, itemId = xml.mtFindTag('/root[count(item)>2]')
   assert(err == ERR_Okay, "count(item)>2 should succeed when AST evaluation is active")
   assert(itemId != 0, "count(item)>2 should return a valid node identifier")

   -- Test text() node test (XPath 1.0 - not supported yet)
   --local err, itemId = xml.mtFindTag('/root/item[text()="2"]')
   --assert(err == ERR_Okay, 'text()="2" failed')
end

-----------------------------------------------------------------------------------------------------------------------
-- Regression: Numeric position predicates should honour requested index

function testNumericPositionPredicates()
   local xml = obj.new("xml", {
      statement = '<root><item>First</item><item>Second</item><item>Third</item></root>'
   })

   local err, secondId = xml.mtFindTag('/root/item[2]')
   assert(err == ERR_Okay, "item[2] should return the second node (bug: predicate currently hard-codes index==1)")

   local err, tag = xml.mtGetTag(secondId)
   assert(err == ERR_Okay and tag.children[1].attribs[1].value == 'Second', "item[2] should locate the 'Second' entry")
end

-----------------------------------------------------------------------------------------------------------------------

-- Test XPath 1.0 boolean operators
function testBooleanOperators()
   local xml = obj.new("xml", {
      statement = '<root><product price="100" category="electronics"/><product price="50" category="books"/></root>'
   })

   local err, productId = xml.mtFindTag('/root/product[@price="100" and @category="electronics"]')
   assert(err == ERR_Okay, "'and' operator should locate the product with matching price and category")
   local err2, category = xml.mtGetAttrib(productId, 'category')
   assert(err2 == ERR_Okay and category == 'electronics', "'and' operator should return the electronics product")

   err, productId = xml.mtFindTag('/root/product[@category="books" or @category="electronics"]')
   assert(err == ERR_Okay, "'or' operator should locate a matching product")
   err2, category = xml.mtGetAttrib(productId, 'category')
   assert(err2 == ERR_Okay and category == 'electronics', "'or' operator should prioritise the first matching product")

   err, productId = xml.mtFindTag('/root/product[not(@category="books")]')
   assert(err == ERR_Okay, "'not()' should exclude the books category and return the electronics product")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test XPath 1.0 comparison operators

function testComparisonOperators()
   local xml = obj.new("xml", {
      statement = '<root><item value="10"/><item value="20"/><item value="30"/></root>'
   })

   local err, itemId = xml.mtFindTag('/root/item[@value > 15]')
   assert(err == ERR_Okay, "Greater than operator should locate the first item above the threshold")
   local err2, value = xml.mtGetAttrib(itemId, 'value')
   assert(err2 == ERR_Okay and value == '20', "@value > 15 should return the item with value 20")

   err, itemId = xml.mtFindTag('/root/item[@value < 25]')
   assert(err == ERR_Okay, "Less than operator should locate an item below the threshold")
   err2, value = xml.mtGetAttrib(itemId, 'value')
   assert(err2 == ERR_Okay and value == '10', "@value < 25 should return the item with value 10")

   err, itemId = xml.mtFindTag('/root/item[@value >= 20]')
   assert(err == ERR_Okay, "Greater than or equal operator should locate a matching item")
   err2, value = xml.mtGetAttrib(itemId, 'value')
   assert(err2 == ERR_Okay and value == '20', "@value >= 20 should return the item with value 20")

   err, itemId = xml.mtFindTag('/root/item[@value != "10"]')
   assert(err == ERR_Okay, "Not equal operator should locate an item different from the provided value")
   err2, value = xml.mtGetAttrib(itemId, 'value')
   assert(err2 == ERR_Okay and value == '20', "@value != 10 should return the first item whose value is not 10")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test XPath 1.0 mathematical expressions

function testMathematicalExpressions()
   local xml = obj.new("xml", {
      statement = '<root><item price="100" tax="10"/><item price="200" tax="20"/></root>'
   })

   -- Test arithmetic addition
   local err, itemId = xml.mtFindTag('/root/item[@price + @tax = 110]')
   assert(err == ERR_Okay, 'Addition predicate should locate matching item: ' .. mSys.GetErrorMsg(err))
   local err2, price = xml.mtGetAttrib(itemId, 'price')
   assert(err2 == ERR_Okay and price == '100', 'Addition predicate should return the first item')

   -- Test arithmetic multiplication
   err, itemId = xml.mtFindTag('/root/item[@price * 2 = 200]')
   assert(err == ERR_Okay, 'Multiplication predicate should locate matching item: ' .. mSys.GetErrorMsg(err))
   err2, price = xml.mtGetAttrib(itemId, 'price')
   assert(err2 == ERR_Okay and price == '100', 'Multiplication predicate should return the first item')

   -- Test arithmetic subtraction
   err, itemId = xml.mtFindTag('/root/item[@price - @tax = 90]')
   assert(err == ERR_Okay, 'Subtraction predicate should locate matching item: ' .. mSys.GetErrorMsg(err))
   err2, price = xml.mtGetAttrib(itemId, 'price')
   assert(err2 == ERR_Okay and price == '100', 'Subtraction predicate should return the first item')

   -- Test arithmetic division
   err, itemId = xml.mtFindTag('/root/item[@price div 2 = 50]')
   assert(err == ERR_Okay, 'Division predicate should locate matching item: ' .. mSys.GetErrorMsg(err))
   err2, price = xml.mtGetAttrib(itemId, 'price')
   assert(err2 == ERR_Okay and price == '100', 'Division predicate should return the first item')

   -- Test arithmetic modulo
   err, itemId = xml.mtFindTag('/root/item[@price mod 90 = 10]')
   assert(err == ERR_Okay, 'Modulo predicate should locate matching item: ' .. mSys.GetErrorMsg(err))
   err2, price = xml.mtGetAttrib(itemId, 'price')
   assert(err2 == ERR_Okay and price == '100', 'Modulo predicate should return the first item')
end

-----------------------------------------------------------------------------------------------------------------------
-- Regression: Attribute filters should allow broader XML name syntax

function testAttributeNameVariants()
   local xml = obj.new("xml", {
      statement = '<root><item data-id="123" xml:lang="en" version1="yes"/></root>'
   })

   local err, dataId = xml.mtFindTag('/root/item[@data-id="123"]')
   assert(err == ERR_Okay, "Attribute names containing hyphens should parse (bug: tokenizer rejects '-')")

   local err, langId = xml.mtFindTag('/root/item[@xml:lang="en"]')
   assert(err == ERR_Okay, "Attribute names with namespace prefixes should parse")

   local err, versionId = xml.mtFindTag('/root/item[@version1]')
   assert(err == ERR_Okay, "Attribute names containing digits should be accepted")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test XPath 1.0 axes (NOT YET SUPPORTED)

function testXPathAxes()
   local xml = obj.new("xml", {
      statement = '<root><section><item id="1"/><item id="2"/></section><other><item id="3"/></other></root>'
   })

   -- Test following-sibling axis (XPath 1.0 - not supported yet)
   local err, itemId = xml.mtFindTag('/root/section/item[@id="1"]/following-sibling::item')
   assert(err != ERR_Okay, "following-sibling axis should not be supported yet")

   -- Test preceding-sibling axis (XPath 1.0 - not supported yet)
   local err, itemId = xml.mtFindTag('/root/section/item[@id="2"]/preceding-sibling::item')
   assert(err != ERR_Okay, "preceding-sibling axis should not be supported yet")

   -- Test ancestor axis (XPath 1.0 - not supported yet)
   local err, itemId = xml.mtFindTag('/root/section/item/ancestor::root')
   assert(err != ERR_Okay, "ancestor axis should not be supported yet")

   -- Test descendant axis (XPath 1.0 - not supported yet)
   local err, itemId = xml.mtFindTag('/root/descendant::item[@id="3"]')
   assert(err != ERR_Okay, "descendant axis should not be supported yet")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test XPath 1.0 union operator

function testUnionOperator()
   local xml = obj.new("xml", {
      statement = '<root><section><item/></section><other><item/></other></root>'
   })

   assert(xml.mtFindTag('/root/section/item | /root/other/item') == ERR_Okay)
end

-----------------------------------------------------------------------------------------------------------------------
-- Test XPath 1.0 variables (NOT YET SUPPORTED)

function testVariables()
   local xml = obj.new("xml", {
      statement = '<root><item id="test"/></root>'
   })

   -- Test variable reference (XPath 1.0 - not supported yet)
   local err, itemId = xml.mtFindTag('/root/item[@id=$testvar]')
   assert(err != ERR_Okay, "Variable references should not be supported yet")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test complex nested predicates

function testComplexNestedPredicates()
   local xml = obj.new("xml", {
      statement = '<library><section name="fiction"><book title="Novel" author="Smith"><chapter num="1">Intro</chapter><chapter num="2">Plot</chapter></book></section></library>'
   })

   -- Test nested bracket expressions with current syntax
   local err, chapterId = xml.mtFindTag('/library/section[@name="fiction"]/book[@author="Smith"]/chapter[@num="2"]')
   assert(err == ERR_Okay, "Complex nested predicates should work with current syntax")

   local err, content = xml.mtGetTag(chapterId)
   assert(err == ERR_Okay, "Should be able to get chapter tag")
end

-----------------------------------------------------------------------------------------------------------------------
-- Regression: Round bracket predicates are deprecated

function testRoundBracketAlternatives()
   local xml = obj.new("xml", {
      statement = '<root><item type="book">Novel</item><item type="magazine">News</item></root>'
   })

   -- XPath 1.0 requires predicates to use square brackets; round brackets should fail
   local err, itemId = xml.mtFindTag('/root/item(@type="book")')
   assert(err == ERR_Search, "Round bracket predicate should be rejected after deprecation")

   err, itemId = xml.mtFindTag('/root/item(="Novel")')
   assert(err == ERR_Search, "Round bracket content predicate should be rejected")

   -- Square bracket predicate remains supported and should continue to succeed
   local squareErr, squareId = xml.mtFindTag('/root/item[@type="book"]')
   assert(squareErr == ERR_Okay, "Square bracket predicate should remain supported")

   local attribErr, typeValue = xml.mtGetAttrib(squareId, 'type')
   assert(attribErr == ERR_Okay and typeValue == "book", "Square bracket predicate should locate the correct item")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test escape characters in attribute strings

function testEscapeCharacters()
   local xml = obj.new("xml", {
      statement = '<root><item title="Simple test" special="asterisk*value"/></root>'
   })

   -- Test basic attribute matching (escaping may not be fully supported yet)
   local err, itemId = xml.mtFindTag('/root/item[@title="Simple test"]')
   assert(err == ERR_Okay, "Basic attribute matching should work")

   -- Test wildcard matching in attribute values
   local err, itemId = xml.mtFindTag('/root/item[@special="asterisk*"]')
   if err == ERR_Okay then
      -- Wildcard matching works
   else
      -- Try exact match instead
      local err, itemId = xml.mtFindTag('/root/item[@special="asterisk*value"]')
      assert(err == ERR_Okay, "Exact attribute matching should work")
   end

   -- Escaped wildcard should be treated literally

   local err, itemId = xml.mtFindTag('/root/item[@special="asterisk\\*value"]')
   assert(err == ERR_Okay, "Escaped wildcard should match literal asterisk in value")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test edge cases and error conditions

function testEdgeCases()
   local xml = obj.new("xml", {
      statement = '<root><empty/><selfclosing attr="value"/><nested><deep><deeper>content</deeper></deep></nested></root>'
   })

   -- Test empty element access
   local err, emptyId = xml.mtFindTag('/root/empty')
   assert(err == ERR_Okay, "Should be able to find empty elements")

   -- Test self-closing element with attributes
   local err, selfId = xml.mtFindTag('/root/selfclosing[@attr="value"]')
   assert(err == ERR_Okay, "Should be able to find self-closing elements with attributes")

   -- Test deeply nested elements
   local err, deepId = xml.mtFindTag('/root/nested/deep/deeper')
   assert(err == ERR_Okay, "Should be able to navigate deeply nested elements")

   -- Test invalid XPath syntax
   local err, invalidId = xml.mtFindTag('/root/[invalid]')
   assert(err != ERR_Okay, "Invalid XPath syntax should return error")

   -- Test missing elements
   local err, missingId = xml.mtFindTag('/root/nonexistent')
   assert(err != ERR_Okay, "Missing elements should return search error")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test performance with larger documents

function testPerformanceScenarios()
   -- Build a larger XML document for performance testing
   local xmlContent = '<root>'
   for i = 1, 50 do  -- Reduced from 100 to 50 for faster testing
      xmlContent = xmlContent .. '<section id="' .. i .. '">'
      for j = 1, 5 do  -- Reduced from 10 to 5 for faster testing
         xmlContent = xmlContent .. '<item type="' .. (j % 3 == 0 and "special" or "normal") .. '" value="' .. (i * 10 + j) .. '">Content ' .. i .. '.' .. j .. '</item>'
      end
      xmlContent = xmlContent .. '</section>'
   end
   xmlContent = xmlContent .. '</root>'

   local xml = obj.new("xml", { statement = xmlContent })

   -- Test deep scanning functionality (without timing)
   local specialCount = 0
   local err, index = xml.mtFindTag('//item[@type="special"]', function(XML, TagID, Attrib)
      specialCount = specialCount + 1
   end)

   assert(err == ERR_Okay, "Deep scanning should work on larger documents")
   assert(specialCount > 0, "Should find special items in large document")

   -- Test that we found the expected number of special items
   -- Every 3rd item (j=3) in each section should be special
   local expectedSpecialCount = 50  -- 50 sections * 1 special item per section
   assert(specialCount == expectedSpecialCount, "Expected " .. expectedSpecialCount .. " special items, found " .. specialCount)
end

-----------------------------------------------------------------------------------------------------------------------
-- Test Phase 3 Function Library Infrastructure

function testPhase3FunctionLibrary()
   -- Test that the Phase 3 XPath function library infrastructure is in place
   -- These tests verify basic functionality without requiring full AST evaluation

   local xml = obj.new("xml", {
      statement = [[
         <library>
            <books>
               <book id="1" rating="4.5">Programming Pearls</book>
               <book id="2" rating="5.0">The Art of Computer Programming</book>
               <book id="3" rating="4.2">Clean Code</book>
            </books>
            <authors count="3">
               <author name="Jon Bentley">Author bio content</author>
               <author name="Donald Knuth">Mathematician and computer scientist</author>
               <author name="Robert Martin">Clean code advocate</author>
            </authors>
         </library>
      ]]
   })

   -- Test that basic XPath functionality continues to work with Phase 3 infrastructure

   local bookContent = xml.getKey('content:/library/books/book[@id="2"]')
   assert(bookContent, "Book should have content")

   -- Test content extraction (important for function library string operations)
   local authorContent = xml.getKey('content:/library/authors/author[@name="Donald Knuth"]')
   assert(authorContent, "Author should have content")

   -- Test navigation to container elements (important for node-set functions)
   err, authorsId = xml.mtFindTag('/library/authors')
   assert(err == ERR_Okay, "Should navigate to authors container")

   local err, authorsTag = xml.mtGetTag(authorsId)
   assert(authorsTag, "Should retrieve authors container")

   -- Verify multiple child access patterns work
   local childCount = 0
   xml.mtFindTag('/library/authors/author', function(XML, TagID, Attrib)
      childCount = childCount + 1
   end)
   assert(childCount == 3, "Should find all 3 authors, found " .. childCount)

   -- Test that wildcards work (important for node matching in functions)
   local allCount = 0
   xml.mtFindTag('/library/*/author', function(XML, TagID, Attrib)
      allCount = allCount + 1
   end)
   assert(allCount == 3, "Wildcard matching should find 3 authors, found " .. allCount)
end

-----------------------------------------------------------------------------------------------------------------------
-- Test Phase 4: Operators and Expressions

function testXPathOperators()
   local xml = obj.new("xml", {
      statement = [[
         <root>
            <numbers>
               <value>10</value>
               <value>20</value>
               <value>30</value>
               <value>5</value>
            </numbers>
            <books>
               <book id="1" rating="4.5" year="2020">Programming Pearls</book>
               <book id="2" rating="5.0" year="2019">The Art of Computer Programming</book>
               <book id="3" rating="4.2" year="2021">Clean Code</book>
               <book id="4" rating="3.8" year="2020">Refactoring</book>
            </books>
            <status enabled="true">active</status>
            <status enabled="false">inactive</status>
         </root>
      ]]
   })

   -- Test Boolean Operators (and, or)
   -- Note: These will currently fail since we need proper AST evaluation for complex expressions
   -- But we verify the parser doesn't crash
   local err, id = xml.mtFindTag('/root/books/book[@rating="5.0" and @year="2019"]')
   -- assert(err == ERR_Okay, "Boolean AND operator should work")

   err, id = xml.mtFindTag('/root/books/book[@rating="5.0" or @year="2021"]')
   -- assert(err == ERR_Okay, "Boolean OR operator should work")

   -- Test Comparison Operators
   err, id = xml.mtFindTag('/root/books/book[@id!="1"]')
   -- assert(err == ERR_Okay, "Not equals operator should work")

   err, id = xml.mtFindTag('/root/numbers/value[text()>"15"]')
   -- assert(err == ERR_Okay, "Greater than operator should work")

   err, id = xml.mtFindTag('/root/numbers/value[text()<="20"]')
   -- assert(err == ERR_Okay, "Less than or equal operator should work")

   -- Test Arithmetic Operators (basic parsing validation)
   -- These should parse without error even if not fully evaluated
   err, id = xml.mtFindTag('/root/numbers/value[position()+1=2]')
   -- assert(err == ERR_Okay, "Addition operator should parse")

   err, id = xml.mtFindTag('/root/numbers/value[position()-1=0]')
   -- assert(err == ERR_Okay, "Subtraction operator should parse")

   err, id = xml.mtFindTag('/root/numbers/value[position()*2=4]')
   -- assert(err == ERR_Okay, "Multiplication operator should parse")

   -- Test that parser accepts these expressions without crashing
   print("Phase 4 operator parsing tests completed - parser accepts complex expressions")
end

function testXPathExpressions()
   local xml = obj.new("xml", {
      statement = [[
         <library>
            <section name="fiction">
               <book title="1984" pages="328">George Orwell</book>
               <book title="Brave New World" pages="268">Aldous Huxley</book>
            </section>
            <section name="technical">
               <book title="Clean Code" pages="464">Robert Martin</book>
               <book title="Design Patterns" pages="395">Gang of Four</book>
            </section>
         </library>
      ]]
   })

   -- Test that complex expressions don't crash the parser
   local err, id = xml.mtFindTag('/library/section[@name="fiction"]/book[contains(@title,"1984")]')
   -- Future: should work when function calls are fully integrated

   err, id = xml.mtFindTag('/library/section[position()>1]/book[@pages>"400"]')
   -- Future: should work when position() and comparison work together

   -- Test union operator syntax (parsing validation)
   err, id = xml.mtFindTag('/library/section[@name="fiction"]/book | /library/section[@name="technical"]/book')
   -- Future: union operator should combine node sets

   print("Phase 4 expression parsing tests completed")
end

function testXPathArithmetic()
   local xml = obj.new("xml", {
      statement = [[
         <math>
            <numbers>
               <num>10</num>
               <num>20</num>
               <num>30</num>
            </numbers>
            <calculations>
               <result value="15">Addition result</result>
               <result value="100">Multiplication result</result>
               <result value="5">Division result</result>
            </calculations>
         </math>
      ]]
   })

   -- Test arithmetic in predicates (syntax validation for now)
   local err, id = xml.mtFindTag('/math/calculations/result[@value div 3 = 5]')
   -- Future: division operator should work

   err, id = xml.mtFindTag('/math/calculations/result[@value mod 10 = 5]')
   -- Future: modulo operator should work

   err, id = xml.mtFindTag('/math/numbers/num[text() + 5 = 25]')
   -- Future: addition with node values should work

   print("Phase 4 arithmetic parsing tests completed")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test Phase 5: XPath Axes

function testXPathForwardAxes()
   local xml = obj.new("xml", {
      statement = [[
         <library>
            <fiction>
               <book id="1" title="1984">George Orwell</book>
               <book id="2" title="Brave New World">Aldous Huxley</book>
               <review rating="5">Excellent dystopian novel</review>
            </fiction>
            <technical>
               <book id="3" title="Clean Code">Robert Martin</book>
               <book id="4" title="Design Patterns">Gang of Four</book>
               <guide type="tutorial">Getting Started</guide>
            </technical>
            <archive>
               <old-book year="1950">Classic Literature</old-book>
            </archive>
         </library>
      ]]
   })

   -- Test child axis (default axis)
   local childCount = 0
   local err, id = xml.mtFindTag('/library/fiction/book', function(XML, TagID, Attrib)
      childCount = childCount + 1
   end)
   assert(err == ERR_Okay, "Child axis should work (default axis)")
   assert(childCount == 2, "Should find 2 books in fiction section, found " .. childCount)

   -- Test explicit child axis
   childCount = 0
   err, id = xml.mtFindTag('/library/child::fiction/child::book', function(XML, TagID, Attrib)
      childCount = childCount + 1
   end)
   -- Note: This will currently fail as explicit axis support needs AST evaluation
   -- assert(err == ERR_Okay, "Explicit child axis should work")

   -- Test descendant axis (all descendants)
   local descendantCount = 0
   err, id = xml.mtFindTag('/library/descendant::book', function(XML, TagID, Attrib)
      descendantCount = descendantCount + 1
   end)
   -- Note: This will currently fail - descendant axis needs AST evaluation
   -- assert(descendantCount == 4, "Descendant axis should find all 4 books")

   -- Test following-sibling axis
   -- This would test finding siblings after a specific node
   -- Currently requires AST evaluation for explicit axis syntax

   print("Phase 5 forward axes parsing tests completed")
end

function testXPathReverseAxes()
   local xml = obj.new("xml", {
      statement = [[
         <root>
            <section id="1">
               <chapter id="1.1">
                  <paragraph id="1.1.1">First paragraph</paragraph>
                  <paragraph id="1.1.2">Second paragraph</paragraph>
               </chapter>
               <chapter id="1.2">
                  <paragraph id="1.2.1">Third paragraph</paragraph>
               </chapter>
            </section>
            <section id="2">
               <chapter id="2.1">
                  <paragraph id="2.1.1">Fourth paragraph</paragraph>
               </chapter>
            </section>
         </root>
      ]]
   })

   -- Test parent axis (.. syntax already works)
   local err, parentId = xml.mtFindTag('/root/section/chapter[@id="1.1"]/..')
   if err == ERR_Okay then
      local _, sectionId = xml.mtGetAttrib(parentId, 'id')
      assert(sectionId == "1", "Parent axis should land on the surrounding section")
   else
      assert(err == ERR_Search, "Parent axis with .. should either succeed or return a search error")
   end

   -- Test explicit parent axis
   err, parentId = xml.mtFindTag('/root/section/chapter/parent::section')
   -- Note: This will currently fail - explicit parent axis needs AST evaluation
   -- assert(err == ERR_Okay, "Explicit parent axis should work")

   -- Test ancestor axis
   err, ancestorId = xml.mtFindTag('/root/section/chapter/paragraph/ancestor::root')
   -- Note: This will currently fail - ancestor axis needs AST evaluation
   -- assert(err == ERR_Okay, "Ancestor axis should work")

   -- Test preceding-sibling axis
   -- This would find siblings before a specific node
   err, siblingId = xml.mtFindTag('/root/section/chapter[2]/preceding-sibling::chapter')
   -- Note: This will currently fail - preceding-sibling axis needs AST evaluation

   print("Phase 5 reverse axes parsing tests completed")
end

function testXPathAxisCombinations()
   local xml = obj.new("xml", {
      statement = [[
         <document>
            <header>
               <title>Document Title</title>
               <meta name="author">John Doe</meta>
            </header>
            <body>
               <section class="intro">
                  <p>Introduction paragraph</p>
                  <p>Second intro paragraph</p>
               </section>
               <section class="content">
                  <p>Main content paragraph</p>
                  <aside>Side note</aside>
               </section>
            </body>
            <footer>
               <p>Footer content</p>
            </footer>
         </document>
      ]]
   })

   -- Test self axis
   local err, selfId = xml.mtFindTag('/document/body/self::body')
   -- Note: This will currently fail - self axis needs AST evaluation
   -- assert(err == ERR_Okay, "Self axis should work")

   -- Test attribute lookups via @ syntax in combination with descendant scans
   local metaAttr = xml.getKey('/document/header/meta/@name')
   assert(metaAttr == "author", "Attribute extraction should work inside mixed axis queries")

   local attrExistsErr, attrExistsId = xml.mtFindTag('/document/header/meta[@name]')
   assert(attrExistsErr == ERR_Okay, "[@name] predicate should be honoured during combined axis tests")

   -- Test complex axis combinations
   -- Find all paragraphs that are descendants of sections
   local paragraphCount = 0
   err, id = xml.mtFindTag('/document/body/section//p', function(XML, TagID, Attrib)
      paragraphCount = paragraphCount + 1
   end)
   assert(err == ERR_Okay, "Deep scanning should work for paragraph descendants")
   assert(paragraphCount == 3, "Should find 3 paragraphs in sections, found " .. paragraphCount)

   print("Phase 5 axis combination tests completed")
end

-----------------------------------------------------------------------------------------------------------------------

function testSiblingFilteringForNumericPredicates()
   local xml = obj.new("xml", {
      statement = '<root><b/><a id="first"/><a id="second"/></root>'
   })

   local err, secondId = xml.mtFindTag('/root/a[2]')
   assert(err == ERR_Okay, 'XPath [2] should select the second <a> node: ' .. mSys.GetErrorMsg(err))

   local err2, value = xml.mtGetAttrib(secondId, 'id')
   assert(err2 == ERR_Okay and value == 'second', 'Second <a> should have been matched')
end

-----------------------------------------------------------------------------------------------------------------------

return {
   tests = {
      -- Current supported features
      'testBasicXPath', 'testAttributeMatching', 'testIndexedAccess', 'testDeepScanning',
      'testWildcardMatching', 'testContentMatching', 'testAttributeExtraction',
      'testCountOperations', 'testExistsOperations', 'testContentExtraction',
      'testExtractOperations', 'testComplexExpressions', 'testAttributePredicateExistence',
      'testDeepScanMidPath',
      'testExtractOperations', 'testComplexExpressions',

      -- Extended current feature tests
      'testNamespaceSupport', 'testParentAxisNavigation', 'testAttributeWildcards',
      'testNamespacePrefixedSteps', 'testFunctionPredicateNodeSets', 'testNumericPositionPredicates',
      'testAttributeNameVariants',
      'testComplexNestedPredicates', 'testEscapeCharacters',
      'testEdgeCases', 'testPerformanceScenarios',
      'testSiblingFilteringForNumericPredicates',
      'testBooleanOperators', 'testComparisonOperators',

      -- Phase 4: Operators and expressions (parsing validation)
      'testXPathOperators', 'testXPathExpressions', 'testXPathArithmetic',

      -- Phase 5: XPath Axes (parsing validation)
      'testXPathForwardAxes', 'testXPathReverseAxes', 'testXPathAxisCombinations',

      -- XPath 1.0 features not yet supported (should fail gracefully)
      'testXPathFunctions',
      'testMathematicalExpressions', 
      --'testXPathAxes', 
      'testUnionOperator', 
      --'testVariables',

      -- Phase 3 infrastructure verification
      'testPhase3FunctionLibrary'
   },
   init = function(ScriptFolder)
      -- Helper function for table.contains
      table.contains = function(table, element)
         for _, value in pairs(table) do
            if value == element then return true end
         end
         return false
      end
   end,
   cleanup = function()
      -- No cleanup needed
   end
}
