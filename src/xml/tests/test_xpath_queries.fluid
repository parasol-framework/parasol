-- Comprehensive XPath query tests

   include 'xml'

-----------------------------------------------------------------------------------------------------------------------
-- Test basic XPath navigation

function testBasicXPath()
   local xml = obj.new("xml", {
      statement = '<root><level1><level2><target>Found</target></level2></level1></root>'
   })

   -- Test absolute path
   local err, targetId = xml.mtFindTag('/root/level1/level2/target')
   assert(err == ERR_Okay, "Failed to find target with absolute path: " .. mSys.GetErrorMsg(err))

   local err, tag = xml.mtGetTag(targetId)
   assert(err == ERR_Okay, "Failed to get target tag")
   assert(tag.children[1].attribs[1].value == "Found", "Target content incorrect")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test attribute matching with [@attribute] syntax

function testAttributeMatching()
   local xml = obj.new("xml", {
      statement = '<root><item type="book" title="Guide"/><item type="magazine" title="News"/><item type="book" title="Manual"/></root>'
   })

   -- Find items with type="book"
   local bookCount = 0
   local err, index = xml.mtFindTag('/root/item[@type="book"]', function(XML, TagID, Attrib)
      bookCount = bookCount + 1
      local err, tag = xml.mtGetTag(TagID)
      assert(err == ERR_Okay, "Failed to get book tag")

      local err, typeValue = xml.mtGetAttrib(TagID, 'type')
      assert(err == ERR_Okay and typeValue == "book", "Book type attribute incorrect")
   end)

   assert(bookCount == 2, "Expected 2 books, found " .. bookCount)
end

-----------------------------------------------------------------------------------------------------------------------
-- Test attribute existence predicate [@attr] and wildcard attribute name [@*="value"]

function testAttributePredicateExistence()
   local xml = obj.new("xml", {
      statement = '<root><section title="Test" note="alpha"/><section/><section title="Other"/></root>'
   })

   -- Existence predicate
   local err, id = xml.mtFindTag('/root/section[@title]')
   assert(err == ERR_Okay, "Attribute existence predicate should find a section with title")

   -- Non-existing attribute should not match
   err, id = xml.mtFindTag('/root/section[@missing]')
   assert(err != ERR_Okay, "Missing attribute existence should not match")

   -- Wildcard attribute name matches any attribute with given value
   err, id = xml.mtFindTag('/root/section[@*="alpha"]')
   assert(err == ERR_Okay, "Wildcard attribute name should match any attribute with value")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test indexed access with [position] syntax

function testIndexedAccess()
   local xml = obj.new("xml", {
      statement = '<root><item>First</item><item>Second</item><item>Third</item></root>'
   })

   -- Test first item (1-based indexing)
   local err, firstId = xml.mtFindTag('/root/item[1]')
   assert(err == ERR_Okay, "Failed to find first item: " .. mSys.GetErrorMsg(err))

   local err, tag = xml.mtGetTag(firstId)
   assert(err == ERR_Okay, "Failed to get first tag")
   assert(tag.children[1].attribs[1].value == "First", "First item content incorrect")

   -- Test third item
   local err, thirdId = xml.mtFindTag('/root/item[3]')
   assert(err == ERR_Okay, "Failed to find third item: " .. mSys.GetErrorMsg(err))

   local err, tag = xml.mtGetTag(thirdId)
   assert(err == ERR_Okay, "Failed to get third tag")
   assert(tag.children[1].attribs[1].value == "Third", "Third item content incorrect")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test deep scanning with double-slash (//) syntax

function testDeepScanning()
   local xml = obj.new("xml", {
      statement = '<root><section><subsection><target id="1"/></subsection></section><othersection><target id="2"/></othersection></root>'
   })

   -- Find all target elements anywhere in document
   local targetCount = 0
   local foundIds = {}
   local err, index = xml.mtFindTag('//target', function(XML, TagID, Attrib)
      targetCount = targetCount + 1
      local err, idValue = xml.mtGetAttrib(TagID, 'id')
      assert(err == ERR_Okay, "Failed to get target id")
      table.insert(foundIds, idValue)
   end)

   assert(targetCount == 2, "Expected 2 targets, found " .. targetCount)
   assert(table.contains(foundIds, "1") and table.contains(foundIds, "2"), "Target IDs not found correctly")
end

-- Ensure deep scan mid-path currently fails gracefully: /root//target

function testDeepScanMidPath()
   local xml = obj.new("xml", {
      statement = '<root><section><subsection><target id="a"/></subsection></section><othersection><target id="b"/></othersection></root>'
   })

   local err, id = xml.mtFindTag('/root//target')
   assert(err == ERR_Okay, "/root//target failed")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test wildcard matching with * syntax

function testWildcardMatching()
   local xml = obj.new("xml", {
      statement = '<root><item1/><item2/><item3/><other/></root>'
   })

   -- Find all children of root
   local childCount = 0
   local err, index = xml.mtFindTag('/root/*', function(XML, TagID, Attrib)
      childCount = childCount + 1
   end)

   assert(childCount == 4, "Expected 4 children, found " .. childCount)
end

-----------------------------------------------------------------------------------------------------------------------
-- Test content matching (Parasol extension)

function testContentMatching()
   local xml = obj.new("xml", {
      statement = '<root><item>apple</item><item>banana</item><item>apple pie</item></root>'
   })

   -- Find items containing "apple"
   local appleCount = 0
   local err, index = xml.mtFindTag('/root/item[=apple]', function(XML, TagID, Attrib)
      appleCount = appleCount + 1
   end)

   assert(appleCount >= 1, "Expected at least 1 apple item, found " .. appleCount)

   -- Wildcard content match

   appleCount = 0
   err, index = xml.mtFindTag('/root/item[=apple*]', function(XML, TagID, Attrib)
      appleCount = appleCount + 1
   end)
   assert(appleCount == 2, "Wildcard content matching should find 2 items, found " .. appleCount)

   -- Square bracket predicates should also support content equality
   local bananaErr, bananaId = xml.mtFindTag('/root/item[=banana]')
   assert(bananaErr == ERR_Okay, "[=value] predicate should locate the banana item")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test attribute extraction with @ syntax

function testAttributeExtraction()
   local xml = obj.new("xml", {
      statement = '<root><book title="Guide" author="Smith"/></root>'
   })

   -- Extract title attribute value
   local err, bookId = xml.mtFindTag('/root/book')
   assert(err == ERR_Okay, "Should locate the book element for attribute extraction")

   local titleErr, titleValue = xml.mtGetAttrib(bookId, 'title')
   assert(titleErr == ERR_Okay and titleValue == "Guide", "Title attribute extraction failed")

   -- Extract author attribute value
   local authorErr, authorValue = xml.mtGetAttrib(bookId, 'author')
   assert(authorErr == ERR_Okay and authorValue == "Smith", "Author attribute extraction failed")

   -- Wildcard attribute name in predicate: matches any attribute value
   local err, id = xml.mtFindTag('/root/book[@*="Smith"]')
   assert(err == ERR_Okay, "Wildcard attribute name predicate should match on any attribute")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test count operations

function testCountOperations()
   local xml = obj.new("xml", {
      statement = '<root><section><item/><item/><item/></section><section><item/></section></root>'
   })

   -- Count all items
   local totalItems = tonumber(xml.getKey('count://item'))
   assert(totalItems == 4, "Expected 4 total items, got " .. totalItems)

   -- Count items in first section
   local firstSectionItems = tonumber(xml.getKey('count:/root/section[1]/item'))
   assert(firstSectionItems == 3, "Expected 3 items in first section, got " .. firstSectionItems)
end

-----------------------------------------------------------------------------------------------------------------------
-- Test exists operations

function testExistsOperations()
   local xml = obj.new("xml", {
      statement = '<root><section title="Test"><item/></section></root>'
   })

   -- Test element existence via XPath lookup
   local err, sectionId = xml.mtFindTag('/root/section')
   assert(err == ERR_Okay, "Section should exist")

   local missingErr, missingId = xml.mtFindTag('/root/missing')
   assert(missingErr != ERR_Okay, "Missing element should not exist")

   -- Test attribute existence
   local titleErr, titleValue = xml.mtGetAttrib(sectionId, 'title')
   assert(titleErr == ERR_Okay and titleValue == "Test", "Title attribute should exist")

   local missingAttrErr, missingAttrValue = xml.mtGetAttrib(sectionId, 'missing')
   assert(missingAttrErr == ERR_NotFound, "Missing attribute should not exist")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test content extraction operations

function testContentExtraction()
   local xml = obj.new("xml", {
      statement = '<root><section>Direct content <em>emphasized</em> more content</section></root>'
   })

   -- Test immediate content extraction (excludes nested tags)
   local immediateContent = xml.getKey('/root/section')
   assert(string.find(immediateContent, "Direct content"), "Immediate content not extracted")
   assert(string.find(immediateContent, "more content"), "Trailing content not extracted")

   -- Test deep content extraction
   local deepContent = xml.getKey('content:/root/section')
   assert(string.find(deepContent, "emphasized"), "Deep content not extracted")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test extract operations (XML serialization)

function testExtractOperations()
   local xml = obj.new("xml", {
      statement = '<root><section><item id="1">Content</item></section></root>'
   })

   -- Extract XML for specific element
   local extractedXML = xml.getKey('extract:/root/section/item')
   assert(string.find(extractedXML, 'id="1"'), "Extracted XML is missing attributes: " .. nz(extractedXML,'NIL'))
   assert(string.find(extractedXML, "Content"), "Extracted XML is missing content" .. nz(extractedXML,'NIL'))
end

-----------------------------------------------------------------------------------------------------------------------
-- Test complex XPath expressions

function testComplexExpressions()
   local xml = obj.new("xml", {
      statement = '<root><products><product category="electronics" price="100"/><product category="books" price="20"/><product category="electronics" price="50"/></products></root>'
   })

   -- Find electronics products
   local electronicsCount = 0
   local err, index = xml.mtFindTag('/root/products/product[@category="electronics"]', function(XML, TagID, Attrib)
      electronicsCount = electronicsCount + 1
   end)

   assert(electronicsCount == 2, "Expected 2 electronics products, found " .. electronicsCount)
end

-----------------------------------------------------------------------------------------------------------------------
-- Test namespace support (XPath 1.0 feature)

function testNamespaceSupport()
   local xml = obj.new("xml", {
      statement = '<root xmlns:book="http://books.com" xmlns:mag="http://magazines.com"><book:item title="Guide"/><mag:item title="News"/></root>'
   })

   -- Test namespace-aware matching (currently supported)
   local bookCount = 0
   local err, index = xml.mtFindTag('/root/book:item', function(XML, TagID, Attrib)
      bookCount = bookCount + 1
   end)

   if err == ERR_Okay then
      assert(bookCount >= 0, "Namespace matching should work or gracefully fail")
   end
end

-----------------------------------------------------------------------------------------------------------------------
-- Regression: prefixed node steps should resolve correctly

function testNamespacePrefixedSteps()
   local xml = obj.new("xml", {
      statement = '<root xmlns:book="http://books.com"><book:item title="Guide"/></root>'
   })

   local err, tagId = xml.mtFindTag('/root/book:item')
   assert(err == ERR_Okay, "Prefixed node steps should locate namespaced elements (bug: parser drops local name)")

   local err, title = xml.mtGetAttrib(tagId, 'title')
   assert(err == ERR_Okay and title == 'Guide', "Namespaced element should remain addressable by prefix")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test parent axis (..) navigation

function testParentAxisNavigation()
   local xml = obj.new("xml", {
      statement = '<root><section id="1"><item id="a"/><item id="b"/></section><section id="2"><item id="c"/></section></root>'
   })

   -- Test parent navigation (currently supported)
   local err, parentId = xml.mtFindTag('/root/section/item[@id="a"]/..')
   if err == ERR_Okay then
      local err, sectionId = xml.mtGetAttrib(parentId, 'id')
      assert(err == ERR_Okay and sectionId == "1", "Parent navigation should return section with id=1")
   end
end

-----------------------------------------------------------------------------------------------------------------------
-- Test attribute wildcard matching

function testAttributeWildcards()
   local xml = obj.new("xml", {
      statement = '<root><item type="book" title="Guide"/><item type="magazine" title="News"/></root>'
   })

   -- Test wildcard in attribute values (currently supported in string-based evaluator when available)
   local err, itemId = xml.mtFindTag('/root/item[@type="bo*"]')
   if err == ERR_Okay then
      local attrErr, typeValue = xml.mtGetAttrib(itemId, 'type')
      assert(attrErr == ERR_Okay and typeValue == "book", "Wildcard attribute predicate should return the matching node")
   else
      assert(err == ERR_Search, "Wildcard attribute predicates should fail gracefully when not implemented")
   end

   -- Attribute existence without a value should be accepted
   local existsErr, existsId = xml.mtFindTag('/root/item[@title]')
   assert(existsErr == ERR_Okay, "Attribute existence predicate [@title] should succeed")

   -- Attribute name wildcards (@*) should match any attribute name using the provided pattern
   local nameWildErr, titledId = xml.mtFindTag('/root/item[@*="Gu*"]')
   if nameWildErr == ERR_Okay then
      local _, titleValue = xml.mtGetAttrib(titledId, 'title')
      assert(titleValue == "Guide", "Wildcard name predicate should still point at the correct node")
   else
      assert(nameWildErr == ERR_Search, "Attribute name wildcard should fall back to a search error when unsupported")
   end
end

-----------------------------------------------------------------------------------------------------------------------
-- Regression: Function predicates should receive node-set arguments

function testFunctionPredicateNodeSets()
   local xml = obj.new("xml", {
      statement = '<root><item/><item/><item/></root>'
   })

   local err, rootId = xml.mtFindTag('/root[count(item)=3]')
   assert(err == ERR_Okay, "count(item)=3 predicate should evaluate with node-set arguments (bug: identifiers become literals)")

   local err, result = xml.mtFindTag('/root[count(item)=2]')
   assert(err == ERR_Search, "count(item)=2 predicate should not match when the function result is false")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test XPath 1.0 functions

function testXPathFunctions()
   local xml = obj.new("xml", {
      statement = '<root><item>1</item><item>2</item><item>3</item></root>'
   })

   local err, itemId = xml.mtFindTag('/root/item[position()=2]')
   assert(err == ERR_Okay, "/root/item[position()=2] failed")

   err, itemId = xml.mtFindTag('/root/item[position()=last()]')
   assert(err == ERR_Okay, "/root/item[position()=last()] failed")

   err, itemId = xml.mtFindTag('/root/item[last()]')
   assert(err == ERR_Okay, "last() predicate should select the final item")
   local err2, lastTag = xml.mtGetTag(itemId)
   assert(err2 == ERR_Okay and lastTag.children[1].attribs[1].value == '3', "last() predicate should locate the third entry")

   err, itemId = xml.mtFindTag('/root[count(item)>2]')
   assert(err == ERR_Okay, "count(item)>2 should succeed when AST evaluation is active")
   assert(itemId != 0, "count(item)>2 should return a valid node identifier")

   -- Test text() node test (XPath 1.0 - not supported yet)
   --local err, itemId = xml.mtFindTag('/root/item[text()="2"]')
   --assert(err == ERR_Okay, 'text()="2" failed')
end

-----------------------------------------------------------------------------------------------------------------------
-- Regression: Numeric position predicates should honour requested index

function testNumericPositionPredicates()
   local xml = obj.new("xml", {
      statement = '<root><item>First</item><item>Second</item><item>Third</item></root>'
   })

   local err, secondId = xml.mtFindTag('/root/item[2]')
   assert(err == ERR_Okay, "item[2] should return the second node (bug: predicate currently hard-codes index==1)")

   local err, tag = xml.mtGetTag(secondId)
   assert(err == ERR_Okay and tag.children[1].attribs[1].value == 'Second', "item[2] should locate the 'Second' entry")
end

-----------------------------------------------------------------------------------------------------------------------

-- Test XPath 1.0 boolean operators
function testBooleanOperators()
   local xml = obj.new("xml", {
      statement = '<root><product price="100" category="electronics"/><product price="50" category="books"/></root>'
   })

   local err, productId = xml.mtFindTag('/root/product[@price="100" and @category="electronics"]')
   assert(err == ERR_Okay, "'and' operator should locate the product with matching price and category")
   local err2, category = xml.mtGetAttrib(productId, 'category')
   assert(err2 == ERR_Okay and category == 'electronics', "'and' operator should return the electronics product")

   err, productId = xml.mtFindTag('/root/product[@category="books" or @category="electronics"]')
   assert(err == ERR_Okay, "'or' operator should locate a matching product")
   err2, category = xml.mtGetAttrib(productId, 'category')
   assert(err2 == ERR_Okay and category == 'electronics', "'or' operator should prioritise the first matching product")

   err, productId = xml.mtFindTag('/root/product[not(@category="books")]')
   assert(err == ERR_Okay, "'not()' should exclude the books category and return the electronics product")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test XPath 1.0 comparison operators

function testComparisonOperators()
   local xml = obj.new("xml", {
      statement = '<root><item value="10"/><item value="20"/><item value="30"/></root>'
   })

   local err, itemId = xml.mtFindTag('/root/item[@value > 15]')
   assert(err == ERR_Okay, "Greater than operator should locate the first item above the threshold")
   local err2, value = xml.mtGetAttrib(itemId, 'value')
   assert(err2 == ERR_Okay and value == '20', "@value > 15 should return the item with value 20")

   err, itemId = xml.mtFindTag('/root/item[@value < 25]')
   assert(err == ERR_Okay, "Less than operator should locate an item below the threshold")
   err2, value = xml.mtGetAttrib(itemId, 'value')
   assert(err2 == ERR_Okay and value == '10', "@value < 25 should return the item with value 10")

   err, itemId = xml.mtFindTag('/root/item[@value >= 20]')
   assert(err == ERR_Okay, "Greater than or equal operator should locate a matching item")
   err2, value = xml.mtGetAttrib(itemId, 'value')
   assert(err2 == ERR_Okay and value == '20', "@value >= 20 should return the item with value 20")

   err, itemId = xml.mtFindTag('/root/item[@value != "10"]')
   assert(err == ERR_Okay, "Not equal operator should locate an item different from the provided value")
   err2, value = xml.mtGetAttrib(itemId, 'value')
   assert(err2 == ERR_Okay and value == '20', "@value != 10 should return the first item whose value is not 10")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test XPath 1.0 mathematical expressions

function testMathematicalExpressions()
   local xml = obj.new("xml", {
      statement = '<root><item price="100" tax="10"/><item price="200" tax="20"/></root>'
   })

   -- Test arithmetic addition
   local err, itemId = xml.mtFindTag('/root/item[@price + @tax = 110]')
   assert(err == ERR_Okay, 'Addition predicate should locate matching item: ' .. mSys.GetErrorMsg(err))
   local err2, price = xml.mtGetAttrib(itemId, 'price')
   assert(err2 == ERR_Okay and price == '100', 'Addition predicate should return the first item')

   -- Test arithmetic multiplication
   err, itemId = xml.mtFindTag('/root/item[@price * 2 = 200]')
   assert(err == ERR_Okay, 'Multiplication predicate should locate matching item: ' .. mSys.GetErrorMsg(err))
   err2, price = xml.mtGetAttrib(itemId, 'price')
   assert(err2 == ERR_Okay and price == '100', 'Multiplication predicate should return the first item')

   -- Test arithmetic subtraction
   err, itemId = xml.mtFindTag('/root/item[@price - @tax = 90]')
   assert(err == ERR_Okay, 'Subtraction predicate should locate matching item: ' .. mSys.GetErrorMsg(err))
   err2, price = xml.mtGetAttrib(itemId, 'price')
   assert(err2 == ERR_Okay and price == '100', 'Subtraction predicate should return the first item')

   -- Test arithmetic division
   err, itemId = xml.mtFindTag('/root/item[@price div 2 = 50]')
   assert(err == ERR_Okay, 'Division predicate should locate matching item: ' .. mSys.GetErrorMsg(err))
   err2, price = xml.mtGetAttrib(itemId, 'price')
   assert(err2 == ERR_Okay and price == '100', 'Division predicate should return the first item')

   -- Test arithmetic modulo
   err, itemId = xml.mtFindTag('/root/item[@price mod 90 = 10]')
   assert(err == ERR_Okay, 'Modulo predicate should locate matching item: ' .. mSys.GetErrorMsg(err))
   err2, price = xml.mtGetAttrib(itemId, 'price')
   assert(err2 == ERR_Okay and price == '100', 'Modulo predicate should return the first item')
end

-----------------------------------------------------------------------------------------------------------------------
-- Regression: Attribute filters should allow broader XML name syntax

function testAttributeNameVariants()
   local xml = obj.new("xml", {
      statement = '<root><item data-id="123" xml:lang="en" version1="yes"/></root>'
   })

   local err, dataId = xml.mtFindTag('/root/item[@data-id="123"]')
   assert(err == ERR_Okay, "Attribute names containing hyphens should parse (bug: tokenizer rejects '-')")

   local err, langId = xml.mtFindTag('/root/item[@xml:lang="en"]')
   assert(err == ERR_Okay, "Attribute names with namespace prefixes should parse")

   local err, versionId = xml.mtFindTag('/root/item[@version1]')
   assert(err == ERR_Okay, "Attribute names containing digits should be accepted")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test XPath 1.0 axes

function testXPathAxes()
   local xml = obj.new("xml", {
      statement = '<root><section><item id="1"/><item id="2"/></section><other><item id="3"/></other></root>'
   })

   -- Test following-sibling axis returns the next item in document order
   local err, itemId = xml.mtFindTag('/root/section/item[@id="1"]/following-sibling::item')
   assert(err == ERR_Okay, "following-sibling axis should locate the next sibling item: " .. mSys.GetErrorMsg(err))
   local err2, siblingId = xml.mtGetAttrib(itemId, 'id')
   assert(err2 == ERR_Okay and siblingId == '2', "following-sibling::item should return id=2")

   -- Test preceding-sibling axis returns the previous sibling
   err, itemId = xml.mtFindTag('/root/section/item[@id="2"]/preceding-sibling::item')
   assert(err == ERR_Okay, "preceding-sibling axis should locate the previous sibling item: " .. mSys.GetErrorMsg(err))
   err2, siblingId = xml.mtGetAttrib(itemId, 'id')
   assert(err2 == ERR_Okay and siblingId == '1', "preceding-sibling::item should return id=1")

   -- Test ancestor axis resolves back to the document root
   local errRoot, rootId = xml.mtFindTag('/root')
   assert(errRoot == ERR_Okay, "Should be able to resolve /root for ancestor comparison")
   err, itemId = xml.mtFindTag('/root/section/item/ancestor::root')
   assert(err == ERR_Okay, "ancestor axis should resolve to the document root: " .. mSys.GetErrorMsg(err))
   assert(itemId == rootId, "ancestor::root should return the root tag identifier")

   -- Test descendant axis traverses nested branches
   err, itemId = xml.mtFindTag('/root/descendant::item[@id="3"]')
   assert(err == ERR_Okay, "descendant axis should locate nested descendants: " .. mSys.GetErrorMsg(err))
   err2, siblingId = xml.mtGetAttrib(itemId, 'id')
   assert(err2 == ERR_Okay and siblingId == '3', "descendant::item[@id=\"3\"] should return id=3")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test XPath 1.0 union operator

function testUnionOperator()
   local xml = obj.new("xml", {
      statement = '<root><section><item/></section><other><item/></other></root>'
   })

   assert(xml.mtFindTag('/root/section/item | /root/other/item') == ERR_Okay)
end

-----------------------------------------------------------------------------------------------------------------------
-- Test XPath 1.0 variables (NOT YET SUPPORTED)

function testVariables()
   local xml = obj.new("xml", {
      statement = '<root><item id="test"/></root>'
   })

   -- Test variable reference (XPath 1.0 - not supported yet)
   local err, itemId = xml.mtFindTag('/root/item[@id=$testvar]')
   assert(err != ERR_Okay, "Variable references should not be supported yet")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test complex nested predicates

function testComplexNestedPredicates()
   local xml = obj.new("xml", {
      statement = '<library><section name="fiction"><book title="Novel" author="Smith"><chapter num="1">Intro</chapter><chapter num="2">Plot</chapter></book></section></library>'
   })

   -- Test nested bracket expressions with current syntax
   local err, chapterId = xml.mtFindTag('/library/section[@name="fiction"]/book[@author="Smith"]/chapter[@num="2"]')
   assert(err == ERR_Okay, "Complex nested predicates should work with current syntax")

   local err, content = xml.mtGetTag(chapterId)
   assert(err == ERR_Okay, "Should be able to get chapter tag")
end

-----------------------------------------------------------------------------------------------------------------------
-- Regression: Round bracket predicates are deprecated

function testRoundBracketAlternatives()
   local xml = obj.new("xml", {
      statement = '<root><item type="book">Novel</item><item type="magazine">News</item></root>'
   })

   -- XPath 1.0 requires predicates to use square brackets; round brackets should fail
   local err, itemId = xml.mtFindTag('/root/item(@type="book")')
   assert(err != ERR_Okay, "Round bracket predicate should be rejected after deprecation, got " .. mSys.GetErrorMsg(err))

   err, itemId = xml.mtFindTag('/root/item(="Novel")')
   assert(err != ERR_Okay, "Round bracket content predicate should be rejected, got " .. mSys.GetErrorMsg(err))

   -- Square bracket predicate remains supported and should continue to succeed
   local squareErr, squareId = xml.mtFindTag('/root/item[@type="book"]')
   assert(squareErr == ERR_Okay, "Square bracket predicate should remain supported")

   local attribErr, typeValue = xml.mtGetAttrib(squareId, 'type')
   assert(attribErr == ERR_Okay and typeValue == "book", "Square bracket predicate should locate the correct item")
end

-----------------------------------------------------------------------------------------------------------------------
-- Regression: Text nodes participate in axes per XPath 1.0

function testTextNodeAxes()
   local xml = obj.new("xml", {
      statement = '<root><a>First</a> Second <b>Third</b></root>'
   })

   local err, textId = xml.mtFindTag('/root/a/following-sibling::text()')
   assert(err == ERR_Okay, 'Text nodes should appear on the following-sibling axis')

   local errTag, textTag = xml.mtGetTag(textId)
   assert(errTag == ERR_Okay and textTag.attribs[1].value == ' Second ',
      'Whitespace in text nodes should be preserved when navigating axes, got ' .. nz(textTag.attribs[1].value, 'NIL'))

   err, textId = xml.mtFindTag('/root/descendant::text()')
   assert(err == ERR_Okay, 'Descendant axis should include text nodes produced by element content')

   err, textId = xml.mtFindTag('/root/b/preceding-sibling::text()')
   assert(err == ERR_Okay, 'Text nodes should also be available via preceding-sibling axis')

   errTag, textTag = xml.mtGetTag(textId)
   assert(errTag == ERR_Okay and textTag.attribs[1].value == ' Second ',
      'preceding-sibling::text() should expose the whitespace-preserved node, got ' .. nz(textTag.attribs[1].value, 'NIL'))
end

-----------------------------------------------------------------------------------------------------------------------
-- XPath 1.0 comment() node test

function testCommentNodeType()
   local xml = obj.new("xml", {
      statement = '<root><!-- marker --><item>Value</item><!-- trailer --></root>', flags = XMF_INCLUDE_COMMENTS
   })

   local err, commentId = xml.mtFindTag('/root/comment()')
   assert(err == ERR_Okay, 'comment() node test should locate the first comment, err=' .. mSys.GetErrorMsg(err))

   local errTag, commentTag = xml.mtGetTag(commentId)
   assert(errTag == ERR_Okay and commentTag.attribs[1].value == ' marker ',
       'comment() should expose the comment content, got ' .. nz(commentTag.attribs[1].value, 'NIL'))

   err, commentId = xml.mtFindTag('/root/item/following-sibling::comment()')
   assert(err == ERR_Okay, 'comment() on following-sibling axis should locate subsequent comments, err=' .. mSys.GetErrorMsg(err))

   errTag, commentTag = xml.mtGetTag(commentId)
   assert(errTag == ERR_Okay and commentTag.attribs[1].value == ' trailer ',
       'following-sibling::comment() should expose trailing comment, got ' .. nz(commentTag.attribs[1].value, 'NIL'))
end

-----------------------------------------------------------------------------------------------------------------------
-- XPath 1.0 processing-instruction() node test

function testProcessingInstructionNodeType()
   local xml = obj.new("xml", {
      statement = '<root><?target data?><item/><?other pi?></root>'
   })

   local err, piId = xml.mtFindTag('/root/processing-instruction()')
   assert(err == ERR_Okay, 'processing-instruction() should locate the first PI node, err=' .. mSys.GetErrorMsg(err))

   local piErr, piTag = xml.mtGetTag(piId)
   assert(piErr == ERR_Okay and piTag.attribs[1].name == '?target', 'processing-instruction() should expose the PI target name')

   err, piId = xml.mtFindTag('/root/processing-instruction("target")')
   assert(err == ERR_Okay, 'processing-instruction("target") should filter by target name, err=' .. mSys.GetErrorMsg(err))

   piErr, piTag = xml.mtGetTag(piId)
   assert(piErr == ERR_Okay and piTag.attribs[1].name == '?target', 'processing-instruction("target") should return the matching PI node')
end

-----------------------------------------------------------------------------------------------------------------------
-- XPath 1.0 node() test

function testGenericNodeType()
   local xml = obj.new("xml", {
      statement = '<root><child/><other/></root>'
   })

   local err, nodeId = xml.mtFindTag('/root/node()')
   assert(err == ERR_Okay, 'node() node test should match any node type at the document root, err=' .. mSys.GetErrorMsg(err))

   err, nodeId = xml.mtFindTag('/root/child/following-sibling::node()')
   assert(err == ERR_Okay, 'following-sibling::node() should match subsequent sibling nodes, err=' .. mSys.GetErrorMsg(err))
end

-----------------------------------------------------------------------------------------------------------------------
-- XPath 1.0 namespace axis (NOT YET SUPPORTED)

function testNamespaceAxis()
   local xml = obj.new("xml", {
      statement = '<root xmlns:ns="http://example.com/ns"><ns:item/></root>'
   })

   local err, nsId = xml.mtFindTag('/root/namespace::*')
   assert(err != ERR_Okay, 'namespace::* axis should remain unsupported, err=' .. mSys.GetErrorMsg(err))

   err, nsId = xml.mtFindTag('/root/namespace::ns')
   assert(err != ERR_Okay, 'namespace::ns should remain unsupported, err=' .. mSys.GetErrorMsg(err))
end

-----------------------------------------------------------------------------------------------------------------------
-- XPath 1.0 function library predicates

function testXPathStringFunctions()
   local xml = obj.new("xml", {
      statement = '<root><item>alpha</item><item>beta</item></root>'
   })

   local err, itemId = xml.mtFindTag('/root/item[string-length(.) = 5]')
   assert(err == ERR_Okay, 'string-length(.) predicate should select five-character strings, err=' .. mSys.GetErrorMsg(err))

   local value = xml.getKey('/root/item[string-length(.) = 5]')
   assert(value == 'alpha', 'string-length(.) predicate should locate the "alpha" element, got ' .. nz(value, 'NIL'))

   err, itemId = xml.mtFindTag('/root/item[normalize-space(.) = "alpha"]')
   assert(err == ERR_Okay, 'normalize-space(.) predicate should evaluate successfully, err=' .. mSys.GetErrorMsg(err))

   value = xml.getKey('/root/item[normalize-space(.) = "alpha"]')
   assert(value == 'alpha', 'normalize-space(.) predicate should collapse whitespace to "alpha", got ' .. nz(value, 'NIL'))
end

function testXPathNumberFunctions()
   local xml = obj.new("xml", {
      statement = '<root><item value="1"/><item value="2"/><item value="3"/></root>'
   })

   local err, itemId = xml.mtFindTag('/root[sum(item/@value) = 6]')
   assert(err != ERR_Okay, 'sum() should remain unsupported until the function library is fully wired, err=' .. mSys.GetErrorMsg(err))

   err, itemId = xml.mtFindTag('/root/item[floor(@value) = 1]')
   assert(err == ERR_Okay, 'floor() predicate should evaluate numeric attributes, err=' .. mSys.GetErrorMsg(err))

   local attribErr, attribValue = xml.mtGetAttrib(itemId, 'value')
   assert(attribErr == ERR_Okay and attribValue == '1', 'floor() predicate should target the item with value="1"')
end

-----------------------------------------------------------------------------------------------------------------------
-- Test escape characters in attribute strings

function testEscapeCharacters()
   local xml = obj.new("xml", {
      statement = '<root><item title="Simple test" special="asterisk*value"/></root>'
   })

   -- Test basic attribute matching (escaping may not be fully supported yet)
   local err, itemId = xml.mtFindTag('/root/item[@title="Simple test"]')
   assert(err == ERR_Okay, "Basic attribute matching should work")

   -- Test wildcard matching in attribute values
   local err, itemId = xml.mtFindTag('/root/item[@special="asterisk*"]')
   if err == ERR_Okay then
      -- Wildcard matching works
   else
      -- Try exact match instead
      local err, itemId = xml.mtFindTag('/root/item[@special="asterisk*value"]')
      assert(err == ERR_Okay, "Exact attribute matching should work")
   end

   -- Escaped wildcard should be treated literally

   local err, itemId = xml.mtFindTag('/root/item[@special="asterisk\\*value"]')
   assert(err == ERR_Okay, "Escaped wildcard should match literal asterisk in value")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test edge cases and error conditions

function testEdgeCases()
   local xml = obj.new("xml", {
      statement = '<root><empty/><selfclosing attr="value"/><nested><deep><deeper>content</deeper></deep></nested></root>'
   })

   -- Test empty element access
   local err, emptyId = xml.mtFindTag('/root/empty')
   assert(err == ERR_Okay, "Should be able to find empty elements")

   -- Test self-closing element with attributes
   local err, selfId = xml.mtFindTag('/root/selfclosing[@attr="value"]')
   assert(err == ERR_Okay, "Should be able to find self-closing elements with attributes")

   -- Test deeply nested elements
   local err, deepId = xml.mtFindTag('/root/nested/deep/deeper')
   assert(err == ERR_Okay, "Should be able to navigate deeply nested elements")

   -- Test invalid XPath syntax
   local err, invalidId = xml.mtFindTag('/root/[invalid]')
   assert(err != ERR_Okay, "Invalid XPath syntax should return error")

   -- Test missing elements
   local err, missingId = xml.mtFindTag('/root/nonexistent')
   assert(err != ERR_Okay, "Missing elements should return search error")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test performance with larger documents

function testPerformanceScenarios()
   -- Build a larger XML document for performance testing
   local xmlContent = '<root>'
   for i = 1, 50 do  -- Reduced from 100 to 50 for faster testing
      xmlContent = xmlContent .. '<section id="' .. i .. '">'
      for j = 1, 5 do  -- Reduced from 10 to 5 for faster testing
         xmlContent = xmlContent .. '<item type="' .. (j % 3 == 0 and "special" or "normal") .. '" value="' .. (i * 10 + j) .. '">Content ' .. i .. '.' .. j .. '</item>'
      end
      xmlContent = xmlContent .. '</section>'
   end
   xmlContent = xmlContent .. '</root>'

   local xml = obj.new("xml", { statement = xmlContent })

   -- Test deep scanning functionality (without timing)
   local specialCount = 0
   local err, index = xml.mtFindTag('//item[@type="special"]', function(XML, TagID, Attrib)
      specialCount = specialCount + 1
   end)

   assert(err == ERR_Okay, "Deep scanning should work on larger documents")
   assert(specialCount > 0, "Should find special items in large document")

   -- Test that we found the expected number of special items
   -- Every 3rd item (j=3) in each section should be special
   local expectedSpecialCount = 50  -- 50 sections * 1 special item per section
   assert(specialCount == expectedSpecialCount, "Expected " .. expectedSpecialCount .. " special items, found " .. specialCount)
end

-----------------------------------------------------------------------------------------------------------------------
-- Test Phase 3 Function Library Infrastructure

function testPhase3FunctionLibrary()
   -- Test that the Phase 3 XPath function library infrastructure is in place
   -- These tests verify basic functionality without requiring full AST evaluation

   local xml = obj.new("xml", {
      statement = [[
         <library>
            <books>
               <book id="1" rating="4.5">Programming Pearls</book>
               <book id="2" rating="5.0">The Art of Computer Programming</book>
               <book id="3" rating="4.2">Clean Code</book>
            </books>
            <authors count="3">
               <author name="Jon Bentley">Author bio content</author>
               <author name="Donald Knuth">Mathematician and computer scientist</author>
               <author name="Robert Martin">Clean code advocate</author>
            </authors>
         </library>
      ]]
   })

   -- Test that basic XPath functionality continues to work with Phase 3 infrastructure

   local bookContent = xml.getKey('content:/library/books/book[@id="2"]')
   assert(bookContent, "Book should have content")

   -- Test content extraction (important for function library string operations)
   local authorContent = xml.getKey('content:/library/authors/author[@name="Donald Knuth"]')
   assert(authorContent, "Author should have content")

   -- Test navigation to container elements (important for node-set functions)
   err, authorsId = xml.mtFindTag('/library/authors')
   assert(err == ERR_Okay, "Should navigate to authors container")

   local err, authorsTag = xml.mtGetTag(authorsId)
   assert(authorsTag, "Should retrieve authors container")

   -- Verify multiple child access patterns work
   local childCount = 0
   xml.mtFindTag('/library/authors/author', function(XML, TagID, Attrib)
      childCount = childCount + 1
   end)
   assert(childCount == 3, "Should find all 3 authors, found " .. childCount)

   -- Test that wildcards work (important for node matching in functions)
   local allCount = 0
   xml.mtFindTag('/library/*/author', function(XML, TagID, Attrib)
      allCount = allCount + 1
   end)
   assert(allCount == 3, "Wildcard matching should find 3 authors, found " .. allCount)
end

-----------------------------------------------------------------------------------------------------------------------
-- Test Phase 4: Operators and Expressions

function testXPathOperators()
   local xml = obj.new("xml", {
      statement = [[
         <root>
            <numbers>
               <value>10</value>
               <value>20</value>
               <value>30</value>
               <value>5</value>
            </numbers>
            <books>
               <book id="1" rating="4.5" year="2020">Programming Pearls</book>
               <book id="2" rating="5.0" year="2019">The Art of Computer Programming</book>
               <book id="3" rating="4.2" year="2021">Clean Code</book>
               <book id="4" rating="3.8" year="2020">Refactoring</book>
            </books>
            <status enabled="true">active</status>
            <status enabled="false">inactive</status>
         </root>
      ]]
   })

   -- Test Boolean Operators (and, or, not)
   local err, id = xml.mtFindTag('/root/books/book[@rating="5.0" and @year="2019"]')
   assert(err == ERR_Okay, "Boolean AND operator should locate the 2019 five-star book: " .. mSys.GetErrorMsg(err))
   local err2, bookId = xml.mtGetAttrib(id, 'id')
   assert(err2 == ERR_Okay and bookId == '2', "Boolean AND should return book id=2")

   err, id = xml.mtFindTag('/root/books/book[@rating="5.0" or @year="2021"]')
   assert(err == ERR_Okay, "Boolean OR operator should match a qualifying book: " .. mSys.GetErrorMsg(err))
   err2, bookId = xml.mtGetAttrib(id, 'id')
   assert(err2 == ERR_Okay and bookId == '2', "Boolean OR should return the first matching book (id=2)")

   err, id = xml.mtFindTag('/root/status[not(@enabled="false")]')
   assert(err == ERR_Okay, "not() operator should filter the disabled status: " .. mSys.GetErrorMsg(err))
   local err3, enabled = xml.mtGetAttrib(id, 'enabled')
   assert(err3 == ERR_Okay and enabled == 'true', "not() should leave only the enabled status entry")

   -- Test Comparison Operators
   err, id = xml.mtFindTag('/root/books/book[@id != "1"]')
   assert(err == ERR_Okay, "Not-equal operator should skip the first book: " .. mSys.GetErrorMsg(err))
   err2, bookId = xml.mtGetAttrib(id, 'id')
   assert(err2 == ERR_Okay and bookId == '2', "@id != \"1\" should return the second book")

   err, id = xml.mtFindTag('/root/books/book[@year > 2020]')
   assert(err == ERR_Okay, "Greater-than operator should locate later publications: " .. mSys.GetErrorMsg(err))
   err2, bookId = xml.mtGetAttrib(id, 'id')
   assert(err2 == ERR_Okay and bookId == '3', "@year > 2020 should return the 2021 release")

   err, id = xml.mtFindTag('/root/books/book[@year <= 2019]')
   assert(err == ERR_Okay, "Less-than-or-equal operator should locate early publications: " .. mSys.GetErrorMsg(err))
   err2, bookId = xml.mtGetAttrib(id, 'id')
   assert(err2 == ERR_Okay and bookId == '2', "@year <= 2019 should return the 2019 release")

   err, id = xml.mtFindTag('/root/books/book[position() + 1 = 3]')
   assert(err == ERR_Okay, "position()+1 should evaluate arithmetic inside predicates: " .. mSys.GetErrorMsg(err))
   local err4, plusBook = xml.mtGetAttrib(id, 'id')
   assert(err4 == ERR_Okay and plusBook == '2', "position()+1=3 should return the second book")

   err, id = xml.mtFindTag('/root/books/book[position() * 2 >= 4]')
   assert(err == ERR_Okay, "position()*2 should honour multiplication semantics: " .. mSys.GetErrorMsg(err))
   local err5, multBook = xml.mtGetAttrib(id, 'id')
   assert(err5 == ERR_Okay and multBook == '2', "position()*2>=4 should return the second entry")
 end

function testXPathExpressions()
   local xml = obj.new("xml", {
      statement = [[
         <library>
            <section name="fiction">
               <book title="1984" pages="328">George Orwell</book>
               <book title="Brave New World" pages="268">Aldous Huxley</book>
            </section>
            <section name="technical">
               <book title="Clean Code" pages="464">Robert Martin</book>
               <book title="Design Patterns" pages="395">Gang of Four</book>
            </section>
         </library>
      ]]
   })

   -- contains() should resolve string functions against attribute values
   local err, id = xml.mtFindTag('/library/section[@name="fiction"]/book[contains(@title,"1984")]')
   assert(err == ERR_Okay, "contains() should match titles within the fiction section: " .. mSys.GetErrorMsg(err))
   local err2, title = xml.mtGetAttrib(id, 'title')
   assert(err2 == ERR_Okay and title == '1984', "contains() predicate should return the 1984 novel")

   -- position() combined with comparison operators should filter later sections
   err, id = xml.mtFindTag('/library/section[position()>1]/book[@pages > 400]')
   assert(err == ERR_Okay, "position()>1 should allow filtering second section books: " .. mSys.GetErrorMsg(err))
   err2, title = xml.mtGetAttrib(id, 'title')
   assert(err2 == ERR_Okay and title == 'Clean Code', "Filtered query should return the 464-page technical book")

   -- Union operator should execute successfully across multiple branches
   local unionTitles = {}
   local unionErr = xml.mtFindTag('/library/section[@name="fiction"]/book | /library/section[@name="technical"]/book', function(XML, TagID, Attrib)
      local titleErr, unionTitle = xml.mtGetAttrib(TagID, 'title')
      table.insert(unionTitles, titleErr == ERR_Okay and unionTitle or '')
   end)
   assert(unionErr == ERR_Okay, "Union operator should execute successfully")
   assert(#unionTitles >= 2, "Union should return at least two nodes, found " .. #unionTitles)
end

function testXPathArithmetic()
   local xml = obj.new("xml", {
      statement = [[
         <math>
            <numbers>
               <num>10</num>
               <num>20</num>
               <num>30</num>
            </numbers>
            <calculations>
               <result value="15">Addition result</result>
               <result value="100">Multiplication result</result>
               <result value="5">Division result</result>
            </calculations>
         </math>
      ]]
   })

   -- Division and modulo on attribute values
   local err, id = xml.mtFindTag('/math/calculations/result[@value div 3 = 5]')
   assert(err == ERR_Okay, "Division operator should evaluate attribute arithmetic: " .. mSys.GetErrorMsg(err))
   local err2, resultValue = xml.mtGetAttrib(id, 'value')
   assert(err2 == ERR_Okay and resultValue == '15', "@value div 3 = 5 should target the 15 result node")

   err, id = xml.mtFindTag('/math/calculations/result[@value mod 10 = 5]')
   assert(err == ERR_Okay, "Modulo operator should evaluate attribute arithmetic: " .. mSys.GetErrorMsg(err))
   err2, resultValue = xml.mtGetAttrib(id, 'value')
   assert(err2 == ERR_Okay and resultValue == '15', "@value mod 10 = 5 should reuse the 15 result node")

   err, id = xml.mtFindTag('/math/calculations/result[@value div 20 = 5]')
   assert(err == ERR_Okay, "Division should also match the 100 result when dividing by 20: " .. mSys.GetErrorMsg(err))
   err2, resultValue = xml.mtGetAttrib(id, 'value')
   assert(err2 == ERR_Okay and resultValue == '100', "@value div 20 = 5 should return the 100 result node")

   -- Additional arithmetic on attribute values
   err, id = xml.mtFindTag('/math/calculations/result[@value + 5 = 20]')
   assert(err == ERR_Okay, "Addition on attributes should evaluate numerically: " .. mSys.GetErrorMsg(err))
   local err3, addedValue = xml.mtGetAttrib(id, 'value')
   assert(err3 == ERR_Okay and addedValue == '15', "@value + 5 = 20 should return the 15 result node")

   err, id = xml.mtFindTag('/math/calculations/result[@value - 80 = 20]')
   assert(err == ERR_Okay, "Subtraction on attributes should evaluate numerically: " .. mSys.GetErrorMsg(err))
   local err4, subValue = xml.mtGetAttrib(id, 'value')
   assert(err4 == ERR_Okay and subValue == '100', "@value - 80 = 20 should return the 100 result node")

   err, id = xml.mtFindTag('/math/calculations/result[@value * 2 = 10]')
   assert(err == ERR_Okay, "Multiplication on attributes should evaluate numerically: " .. mSys.GetErrorMsg(err))
   local err5, multValue = xml.mtGetAttrib(id, 'value')
   assert(err5 == ERR_Okay and multValue == '5', "@value * 2 = 10 should return the 5 result node")
 end

-----------------------------------------------------------------------------------------------------------------------
-- Test Phase 5: XPath Axes

function testXPathForwardAxes()
   local xml = obj.new("xml", {
      statement = [[
         <library>
            <fiction>
               <book id="1" title="1984">George Orwell</book>
               <book id="2" title="Brave New World">Aldous Huxley</book>
               <review rating="5">Excellent dystopian novel</review>
            </fiction>
            <technical>
               <book id="3" title="Clean Code">Robert Martin</book>
               <book id="4" title="Design Patterns">Gang of Four</book>
               <guide type="tutorial">Getting Started</guide>
            </technical>
            <archive>
               <old-book year="1950">Classic Literature</old-book>
            </archive>
         </library>
      ]]
   })

   -- Test child axis (default axis)
   local childCount = 0
   local err, id = xml.mtFindTag('/library/fiction/book', function(XML, TagID, Attrib)
      childCount = childCount + 1
   end)
   assert(err == ERR_Okay, "Child axis should work (default axis)")
   assert(childCount == 2, "Should find 2 books in fiction section, found " .. childCount)

   -- Test explicit child axis
   childCount = 0
   err, id = xml.mtFindTag('/library/child::fiction/child::book', function(XML, TagID, Attrib)
      childCount = childCount + 1
   end)
   assert(err == ERR_Okay, "Explicit child axis should iterate children correctly: " .. mSys.GetErrorMsg(err))
   assert(childCount == 2, "child::book should still find the two fiction books, found " .. childCount)

   -- Test descendant axis (all descendants)
   local descendantCount = 0
   err, id = xml.mtFindTag('/library/descendant::book', function(XML, TagID, Attrib)
      descendantCount = descendantCount + 1
   end)
   assert(err == ERR_Okay, "descendant::book should traverse the entire subtree: " .. mSys.GetErrorMsg(err))
   assert(descendantCount == 4, "Descendant axis should find all 4 books, found " .. descendantCount)

   -- Test following-sibling axis between top-level sections
   local errTech, technicalId = xml.mtFindTag('/library/technical')
   assert(errTech == ERR_Okay, "Should resolve /library/technical for comparison")

   err, id = xml.mtFindTag('/library/fiction/following-sibling::technical')
   assert(err == ERR_Okay, "following-sibling axis should locate the technical section: " .. mSys.GetErrorMsg(err))
   assert(id == technicalId, "following-sibling::technical should resolve to the technical section id")

   -- Test following axis to find nodes later in document order
   err, id = xml.mtFindTag('/library/fiction/book[@id="2"]/following::guide')
   assert(err == ERR_Okay, "following axis should locate guide nodes later in the document: " .. mSys.GetErrorMsg(err))
   local err2, guideType = xml.mtGetAttrib(id, 'type')
   assert(err2 == ERR_Okay and guideType == 'tutorial', "following::guide should return the tutorial guide element")
end

function testXPathReverseAxes()
   local xml = obj.new("xml", {
      statement = [[
         <root>
            <section id="1">
               <chapter id="1.1">
                  <paragraph id="1.1.1">First paragraph</paragraph>
                  <paragraph id="1.1.2">Second paragraph</paragraph>
               </chapter>
               <chapter id="1.2">
                  <paragraph id="1.2.1">Third paragraph</paragraph>
               </chapter>
            </section>
            <section id="2">
               <chapter id="2.1">
                  <paragraph id="2.1.1">Fourth paragraph</paragraph>
               </chapter>
            </section>
         </root>
      ]]
   })

   -- Test parent axis (.. syntax already works)
   local err, parentId = xml.mtFindTag('/root/section/chapter[@id="1.1"]/..')
   assert(err == ERR_Okay, "Parent axis via .. should return the owning section: " .. mSys.GetErrorMsg(err))
   local err2, sectionId = xml.mtGetAttrib(parentId, 'id')
   assert(err2 == ERR_Okay and sectionId == '1', "Parent axis should land on the section with id=1")

   -- Test explicit parent axis
   err, parentId = xml.mtFindTag('/root/section/chapter/parent::section')
   assert(err == ERR_Okay, "Explicit parent axis should resolve to the enclosing section: " .. mSys.GetErrorMsg(err))
   err2, sectionId = xml.mtGetAttrib(parentId, 'id')
   assert(err2 == ERR_Okay and (sectionId == '1' or sectionId == '2'), "parent::section should return a valid section node")

   -- Test ancestor axis
   local errRoot, rootId = xml.mtFindTag('/root')
   assert(errRoot == ERR_Okay, "Should resolve /root for ancestor comparison")
   err, ancestorId = xml.mtFindTag('/root/section/chapter/paragraph/ancestor::root')
   assert(err == ERR_Okay, "Ancestor axis should climb to the document root: " .. mSys.GetErrorMsg(err))
   assert(ancestorId == rootId, "ancestor::root should return the root tag identifier")

   -- Test preceding-sibling axis
   err, siblingId = xml.mtFindTag('/root/section/chapter[2]/preceding-sibling::chapter')
   assert(err == ERR_Okay, "preceding-sibling::chapter should locate the prior chapter: " .. mSys.GetErrorMsg(err))
   local err3, siblingChapter = xml.mtGetAttrib(siblingId, 'id')
   assert(err3 == ERR_Okay and siblingChapter == '1.1', "preceding-sibling::chapter should return chapter 1.1")

   -- Test preceding axis (reverse document order)
   err, siblingId = xml.mtFindTag('/root/section/chapter[2]/paragraph/preceding::paragraph')
   assert(err == ERR_Okay, "preceding::paragraph should return earlier paragraphs: " .. mSys.GetErrorMsg(err))
   local err4, precedingParagraph = xml.mtGetAttrib(siblingId, 'id')
   assert(err4 == ERR_Okay and precedingParagraph == '1.1.2', "preceding::paragraph should return the nearest preceding paragraph")
end

function testXPathAxisCombinations()
   local xml = obj.new("xml", {
      statement = [[
         <document>
            <header>
               <title>Document Title</title>
               <meta name="author">John Doe</meta>
            </header>
            <body>
               <section class="intro">
                  <p>Introduction paragraph</p>
                  <p>Second intro paragraph</p>
               </section>
               <section class="content">
                  <p>Main content paragraph</p>
                  <aside>Side note</aside>
               </section>
            </body>
            <footer>
               <p>Footer content</p>
            </footer>
         </document>
      ]]
   })

   -- Test self axis
   local err, bodyId = xml.mtFindTag('/document/body')
   assert(err == ERR_Okay, "Should resolve /document/body for self-axis comparison")

   local errSelf, selfId = xml.mtFindTag('/document/body/self::body')
   assert(errSelf == ERR_Okay, "self::body should reference the current context node: " .. mSys.GetErrorMsg(errSelf))
   assert(selfId == bodyId, "self::body should return the same identifier as /document/body")

   -- Test attribute lookups via @ syntax in combination with descendant scans
   local metaErr, metaId = xml.mtFindTag('/document/header/meta')
   assert(metaErr == ERR_Okay, "Meta element should be reachable for attribute verification")
   local attrErr, metaAttr = xml.mtGetAttrib(metaId, 'name')
   assert(attrErr == ERR_Okay and metaAttr == 'author', "Attribute extraction should work inside mixed axis queries")

   local attrExistsErr, attrExistsId = xml.mtFindTag('/document/header/meta[@name]')
   assert(attrExistsErr == ERR_Okay, "[@name] predicate should be honoured during combined axis tests")

   -- Test complex axis combinations
   -- Find all paragraphs that are descendants of sections
   local paragraphCount = 0
   err, id = xml.mtFindTag('/document/body/section//p', function(XML, TagID, Attrib)
      paragraphCount = paragraphCount + 1
   end)
   assert(err == ERR_Okay, "Deep scanning should work for paragraph descendants")
   assert(paragraphCount == 3, "Should find 3 paragraphs in sections, found " .. paragraphCount)

   -- Combine following-sibling and descendant axes to locate the aside element
   err, id = xml.mtFindTag('/document/body/section[@class="intro"]/following-sibling::section/descendant::aside')
   assert(err == ERR_Okay, "following-sibling::section/descendant::aside should locate the aside element: " .. mSys.GetErrorMsg(err))

   -- Verify ancestor axes in combination with descendant-or-self
   local errAncestor = xml.mtFindTag('/document/body/section[@class="content"]/aside/ancestor::body')
   assert(errAncestor == ERR_Okay, "ancestor::body should reach the body element from the aside")

   err, id = xml.mtFindTag('/document/body/section[@class="content"]/descendant-or-self::section')
   assert(err == ERR_Okay, "descendant-or-self::section should include the current section node")
end

-----------------------------------------------------------------------------------------------------------------------

function testSiblingFilteringForNumericPredicates()
   local xml = obj.new("xml", {
      statement = '<root><b/><a id="first"/><a id="second"/></root>'
   })

   local err, secondId = xml.mtFindTag('/root/a[2]')
   assert(err == ERR_Okay, 'XPath [2] should select the second <a> node: ' .. mSys.GetErrorMsg(err))

   local err2, value = xml.mtGetAttrib(secondId, 'id')
   assert(err2 == ERR_Okay and value == 'second', 'Second <a> should have been matched')
end

-----------------------------------------------------------------------------------------------------------------------

return {
   tests = {
      -- Current supported features
      'testBasicXPath', 'testAttributeMatching', 'testIndexedAccess', 'testDeepScanning',
      'testWildcardMatching', 'testContentMatching', 'testAttributeExtraction',
      'testCountOperations', 'testExistsOperations', 'testContentExtraction',
      'testExtractOperations', 'testComplexExpressions', 'testAttributePredicateExistence',
      'testDeepScanMidPath',
      'testExtractOperations', 'testComplexExpressions',

      -- Extended current feature tests
      'testNamespaceSupport', 'testParentAxisNavigation', 'testAttributeWildcards',
      'testNamespacePrefixedSteps', 'testFunctionPredicateNodeSets', 'testNumericPositionPredicates',
      'testAttributeNameVariants',
      'testComplexNestedPredicates', 'testRoundBracketAlternatives', 'testTextNodeAxes', 'testEscapeCharacters',
      'testEdgeCases', 'testPerformanceScenarios',
      'testSiblingFilteringForNumericPredicates',
      'testBooleanOperators', 'testComparisonOperators',

      -- Phase 4: Operators and expressions
      'testXPathOperators', 'testXPathExpressions', 'testXPathArithmetic',

      -- Phase 5: XPath Axes
      'testXPathAxes', 'testXPathForwardAxes', 'testXPathReverseAxes', 'testXPathAxisCombinations',

      -- XPath 1.0 features not yet supported (should fail gracefully)
      'testXPathFunctions',
      'testMathematicalExpressions', 
      'testUnionOperator', 
      --'testVariables',
      'testCommentNodeType',
      'testProcessingInstructionNodeType',
      'testGenericNodeType',
      'testNamespaceAxis',
      'testXPathStringFunctions',
      'testXPathNumberFunctions',

      -- Phase 3 infrastructure verification
      'testPhase3FunctionLibrary'
   },
   init = function(ScriptFolder)
      -- Helper function for table.contains
      table.contains = function(table, element)
         for _, value in pairs(table) do
            if value == element then return true end
         end
         return false
      end
   end,
   cleanup = function()
      -- No cleanup needed
   end
}
