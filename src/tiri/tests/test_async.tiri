
-----------------------------------------------------------------------------------------------------------------------
-- Create two dummy objects and use them to confirm that the signalling of multiple objects works.
-- Also ensures that the garbage collector doesn't collect the script while it's running.
-- This is not a genuine threading test (only one thread and the main program is active at any time).

@Test(priority=1) function MultipleSignals()
   signal_a = obj.new('time', { }) -- This would normally be something more practical, like a file
   signal_b = obj.new('time', { })
   work_list = array<object> { signal_a, signal_b }

   callback = function()
      msg('Thread has finished execution.')
      work_list:each(o => o.acSignal())
   end

   proc = processing.new({ timeout=1.0, signals = work_list })

   -- Verify that garbage collection doesn't invalidate the thread while it's running

   for i=1,100 do
      do
         script = obj.new('script', { statement=[[ msg('Thread is now in session.') ]] })
         async.script(script, callback)
      end

      processing.collect()

      msg('Sleeping....')
      check proc.sleep()
   end

   -- Allocate the threaded script once, then run it multiple times.  Note that you can't run the
   -- same object in parallel (you'd have to allocate more and reference the same string).

   script = obj.new('script', { statement=[[ msg('Thread is now in session.') ]] })

   for i=1,100 do -- Run enough times to sufficiently test thread locking and the JIT
      async.script(script, callback)

      msg('Sleeping....')
      check proc.sleep()
   end
end

-----------------------------------------------------------------------------------------------------------------------
-- Verify that the async.script() callback receives an error code and message when the script fails.

@Test(priority=2) function ScriptCallbackError()
   script = obj.new('script', { statement=[[ error('Deliberate test failure') ]] })

   glCallbackError = nil
   glCallbackMsg = nil
   glCallbackFired = false

   async.script(script, function()
      glCallbackError = script.error
      glCallbackMsg   = script.errorMessage
      glCallbackFired = true
      processing.signal()
   end)

   check processing.sleep(3.0)

   assert(glCallbackFired, 'Callback was not invoked.')
   assert(glCallbackError != ERR_Okay, f'Expected a non-zero error code, got ERR_Okay')
   assert(glCallbackMsg and #glCallbackMsg > 0, 'Expected a non-empty error message')
   print(f'Script error reported: {glCallbackError}, message: {glCallbackMsg}')
end

-----------------------------------------------------------------------------------------------------------------------
-- Queue multiple async.script() calls against separate script objects without waiting between each dispatch.
-- AsyncAction serialises requests per-object, so distinct objects can run concurrently.  The test verifies that all
-- callbacks fire and that no registry references are corrupted when multiple ThreadScriptMsg allocations are in flight.

@Test(priority=3) function QueuedScriptExecution()
   total = 50
   completed = 0

   signal = obj.new('time', { })
   proc = processing.new({ timeout=5.0, signals = array<object> { signal } })

   scripts = array<object>
   for i=0, total-1 do
      scripts:push(obj.new('script', { statement = [[ msg('Queued script ]] .. i .. [[ running.') ]] }))
   end

   for script in values(scripts) do
      async.script(script, function()
         completed++
         msg(f'Callback {completed}/{total} fired.')
         if completed >= total then
            signal.acSignal()
         end
      end)
   end

   check proc.sleep()

   assert(completed >= total, f'Expected {total} callbacks but only {completed} fired.')
   print(f'All {completed} queued script callbacks completed successfully.')
end

-----------------------------------------------------------------------------------------------------------------------
-- Demonstrate the use of array<object> |> pipe iteration to fan out async work across multiple objects.
-- Each script object runs in its own thread; the pipe dispatches all of them without an explicit loop.

@Test(priority=4) function ArrayPipeFanOut()
   -- Create a bunch of worker scripts that return a result

   scripts = array<object> { }
   for i in {1...10} do
      scripts:push(obj.new('script', { statement = [[ print('Pipe worker ]] .. i .. [[ running.'); return ]] .. i }))
   end

   proc = processing.new({ timeout=5.0, signals = scripts })

   -- Run all the workers in one go

   completed = 0
   scripts |> function(script)
      async.script(script, function(Object)
         Object.acSignal()
         print('Received result: ', Object.results?[0])
         check Object.error
         completed++
      end)
   end

   check proc.sleep()

   assert(completed >= #scripts, f'Expected {total} callbacks but only {completed} fired.')
end

-----------------------------------------------------------------------------------------------------------------------
-- Verify that async.pool supports reading and writing scalar values (number, string, boolean).

@Test(priority=5) function PoolScalarReadWrite()
   async.pool.clear()

   async.pool.count = 42
   async.pool.name  = 'hello'
   async.pool.flag  = true

   assert(async.pool.count is 42, f'Expected 42, got {async.pool.count}')
   assert(async.pool.name is 'hello', f'Expected hello, got {async.pool.name}')
   assert(async.pool.flag is true, f'Expected true, got {async.pool.flag}')

   -- Overwrite with different types
   async.pool.count = 'now a string'
   assert(async.pool.count is 'now a string', f'Expected "now a string", got {async.pool.count}')

   -- Non-existent key returns nil
   assert(async.pool.nonexistent is nil, 'Expected nil for missing key')

   async.pool.clear()
end

-----------------------------------------------------------------------------------------------------------------------
-- Verify that storing an object in the pool stores its ID and reads back as a live object.

@Test(priority=6) function PoolObjectStorage()
   async.pool.clear()

   signal = obj.new('time', { })
   expected_id = signal.id

   async.pool.target = signal

   result = async.pool.target
   assert(result != nil, 'Expected object, got nil')
   assert(result.id is expected_id, f'Expected object ID {expected_id}, got {result.id}')

   async.pool.clear()
end

-----------------------------------------------------------------------------------------------------------------------
-- Verify that assigning nil to a pool key deletes it.

@Test(priority=7) function PoolNilDeletion()
   async.pool.clear()

   async.pool.temp = 99
   assert(async.pool.temp is 99, 'Expected 99')

   async.pool.temp = nil
   assert(async.pool.temp is nil, 'Expected nil after deletion')

   async.pool.clear()
end

-----------------------------------------------------------------------------------------------------------------------
-- Verify that async.pool.clear() removes all entries.

@Test(priority=8) function PoolClear()
   async.pool.clear()

   async.pool.a = 1
   async.pool.b = 2
   async.pool.c = 3

   async.pool.clear()

   assert(async.pool.a is nil, 'Expected nil after clear')
   assert(async.pool.b is nil, 'Expected nil after clear')
   assert(async.pool.c is nil, 'Expected nil after clear')
end

-----------------------------------------------------------------------------------------------------------------------
-- Verify that a worker thread can read and write the pool, and the main thread sees the results.

@Test(priority=9) function PoolCrossThread()
   async.pool.clear()
   async.pool.input = 'from main'

   script = obj.new('script', { statement=[[
      val = async.pool.input
      async.pool.output = 'from thread: ' .. val
   ]] })

   async.script(script, function(Object)
      check Object.error
      processing.signal()
   end)

   check processing.sleep(3.0)

   assert(async.pool.output is 'from thread: from main',
      f'Expected "from thread: from main", got "{async.pool.output}"')

   async.pool.clear()
end

-----------------------------------------------------------------------------------------------------------------------
-- In this test the signals are sent from the threaded script rather than being managed by the main thread's callback.

@Test(priority=10) function MultipleClientSignals()
   signal_a = obj.new('time', { }) -- This would normally be something more practical, like a file
   work_list = array<object> { signal_a } -- List all the objects that will be worked on

   async_statement = [[
      print(f'Thread {arg('Iteration')} is now in session.')
      sig_a = obj.find(arg('A'))
      sig_a.acSignal()
   ]]

   local script = obj.new('script', { statement = async_statement })
   script.acQuery()
   script.setKey('A', signal_a.id) -- Make the signal object available via arg()

   proc = processing.new({ timeout=1.0, signals = work_list })

   for i=1,100 do
      script.setKey('Iteration', i)
      async.script(script)
      check proc.sleep()
   end
end
