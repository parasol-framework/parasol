
-----------------------------------------------------------------------------------------------------------------------
-- Create two dummy objects and use them to confirm that the signalling of multiple objects works.
-- Also ensures that the garbage collector doesn't collect the script while it's running.
-- This is not a genuine threading test (only one thread and the main program is active at any time).

@Test(priority=1) function MultipleSignals()
   signal_a = obj.new('time', { }) -- This would normally be something more practical, like a file
   signal_b = obj.new('time', { })
   work_list = array<object> { signal_a, signal_b }

   callback = function()
      msg('Thread has finished execution.')
      work_list:each(o => o.acSignal())
   end
   
   proc = processing.new({ timeout=1.0, signals = work_list })

   -- Verify that garbage collection doesn't invalidate the thread while it's running

   for i=1,100 do
      do
         script = obj.new('script', { statement=[[ msg('Thread is now in session.') ]] })
         thread.script(script, callback)
      end

      processing.collect()

      msg('Sleeping....')
      check proc.sleep()
   end

   -- Allocate the threaded script once, then run it multiple times.  Note that you can't run the
   -- same object in parallel (you'd have to allocate more and reference the same string).

   script = obj.new('script', { statement=[[ msg('Thread is now in session.') ]] })

   for i=1,100 do -- Run enough times to sufficiently test thread locking and the JIT
      thread.script(script, callback)

      msg('Sleeping....')
      check proc.sleep()
   end
end

-----------------------------------------------------------------------------------------------------------------------
-- Verify that the thread.script() callback receives an error code and message when the script fails.

@Test(priority=2) function ScriptCallbackError()
   script = obj.new('script', { statement=[[ error('Deliberate test failure') ]] })

   glCallbackError = nil
   glCallbackMsg = nil
   glCallbackFired = false

   thread.script(script, function()
      glCallbackError = script.error
      glCallbackMsg   = script.errorMessage
      glCallbackFired = true
      processing.signal()
   end)

   check processing.sleep(3.0)

   assert(glCallbackFired, 'Callback was not invoked.')
   assert(glCallbackError != ERR_Okay, f'Expected a non-zero error code, got ERR_Okay')
   assert(glCallbackMsg and #glCallbackMsg > 0, 'Expected a non-empty error message')
   print(f'Script error reported: {glCallbackError}, message: {glCallbackMsg}')
end

-----------------------------------------------------------------------------------------------------------------------
-- In this test the signals are sent from the threaded script rather than being managed by the main thread's callback.

@Test(priority=4) function MultipleClientSignals()
   signal_a = obj.new('time', { }) -- This would normally be something more practical, like a file
   work_list = array<object> { signal_a } -- List all the objects that will be worked on

   thread_statement = [[
      print(f'Thread {arg('Iteration')} is now in session.')
      sig_a = obj.find(arg('A'))
      sig_a.acSignal()
      print('Finished')
   ]]

   local script = obj.new('script', { statement = thread_statement })
   script.setKey('A', signal_a.id) -- Make the signal object available via arg()

   proc = processing.new({ timeout=1.0, signals = work_list })

   for i=1,100 do
      print('Iteration ' .. i)
      script.setKey('Iteration', i)
      thread.script(script)
      check proc.sleep()
   end
end
