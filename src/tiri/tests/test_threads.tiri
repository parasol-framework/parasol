-- Test the use of action threading (asynchronous callbacks) by loading multiple pictures simultaneously.
--
-- The  testParallel() function executes the threads and then waits for them to complete by calling proc.sleep()
-- until picLoaded() sends a signal().

   import 'io/filesearch'

   proc = processing.new(5.0)
   glPicsProcessed = 0
   glPictures = array<table>

@BeforeAll function init()
   mGfx ?? return

   folder = 'icons:programs/'
   list = ''
   print(f'Scanning "{folder}" for SVGs')
   io.search(folder, {
      nameFilter = regex.new('.+\\.svg'),
      matchFeedback = function(Path:str, FileName:str, File:obj)
         list ..= FileName .. ' '
         glPictures:push({ path=Path .. FileName })
      end
   })

   print(f'Found {#glPictures} SVG files: {list}')

   assert(#glPictures > 0, 'Failed to find any SVG files.')
end

function initPictures()
   for v in values(glPictures) do
      v.pic = obj.new('picture', { path=v.path, flags=PCF_QUERY } )
   end
end

function freePictures()
   for v in values(glPictures) do
      if v.pic then v.pic = nil end
   end
end

-----------------------------------------------------------------------------------------------------------------------
-- This callback function is called every time that a thread completes its Activate() action.

function picProcessed(ActionID, pic, Error, Key)
   if Error != ERR_Okay then
      print('Failed to load picture, error: ' .. mSys.GetErrorMsg(Error))
   end

   glPicsProcessed++

   if glPicsProcessed >= #glPictures then
      --print('All pictures have been processed, exiting now.')
      proc.signal()
   end
end

-----------------------------------------------------------------------------------------------------------------------

@Test(priority=1); @Requires(display=true) function Parallel()
   initPictures()

   glPicsProcessed = 0
   count = 0

   for k, v in glPictures do
      if v.pic then
         thread.action(v.pic, 'Activate', picProcessed, k)
         count++
      end
   end

   -- Wait for threads to complete

   if count > 0 then
      err = proc.sleep()
   end

   freePictures()
end

-----------------------------------------------------------------------------------------------------------------------
-- This is the control test for demonstrating how fast parallel execution can actually be versus sequential execution.

@Test(priority=2); @Requires(display=true) function Sequential()
   initPictures()

   for v in values(glPictures) do
      v.pic?.acActivate()
   end

   freePictures()
end

-----------------------------------------------------------------------------------------------------------------------
-- Create two dummy objects and use them to confirm that the signalling of multiple objects works.
-- Also ensures that the garbage collector doesn't collect the script while it's running.
-- This is not a genuine threading test (only one thread and the main program is active at any time).

@Test(priority=3) function MultipleSignals()
   signal_a = obj.new('time', { }) -- This would normally be something more practical, like a file
   signal_b = obj.new('time', { })

   callback = function()
      msg('Thread has been executed.')
      signal_a.acSignal()
      signal_b.acSignal()
   end

   -- Verify that garbage collection doesn't invalidate the thread while it's running

   for i=1,10 do
      do
         script = obj.new('script', { statement=[[ msg('Thread is now in session.') ]] })
         thread.script(script, callback)
      end

      processing.collect()

      try
         proc = processing.new({ timeout=1.0, signals = array<object> { signal_a, signal_b } })
         msg('Sleeping....')
         proc.sleep()
      except e
         error('Error during MultipleSignals test: ' .. e.message)
      end
   end

   -- Allocate the threaded script once, then run it multiple times.  Note that you can't run the
   -- same object in parallel (you'd have to allocate more and reference the same string).

   script = obj.new('script', { statement=[[ msg('Thread is now in session.') ]] })

   for i=1,80 do -- Run enough times to sufficiently test thread locking and the JIT
      thread.script(script, callback)

      try
         proc = processing.new({ timeout=1.0, signals = array<object> { signal_a, signal_b } })
         msg('Sleeping....')
         proc.sleep()
      except e
         error('Error during MultipleSignals test: ' .. e.message)
      end
   end
end

-----------------------------------------------------------------------------------------------------------------------
-- Verify that the thread.script() callback receives an error code and message when the script fails.

@Test(priority=4) function ScriptCallbackError()
   script = obj.new('script', { statement=[[ error('Deliberate test failure') ]] })

   glCallbackError = nil
   glCallbackMsg = nil
   glCallbackFired = false

   thread.script(script, function()
      glCallbackError = script.error
      glCallbackMsg   = script.errorMessage
      glCallbackFired = true
      processing.signal()
   end)

   err = processing.sleep(3.0)

   assert(err is ERR_Okay, f'Processing sleep returned: {err}')
   assert(glCallbackFired, 'Callback was not invoked.')
   assert(glCallbackError != ERR_Okay, f'Expected a non-zero error code, got ERR_Okay')
   assert(glCallbackMsg and #glCallbackMsg > 0, 'Expected a non-empty error message')
   print(f'Script error reported: {glCallbackError}, message: {glCallbackMsg}')
end

-----------------------------------------------------------------------------------------------------------------------
-- In this test the signals are sent from the threaded script rather than being managed by the main thread's callback.

@Test(priority=5); @Disabled function MultipleClientSignals()
   signal_a = obj.new('time', { }) -- This would normally be something more practical, like a file

   thread_statement = [[
      msg('Thread is now in session.')
      sig_a = obj.find(arg('A'))
      sig_a.acSignal()
      print('Finished')
   ]]

   for i=1,10 do
      do
         script = obj.new('script', { statement=[[ msg('Thread is now in session.') ]] })
         script.setKey('A', signal_a.id) -- Make the signal object available via arg()

         thread.script(script)
      end

      processing.collect()

      try
         proc = processing.new({ timeout=1.0, signals = array<object> { signal_a } })
         msg('Sleeping....')
         proc.sleep()
      except e
         error('Error during MultipleClientSignals test: ' .. e.message)
      end
   end

end

-----------------------------------------------------------------------------------------------------------------------
-- Verify that multiple thread.action() calls on the same object execute in FIFO order.
-- Each callback records its Key parameter; the final order should match submission order.

@Test(priority=6); @Requires(display=true) function FifoOrdering()
   pic = obj.new('picture', { path=glPictures[0].path, flags=PCF_QUERY })

   order_log = { }
   completed = 0
   expected = 8

   for i = 0, expected - 1 do
      thread.action(pic, 'Activate', function(ActionID, Object, Error, Key)
         table.insert(order_log, Key)
         completed++
         if completed >= expected then
            processing.signal()
         end
      end, i)
   end

   err = processing.sleep(15)
   assert(err is ERR_Okay, f'Processing sleep returned error: {err}')
   assert(completed is expected, f'Expected {expected} completions, got {completed}')

   -- Verify FIFO ordering: keys should arrive in submission order (0, 1, 2, ..., 7)
   for i = 0, #order_log - 1 do
      assert(order_log[i] is i, f'Expected key {i} at position {i}, got {order_log[i]}')
   end
end

-----------------------------------------------------------------------------------------------------------------------
-- Verify that queued actions without callbacks still allow subsequent queued actions to dispatch.

@Test(priority=7); @Requires(display=true) function CallbacklessQueueing()
   pic = obj.new('picture', { path=glPictures[0].path, flags=PCF_QUERY })

   completed = 0

   -- Queue 3 actions on the same object without callbacks, followed by 1 with a callback
   thread.action(pic, 'Activate')
   thread.action(pic, 'Activate')
   thread.action(pic, 'Activate')
   thread.action(pic, 'Activate', function(ActionID, Object, Error, Key)
      completed++
      processing.signal()
   end, 0)

   err = processing.sleep(15)
   assert(err is ERR_Okay, f'Processing sleep returned error: {err}')
   assert(completed is 1, 'Final callback was not invoked after callback-less queued actions.')
end
