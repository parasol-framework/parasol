-- Flute tests for the postfix ?? operator (presence check)
-- Returns boolean: true if value is truthy, false if falsey (nil, false, 0, "")

@BeforeEach(hotpath=true)
function enforce_hotpath() end

@Test function Nil()
   v = nil
   assert((v??) is false, "Failed nil case: expected false")
end

@Test function False()
   v = false
   assert((v??) is false, "Failed false case: expected false")
end

@Test function Zero()
   v = 0
   assert((v??) is false, "Failed zero case: expected false")
end

@Test function EmptyString()
   v = ""
   assert((v??) is false, "Failed empty string case: expected false")
end

@Test function TruthyString()
   v = "X"
   assert((v??) is true, "Failed truthy string case: expected true")
end

@Test function TruthyNumber()
   v = 5
   assert((v??) is true, "Failed truthy number case: expected true")
end

@Test function True()
   v = true
   assert((v??) is true, "Failed true case: expected true")
end

-- Test in conditionals
@Test function InConditional()
   comment = "Hello"
   if comment?? then
      -- Expected path
   else
      error("Should enter if block when comment is truthy")
   end

   empty = ""
   if empty?? then
      error("Should not enter if block when empty string")
   else
      -- Expected path
   end

   zero = 0
   if zero?? then
      error("Should not enter if block when zero")
   end
end

-- Test in expressions
@Test function InExpression()
   name = "Alice"
   msg = name?? and "Hello, " .. name or "Hello, Guest"
   assert(msg is "Hello, Alice", "Failed expression test with truthy name")

   empty_name = ""
   msg2 = empty_name?? and "Hello, " .. empty_name or "Hello, Guest"
   assert(msg2 is "Hello, Guest", "Failed expression test with empty name")
end

-- Test chaining with logical operators
@Test function Chaining()
   comment = "Test"
   author = "User"
   if comment?? and author?? then
      -- Expected path
   else
      error("Should enter if block when both are truthy")
   end

   empty_comment = ""
   if empty_comment?? and author?? then
      error("Should not enter if block when comment is empty")
   end

   if empty_comment?? or author?? then
      -- Expected path (author is truthy)
   else
      error("Should enter if block when author is truthy")
   end
end

-- Test with parentheses
@Test function Parentheses()
   x = 5
   y = 10
   v = (x + y)??
   assert(v is true, "Failed parentheses test: expected true for non-zero sum")

   z = -5
   w = (x + z)??
   assert(w is false, "Failed parentheses test: expected false for zero sum")
end

-- Test with table access
@Test function TableAccess()
   t = { name = "Test" }
   v = t.name??
   assert(v is true, "Failed table access test: expected true for non-empty string")

   t2 = { name = "" }
   v2 = t2.name??
   assert(v2 is false, "Failed table access test: expected false for empty string")

   t3 = { value = 0 }
   v3 = t3.value??
   assert(v3 is false, "Failed table access test: expected false for zero")
end

-- Test runtime values
@Test function Runtime()
   x = 0
   v = x??
   assert(v is false, "Runtime zero test failed: expected false")

   x = 5
   v = x??
   assert(v is true, "Runtime non-zero test failed: expected true")

   s = ""
   v = s??
   assert(v is false, "Runtime empty string test failed: expected false")

   s = "Hello"
   v = s??
   assert(v is true, "Runtime non-empty string test failed: expected true")

   b = false
   v = b??
   assert(v is false, "Runtime false test failed: expected false")

   b = true
   v = b??
   assert(v is true, "Runtime true test failed: expected true")
end

-- Test constant expressions
@Test function Constants()
   assert((nil??) is false, "Constant nil test failed")
   assert((false??) is false, "Constant false test failed")
   assert((0??) is false, "Constant zero test failed")
   assert((""??) is false, "Constant empty string test failed")
   assert((true??) is true, "Constant true test failed")
   assert((1??) is true, "Constant one test failed")
   assert(("test"??) is true, "Constant string test failed")
   assert((42??) is true, "Constant number test failed")
end

-- Test that ?? returns boolean, not the value
@Test function ReturnsBool()
   v = "Hello"
   result = v??
   assert(result is true, "Should return true, not the value")
   assert(result != "Hello", "Should return boolean, not the string value")

   n = 42
   result = n??
   assert(result is true, "Should return true, not the value")
   assert(result != 42, "Should return boolean, not the numeric value")
end

-- Test chained field access
@Test function ChainedAccess()
   obj = { user = { name = "Alice" } }
   assert((obj.user.name??) is true, "Failed chained access test")

   obj2 = { user = { name = "" } }
   assert((obj2.user.name??) is false, "Failed chained access with empty string")
end

-- Test with negative numbers
@Test function NegativeNumbers()
   v = -5
   assert((v??) is true, "Failed negative number test: expected true for -5")

   v2 = -0.0
   assert((v2??) is false, "Failed negative zero test: expected false for -0.0")
end

-- Tests to verify bytecode semantics claimed in PR comment
-- PR comment claims: BC_ISEQP/BC_ISEQN/BC_ISEQS skip next instruction when comparison succeeds
-- These tests verify the actual runtime behavior

-- Test: Verify truthy string returns true (proves jumps don't fire incorrectly)
@Test function BytecodeSemanticsTruthyString()
   s = "test"
   result = s??
   assert(result is true, "Truthy string must return true - if false, BC_ISEQS may be skipping when equal (wrong)")
end

-- Test: Verify truthy number returns true
@Test function BytecodeSemanticsTruthyNumber()
   n = 42
   result = n??
   assert(result is true, "Truthy number must return true - if false, BC_ISEQN may be skipping when equal (wrong)")
end

-- Test: Verify falsey string returns false (proves jumps fire correctly)
@Test function BytecodeSemanticsFalseyString()
   s = ""
   result = s??
   assert(result is false, "Falsey string must return false - if true, BC_ISEQS may not be jumping when equal")
end

-- Test: Verify falsey number returns false
@Test function BytecodeSemanticsFalseyNumber()
   n = 0
   result = n??
   assert(result is false, "Falsey number must return false - if true, BC_ISEQN may not be jumping when equal")
end

-- Test: Verify type mismatch doesn't cause false positives (string vs number comparison)
@Test function BytecodeSemanticsTypeMismatchStringToNumber()
   s = "hello"
   -- Comparing string to number (zero check) should not trigger false jump
   result = s??
   assert(result is true, "String compared to number (zero check) should not trigger false - type mismatch handling")
end

-- Test: Verify type mismatch doesn't cause false positives (number vs string comparison)
@Test function BytecodeSemanticsTypeMismatchNumberToString()
   n = 42
   -- Comparing number to string (empty check) should not trigger false jump
   result = n??
   assert(result is true, "Number compared to string (empty check) should not trigger false - type mismatch handling")
end

-- Test: Verify nil returns false correctly
@Test function BytecodeSemanticsNil()
   v = nil
   result = v??
   assert(result is false, "Nil must return false - verifies BC_ISEQP behavior")
end

-- Test: Verify false returns false correctly
@Test function BytecodeSemanticsFalse()
   v = false
   result = v??
   assert(result is false, "False must return false - verifies BC_ISEQP behavior")
end

-- Test: Comprehensive runtime truthy values
@Test function BytecodeSemanticsAllTruthyValues()
   test_cases = {
      {val = "hello", name = "non-empty string"},
      {val = 1, name = "positive number"},
      {val = -1, name = "negative number"},
      {val = 0.5, name = "fractional number"},
      {val = true, name = "boolean true"},
      {val = {}, name = "empty table"},
      {val = {x=1}, name = "non-empty table"}
   }
   for _, tc in ipairs(test_cases) do
      result = (tc.val)??
      assert(result is true, "Truthy value '" .. tc.name .. "' must return true, got: " .. tostring(result))
   end
end

-- Test: Comprehensive runtime falsey values
@Test function BytecodeSemanticsAllFalseyValues()
   test_cases = {
      {val = nil, name = "nil"},
      {val = false, name = "false"},
      {val = 0, name = "zero"},
      {val = "", name = "empty string"}
   }
   for _, tc in ipairs(test_cases) do
      result = (tc.val)??
      assert(result is false, "Falsey value '" .. tc.name .. "' must return false, got: " .. tostring(result))
   end
end

@Test function Flags()
   trigger = 0
   perm = PERMIT_READ|PERMIT_WRITE
   if (perm & PERMIT_READ)??  then trigger++ end
   if (perm & PERMIT_WRITE)?? then trigger++ end
   if (perm & PERMIT_READ|PERMIT_WRITE)??  then trigger++ end
   if (perm & PERMIT_EXEC)??  then trigger++ end
   assert(trigger is 3, "Expected 3 bit-flags to pass, got " .. trigger)
end

@Test function ShortCircuit()
   function sideEffect()
      error("This function should not be called due to short-circuiting")
   end
   a = false
   b = true

   -- Short-circuit AND
   if (a?? and sideEffect()??) then
      error("Should not enter this block due to short-circuiting")
   end

   -- Short-circuit OR
   if (b?? or sideEffect()??) then
      -- Expected path, sideEffect should not be called
   else
      error("Should enter this block since b is truthy")
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Array presence tests: empty arrays (len == 0) are considered falsey

@Test function EmptyArrayPresence()
   local empty = array<int>
   assert((empty??) is false, "Empty array should return false for ??")
end

@Test function NonEmptyArrayPresence()
   local filled = array<int, 5>
   assert((filled??) is true, "Non-empty array should return true for ??")
end

@Test function ArrayInConditional()
   local empty = array<int>
   if empty?? then
      error("Should not enter if block for empty array")
   end

   local filled = array<int, 3>
   entered = false
   if filled?? then
      entered = true
   end
   assert(entered is true, "Should enter if block for non-empty array")
end

@Test function ArrayWithVariousTypes()
   -- Test presence check with various array element types
   local int_empty = array<int>
   local double_empty = array<double>
   local byte_empty = array<byte>
   local int_filled = array<int, 1>

   assert((int_empty??) is false, "Empty int array should return false")
   assert((double_empty??) is false, "Empty double array should return false")
   assert((byte_empty??) is false, "Empty byte array should return false")
   assert((int_filled??) is true, "Non-empty int array should return true")
end

@Test function ArrayInComprehensiveFalseyList()
   -- Verify arrays are now included in the falsey value set
   test_cases = {
      {val = nil, name = "nil", expected = false},
      {val = false, name = "false", expected = false},
      {val = 0, name = "zero", expected = false},
      {val = "", name = "empty string", expected = false},
      {val = array<int>, name = "empty array", expected = false},
      {val = true, name = "true", expected = true},
      {val = 1, name = "one", expected = true},
      {val = "test", name = "non-empty string", expected = true},
      {val = array<int, 3>, name = "non-empty array", expected = true}
   }
   for _, tc in ipairs(test_cases) do
      result = (tc.val)??
      assert(result is tc.expected, "Value '" .. tc.name .. "' should return " .. tostring(tc.expected) .. ", got: " .. tostring(result))
   end
end
