-- Flute tests that need to exercise the JIT in specific ways.

jit.on()
jit.opt.start()  -- Reset to default JIT options before starting tests.

cached_trace_no = nil
cached_trace_info = nil
outer_upvalue = 37

function build_trace()
   jit.on()
   jit.flush()
   jit.opt.start("hotloop=1", "hotexit=1", "minstitch=0")

   function traced_sum(Count)
      running_total = 0
      for i = 1, Count do
         running_total += i
      end
      return running_total
   end

   for i = 1, 80 do
      traced_sum(10)
   end

   for trace_no = 1, 20 do
      info = jit.util.traceinfo(trace_no)
      if info then
         cached_trace_no = trace_no
         cached_trace_info = info
         return trace_no, info
      end
   end

   error("Failed to create a JIT trace for inspection")
end

function get_trace()
   if cached_trace_no != nil and cached_trace_info != nil then
      return cached_trace_no, cached_trace_info
   end
   return build_trace()
end

function sample_vararg(Left, Right, ...)
   padding = 1
   return Left + Right + padding
end

function upvalue_consumer(Multiplier)
   extra = outer_upvalue * Multiplier
   return extra
end

function constant_target(Value)
   offset = 12345.6789  -- Non-integer to ensure it is stored in the numeric constant pool.
   label = "jit-constant"
   if Value > 0 then
      return Value + offset, label
   end
   return offset, label
end

@Test function EngineModeToggles()
   jit.on()
   enabled_on = jit.status()
   assert(enabled_on is true, "jit.on() should enable the compiler")

   jit.off()
   enabled_off = jit.status()
   assert(enabled_off is false, "jit.off() should disable the compiler")

   jit.on()
   enabled_again, first_flag = jit.status()
   assert(enabled_again is true, "jit.on() should restore the compiler state")

   if first_flag != nil and type(first_flag) != 'string' then
      error("jit.status secondary results should be flag strings when present")
   end
end

@Test function FuncInfoForLuaFunction()
   info = jit.util.funcinfo(sample_vararg, 0)
   assert(info.params is 2, "Expected sample_vararg to report two parameters")
   assert(info.isVarArg is true, "Vararg flag should be set for sample_vararg")
   assert(info.lastLineDefined >= info.lineDefined, "Line range should be ordered")
   assert(info.stackSlots > 0, "Stack slots should be reported")
   assert(info.byteCodes > 0, "Bytecode count should be reported")
   assert(info.proto != nil, "Proto reference should be available for Lua functions")
end

@Test function FuncInfoForCFunction()
   info = jit.util.funcinfo(print)
   if info.ffid != nil then
      assert(type(info.ffid) is "number", "FFI id should be numeric when present")
   end
   assert(type(info.addr) is "number", "C function address should be numeric")
   assert(type(info.upvalues) is "number", "C function upvalue count should be numeric")
end

@Test function FuncBCAndFunck()
   info = jit.util.funcinfo(constant_target, 0)
   first_ins, mode = jit.util.funcbc(constant_target, 0)
   assert(type(first_ins) is "number", "funcbc should return an instruction")
   assert(type(mode) is "number", "funcbc should return an instruction mode")

   invalid_ins, invalid_mode = jit.util.funcbc(constant_target, info.byteCodes)
   assert(invalid_ins is nil and invalid_mode is nil, "Out-of-range funcbc should return nothing")

   constants = { }
   numeric_count = 0
   for idx = 0, info.nConsts - 1 do
      value = jit.util.funck(constant_target, idx)
      if value != nil then
         constants[numeric_count] = value
         numeric_count++
      end
   end

   found_number = false
   for i = 0, numeric_count - 1 do
      if type(constants[i]) is "number" then found_number = true end
   end
   assert(found_number is true, "jit.util.funck should expose numeric constants")

   gc_values = { }
   gc_count = 0
   for idx = -1, -info.gcConsts, -1 do
      value = jit.util.funck(constant_target, idx)
      if value != nil then
         gc_values[gc_count] = value
         gc_count++
      end
   end

   found_label = false
   for i = 0, gc_count - 1 do
      if type(gc_values[i]) is "string" then found_label = true end
   end
   assert(found_label is true, "jit.util.funck should expose GC constants")
end

@Test function FuncUpvalueName()
   name = jit.util.funcuvname(upvalue_consumer, 0)
   assert(name is "outer_upvalue", "First upvalue name should match outer_upvalue")
end

@Test function TraceInfoAndIR()
   trace_no, info = get_trace()

   assert(type(info.nins) is "number" and info.nins > 0, "traceinfo should report instruction count")
   assert(type(info.link) is "number", "traceinfo link should be numeric")
   assert(type(info.linktype) is "string", "traceinfo linktype should be a string")

   allowed_links = {
      root = true,
      loop = true,
      ["tail-recursion"] = true,
      ["up-recursion"] = true,
      ["down-recursion"] = true,
      interpreter = true,
      ["return"] = true,
      stitch = true,
      none = true
   }
   assert(allowed_links[info.linktype] is true, "Unexpected linktype: " .. tostring(info.linktype))

   ir_mode, ir_ot, ir_op1, ir_op2, ir_prev = jit.util.traceir(trace_no, info.nins)
   assert(type(ir_mode) is "number", "traceir should return mode information")
   assert(type(ir_ot) is "number", "traceir should return type information")
   assert(type(ir_op1) is "number", "traceir should return first operand")
   assert(type(ir_op2) is "number", "traceir should return second operand")
   assert(type(ir_prev) is "number", "traceir should return previous reference")
end

@Test function TraceConstantsAndSnapshot()
   trace_no, info = get_trace()
   if type(info.nk) is "number" and info.nk <= 0 then
      error("Trace did not expose any constants for verification")
   end

   k_value, k_type, k_slot = nil, nil, nil
   for idx = -info.nk, -1 do
      value, kind, slot = jit.util.tracek(trace_no, idx)
      if value != nil then
         k_value, k_type, k_slot = value, kind, slot
         break
      end
   end
   assert(k_value != nil, "tracek should return at least one constant for available trace constants")
   assert(type(k_type) is "number", "tracek should return a type tag")
   if k_slot != nil then
      assert(type(k_slot) is "number", "tracek slot should be numeric when present")
   end

   snapshot = jit.util.tracesnap(trace_no, 0)
   assert(snapshot != nil, "tracesnap should provide a snapshot table")
   assert(type(snapshot[0]) is "number", "Snapshot should store reference at index 0")
   assert(type(snapshot[1]) is "number", "Snapshot should store slot count at index 1")
   assert(#snapshot >= 3, "Snapshot should include map entries and sentinel")
end

@Test function TraceMachineCodeAndExitStub()
   trace_no = get_trace()
   mcode, addr, loop_flag = jit.util.tracemc(trace_no)
   assert(mcode != nil, "tracemc should return machine code for hot traces")
   assert(type(addr) is "number", "tracemc should return a code address")
   assert(type(loop_flag) is "number", "tracemc should return loop flag information")
   if #mcode <= 0 then
      error("tracemc returned an empty machine code buffer")
   end

   exit_addr = jit.util.traceexitstub(trace_no, 0)
   if exit_addr is nil then
      exit_addr = jit.util.traceexitstub(0)
   end
   assert(exit_addr != nil, "traceexitstub should return a stub address")
   assert(type(exit_addr) is "number", "traceexitstub should return a numeric address")
end

@Test function IrCallAddrLookup()
   addr = jit.util.ircalladdr(0)
   assert(addr != nil, "ircalladdr(0) should return a function pointer")
   assert(type(addr) is "number", "ircalladdr(0) should be numeric")

   invalid = jit.util.ircalladdr(99999)
   assert(invalid is nil, "Out-of-range ircalladdr should return nil")
end

@Test function JitAttachTraceEvent()
   cached_trace_no = nil
   cached_trace_info = nil

   trace_events = 0
   function trace_handler(TraceNo, Reason)
      trace_events++
   end

   jit.attach(trace_handler, "trace")
   build_trace()
   jit.attach(trace_handler)

   assert(trace_events > 0, "Trace handler should run at least once")
end

@Test function ArrayIteratorTraces()
   cached_trace_no = nil
   cached_trace_info = nil

   function ensure_trace(IterFunc)
      jit.on()
      jit.flush()
      jit.opt.start("hotloop=1", "hotexit=1", "minstitch=0")

      function traced_loop(Count)
         arr = array<int> { 1, 2, 3, 4 }
         sum = 0
         for i = 1, Count do
            for idx, val in IterFunc(arr) do
               sum += val
            end
         end
         return sum
      end

      for i = 1, 80 do
         traced_loop(3)
      end

      for trace_no = 1, 20 do
         info = jit.util.traceinfo(trace_no)
         if info != nil then
            return true
         end
      end

      return false
   end

   assert(ensure_trace(ipairs) is true, "Expected array ipairs to produce a JIT trace")
   assert(ensure_trace(pairs) is true, "Expected array pairs to produce a JIT trace")
end
