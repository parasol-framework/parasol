-- Flute tests for the regex functionality

@Test function Construction()
   -- Test valid regex construction

   simple_regex = regex.new('hello')
   assert(simple_regex != nil, 'Failed to create simple regex')
   assert(simple_regex.pattern is 'hello', 'Pattern property incorrect')
   assert(simple_regex.flags is 0, 'Flags should default to 0')

   -- Test regex with flags

   case_regex = regex.new('HELLO', regex.ICASE)
   assert(case_regex.flags is regex.ICASE, 'Case insensitive flag not set correctly')

   -- Test invalid regex

   local invalid_regex
   try
      invalid_regex = regex.new('[unclosed')
   end
   assert(invalid_regex is nil, 'Invalid regex should have failed')
end

-----------------------------------------------------------------------------------------------------------------------

@Test function FindFirst()
   local rx_whitespace = regex.new('[^ \\t\\n\\r\\f\\v]')

   sample_regex = regex.new('\\d+')
   pos, len = sample_regex.findFirst('abc123def', 0)
   assert(pos is 3, 'Expected position 3, got ' .. tostring(pos))
   assert(len is 3, 'Expected length 3, got ' .. tostring(len))

   pos2, len2 = sample_regex.findFirst('no digits here', 0)
   assert(pos2 is nil and len2 is nil, 'Expected no match, got position ' .. tostring(pos2))

   pos, len = rx_whitespace.findFirst('   leading space', 0)
   assert(pos is 3, 'Expected position 3, got ' .. tostring(pos))
   assert(len is 1, 'Expected length 1, got ' .. tostring(len))

   pos, len = rx_whitespace.findFirst('   leading space', 2)
   assert(pos is 3, 'Expected position 3, got ' .. tostring(pos))
   assert(len is 1, 'Expected length 1, got ' .. tostring(len))
end

-----------------------------------------------------------------------------------------------------------------------

@Test function TestMethod()
   test_regex = regex.new('\\d+')
   assert(test_regex.test('abc123def'), 'Should find digits in string')
   assert(not test_regex.test('hello world'), 'Should not find digits in text')
   assert(test_regex.test('999'), 'Should match all digits')

   -- Case insensitive test
   case_test = regex.new('hello', regex.ICASE)
   assert(case_test.test('Hello World'), 'Case insensitive should match Hello')
   assert(case_test.test('HELLO'), 'Case insensitive should match HELLO')
   assert(not case_test.test('goodbye'), 'Should not match different word')
end

-----------------------------------------------------------------------------------------------------------------------

@Test function Match()
   -- Simple match
   word_regex = regex.new('(\\w+)')
   matches = word_regex.search('hello world')
   assert(matches, 'Match should succeed')
   assert(#matches is 2, 'Expected two matches (hello and world), got ' .. #matches)
   assert(matches[0][0] is 'hello', "Full match should be 'hello'")
   assert(matches[0][1] is 'hello', "Capture should be 'hello'")
   assert(matches[1][0] is 'world', "Full match should be 'world'")
   assert(matches[1][1] is 'world', "Capture should be 'world'")

   -- Multiple capture groups
   email_regex = regex.new('([^@]+)@([^.]+)\\.(.+)')
   email_matches = email_regex.match('user@example.com')
   assert(email_matches, 'Should match email')
   assert(email_matches[0] is 'user@example.com', 'Full match incorrect')
   assert(email_matches[1] is 'user', 'Username capture incorrect')
   assert(email_matches[2] is 'example', 'Domain capture incorrect')
   assert(email_matches[3] is 'com', 'TLD capture incorrect')

   -- No match case
   no_regex = regex.new('([ABC]+)')
   assert(not no_regex.match('123 456'), 'Should return nil for no match')
end

-----------------------------------------------------------------------------------------------------------------------

@Test function Search()
   digit_regex = regex.new('(\\d+)')
   all_matches = digit_regex.search('abc123def456ghi')
   assert(#all_matches is 2, 'Should find 2 digit sequences')
   assert(all_matches[0][0] is '123', "First match should be '123'")
   assert(all_matches[0][1] is '123', "First capture group should be '123'")
   assert(all_matches[1][0] is '456', "Second match should be '456'")
   assert(all_matches[1][1] is '456', "Second capture group should be '456'")

   -- Test with no matches
   no_matches = digit_regex.search('hello world')
   assert(no_matches is nil, "Should return nil for no matches")
end

-----------------------------------------------------------------------------------------------------------------------

@Test function Replace()
   replace_regex = regex.new('\\d+')
   result1 = replace_regex.replace('abc123def456', 'XXX')
   assert(result1 is 'abcXXXdefXXX', 'Failed to replace both occurrences')

   -- Test with backreferences
   phone_regex = regex.new('(\\d{3})-(\\d{3})-(\\d{4})')
   phone_result = phone_regex.replace('555-123-4567', '($1) $2-$3')
   assert(phone_result is '(555) 123-4567', 'Should format phone number correctly')

   -- Test no match
   no_replace = replace_regex.replace('hello world', 'XXX')
   assert(no_replace is 'hello world', 'Should return original if no match')

   all_replace_regex = regex.new('\\d+')
   all_result = all_replace_regex.replace('abc123def456ghi', 'XXX')
   assert(all_result is 'abcXXXdefXXXghi', 'Should replace all occurrences')

   -- Test global replacement with backreferences
   word_regex2 = regex.new('(\\w+)')
   caps_result = word_regex2.replace('hello world', '[$1]')
   assert(caps_result is '[hello] [world]', 'Should wrap all words in brackets')
end

-----------------------------------------------------------------------------------------------------------------------

@Test function Split()
   comma_regex = regex.new('\\s*,\\s*')
   split_result = comma_regex.split('apple, banana,  cherry')
   assert(#split_result is 3, 'Should split into 3 parts')
   assert(split_result[0] is "apple", "First part should be 'apple'")
   assert(split_result[1] is "banana", "Second part should be 'banana'")
   assert(split_result[2] is "cherry", "Third part should be 'cherry'")

   -- Test splitting with multiple delimiters
   multi_regex = regex.new("[,;]\\s*")
   multi_result = multi_regex.split("a,b; c,d")
   assert(#multi_result is 4, "Should split on both comma and semicolon")
   assert(multi_result[0] is "a", "First part incorrect")
   assert(multi_result[1] is "b", "Second part incorrect")
   assert(multi_result[2] is "c", "Third part incorrect")
   assert(multi_result[3] is "d", "Fourth part incorrect")

   -- Test no split (no matches)
   no_split_result = comma_regex.split("no delimiters here")
   assert(#no_split_result is 1, "Should return single element")
   assert(no_split_result[0] is "no delimiters here", "Should return original string")
end

-----------------------------------------------------------------------------------------------------------------------

@Test function Flags()
   -- Case insensitive flag
   icase_regex = regex.new('hello', regex.ICASE)
   assert(icase_regex.test('HELLO'), 'ICASE flag should work')
   assert(icase_regex.test('Hello'), 'ICASE flag should work')
   assert(icase_regex.test('hello'), 'ICASE flag should work')
end

-----------------------------------------------------------------------------------------------------------------------

@Test function ErrorHandling()
   -- Test empty pattern (valid)
   empty_regex = regex.new('')
   assert(empty_regex.test('anything') is true, 'Empty pattern should match anything')

   local invalid
   try
      invalid = regex.new('(unclosed')
   end
   assert(invalid is nil, 'Invalid regex pattern should error')
end

-----------------------------------------------------------------------------------------------------------------------

@Test function RealWorldPatterns()
   -- Email validation
   email_validator = regex.new("^[\\w._%+\\-]+@[\\w.\\-]+\\.[A-Za-z]{2,}$")
   assert(email_validator.test("user@example.com"), "Valid email should pass")
   assert(email_validator.test("test.email+tag@domain.co.uk"), "Complex email should pass")
   assert(not email_validator.test("invalid.email"), "Invalid email should fail")
   assert(not email_validator.test("@invalid.com"), "Invalid email should fail")

   -- URL extraction
   url_extractor = regex.new("https?://[\\w.\\-]+(?:/[\\w.\\/?%&=]*)?")
   url_matches = url_extractor.search("Visit https://example.com or http://test.org/path")
   assert(#url_matches is 2, "Should find 2 URLs, got " .. #url_matches)
   assert(url_matches[0][0] is "https://example.com", "First URL incorrect")
   assert(url_matches[1][0] is "http://test.org/path", "Second URL incorrect")

   -- HTML tag removal
   html_stripper = regex.new("<[^>]*>")
   clean_text = html_stripper.replace("<p>Hello <b>world</b>!</p>", "")
   assert(clean_text is "Hello world!", "Should strip HTML tags")

   -- Phone number formatting
   phone_formatter = regex.new("\\D")
   digits_only = phone_formatter.replace("(555) 123-4567", "")
   assert(digits_only is "5551234567", "Should extract digits only")
end

-----------------------------------------------------------------------------------------------------------------------

@Test function MemoryManagement()
   -- Create many regex objects to test memory handling
   regex_list = {}
   for i = 0, 99 do
      regex_list[i] = regex.new("pattern" .. i)
   end

   processing.collect()

   -- Verify objects still work after GC pressure
   assert(regex_list[50].test("pattern50") is true, "Regex should survive garbage collection")
end

-----------------------------------------------------------------------------------------------------------------------

@Test function Escape()
   -- Test escaping of all metacharacters
   escaped = regex.escape('hello.world')
   assert(escaped is 'hello\\.world', 'Should escape dot')

   escaped = regex.escape('a+b*c?d')
   assert(escaped is 'a\\+b\\*c\\?d', 'Should escape quantifiers')

   escaped = regex.escape('(group)[class]{count}')
   assert(escaped is '\\(group\\)\\[class\\]\\{count\\}', 'Should escape brackets')

   escaped = regex.escape('^start|end$')
   assert(escaped is '\\^start\\|end\\$', 'Should escape anchors and alternation')

   escaped = regex.escape('back\\slash')
   assert(escaped is 'back\\\\slash', 'Should escape backslash')

   -- Test that escaped strings work as literal patterns
   pattern = regex.escape('file.txt')
   rx = regex.new(pattern)
   assert(rx.test('file.txt') is true, 'Should match literal string')
   assert(rx.test('filextxt') is false, 'Should not match unescaped pattern')

   -- Test with user input scenario
   user_input = '[user@example.com]'
   safe_pattern = regex.new(regex.escape(user_input))
   assert(safe_pattern.test('[user@example.com]') is true, 'Should match user input literally')
   assert(safe_pattern.test('user@example.com') is false, 'Should require brackets')
end

-----------------------------------------------------------------------------------------------------------------------

@Test function FindAll()
   -- Test iterator pattern with for loop
   digit_regex = regex.new("[0-9]+")
   matches = {}
   for pos, len in digit_regex.findAll("abc123def456ghi789") do
      matches[#matches] = { pos = pos, len = len }
   end
   assert(#matches is 3, "Should find 3 digit sequences, found " .. #matches)
   assert(matches[0].pos is 3 and matches[0].len is 3, "First match at pos 3, len 3")
   assert(matches[1].pos is 9 and matches[1].len is 3, "Second match at pos 9, len 3")
   assert(matches[2].pos is 15 and matches[2].len is 3, "Third match at pos 15, len 3")

   -- Test with starting position (pos 6 skips past "123" entirely)
   matches2 = {}
   for pos, len in digit_regex.findAll("abc123def456ghi789", 6) do
      matches2[#matches2] = { pos = pos, len = len }
   end
   assert(#matches2 is 2, "Should find 2 digit sequences when starting at pos 6")
   assert(matches2[0].pos is 9, "First match should be at pos 9")

   -- Test no matches
   count = 0
   for pos, len in digit_regex.findAll("no digits here") do
      count += 1
   end
   assert(count is 0, "Should find no matches")

   -- Test single character matches
   char_regex = regex.new("[aeiou]")
   vowels = {}
   for pos, len in char_regex.findAll("hello world") do
      vowels[#vowels] = pos
   end
   assert(#vowels is 3, "Should find 3 vowels (e, o, o)")
   assert(vowels[0] is 1, "First vowel 'e' at pos 1")
   assert(vowels[1] is 4, "Second vowel 'o' at pos 4")
   assert(vowels[2] is 7, "Third vowel 'o' at pos 7")
end
