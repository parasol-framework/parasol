-- Flute tests for the regex functionality

function testConstruction()
   -- Test valid regex construction

   local simple_regex = regex.new("hello")
   assert(simple_regex != nil, "Failed to create simple regex")
   assert(simple_regex.pattern == "hello", "Pattern property incorrect")
   assert(simple_regex.flags == 0, "Flags should default to 0")

   -- Test regex with flags

   local case_regex = regex.new("HELLO", regex.ICASE)
   assert(case_regex.flags == regex.ICASE, "Case insensitive flag not set correctly")

   -- Test invalid regex

   local invalid_regex
   catch(function() invalid_regex = regex.new("[unclosed") end)
   assert(invalid_regex == nil, "Invalid regex should have failed")
end

-----------------------------------------------------------------------------------------------------------------------

function testTestMethod()
   local test_regex = regex.new("\\d+")
   assert(test_regex.test("abc123def"), "Should find digits in string")
   assert(not test_regex.test("hello world"), "Should not find digits in text")
   assert(test_regex.test("999"), "Should match all digits")

   -- Case insensitive test
   local case_test = regex.new("hello", regex.ICASE)
   assert(case_test.test("Hello World"), "Case insensitive should match Hello")
   assert(case_test.test("HELLO"), "Case insensitive should match HELLO")
   assert(not case_test.test("goodbye"), "Should not match different word")
end

-----------------------------------------------------------------------------------------------------------------------

function testMatchMethod()
   -- Simple match
   local word_regex = regex.new("(\\w+)")
   local matches = word_regex.search("hello world")
   assert(matches, "Match should succeed")
   assert(#matches == 2, "Expected two matches (hello and world)")
   assert(matches[1][1] == "hello", "Full match should be 'hello'")
   assert(matches[1][2] == "hello", "Capture should be 'hello'")
   assert(matches[2][1] == "world", "Full match should be 'world'")
   assert(matches[2][2] == "world", "Capture should be 'world'")

   -- Multiple capture groups
   local email_regex = regex.new("([^@]+)@([^.]+)\\.(.+)")
   local email_matches = email_regex.match("user@example.com")
   assert(email_matches, "Should match email")
   assert(email_matches[1] == "user@example.com", "Full match incorrect")
   assert(email_matches[2] == "user", "Username capture incorrect")
   assert(email_matches[3] == "example", "Domain capture incorrect")
   assert(email_matches[4] == "com", "TLD capture incorrect")

   -- No match case
   local no_regex = regex.new("([ABC]+)")
   assert(not no_regex.match("123 456"), "Should return nil for no match")
end

-----------------------------------------------------------------------------------------------------------------------

function testSearchMethod()
   local digit_regex = regex.new("(\\d+)")
   local all_matches = digit_regex.search("abc123def456ghi")
   assert(#all_matches == 2, "Should find 2 digit sequences")
   assert(all_matches[1][1] == "123", "First match should be '123'")
   assert(all_matches[1][2] == "123", "First capture group should be '123'")
   assert(all_matches[2][1] == "456", "Second match should be '456'")
   assert(all_matches[2][2] == "456", "Second capture group should be '456'")

   -- Test with no matches
   local no_matches = digit_regex.search("hello world")
   assert(no_matches == nil, "Should return nil for no matches")
end

-----------------------------------------------------------------------------------------------------------------------

function testReplaceMethod()
   local replace_regex = regex.new("\\d+")
   local result1 = replace_regex.replace("abc123def456", "XXX")
   assert(result1 == "abcXXXdefXXX", "Failed to replace both occurrences")

   -- Test with backreferences
   local phone_regex = regex.new("(\\d{3})-(\\d{3})-(\\d{4})")
   local phone_result = phone_regex.replace("555-123-4567", "($1) $2-$3")
   assert(phone_result == "(555) 123-4567", "Should format phone number correctly")

   -- Test no match
   local no_replace = replace_regex.replace("hello world", "XXX")
   assert(no_replace == "hello world", "Should return original if no match")

   local all_replace_regex = regex.new("\\d+")
   local all_result = all_replace_regex.replace("abc123def456ghi", "XXX")
   assert(all_result == "abcXXXdefXXXghi", "Should replace all occurrences")

   -- Test global replacement with backreferences
   local word_regex2 = regex.new("(\\w+)")
   local caps_result = word_regex2.replace("hello world", "[$1]")
   assert(caps_result == "[hello] [world]", "Should wrap all words in brackets")
end

-----------------------------------------------------------------------------------------------------------------------

function testSplitMethod()
   local comma_regex = regex.new("\\s*,\\s*")
   local split_result = comma_regex.split("apple, banana,  cherry")
   assert(#split_result == 3, "Should split into 3 parts")
   assert(split_result[1] == "apple", "First part should be 'apple'")
   assert(split_result[2] == "banana", "Second part should be 'banana'")
   assert(split_result[3] == "cherry", "Third part should be 'cherry'")

   -- Test splitting with multiple delimiters
   local multi_regex = regex.new("[,;]\\s*")
   local multi_result = multi_regex.split("a,b; c,d")
   assert(#multi_result == 4, "Should split on both comma and semicolon")
   assert(multi_result[1] == "a", "First part incorrect")
   assert(multi_result[2] == "b", "Second part incorrect")
   assert(multi_result[3] == "c", "Third part incorrect")
   assert(multi_result[4] == "d", "Fourth part incorrect")

   -- Test no split (no matches)
   local no_split_result = comma_regex.split("no delimiters here")
   assert(#no_split_result == 1, "Should return single element")
   assert(no_split_result[1] == "no delimiters here", "Should return original string")
end

-----------------------------------------------------------------------------------------------------------------------

function testFlags()
   -- Case insensitive flag
   local icase_regex = regex.new("hello", regex.ICASE)
   assert(icase_regex.test("HELLO"), "ICASE flag should work")
   assert(icase_regex.test("Hello"), "ICASE flag should work")
   assert(icase_regex.test("hello"), "ICASE flag should work")

   -- Multiple flags (test combining)
   local multi_flag_regex = regex.new("hello", regex.ICASE + regex.EXTENDED)
   assert(multi_flag_regex.flags == (regex.ICASE + regex.EXTENDED), "Multiple flags should combine")
end

-----------------------------------------------------------------------------------------------------------------------

function testErrorHandling()
   -- Test empty pattern (valid)
   local empty_regex = regex.new("")
   assert(empty_regex.test("anything") == true, "Empty pattern should match anything")

   local invalid
   catch(function() invalid = regex.new("(unclosed") end)
   assert(invalid == nil, "Invalid regex pattern should error")
end

-----------------------------------------------------------------------------------------------------------------------

function testRealWorldPatterns()
   -- Email validation
   local email_validator = regex.new("^[\\w._%+\\-]+@[\\w.\\-]+\\.[A-Za-z]{2,}$")
   assert(email_validator.test("user@example.com"), "Valid email should pass")
   assert(email_validator.test("test.email+tag@domain.co.uk"), "Complex email should pass")
   assert(not email_validator.test("invalid.email"), "Invalid email should fail")
   assert(not email_validator.test("@invalid.com"), "Invalid email should fail")

   -- URL extraction
   local url_extractor = regex.new("https?://[\\w.\\-]+(?:/[\\w.\\/?%&=]*)?")
   local url_matches = url_extractor.search("Visit https://example.com or http://test.org/path")
   assert(#url_matches == 2, "Should find 2 URLs")
   assert(url_matches[1][1] == "https://example.com", "First URL incorrect")
   assert(url_matches[2][1] == "http://test.org/path", "Second URL incorrect")

   -- HTML tag removal
   local html_stripper = regex.new("<[^>]*>")
   local clean_text = html_stripper.replace("<p>Hello <b>world</b>!</p>", "")
   assert(clean_text == "Hello world!", "Should strip HTML tags")

   -- Phone number formatting
   local phone_formatter = regex.new("\\D")
   local digits_only = phone_formatter.replace("(555) 123-4567", "")
   assert(digits_only == "5551234567", "Should extract digits only")
end

-----------------------------------------------------------------------------------------------------------------------

function testMemoryManagement()
   -- Create many regex objects to test memory handling
   local regex_list = {}
   for i = 1, 100 do
      regex_list[i] = regex.new("pattern" .. i)
   end

   collectgarbage()

   -- Verify objects still work after GC pressure
   assert(regex_list[50].test("pattern50") == true, "Regex should survive garbage collection")
end

-----------------------------------------------------------------------------------------------------------------------

   return {
      tests = {
         'testConstruction',
         'testTestMethod',
         'testMatchMethod',
         'testSearchMethod',
         'testReplaceMethod',
         'testSplitMethod',
         'testFlags',
         'testErrorHandling',
         'testRealWorldPatterns',
         'testMemoryManagement'
      }
   }