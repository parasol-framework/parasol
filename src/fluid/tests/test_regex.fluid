-- Flute tests for the regex functionality

function testConstruction()
   -- Test valid regex construction
   local simple_regex = regex.new("hello")
   if simple_regex == nil then error("Failed to create simple regex") end
   if simple_regex.pattern != "hello" then error("Pattern property incorrect") end
   if simple_regex.flags != 0 then error("Flags should default to 0") end
   if simple_regex.valid != true then error("Simple regex should be valid") end

   -- Test regex with flags
   local case_regex = regex.new("HELLO", regex.ICASE)
   if case_regex.flags != regex.ICASE then error("Case insensitive flag not set correctly") end
   if case_regex.valid != true then error("Case insensitive regex should be valid") end

   -- Test invalid regex (should not crash, but be marked invalid)
   local invalid_regex = regex.new("[unclosed")
   if invalid_regex.valid != false then error("Invalid regex should be marked as invalid") end
   if invalid_regex.error == nil then error("Invalid regex should have error message") end
end

-----------------------------------------------------------------------------------------------------------------------

function testTestMethod()
   local test_regex = regex.new("\\d+")
   if test_regex.test("abc123def") != true then error("Should find digits in string") end
   if test_regex.test("hello world") != false then error("Should not find digits in text") end
   if test_regex.test("999") != true then error("Should match all digits") end

   -- Case insensitive test
   local case_test = regex.new("hello", regex.ICASE)
   if case_test.test("Hello World") != true then error("Case insensitive should match Hello") end
   if case_test.test("HELLO") != true then error("Case insensitive should match HELLO") end
   if case_test.test("goodbye") != false then error("Should not match different word") end
end

-----------------------------------------------------------------------------------------------------------------------

function testMatchMethod()
   -- Simple match
   local word_regex = regex.new("(\\w+)")
   local matches = word_regex.match("hello world")
   if matches == nil then error("Should find match") end
   if matches[1] != "hello" then error("Full match should be 'hello'") end
   if matches[2] != "hello" then error("First capture group should be 'hello'") end

   -- Multiple capture groups
   local email_regex = regex.new("([^@]+)@([^.]+)\\.(.+)")
   local email_matches = email_regex.match("user@example.com")
   if email_matches == nil then error("Should match email") end
   if email_matches[1] != "user@example.com" then error("Full match incorrect") end
   if email_matches[2] != "user" then error("Username capture incorrect") end
   if email_matches[3] != "example" then error("Domain capture incorrect") end
   if email_matches[4] != "com" then error("TLD capture incorrect") end

   -- No match case
   local no_regex = regex.new("([ABC]+)")
   local no_match = no_regex.match("123 456")
   if no_match != nil then error("Should return nil for no match, got '" .. tostring(nz(no_match,'NIL')) .. "'") end
end

-----------------------------------------------------------------------------------------------------------------------

function testMatchAllMethod()
   local digit_regex = regex.new("(\\d+)")
   local all_matches = digit_regex.matchAll("abc123def456ghi")
   if #all_matches != 2 then error("Should find 2 digit sequences") end
   if all_matches[1][1] != "123" then error("First match should be '123'") end
   if all_matches[1][2] != "123" then error("First capture group should be '123'") end
   if all_matches[2][1] != "456" then error("Second match should be '456'") end
   if all_matches[2][2] != "456" then error("Second capture group should be '456'") end

   -- Test with no matches
   local no_matches = digit_regex.matchAll("hello world")
   if #no_matches != 0 then error("Should return empty table for no matches") end
end

-----------------------------------------------------------------------------------------------------------------------

function testReplaceMethod()
   local replace_regex = regex.new("\\d+")
   local result1 = replace_regex.replace("abc123def456", "XXX")
   if result1 != "abcXXXdef456" then error("Should replace only first occurrence") end

   -- Test with backreferences
   local phone_regex = regex.new("(\\d{3})-(\\d{3})-(\\d{4})")
   local phone_result = phone_regex.replace("555-123-4567", "($1) $2-$3")
   if phone_result != "(555) 123-4567" then error("Should format phone number correctly") end

   -- Test no match
   local no_replace = replace_regex.replace("hello world", "XXX")
   if no_replace != "hello world" then error("Should return original if no match") end
end

-----------------------------------------------------------------------------------------------------------------------

function testReplaceAllMethod()
   local all_replace_regex = regex.new("\\d+")
   local all_result = all_replace_regex.replaceAll("abc123def456ghi", "XXX")
   if all_result != "abcXXXdefXXXghi" then error("Should replace all occurrences") end

   -- Test global replacement with backreferences
   local word_regex2 = regex.new("(\\w+)")
   local caps_result = word_regex2.replaceAll("hello world", "[$1]")
   if caps_result != "[hello] [world]" then error("Should wrap all words in brackets") end
end

-----------------------------------------------------------------------------------------------------------------------

function testSplitMethod()
   local comma_regex = regex.new("\\s*,\\s*")
   local split_result = comma_regex.split("apple, banana,  cherry")
   if #split_result != 3 then error("Should split into 3 parts") end
   if split_result[1] != "apple" then error("First part should be 'apple'") end
   if split_result[2] != "banana" then error("Second part should be 'banana'") end
   if split_result[3] != "cherry" then error("Third part should be 'cherry'") end

   -- Test splitting with multiple delimiters
   local multi_regex = regex.new("[,;]\\s*")
   local multi_result = multi_regex.split("a,b; c,d")
   if #multi_result != 4 then error("Should split on both comma and semicolon") end
   if multi_result[1] != "a" then error("First part incorrect") end
   if multi_result[2] != "b" then error("Second part incorrect") end
   if multi_result[3] != "c" then error("Third part incorrect") end
   if multi_result[4] != "d" then error("Fourth part incorrect") end

   -- Test no split (no matches)
   local no_split_result = comma_regex.split("no delimiters here")
   if #no_split_result != 1 then error("Should return single element") end
   if no_split_result[1] != "no delimiters here" then error("Should return original string") end
end

-----------------------------------------------------------------------------------------------------------------------

function testFlags()
   -- Case insensitive flag
   local icase_regex = regex.new("hello", regex.ICASE)
   if icase_regex.test("HELLO") != true then error("ICASE flag should work") end
   if icase_regex.test("Hello") != true then error("ICASE flag should work") end
   if icase_regex.test("hello") != true then error("ICASE flag should work") end

   -- Multiple flags (test combining)
   local multi_flag_regex = regex.new("hello", regex.ICASE + regex.EXTENDED)
   if multi_flag_regex.flags != (regex.ICASE + regex.EXTENDED) then error("Multiple flags should combine") end
end

-----------------------------------------------------------------------------------------------------------------------

function testErrorHandling()
   -- Test empty pattern
   local empty_regex = regex.new("")
   if empty_regex.valid != true then error("Empty pattern should be valid") end
   if empty_regex.test("anything") != true then error("Empty pattern should match anything") end

   -- Test methods on invalid regex should error gracefully
   local invalid = regex.new("(unclosed")
   local success, err = pcall(function() return invalid.test("test") end)
   if success != false then error("Invalid regex methods should error") end
   if not string.find(err, "Invalid regex") then error("Should get proper error message") end
end

-----------------------------------------------------------------------------------------------------------------------

function testRealWorldPatterns()
   -- Email validation
   local email_validator = regex.new("^[\\w._%+-]+@[\\w.-]+\\.[A-Za-z]{2,}$")
   if email_validator.test("user@example.com") != true then error("Valid email should pass") end
   if email_validator.test("test.email+tag@domain.co.uk") != true then error("Complex email should pass") end
   if email_validator.test("invalid.email") != false then error("Invalid email should fail") end
   if email_validator.test("@invalid.com") != false then error("Invalid email should fail") end

   -- URL extraction
   local url_extractor = regex.new("https?://[\\w.-]+(?:/[\\w./?%&=]*)?")
   local url_matches = url_extractor.matchAll("Visit https://example.com or http://test.org/path")
   if #url_matches != 2 then error("Should find 2 URLs") end
   if url_matches[1][1] != "https://example.com" then error("First URL incorrect") end
   if url_matches[2][1] != "http://test.org/path" then error("Second URL incorrect") end

   -- HTML tag removal
   local html_stripper = regex.new("<[^>]*>")
   local clean_text = html_stripper.replaceAll("<p>Hello <b>world</b>!</p>", "")
   if clean_text != "Hello world!" then error("Should strip HTML tags") end

   -- Phone number formatting
   local phone_formatter = regex.new("\\D")
   local digits_only = phone_formatter.replaceAll("(555) 123-4567", "")
   if digits_only != "5551234567" then error("Should extract digits only") end
end

-----------------------------------------------------------------------------------------------------------------------

function testMemoryManagement()
   -- Create many regex objects to test memory handling
   local regex_list = {}
   for i = 1, 100 do
      regex_list[i] = regex.new("pattern" .. i)
      if regex_list[i].valid != true then error("Regex " .. i .. " should be valid") end
   end

   collectgarbage()

   -- Verify objects still work after GC pressure
   if regex_list[50].test("pattern50") != true then error("Regex should survive garbage collection") end
end

-----------------------------------------------------------------------------------------------------------------------

   return {
      tests = {
         'testConstruction',
         'testTestMethod',
         'testMatchMethod',
         'testMatchAllMethod',
         'testReplaceMethod',
         'testReplaceAllMethod',
         'testSplitMethod',
         'testFlags',
         'testErrorHandling',
         'testRealWorldPatterns',
         'testMemoryManagement'
      }
   }