-- Flute tests for the regex functionality

@Test function Construction()
   -- Test valid regex construction

   simple_regex = regex.new("hello")
   assert(simple_regex != nil, "Failed to create simple regex")
   assert(simple_regex.pattern is "hello", "Pattern property incorrect")
   assert(simple_regex.flags is 0, "Flags should default to 0")

   -- Test regex with flags

   case_regex = regex.new("HELLO", regex.ICASE)
   assert(case_regex.flags is regex.ICASE, "Case insensitive flag not set correctly")

   -- Test invalid regex

   local invalid_regex
   try
      invalid_regex = regex.new("[unclosed")
   end
   assert(invalid_regex is nil, "Invalid regex should have failed")
end

-----------------------------------------------------------------------------------------------------------------------

@Test function TestMethod()
   test_regex = regex.new("\\d+")
   assert(test_regex.test("abc123def"), "Should find digits in string")
   assert(not test_regex.test("hello world"), "Should not find digits in text")
   assert(test_regex.test("999"), "Should match all digits")

   -- Case insensitive test
   case_test = regex.new("hello", regex.ICASE)
   assert(case_test.test("Hello World"), "Case insensitive should match Hello")
   assert(case_test.test("HELLO"), "Case insensitive should match HELLO")
   assert(not case_test.test("goodbye"), "Should not match different word")
end

-----------------------------------------------------------------------------------------------------------------------

@Test function MatchMethod()
   -- Simple match
   word_regex = regex.new("(\\w+)")
   matches = word_regex.search("hello world")
   assert(matches, "Match should succeed")
   assert(#matches is 2, "Expected two matches (hello and world), got " .. #matches)
   assert(matches[0][0] is "hello", "Full match should be 'hello'")
   assert(matches[0][1] is "hello", "Capture should be 'hello'")
   assert(matches[1][0] is "world", "Full match should be 'world'")
   assert(matches[1][1] is "world", "Capture should be 'world'")

   -- Multiple capture groups
   email_regex = regex.new("([^@]+)@([^.]+)\\.(.+)")
   email_matches = email_regex.match("user@example.com")
   assert(email_matches, "Should match email")
   assert(email_matches[0] is "user@example.com", "Full match incorrect")
   assert(email_matches[1] is "user", "Username capture incorrect")
   assert(email_matches[2] is "example", "Domain capture incorrect")
   assert(email_matches[3] is "com", "TLD capture incorrect")

   -- No match case
   no_regex = regex.new("([ABC]+)")
   assert(not no_regex.match("123 456"), "Should return nil for no match")
end

-----------------------------------------------------------------------------------------------------------------------

@Test function SearchMethod()
   digit_regex = regex.new("(\\d+)")
   all_matches = digit_regex.search("abc123def456ghi")
   assert(#all_matches is 2, "Should find 2 digit sequences")
   assert(all_matches[0][0] is "123", "First match should be '123'")
   assert(all_matches[0][1] is "123", "First capture group should be '123'")
   assert(all_matches[1][0] is "456", "Second match should be '456'")
   assert(all_matches[1][1] is "456", "Second capture group should be '456'")

   -- Test with no matches
   no_matches = digit_regex.search("hello world")
   assert(no_matches is nil, "Should return nil for no matches")
end

-----------------------------------------------------------------------------------------------------------------------

@Test function ReplaceMethod()
   replace_regex = regex.new("\\d+")
   result1 = replace_regex.replace("abc123def456", "XXX")
   assert(result1 is "abcXXXdefXXX", "Failed to replace both occurrences")

   -- Test with backreferences
   phone_regex = regex.new("(\\d{3})-(\\d{3})-(\\d{4})")
   phone_result = phone_regex.replace("555-123-4567", "($1) $2-$3")
   assert(phone_result is "(555) 123-4567", "Should format phone number correctly")

   -- Test no match
   no_replace = replace_regex.replace("hello world", "XXX")
   assert(no_replace is "hello world", "Should return original if no match")

   all_replace_regex = regex.new("\\d+")
   all_result = all_replace_regex.replace("abc123def456ghi", "XXX")
   assert(all_result is "abcXXXdefXXXghi", "Should replace all occurrences")

   -- Test global replacement with backreferences
   word_regex2 = regex.new("(\\w+)")
   caps_result = word_regex2.replace("hello world", "[$1]")
   assert(caps_result is "[hello] [world]", "Should wrap all words in brackets")
end

-----------------------------------------------------------------------------------------------------------------------

@Test function SplitMethod()
   comma_regex = regex.new("\\s*,\\s*")
   split_result = comma_regex.split("apple, banana,  cherry")
   assert(#split_result is 3, "Should split into 3 parts")
   assert(split_result[0] is "apple", "First part should be 'apple'")
   assert(split_result[1] is "banana", "Second part should be 'banana'")
   assert(split_result[2] is "cherry", "Third part should be 'cherry'")

   -- Test splitting with multiple delimiters
   multi_regex = regex.new("[,;]\\s*")
   multi_result = multi_regex.split("a,b; c,d")
   assert(#multi_result is 4, "Should split on both comma and semicolon")
   assert(multi_result[0] is "a", "First part incorrect")
   assert(multi_result[1] is "b", "Second part incorrect")
   assert(multi_result[2] is "c", "Third part incorrect")
   assert(multi_result[3] is "d", "Fourth part incorrect")

   -- Test no split (no matches)
   no_split_result = comma_regex.split("no delimiters here")
   assert(#no_split_result is 1, "Should return single element")
   assert(no_split_result[0] is "no delimiters here", "Should return original string")
end

-----------------------------------------------------------------------------------------------------------------------

@Test function Flags()
   -- Case insensitive flag
   icase_regex = regex.new("hello", regex.ICASE)
   assert(icase_regex.test("HELLO"), "ICASE flag should work")
   assert(icase_regex.test("Hello"), "ICASE flag should work")
   assert(icase_regex.test("hello"), "ICASE flag should work")
end

-----------------------------------------------------------------------------------------------------------------------

@Test function ErrorHandling()
   -- Test empty pattern (valid)
   empty_regex = regex.new("")
   assert(empty_regex.test("anything") is true, "Empty pattern should match anything")

   local invalid
   try
      invalid = regex.new("(unclosed")
   end
   assert(invalid is nil, "Invalid regex pattern should error")
end

-----------------------------------------------------------------------------------------------------------------------

@Test function RealWorldPatterns()
   -- Email validation
   email_validator = regex.new("^[\\w._%+\\-]+@[\\w.\\-]+\\.[A-Za-z]{2,}$")
   assert(email_validator.test("user@example.com"), "Valid email should pass")
   assert(email_validator.test("test.email+tag@domain.co.uk"), "Complex email should pass")
   assert(not email_validator.test("invalid.email"), "Invalid email should fail")
   assert(not email_validator.test("@invalid.com"), "Invalid email should fail")

   -- URL extraction
   url_extractor = regex.new("https?://[\\w.\\-]+(?:/[\\w.\\/?%&=]*)?")
   url_matches = url_extractor.search("Visit https://example.com or http://test.org/path")
   assert(#url_matches is 2, "Should find 2 URLs, got " .. #url_matches)
   assert(url_matches[0][0] is "https://example.com", "First URL incorrect")
   assert(url_matches[1][0] is "http://test.org/path", "Second URL incorrect")

   -- HTML tag removal
   html_stripper = regex.new("<[^>]*>")
   clean_text = html_stripper.replace("<p>Hello <b>world</b>!</p>", "")
   assert(clean_text is "Hello world!", "Should strip HTML tags")

   -- Phone number formatting
   phone_formatter = regex.new("\\D")
   digits_only = phone_formatter.replace("(555) 123-4567", "")
   assert(digits_only is "5551234567", "Should extract digits only")
end

-----------------------------------------------------------------------------------------------------------------------

@Test function MemoryManagement()
   -- Create many regex objects to test memory handling
   regex_list = {}
   for i = 0, 99 do
      regex_list[i] = regex.new("pattern" .. i)
   end

   collectgarbage()

   -- Verify objects still work after GC pressure
   assert(regex_list[50].test("pattern50") is true, "Regex should survive garbage collection")
end
