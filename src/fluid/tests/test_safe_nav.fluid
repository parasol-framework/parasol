-- Flute tests for the safe navigation operators - ?., ?: and ?[

@BeforeEach(hotpath=true)
function enforce_hotpath() end

----------------------------------------------------------------------------------------------------------------------

@Test function testSafeFieldOnNil()
   user = nil
   name = user?.profile?.details?.name
   assert(name is nil, "Safe field on nil should yield nil")
end

----------------------------------------------------------------------------------------------------------------------

@Test function testSafeFieldChain()
   user = { profile = { name = "Alex" } }
   name = user.profile.name -- To prove no exception thrown for access
   name = user?.profile?.name
   assert(name is "Alex", "Safe field chain should return nested value, got " .. tostring(name))
   missing = user?.profile?.address
   assert(missing is nil, "Missing field in chain should yield nil")
end

----------------------------------------------------------------------------------------------------------------------

@Test function testSafeIndexOnNil()
   items = nil
   value = items?[1]
   assert(value is nil, "Safe index on nil should yield nil, got " .. tostring(value))
end

----------------------------------------------------------------------------------------------------------------------

@Test function testSafeIndexValue()
   container = { values = { [1] = "First", [2] = "Second" } }
   value = container?.values?[2]
   assert(value is "Second", "Safe index should return stored element when present, got " .. tostring(value))
end

----------------------------------------------------------------------------------------------------------------------

@Test function testSafeIndexShortCircuit()
   calls = 0
   function nextIndex()
      calls++
      return 2
   end
   arr = nil
   value = arr?[nextIndex()]
   assert(value is nil, "Safe index should produce nil when base is nil")
   assert(calls is 0, "Index expression must not be evaluated when base is nil")
end

----------------------------------------------------------------------------------------------------------------------

@Test function testSafeMethodOnNil()
   calls = 0
   function argument()
      calls += 1
      return "ignored"
   end
   target = nil
   result = target?:speak(argument())
   assert(result is nil, "Safe method on nil should yield nil")
   assert(calls is 0, "Method arguments must not be evaluated when base is nil")
end

----------------------------------------------------------------------------------------------------------------------

@Test function testSafeMethodValue()
   greeter = { prefix = "Hello" }
   function greeter:say(name)
      return self.prefix .. ", " .. name
   end
   result = greeter?:say("World")
   assert(result is "Hello, World", "Safe method should call method when base exists, got " .. tostring(result))
end

----------------------------------------------------------------------------------------------------------------------

@Test function testSafeMethodChain()
   account = { profile = { email = "user@example.com" } }
   function account:getProfile()
      return self.profile
   end
   email = account?:getProfile()?.email
   assert(email is "user@example.com", "Safe method chain should propagate returned table, got " .. tostring(email))
   missing = nil?:getProfile()?.email
   assert(missing is nil, "Safe method chain should short-circuit on nil base, got " .. tostring(missing))
end

----------------------------------------------------------------------------------------------------------------------

@Test function testIntegrationWithPresence()
   guest = nil
   display = guest?.profile?.name ?? "Guest"
   assert(display is "Guest", "Presence operator should provide default when safe chain yields nil, got " .. tostring(display))
   member = { profile = { name = "Chloe" } }
   memberDisplay = member?.profile?.name ?? "Guest"
   assert(memberDisplay is "Chloe", "Presence operator should see real value when safe chain succeeds")
end

----------------------------------------------------------------------------------------------------------------------

@Test function testSafeNavPresenceFallbackVariants()
   guest = nil

   constantFallback = guest?.profile?.name ?? "Guest"
   assert(constantFallback is "Guest", "Constant fallback should survive safe navigation presence chain")

   fallbackLabel = "Visitor"
   localFallback = guest?.profile?.name ?? fallbackLabel
   assert(localFallback is "Visitor", "Local fallback should be forwarded when chain is nil")

   function computeFallback()
      return "Computed"
   end
   computedFallback = guest?.profile?.name ?? computeFallback()
   assert(computedFallback is "Computed", "Function fallback should be invoked when chain is nil")

   member = { profile = { name = "Chloe" } }
   truthyChain = member?.profile?.name ?? "Guest"
   assert(truthyChain is "Chloe", "Truthy safe navigation chain should bypass the fallback value")
end

----------------------------------------------------------------------------------------------------------------------

@Test function testSafeNavPresenceInsideCallLosesFallback()
   guest = nil
   function capture(value)
      return value
   end
   result = ""
   ok, err = pcall(function()
      result = capture(guest?.profile?.name ?? "Guest")
   end)
   assert(ok is true, "Function call should succeed, err=" .. tostring(err))
   assert(result is "Guest", "BUG: safe-nav + ?? argument currently yields " .. tostring(result) .. " instead of fallback")
end

----------------------------------------------------------------------------------------------------------------------

@Test function testSafeNavPresenceWithSiblingArgumentLosesFallback()
   guest = nil
   function capture(first, second)
      return first, second
   end
   firstResult, secondResult = "", ""
   ok, err = pcall(function()
      firstResult, secondResult = capture(guest?.profile?.name ?? "Guest", "suffix")
   end)
   assert(ok is true, "Function call with extra argument should succeed, err=" .. tostring(err))
   assert(firstResult is "Guest", "BUG: safe-nav + ?? argument produced " .. tostring(firstResult) .. " instead of fallback")
   assert(secondResult is "suffix", "BUG: sibling argument should pass through unchanged")
end

----------------------------------------------------------------------------------------------------------------------

@Test function testSafeFieldWithOrQuestion()
   fallback = { label = "Fallback" }
   label = fallback?.missingField ?? "Default"
   assert(label is "Default", "?? should observe nil result from safe field, got " .. tostring(label))
end

----------------------------------------------------------------------------------------------------------------------
-- Test safe navigation with false values (should not treat as nil)

@Test function testSafeFieldFalseValue()
   obj = { flag = false }
   v = obj?.flag
   assert(v is false, "Safe field should return false, not nil")
end

----------------------------------------------------------------------------------------------------------------------
-- Test safe navigation with zero values (should not treat as nil)

@Test function testSafeFieldZeroValue()
   obj = { count = 0 }
   v = obj?.count
   assert(v is 0, "Safe field should return 0, not nil")
end

----------------------------------------------------------------------------------------------------------------------
-- Test safe navigation with empty string (should not treat as nil)

@Test function testSafeFieldEmptyString()
   obj = { text = "" }
   v = obj?.text
   assert(v is "", "Safe field should return empty string, not nil")
end

----------------------------------------------------------------------------------------------------------------------
-- Test three-level chaining

@Test function testThreeLevelChaining()
   obj = { a = { b = { c = 123 } } }
   v = obj?.a?.b?.c
   assert(v is 123, "Three-level chaining should return nested value")

   obj2 = { a = { b = nil } }
   v2 = obj2?.a?.b?.c
   assert(v2 is nil, "Three-level chaining should short-circuit on nil")
end

----------------------------------------------------------------------------------------------------------------------
-- Test safe method with multiple arguments

@Test function testSafeMethodMultipleArgs()
   calculator = {
      add = function(self, a, b, c)
         return a + b + c
      end
   }
   result = calculator?:add(1, 2, 3)
   assert(result is 6, "Safe method should handle multiple arguments, got " .. tostring(result))
end

----------------------------------------------------------------------------------------------------------------------
-- Test safe index with variable key

@Test function testSafeIndexVariableKey()
   key = "mykey"
   obj = { mykey = "myvalue" }
   v = obj?[key]
   assert(v is "myvalue", "Safe index should work with variable keys")

   obj2 = nil
   v2 = obj2?[key]
   assert(v2 is nil, "Safe index on nil should return nil with variable key")
end

----------------------------------------------------------------------------------------------------------------------
-- Test mixed safe field and safe index

@Test function testMixedFieldAndIndex()
   obj = { arr = { [1] = "first", [2] = "second" } }
   v = obj?.arr?[2]
   assert(v is "second", "Mixed safe field and index should work")

   obj2 = { arr = nil }
   v2 = obj2?.arr?[1]
   assert(v2 is nil, "Mixed safe field and index should short-circuit")
end

----------------------------------------------------------------------------------------------------------------------
-- Test safe navigation on empty table

@Test function testSafeFieldOnEmptyTable()
   obj = {}
   v = obj?.missingField
   assert(v is nil, "Safe field on empty table should return nil")
end

----------------------------------------------------------------------------------------------------------------------
-- Test chaining with methods and fields

@Test function testChainingMethodsAndFields()
   ef_called = 0
   service = {
      data = {
         value = 42,
         embedded_function = function(arg1, arg2, arg3)
            ef_called++
            assert(arg1 is 1, "Embedded function arg1 mismatch, got " .. tostring(arg1))
            assert(arg2 is '2', "Embedded function arg2 mismatch, got " .. tostring(arg2))
            assert(arg3[0] is '3', "Embedded function arg3 mismatch, got " .. tostring(arg3[0]))
            return 0xff
         end
      },
      getData = function(self)
         return self.data
      end
   }
   v = service?:getData()?.value
   assert(v is 42, "Chaining methods and fields should work, got " .. tostring(v))

   nilService = nil
   v2 = nilService?:getData()?.value
   assert(v2 is nil, "Chaining methods and fields should short-circuit on nil")

   v = service.data.embedded_function(1, "2", { "3" })
   assert(v is 255, "Embedded function should return the correct value")

   v = service.data?.embedded_function(1, "2", { "3" })
   assert(v is 255, "Embedded function should return the correct value")

   v = service.data?.not_embedded_function()
   assert(not v, "Expected nil for function that doesn't exist")

   assert(ef_called is 2, "Embedded function should have been called 3 times, was called " .. tostring(ef_called) .. " times")
end

----------------------------------------------------------------------------------------------------------------------
-- Test safe index with numeric keys

@Test function testSafeIndexNumericKeys()
   arr = { 10, 20, 30, 40 }
   v = arr?[2]
   assert(v is 30, "Safe index should work with numeric keys")

   nilArr = nil
   v2 = nilArr?[1]
   assert(v2 is nil, "Safe index on nil array should return nil")
end

----------------------------------------------------------------------------------------------------------------------
-- Test complex chaining scenario

@Test function testComplexChaining()
   data = {
      users = {
         [1] = {
            profile = {
               settings = {
                  theme = "dark"
               }
            }
         }
      }
   }
   theme = data?.users?[1]?.profile?.settings?.theme
   assert(theme is "dark", "Complex chaining should work")

   data2 = { users = { [1] = { profile = nil } } }
   theme2 = data2?.users?[1]?.profile?.settings?.theme
   assert(theme2 is nil, "Complex chaining should short-circuit")
end

----------------------------------------------------------------------------------------------------------------------
-- Test safe method returning nil

@Test function testSafeMethodReturningNil()
   obj = {
      getNil = function(self)
         return nil
      end
   }
   v = obj?:getNil()
   assert(v is nil, "Safe method can return nil as a valid result")
end

----------------------------------------------------------------------------------------------------------------------
-- Test safe navigation with if-empty on each level.  NB: Failure could mean a problem with either operator, or
-- interference of one with the other.

@Test function testChainingWithIfEmpty()
   obj = { a = { b = nil } }
   v = (obj?.a?.b?.c) ?? "default"
   assert(v is "default", "Chaining with if-empty should use default on nil, got " .. tostring(v))

   obj2 = { a = { b = { c = "value" } } }
   v2 = (obj2?.a?.b?.c) ?? "default"
   assert(v2 is "value", "Chaining with if-empty should use value when present")
end
