-- Flute tests for the safe navigation operators - ?., ?: and ?[

@BeforeEach(hotpath=true)
function enforce_hotpath() end

----------------------------------------------------------------------------------------------------------------------

@Test function testSafeFieldOnNil()
   user = nil
   name = user?.profile?.details?.name
   assert(name is nil, "Safe field on nil should yield nil")
end

----------------------------------------------------------------------------------------------------------------------

@Test function testSafeFieldChain()
   user = { profile = { name = "Alex" } }
   name = user.profile.name -- To prove no exception thrown for access
   name = user?.profile?.name
   assert(name is "Alex", "Safe field chain should return nested value, got " .. tostring(name))
   missing = user?.profile?.address
   assert(missing is nil, "Missing field in chain should yield nil")
end

----------------------------------------------------------------------------------------------------------------------

@Test function testSafeIndexOnNil()
   items = nil
   value = items?[1]
   assert(value is nil, "Safe index on nil should yield nil, got " .. tostring(value))
end

----------------------------------------------------------------------------------------------------------------------

@Test function testSafeIndexValue()
   container = { values = { [1] = "First", [2] = "Second" } }
   value = container?.values?[2]
   assert(value is "Second", "Safe index should return stored element when present, got " .. tostring(value))

   -- Test with native Fluid array (use separate variable since array != table)
   arr_container = array<string> { "First", "Second" }
   value = arr_container?[1]
   assert(value is "Second", "Safe index should return stored element when present, got " .. tostring(value))

   value = arr_container?[6]
   assert(value is nil, "Safe index should return nil when index is out of bounds, got " .. tostring(value))
end

----------------------------------------------------------------------------------------------------------------------

@Test function testSafeIndexShortCircuit()
   calls = 0
   function nextIndex()
      calls++
      return 2
   end
   arr = nil
   value = arr?[nextIndex()]
   assert(value is nil, "Safe index should produce nil when base is nil")
   assert(calls is 0, "Index expression must not be evaluated when base is nil")
end

----------------------------------------------------------------------------------------------------------------------

@Test function testSafeMethodOnNil()
   calls = 0
   function argument()
      calls += 1
      return "ignored"
   end
   target = nil
   result = target?:speak(argument())
   assert(result is nil, "Safe method on nil should yield nil")
   assert(calls is 0, "Method arguments must not be evaluated when base is nil")
end

----------------------------------------------------------------------------------------------------------------------

@Test function testSafeMethodValue()
   greeter = { prefix = "Hello" }
   function greeter:say(name)
      return self.prefix .. ", " .. name
   end
   result = greeter?:say("World")
   assert(result is "Hello, World", "Safe method should call method when base exists, got " .. tostring(result))
end

----------------------------------------------------------------------------------------------------------------------

@Test function testSafeMethodChain()
   account = { profile = { email = "user@example.com" } }
   function account:getProfile()
      return self.profile
   end
   email = account?:getProfile()?.email
   assert(email is "user@example.com", "Safe method chain should propagate returned table, got " .. tostring(email))
   missing = nil?:getProfile()?.email
   assert(missing is nil, "Safe method chain should short-circuit on nil base, got " .. tostring(missing))
end

----------------------------------------------------------------------------------------------------------------------

@Test function testIntegrationWithPresence()
   guest = nil
   display = guest?.profile?.name ?? "Guest"
   assert(display is "Guest", "Presence operator should provide default when safe chain yields nil, got " .. tostring(display))
   member = { profile = { name = "Chloe" } }
   memberDisplay = member?.profile?.name ?? "Guest"
   assert(memberDisplay is "Chloe", "Presence operator should see real value when safe chain succeeds")
end

----------------------------------------------------------------------------------------------------------------------

@Test function testSafeNavPresenceFallbackVariants()
   guest = nil

   constantFallback = guest?.profile?.name ?? "Guest"
   assert(constantFallback is "Guest", "Constant fallback should survive safe navigation presence chain")

   fallbackLabel = "Visitor"
   localFallback = guest?.profile?.name ?? fallbackLabel
   assert(localFallback is "Visitor", "Local fallback should be forwarded when chain is nil")

   function computeFallback()
      return "Computed"
   end
   computedFallback = guest?.profile?.name ?? computeFallback()
   assert(computedFallback is "Computed", "Function fallback should be invoked when chain is nil")

   member = { profile = { name = "Chloe" } }
   truthyChain = member?.profile?.name ?? "Guest"
   assert(truthyChain is "Chloe", "Truthy safe navigation chain should bypass the fallback value")
end

----------------------------------------------------------------------------------------------------------------------

@Test function testSafeNavPresenceInsideCallLosesFallback()
   guest = nil
   function capture(value)
      return value
   end

   try
      result = capture(guest?.profile?.name ?? "Guest")
      assert(result is "Guest", f"BUG: safe-nav + ?? argument currently yields {result} instead of fallback")
   except ex
      error("Function call should succeed, err=" .. ex.message)
   end
end

----------------------------------------------------------------------------------------------------------------------

@Test function testSafeNavPresenceWithSiblingArgumentLosesFallback()
   guest = nil
   function capture(first, second)
      return first, second
   end

   firstResult, secondResult = capture(guest?.profile?.name ?? "Guest", "suffix")
   assert(firstResult is "Guest", f"BUG: safe-nav + ?? argument produced {firstResult} instead of fallback")
   assert(secondResult is "suffix", "BUG: sibling argument should pass through unchanged")
end

----------------------------------------------------------------------------------------------------------------------

@Test function testSafeFieldWithOrQuestion()
   fallback = { label = "Fallback" }
   label = fallback?.missingField ?? "Default"
   assert(label is "Default", "?? should observe nil result from safe field, got " .. tostring(label))
end

----------------------------------------------------------------------------------------------------------------------
-- Test safe navigation with false values (should not treat as nil)

@Test function testSafeFieldFalseValue()
   obj = { flag = false }
   v = obj?.flag
   assert(v is false, "Safe field should return false, not nil")
end

----------------------------------------------------------------------------------------------------------------------
-- Test safe navigation with zero values (should not treat as nil)

@Test function testSafeFieldZeroValue()
   obj = { count = 0 }
   v = obj?.count
   assert(v is 0, "Safe field should return 0, not nil")
end

----------------------------------------------------------------------------------------------------------------------
-- Test safe navigation with empty string (should not treat as nil)

@Test function testSafeFieldEmptyString()
   obj = { text = "" }
   v = obj?.text
   assert(v is "", "Safe field should return empty string, not nil")
end

----------------------------------------------------------------------------------------------------------------------
-- Test three-level chaining

@Test function testThreeLevelChaining()
   obj = { a = { b = { c = 123 } } }
   v = obj?.a?.b?.c
   assert(v is 123, "Three-level chaining should return nested value")

   obj2 = { a = { b = nil } }
   v2 = obj2?.a?.b?.c
   assert(v2 is nil, "Three-level chaining should short-circuit on nil")
end

----------------------------------------------------------------------------------------------------------------------
-- Test safe method with multiple arguments

@Test function testSafeMethodMultipleArgs()
   calculator = {
      add = function(self, a, b, c)
         return a + b + c
      end
   }
   result = calculator?:add(1, 2, 3)
   assert(result is 6, "Safe method should handle multiple arguments, got " .. tostring(result))
end

----------------------------------------------------------------------------------------------------------------------
-- Test safe index with variable key

@Test function testSafeIndexVariableKey()
   key = "mykey"
   obj = { mykey = "myvalue" }
   v = obj?[key]
   assert(v is "myvalue", "Safe index should work with variable keys")

   obj2 = nil
   v2 = obj2?[key]
   assert(v2 is nil, "Safe index on nil should return nil with variable key")
end

----------------------------------------------------------------------------------------------------------------------
-- Test mixed safe field and safe index

@Test function testMixedFieldAndIndex()
   obj = { arr = { [1] = "first", [2] = "second" } }
   v = obj?.arr?[2]
   assert(v is "second", "Mixed safe field and index should work")

   obj2 = { arr = nil }
   v2 = obj2?.arr?[1]
   assert(v2 is nil, "Mixed safe field and index should short-circuit")
end

----------------------------------------------------------------------------------------------------------------------
-- Test safe navigation on empty table

@Test function testSafeFieldOnEmptyTable()
   obj = {}
   v = obj?.missingField
   assert(v is nil, "Safe field on empty table should return nil")
end

----------------------------------------------------------------------------------------------------------------------
-- Test chaining with methods and fields

@Test function testChainingMethodsAndFields()
   ef_called = 0
   service = {
      data = {
         value = 42,
         embedded_function = function(arg1, arg2, arg3)
            ef_called++
            assert(arg1 is 1, "Embedded function arg1 mismatch, got " .. tostring(arg1))
            assert(arg2 is '2', "Embedded function arg2 mismatch, got " .. tostring(arg2))
            assert(arg3[0] is '3', "Embedded function arg3 mismatch, got " .. tostring(arg3[0]))
            return 0xff
         end
      },
      getData = function(self)
         return self.data
      end
   }
   v = service?:getData()?.value
   assert(v is 42, "Chaining methods and fields should work, got " .. tostring(v))

   nilService = nil
   v2 = nilService?:getData()?.value
   assert(v2 is nil, "Chaining methods and fields should short-circuit on nil")

   v = service.data.embedded_function(1, "2", { "3" })
   assert(v is 255, "Embedded function should return the correct value")

   v = service.data?.embedded_function(1, "2", { "3" })
   assert(v is 255, "Embedded function should return the correct value")

   v = service.data?.not_embedded_function()
   assert(not v, "Expected nil for function that doesn't exist")

   assert(ef_called is 2, "Embedded function should have been called 3 times, was called " .. tostring(ef_called) .. " times")
end

----------------------------------------------------------------------------------------------------------------------
-- Test safe index with numeric keys

@Test function testSafeIndexNumericKeys()
   arr = { 10, 20, 30, 40 }
   v = arr?[2]
   assert(v is 30, "Safe index should work with numeric keys")

   nilArr = nil
   v2 = nilArr?[1]
   assert(v2 is nil, "Safe index on nil array should return nil")
end

----------------------------------------------------------------------------------------------------------------------
-- Test complex chaining scenario

@Test function testComplexChaining()
   data = {
      users = {
         [1] = {
            profile = {
               settings = {
                  theme = "dark"
               }
            }
         }
      }
   }
   theme = data?.users?[1]?.profile?.settings?.theme
   assert(theme is "dark", "Complex chaining should work")

   data2 = { users = { [1] = { profile = nil } } }
   theme2 = data2?.users?[1]?.profile?.settings?.theme
   assert(theme2 is nil, "Complex chaining should short-circuit")
end

----------------------------------------------------------------------------------------------------------------------
-- Test safe method returning nil

@Test function testSafeMethodReturningNil()
   obj = {
      getNil = function(self)
         return nil
      end
   }
   v = obj?:getNil()
   assert(v is nil, "Safe method can return nil as a valid result")
end

----------------------------------------------------------------------------------------------------------------------
-- Test safe navigation with if-empty on each level.  NB: Failure could mean a problem with either operator, or
-- interference of one with the other.

@Test function testChainingWithIfEmpty()
   obj = { a = { b = nil } }
   v = (obj?.a?.b?.c) ?? "default"
   assert(v is "default", "Chaining with if-empty should use default on nil, got " .. tostring(v))

   obj2 = { a = { b = { c = "value" } } }
   v2 = (obj2?.a?.b?.c) ?? "default"
   assert(v2 is "value", "Chaining with if-empty should use value when present")
end

----------------------------------------------------------------------------------------------------------------------
-- Fluid Array Safe Navigation Tests

@Test function testFluidArraySafeIndexBasic()
   -- Test different array element types with safe navigation
   intArr = array<int> { 10, 20, 30, 40, 50 }
   assert(intArr?[0] is 10, "Safe index on int array should return first element")
   assert(intArr?[2] is 30, "Safe index on int array should return middle element")
   assert(intArr?[4] is 50, "Safe index on int array should return last element")
   assert(intArr?[5] is nil, "Safe index out of bounds should return nil")
   assert(intArr?[100] is nil, "Safe index far out of bounds should return nil")

   doubleArr = array<double> { 1.5, 2.5, 3.5 }
   assert(doubleArr?[0] is 1.5, "Safe index on double array should work")
   assert(doubleArr?[3] is nil, "Safe index out of bounds on double array should return nil")

   byteArr = array<byte> { 255, 128, 0 }
   assert(byteArr?[0] is 255, "Safe index on byte array should work")
   assert(byteArr?[1] is 128, "Safe index on byte array should return correct value")
   assert(byteArr?[3] is nil, "Safe index out of bounds on byte array should return nil")
end

----------------------------------------------------------------------------------------------------------------------

@Test function testFluidArraySafeIndexVariable()
   -- Test safe navigation with variable indices
   arr = array<string> { "zero", "one", "two", "three" }

   idx = 0
   assert(arr?[idx] is "zero", "Safe index with variable index 0 should work")

   idx = 2
   assert(arr?[idx] is "two", "Safe index with variable index should work")

   idx = 10
   assert(arr?[idx] is nil, "Safe index with out-of-bounds variable index should return nil")

   -- Test with computed index
   base = 1
   assert(arr?[base + 1] is "two", "Safe index with computed index should work")
   assert(arr?[base + 100] is nil, "Safe index with out-of-bounds computed index should return nil")
end

----------------------------------------------------------------------------------------------------------------------

@Test function testFluidArraySafeIndexNilArray()
   -- Test safe navigation on nil array variable
   nilArr = nil
   assert(nilArr?[0] is nil, "Safe index on nil should return nil")
   assert(nilArr?[5] is nil, "Safe index on nil with any index should return nil")

   -- Verify index expression is not evaluated when base is nil
   indexCalls = 0
   function getIndex()
      indexCalls++
      return 0
   end
   result = nilArr?[getIndex()]
   assert(result is nil, "Safe index on nil should return nil")
   assert(indexCalls is 0, "Index expression should not be evaluated when array is nil")
end

----------------------------------------------------------------------------------------------------------------------

@Test function testFluidArraySafeIndexChained()
   -- Test chained safe navigation with arrays
   data = {
      items = array<int> { 100, 200, 300 }
   }
   assert(data?.items?[0] is 100, "Chained safe navigation to array should work")
   assert(data?.items?[2] is 300, "Chained safe navigation to array last element should work")
   assert(data?.items?[5] is nil, "Chained safe navigation with out-of-bounds should return nil")

   -- Test with nil intermediate
   data2 = { items = nil }
   assert(data2?.items?[0] is nil, "Chained safe navigation with nil intermediate should return nil")

   -- Test with nil base
   data3 = nil
   assert(data3?.items?[0] is nil, "Chained safe navigation with nil base should return nil")
end

----------------------------------------------------------------------------------------------------------------------

@Test function testFluidArraySafeIndexWithFallback()
   -- Test safe array navigation combined with ?? operator
   arr = array<string> { "first", "second" }

   v = arr?[0] ?? "default"
   assert(v is "first", "Safe index with fallback should return value when present")

   v = arr?[10] ?? "default"
   assert(v is "default", "Safe index out of bounds with fallback should return default")

   nilArr = nil
   v = nilArr?[0] ?? "default"
   assert(v is "default", "Safe index on nil with fallback should return default")
end

----------------------------------------------------------------------------------------------------------------------

@Test function testFluidArraySafeIndexNestedArrays()
   -- Test arrays containing other arrays (if supported)
   outer = array<any> { array<int> { 1, 2, 3 }, array<int> { 4, 5, 6 } }

   inner = outer?[0]
   assert(inner, "Safe index should return nested array")
   assert(inner?[0] is 1, "Safe index on nested array should work")
   assert(inner?[2] is 3, "Safe index on nested array should return correct value")

   -- Out of bounds on outer
   assert(outer?[5] is nil, "Safe index out of bounds on outer array should return nil")

   -- Out of bounds on inner (if we got a valid inner)
   inner2 = outer?[1]
   assert(inner2?[10] is nil, "Safe index out of bounds on inner array should return nil")
end

----------------------------------------------------------------------------------------------------------------------

@Test function testFluidArraySafeIndexEmptyArray()
   -- Test safe navigation on empty arrays
   emptyInt = array.new(0, 'int')
   assert(emptyInt?[0] is nil, "Safe index on empty array should return nil")

   emptyStr = array.new(0, 'string')
   assert(emptyStr?[0] is nil, "Safe index on empty string array should return nil")
end

----------------------------------------------------------------------------------------------------------------------

@Test function testFluidArraySafeIndexInLoop()
   -- Test safe navigation in loop context
   arr = array<int> { 10, 20, 30 }
   results = {}

   for i in {0..5} do
      results[i] = arr?[i] ?? -1
   end

   assert(results[0] is 10, "Safe index in loop should work for index 0")
   assert(results[1] is 20, "Safe index in loop should work for index 1")
   assert(results[2] is 30, "Safe index in loop should work for index 2")
   assert(results[3] is -1, "Safe index in loop should return fallback for out of bounds")
   assert(results[4] is -1, "Safe index in loop should return fallback for out of bounds")
end

----------------------------------------------------------------------------------------------------------------------

@Test function testFluidArraySafeIndexTableInArray()
   -- Test array containing tables
   arr = array<table> { { name = "Alice" }, { name = "Bob" }, { name = "Carol" } }

   assert(arr?[0]?.name is "Alice", "Safe navigation through array to table field should work")
   assert(arr?[1]?.name is "Bob", "Safe navigation through array to table field should work")
   assert(arr?[5]?.name is nil, "Safe navigation with out-of-bounds array should return nil")
end
