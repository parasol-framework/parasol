-- Flute tests for the blank identifier (_) feature
-- The blank identifier allows explicitly ignoring values in assignments and for loops

@Test function testBasicAssignment()
   x, _ = 10, 20
   assert(x is 10, "Failed basic assignment: expected x=10, got " .. x)
end

@Test function testBlankFirst()
   _, x = 10, 20
   assert(x is 20, "Failed blank first: expected x=20, got " .. x)
end

@Test function testBlankLast()
   x, _ = 10, 20
   assert(x is 10, "Failed blank last: expected x=10, got " .. x)
end

@Test function testBlankMiddle()
   x, _, y = 1, 2, 3
   assert(x is 1, "Failed blank middle: expected x=1, got " .. x)
   assert(y is 3, "Failed blank middle: expected y=3, got " .. y)
end

@Test function testMultipleBlanks()
   _, _, x = 1, 2, 3
   assert(x is 3, "Failed multiple blanks: expected x=3, got " .. x)
end

@Test function testAllBlanks()
   -- All blanks should work - values consumed but not stored
   _, _, _ = 1, 2, 3
end

@Test function testBlankWithNil()
   x, _ = 10, nil
   assert(x is 10, "Failed blank with nil: expected x=10, got " .. x)
end

@Test function testBlankPartialAssignment()
   -- When RHS has fewer values than LHS, blanks still work
   x, _, y = 10, 20
   assert(x is 10, "Failed partial assignment: expected x=10, got " .. x)
   assert(y is nil, "Failed partial assignment: expected y=nil, got " .. tostring(y))
end

-- For loop tests

@Test function testForLoopBlankIndex()
   t = {10, 20, 30}
   sum = 0
   for _, value in ipairs(t) do
      sum += value
   end
   assert(sum is 60, "Failed for loop blank index: expected sum=60, got " .. sum)
end

@Test function testForLoopBlankValue()
   t = {10, 20, 30}
   count = 0
   for i, _ in ipairs(t) do
      count += 1
   end
   assert(count is 3, "Failed for loop blank value: expected count=3, got " .. count)
end

@Test function testForLoopPairsBlank()
   t = {a=1, b=2, c=3}
   sum = 0
   for _, val in pairs(t) do
      sum += val
   end
   assert(sum is 6, "Failed for loop pairs blank: expected sum=6, got " .. sum)
end

@Test function testForLoopPairsBlankValue()
   t = {a=1, b=2, c=3}
   keys = {}
   for key, _ in pairs(t) do
      table.insert(keys, key)
   end
   assert(#keys is 3, "Failed for loop pairs blank value: expected 3 keys, got " .. #keys)
end

@Test function testForLoopMultipleBlanks()
   -- In generic for, only first variable can be omitted in standard Lua
   -- Additional blanks still work
   t = {10, 20, 30}
   iterations = 0
   for _, _, _ in ipairs(t) do
      iterations += 1
   end
   assert(iterations is 3, "Failed for loop multiple blanks: expected 3 iterations, got " .. iterations)
end

-- Function return tests

@Test function testFunctionReturn()
   function getValues()
      return 1, 2, 3
   end
   _, _, x = getValues()
   assert(x is 3, "Failed function return: expected x=3, got " .. x)
end

@Test function testFunctionReturnBlankFirst()
   function getValues2()
      return 10, 20
   end
   _, x = getValues2()
   assert(x is 20, "Failed function return blank first: expected x=20, got " .. x)
end

-- Edge cases

@Test function testNestedFunctions()
   function outer()
      _, x = 1, 2
      return x
   end
   result = outer()
   assert(result is 2, "Failed nested function: expected result=2, got " .. result)
end

@Test function testMultipleStatements()
   x, _ = 10, 20
   _, y = 30, 40
   assert(x is 10, "Failed multiple statements: expected x=10, got " .. x)
   assert(y is 40, "Failed multiple statements: expected y=40, got " .. y)
end

@Test function testBlankInTable()
   -- Blank identifiers work with table destructuring patterns
   t = {1, 2, 3}
   _, _, x = t[0], t[1], t[2]
   assert(x is 3, "Failed blank in table: expected x=3, got " .. x)
end

-- Non-local assignment tests

@Test function testNonLocalAssignment()
   -- Blank identifier in non-local assignment (not local declaration)
   local function getValues()
      return 1, 2, 3
   end
   global _, value, _ = getValues()
   assert(value is 2, "Failed non-local assignment: expected value=2, got " .. value)
end

@Test function testNonLocalAssignmentSimple()
   -- Simple non-local assignment with blank identifier
   global _ = 42
   -- No assertion needed - just verify it doesn't error
end

@Test function testNonLocalInFunction()
   -- Non-local assignment inside a function
   function test()
      global _, x = 10, 20
      return x
   end
   result = test()
   assert(result is 20, "Failed non-local in function: expected result=20, got " .. result)
end
