-- Flute tests for the custom string functions

function testAlloc()
   local s = string.alloc(10)
   assert(#s is 10, "String size is not 10 characters, got " .. #s)

   -- Test zero size
   local empty = string.alloc(0)
   assert(#empty is 0, "Zero alloc should create empty string, got " .. #empty)

   -- Test large size
   local big = string.alloc(1000)
   assert(#big is 1000, "Large alloc failed, expected 1000, got " .. #big)
end

function testSplit()
   -- Basic comma split
   local parts = string.split("a,b,c", ",")
   assert(#parts is 3, "Expected 3 parts, got " .. #parts)
   assert(parts[0] is "a", "Expected 'a', got '" .. parts[0] .. "'")
   assert(parts[1] is "b", "Expected 'b', got '" .. parts[1] .. "'")
   assert(parts[2] is "c", "Expected 'c', got '" .. parts[2] .. "'")

   -- Whitespace split (default)
   local words = string.split("hello world\ttab\nnewline")
   assert(#words is 4, "Expected 4 words, got " .. #words)
   assert(words[0] is "hello", "Expected 'hello', got '" .. words[0] .. "'")
   assert(words[1] is "world", "Expected 'world', got '" .. words[1] .. "'")
   assert(words[2] is "tab", "Expected 'tab', got '" .. words[2] .. "'")
   assert(words[3] is "newline", "Expected 'newline', got '" .. words[3] .. "'")

   -- Multi-character separator
   local multi = string.split("one::two::three", "::")
   assert(#multi is 3, "Expected 3 parts with :: separator, got " .. #multi)
   assert(multi[0] is "one", "Expected 'one', got '" .. multi[0] .. "'")
   assert(multi[1] is "two", "Expected 'two', got '" .. multi[1] .. "'")
   assert(multi[2] is "three", "Expected 'three', got '" .. multi[2] .. "'")

   -- Empty string
   local empty = string.split("")
   assert(#empty is 0, "Empty string split should return empty table, got " .. #empty)

   -- No separator found
   local nosep = string.split("hello", ",")
   assert(#nosep is 1, "No separator should return single item, got " .. #nosep)
   assert(nosep[0] is "hello", "Expected 'hello', got '" .. nosep[0] .. "'")
end

function testTrim()
   -- Basic trim
   local trimmed = string.trim("  hello world  ")
   assert(trimmed is "hello world", "Expected 'hello world', got '" .. trimmed .. "'")

   -- Left whitespace only
   local left = string.trim("  hello")
   assert(left is "hello", "Expected 'hello', got '" .. left .. "'")

   -- Right whitespace only
   local right = string.trim("hello  ")
   assert(right is "hello", "Expected 'hello', got '" .. right .. "'")

   -- Mixed whitespace types
   local mixed = string.trim("\t\n  hello world  \r\n\t")
   assert(mixed is "hello world", "Expected 'hello world', got '" .. mixed .. "'")

   -- All whitespace
   local allspace = string.trim("   \t\n\r   ")
   assert(allspace is "", "All whitespace should return empty string, got '" .. allspace .. "'")

   -- Empty string
   local empty = string.trim("")
   assert(empty is "", "Empty string should remain empty, got '" .. empty .. "'")

   -- No whitespace
   local none = string.trim("hello")
   assert(none is "hello", "No whitespace should be unchanged, got '" .. none .. "'")
end

function testRTrim()
   -- Basic right trim
   local trimmed = string.rtrim("hello world  ")
   assert(trimmed is "hello world", "Expected 'hello world', got '" .. trimmed .. "'")

   -- Left whitespace preserved
   local left = string.rtrim("  hello world  ")
   assert(left is "  hello world", "Expected '  hello world', got '" .. left .. "'")

   -- Mixed whitespace types
   local mixed = string.rtrim("hello world  \r\n\t")
   assert(mixed is "hello world", "Expected 'hello world', got '" .. mixed .. "'")

   -- All whitespace
   local allspace = string.rtrim("   \t\n\r   ")
   assert(allspace is "", "All whitespace should return empty string, got '" .. allspace .. "'")

   -- Empty string
   local empty = string.rtrim("")
   assert(empty is "", "Empty string should remain empty, got '" .. empty .. "'")

   -- No whitespace
   local none = string.rtrim("hello")
   assert(none is "hello", "No whitespace should be unchanged, got '" .. none .. "'")
end

function testJoin()
   -- Basic join
   local joined = string.join({"hello", "world"}, " ")
   assert(joined is "hello world", "Expected 'hello world', got '" .. joined .. "'")

   -- CSV style
   local csv = string.join({"a", "b", "c"}, ",")
   assert(csv is "a,b,c", "Expected 'a,b,c', got '" .. csv .. "'")

   -- No separator
   local concat = string.join({"a", "b", "c"})
   assert(concat is "abc", "Expected 'abc', got '" .. concat .. "'")

   -- Mixed types (numbers should be converted)
   local mixed = string.join({1, "hello", 2.5, "world"}, "-")
   assert(mixed is "1-hello-2.5-world", "Expected '1-hello-2.5-world', got '" .. mixed .. "'")

   -- Empty table
   local empty = string.join({}, ",")
   assert(empty is "", "Empty table should return empty string, got '" .. empty .. "'")

   -- Single item
   local single = string.join({"hello"}, ",")
   assert(single is "hello", "Single item should return 'hello', got '" .. single .. "'")

   -- Empty strings in table
   local withEmpty = string.join({"a", "", "b"}, ",")
   assert(withEmpty is "a,,b", "Expected 'a,,b', got '" .. withEmpty .. "'")
end

function testStartsWith()
   -- Basic positive case
   assert(string.startsWith("hello world", "hello"), "Should start with 'hello'")

   -- Basic negative case
   assert(not string.startsWith("hello world", "world"), "Should not start with 'world'")

   -- Empty prefix (should always match)
   assert(string.startsWith("hello", ""), "Should match empty prefix")

   -- Prefix longer than string
   assert(not string.startsWith("hi", "hello"), "Should not match longer prefix")

   -- Exact match
   assert(string.startsWith("hello", "hello"), "Should match exact string")

   -- Empty string with empty prefix
   assert(string.startsWith("", ""), "Empty string should match empty prefix")

   -- Empty string with non-empty prefix
   assert(not string.startsWith("", "hello"), "Empty string should not match non-empty prefix")

   -- Case sensitive
   assert(not string.startsWith("Hello", "hello"), "Should be case sensitive")
end

function testEndsWith()
   -- Basic positive case
   assert(string.endsWith("hello world", "world"), "Should end with 'world'")

   -- Basic negative case
   assert(not string.endsWith("hello world", "hello"), "Should not end with 'hello'")

   -- Empty suffix (should always match)
   assert(string.endsWith("hello", ""), "Should match empty suffix")

   -- Suffix longer than string
   assert(not string.endsWith("hi", "hello"), "Should not match longer suffix")

   -- Exact match
   assert(string.endsWith("hello", "hello"), "Should match exact string")

   -- Empty string with empty suffix
   assert(string.endsWith("", ""), "Empty string should match empty suffix")

   -- Empty string with non-empty suffix
   assert(not string.endsWith("", "hello"), "Empty string should not match non-empty suffix")

   -- Case sensitive
   assert(not string.endsWith("Hello", "hello"), "Should be case sensitive")
end

function testCap()
   -- Basic capitalization
   local capped = string.cap("hello")
   assert(capped is "Hello", "Expected 'Hello', got '" .. capped .. "'")

   -- Already capitalized
   local already = string.cap("Hello")
   assert(already is "Hello", "Expected 'Hello', got '" .. already .. "'")

   -- Single character
   local single = string.cap("a")
   assert(single is "A", "Expected 'A', got '" .. single .. "'")

   -- Empty string
   local empty = string.cap("")
   assert(empty is "", "Empty string should remain empty, got '" .. empty .. "'")

   -- Non-alphabetic first character
   local nonalpha = string.cap("123hello")
   assert(nonalpha is "123hello", "Expected '123hello', got '" .. nonalpha .. "'")

   -- Mixed case
   local mixed = string.cap("hELLO")
   assert(mixed is "HELLO", "Expected 'HELLO', got '" .. mixed .. "'")
end

function testDecap()
   -- Basic decapitalization
   local decapped = string.decap("Hello")
   assert(decapped is "hello", "Expected 'hello', got '" .. decapped .. "'")

   -- Already lowercase
   local already = string.decap("hello")
   assert(already is "hello", "Expected 'hello', got '" .. already .. "'")

   -- Single character
   local single = string.decap("A")
   assert(single is "a", "Expected 'a', got '" .. single .. "'")

   -- Empty string
   local empty = string.decap("")
   assert(empty is "", "Empty string should remain empty, got '" .. empty .. "'")

   -- Non-alphabetic first character
   local nonalpha = string.decap("123Hello")
   assert(nonalpha is "123Hello", "Expected '123Hello', got '" .. nonalpha .. "'")

   -- Mixed case
   local mixed = string.decap("HeLLo")
   assert(mixed is "heLLo", "Expected 'heLLo', got '" .. mixed .. "'")
end

function testHash()
   -- Basic hash (case insensitive by default)
   local hash1 = string.hash("hello")
   local hash2 = string.hash("HELLO")
   assert(hash1 is hash2, "Case insensitive hashes should match: " .. hash1 .. " != " .. hash2)

   -- Case sensitive hash
   local hash3 = string.hash("hello", true)
   local hash4 = string.hash("HELLO", true)
   assert(hash3 != hash4, "Case sensitive hashes should differ: " .. hash3 .. " is " .. hash4)

   -- Empty string
   local emptyHash = string.hash("")
   assert(emptyHash != 0, "Empty string hash should not be 0, got " .. emptyHash)

   -- Same string should produce same hash
   local consistent1 = string.hash("test")
   local consistent2 = string.hash("test")
   assert(consistent1 is consistent2, "Consistent hashing failed: " .. consistent1 .. " != " .. consistent2)

   -- Different strings should produce different hashes (highly likely)
   local diff1 = string.hash("hello")
   local diff2 = string.hash("world")
   assert(diff1 != diff2, "Different strings produced same hash (collision): " .. diff1)
end

function testEscXML()
   -- Basic XML escaping
   local escaped = string.escXML("Hello & goodbye")
   assert(escaped is "Hello &amp; goodbye", "Expected 'Hello &amp; goodbye', got '" .. escaped .. "'")

   -- Less than and greater than
   local brackets = string.escXML("<tag>content</tag>")
   assert(brackets is "&lt;tag&gt;content&lt;/tag&gt;", "Expected '&lt;tag&gt;content&lt;/tag&gt;', got '" .. brackets .. "'")

   -- All three special characters
   local all = string.escXML("A & B < C > D")
   assert(all is "A &amp; B &lt; C &gt; D", "Expected 'A &amp; B &lt; C &gt; D', got '" .. all .. "'")

   -- No special characters
   local normal = string.escXML("Hello World")
   assert(normal is "Hello World", "Expected 'Hello World', got '" .. normal .. "'")

   -- Empty string
   local empty = string.escXML("")
   assert(empty is "", "Empty string should remain empty, got '" .. empty .. "'")

   -- Nil input (should return empty string)
   local nilResult = string.escXML(nil)
   assert(nilResult is "", "Nil input should return empty string, got '" .. nilResult .. "'")

   -- Multiple ampersands (should not double-escape)
   local amps = string.escXML("A & B & C")
   assert(amps is "A &amp; B &amp; C", "Expected 'A &amp; B &amp; C', got '" .. amps .. "'")

   -- Mixed with quotes (should not escape quotes)
   local quotes = string.escXML('Hello "world" & <test>')
   assert(quotes is 'Hello "world" &amp; &lt;test&gt;', "Expected 'Hello \"world\" &amp; &lt;test&gt;', got '" .. quotes .. "'")
end

-----------------------------------------------------------------------------------------------------------------------

   return {
      tests = {
         'testAlloc',
         'testSplit',
         'testTrim',
         'testRTrim',
         'testJoin',
         'testStartsWith',
         'testEndsWith',
         'testCap',
         'testDecap',
         'testHash',
         'testEscXML'
      }
   }
