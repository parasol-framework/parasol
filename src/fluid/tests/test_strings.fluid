-- Flute tests for the custom string functions

function testAlloc()
   local s = string.alloc(10)
   if #s != 10 then error("String size is not 10 characters, got " .. #s) end

   -- Test zero size
   local empty = string.alloc(0)
   if #empty != 0 then error("Zero alloc should create empty string, got " .. #empty) end

   -- Test large size
   local big = string.alloc(1000)
   if #big != 1000 then error("Large alloc failed, expected 1000, got " .. #big) end
end

function testSplit()
   -- Basic comma split
   local parts = string.split("a,b,c", ",")
   if #parts != 3 then error("Expected 3 parts, got " .. #parts) end
   if parts[1] != "a" then error("Expected 'a', got '" .. parts[1] .. "'") end
   if parts[2] != "b" then error("Expected 'b', got '" .. parts[2] .. "'") end
   if parts[3] != "c" then error("Expected 'c', got '" .. parts[3] .. "'") end

   -- Whitespace split (default)
   local words = string.split("hello world\ttab\nnewline")
   if #words != 4 then error("Expected 4 words, got " .. #words) end
   if words[1] != "hello" then error("Expected 'hello', got '" .. words[1] .. "'") end
   if words[2] != "world" then error("Expected 'world', got '" .. words[2] .. "'") end
   if words[3] != "tab" then error("Expected 'tab', got '" .. words[3] .. "'") end
   if words[4] != "newline" then error("Expected 'newline', got '" .. words[4] .. "'") end

   -- Multi-character separator
   local multi = string.split("one::two::three", "::")
   if #multi != 3 then error("Expected 3 parts with :: separator, got " .. #multi) end
   if multi[1] != "one" then error("Expected 'one', got '" .. multi[1] .. "'") end
   if multi[2] != "two" then error("Expected 'two', got '" .. multi[2] .. "'") end
   if multi[3] != "three" then error("Expected 'three', got '" .. multi[3] .. "'") end

   -- Empty string
   local empty = string.split("")
   if #empty != 0 then error("Empty string split should return empty table, got " .. #empty) end

   -- No separator found
   local nosep = string.split("hello", ",")
   if #nosep != 1 then error("No separator should return single item, got " .. #nosep) end
   if nosep[1] != "hello" then error("Expected 'hello', got '" .. nosep[1] .. "'") end
end

function testTrim()
   -- Basic trim
   local trimmed = string.trim("  hello world  ")
   if trimmed != "hello world" then error("Expected 'hello world', got '" .. trimmed .. "'") end

   -- Left whitespace only
   local left = string.trim("  hello")
   if left != "hello" then error("Expected 'hello', got '" .. left .. "'") end

   -- Right whitespace only
   local right = string.trim("hello  ")
   if right != "hello" then error("Expected 'hello', got '" .. right .. "'") end

   -- Mixed whitespace types
   local mixed = string.trim("\t\n  hello world  \r\n\t")
   if mixed != "hello world" then error("Expected 'hello world', got '" .. mixed .. "'") end

   -- All whitespace
   local allspace = string.trim("   \t\n\r   ")
   if allspace != "" then error("All whitespace should return empty string, got '" .. allspace .. "'") end

   -- Empty string
   local empty = string.trim("")
   if empty != "" then error("Empty string should remain empty, got '" .. empty .. "'") end

   -- No whitespace
   local none = string.trim("hello")
   if none != "hello" then error("No whitespace should be unchanged, got '" .. none .. "'") end
end

function testRTrim()
   -- Basic right trim
   local trimmed = string.rtrim("hello world  ")
   if trimmed != "hello world" then error("Expected 'hello world', got '" .. trimmed .. "'") end

   -- Left whitespace preserved
   local left = string.rtrim("  hello world  ")
   if left != "  hello world" then error("Expected '  hello world', got '" .. left .. "'") end

   -- Mixed whitespace types
   local mixed = string.rtrim("hello world  \r\n\t")
   if mixed != "hello world" then error("Expected 'hello world', got '" .. mixed .. "'") end

   -- All whitespace
   local allspace = string.rtrim("   \t\n\r   ")
   if allspace != "" then error("All whitespace should return empty string, got '" .. allspace .. "'") end

   -- Empty string
   local empty = string.rtrim("")
   if empty != "" then error("Empty string should remain empty, got '" .. empty .. "'") end

   -- No whitespace
   local none = string.rtrim("hello")
   if none != "hello" then error("No whitespace should be unchanged, got '" .. none .. "'") end
end

function testJoin()
   -- Basic join
   local joined = string.join({"hello", "world"}, " ")
   if joined != "hello world" then error("Expected 'hello world', got '" .. joined .. "'") end

   -- CSV style
   local csv = string.join({"a", "b", "c"}, ",")
   if csv != "a,b,c" then error("Expected 'a,b,c', got '" .. csv .. "'") end

   -- No separator
   local concat = string.join({"a", "b", "c"})
   if concat != "abc" then error("Expected 'abc', got '" .. concat .. "'") end

   -- Mixed types (numbers should be converted)
   local mixed = string.join({1, "hello", 2.5, "world"}, "-")
   if mixed != "1-hello-2.5-world" then error("Expected '1-hello-2.5-world', got '" .. mixed .. "'") end

   -- Empty table
   local empty = string.join({}, ",")
   if empty != "" then error("Empty table should return empty string, got '" .. empty .. "'") end

   -- Single item
   local single = string.join({"hello"}, ",")
   if single != "hello" then error("Single item should return 'hello', got '" .. single .. "'") end

   -- Empty strings in table
   local withEmpty = string.join({"a", "", "b"}, ",")
   if withEmpty != "a,,b" then error("Expected 'a,,b', got '" .. withEmpty .. "'") end
end

function testStartsWith()
   -- Basic positive case
   if not string.startsWith("hello world", "hello") then error("Should start with 'hello'") end

   -- Basic negative case
   if string.startsWith("hello world", "world") then error("Should not start with 'world'") end

   -- Empty prefix (should always match)
   if not string.startsWith("hello", "") then error("Should match empty prefix") end

   -- Prefix longer than string
   if string.startsWith("hi", "hello") then error("Should not match longer prefix") end

   -- Exact match
   if not string.startsWith("hello", "hello") then error("Should match exact string") end

   -- Empty string with empty prefix
   if not string.startsWith("", "") then error("Empty string should match empty prefix") end

   -- Empty string with non-empty prefix
   if string.startsWith("", "hello") then error("Empty string should not match non-empty prefix") end

   -- Case sensitive
   if string.startsWith("Hello", "hello") then error("Should be case sensitive") end
end

function testEndsWith()
   -- Basic positive case
   if not string.endsWith("hello world", "world") then error("Should end with 'world'") end

   -- Basic negative case
   if string.endsWith("hello world", "hello") then error("Should not end with 'hello'") end

   -- Empty suffix (should always match)
   if not string.endsWith("hello", "") then error("Should match empty suffix") end

   -- Suffix longer than string
   if string.endsWith("hi", "hello") then error("Should not match longer suffix") end

   -- Exact match
   if not string.endsWith("hello", "hello") then error("Should match exact string") end

   -- Empty string with empty suffix
   if not string.endsWith("", "") then error("Empty string should match empty suffix") end

   -- Empty string with non-empty suffix
   if string.endsWith("", "hello") then error("Empty string should not match non-empty suffix") end

   -- Case sensitive
   if string.endsWith("Hello", "hello") then error("Should be case sensitive") end
end

function testCap()
   -- Basic capitalization
   local capped = string.cap("hello")
   if capped != "Hello" then error("Expected 'Hello', got '" .. capped .. "'") end

   -- Already capitalized
   local already = string.cap("Hello")
   if already != "Hello" then error("Expected 'Hello', got '" .. already .. "'") end

   -- Single character
   local single = string.cap("a")
   if single != "A" then error("Expected 'A', got '" .. single .. "'") end

   -- Empty string
   local empty = string.cap("")
   if empty != "" then error("Empty string should remain empty, got '" .. empty .. "'") end

   -- Non-alphabetic first character
   local nonalpha = string.cap("123hello")
   if nonalpha != "123hello" then error("Expected '123hello', got '" .. nonalpha .. "'") end

   -- Mixed case
   local mixed = string.cap("hELLO")
   if mixed != "HELLO" then error("Expected 'HELLO', got '" .. mixed .. "'") end
end

function testDecap()
   -- Basic decapitalization
   local decapped = string.decap("Hello")
   if decapped != "hello" then error("Expected 'hello', got '" .. decapped .. "'") end

   -- Already lowercase
   local already = string.decap("hello")
   if already != "hello" then error("Expected 'hello', got '" .. already .. "'") end

   -- Single character
   local single = string.decap("A")
   if single != "a" then error("Expected 'a', got '" .. single .. "'") end

   -- Empty string
   local empty = string.decap("")
   if empty != "" then error("Empty string should remain empty, got '" .. empty .. "'") end

   -- Non-alphabetic first character
   local nonalpha = string.decap("123Hello")
   if nonalpha != "123Hello" then error("Expected '123Hello', got '" .. nonalpha .. "'") end

   -- Mixed case
   local mixed = string.decap("HeLLo")
   if mixed != "heLLo" then error("Expected 'heLLo', got '" .. mixed .. "'") end
end

function testHash()
   -- Basic hash (case insensitive by default)
   local hash1 = string.hash("hello")
   local hash2 = string.hash("HELLO")
   if hash1 != hash2 then error("Case insensitive hashes should match: " .. hash1 .. " != " .. hash2) end

   -- Case sensitive hash
   local hash3 = string.hash("hello", true)
   local hash4 = string.hash("HELLO", true)
   if hash3 == hash4 then error("Case sensitive hashes should differ: " .. hash3 .. " == " .. hash4) end

   -- Empty string
   local emptyHash = string.hash("")
   if emptyHash == 0 then error("Empty string hash should not be 0, got " .. emptyHash) end

   -- Same string should produce same hash
   local consistent1 = string.hash("test")
   local consistent2 = string.hash("test")
   if consistent1 != consistent2 then error("Consistent hashing failed: " .. consistent1 .. " != " .. consistent2) end

   -- Different strings should produce different hashes (highly likely)
   local diff1 = string.hash("hello")
   local diff2 = string.hash("world")
   if diff1 == diff2 then error("Different strings produced same hash (collision): " .. diff1) end
end

function testEscXML()
   -- Basic XML escaping
   local escaped = string.escXML("Hello & goodbye")
   if escaped != "Hello &amp; goodbye" then error("Expected 'Hello &amp; goodbye', got '" .. escaped .. "'") end

   -- Less than and greater than
   local brackets = string.escXML("<tag>content</tag>")
   if brackets != "&lt;tag&gt;content&lt;/tag&gt;" then error("Expected '&lt;tag&gt;content&lt;/tag&gt;', got '" .. brackets .. "'") end

   -- All three special characters
   local all = string.escXML("A & B < C > D")
   if all != "A &amp; B &lt; C &gt; D" then error("Expected 'A &amp; B &lt; C &gt; D', got '" .. all .. "'") end

   -- No special characters
   local normal = string.escXML("Hello World")
   if normal != "Hello World" then error("Expected 'Hello World', got '" .. normal .. "'") end

   -- Empty string
   local empty = string.escXML("")
   if empty != "" then error("Empty string should remain empty, got '" .. empty .. "'") end

   -- Nil input (should return empty string)
   local nilResult = string.escXML(nil)
   if nilResult != "" then error("Nil input should return empty string, got '" .. nilResult .. "'") end

   -- Multiple ampersands (should not double-escape)
   local amps = string.escXML("A & B & C")
   if amps != "A &amp; B &amp; C" then error("Expected 'A &amp; B &amp; C', got '" .. amps .. "'") end

   -- Mixed with quotes (should not escape quotes)
   local quotes = string.escXML('Hello "world" & <test>')
   if quotes != 'Hello "world" &amp; &lt;test&gt;' then error("Expected 'Hello \"world\" &amp; &lt;test&gt;', got '" .. quotes .. "'") end
end

-----------------------------------------------------------------------------------------------------------------------

   return {
      tests = {
         'testAlloc',
         'testSplit',
         'testTrim',
         'testRTrim',
         'testJoin',
         'testStartsWith',
         'testEndsWith',
         'testCap',
         'testDecap',
         'testHash',
         'testEscXML'
      }
   }
