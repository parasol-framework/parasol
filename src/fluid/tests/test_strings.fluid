-- Flute tests for the custom string functions
-- String functions that are JIT-optimised are executed in loops to ensure coverage of their fast calls.

@BeforeEach(hotpath=true) 
function enforce_hotpath() end

@Test function testAlloc()
   s = string.alloc(10)
   assert(#s is 10, "String size is not 10 characters, got " .. #s)

   -- Test zero size
   empty = string.alloc(0)
   assert(#empty is 0, "Zero alloc should create empty string, got " .. #empty)

   -- Test large size
   big = string.alloc(1000)
   assert(#big is 1000, "Large alloc failed, expected 1000, got " .. #big)
end

@Test function testIndex()
--   getmetatable('').__index = function(str,i) return string.sub(str,i,i) end
--   hw = "Hello World"
--   assert(string[1] is "H", "Expected 'H' at index 0, got '" .. tostring(string[1]) .. "'")
end

@Test function testSplit()
   parts = string.split("\n\n\n", "\n")
   assert(#parts is 4, "Expected 4 parts for consecutive newlines, got " .. #parts)
   assert(parts[0] is "", "Expected empty string for first part, got '" .. parts[0] .. "'")
   assert(parts[1] is "", "Expected empty string for first part, got '" .. parts[1] .. "'")
   assert(parts[2] is "", "Expected empty string for first part, got '" .. parts[2] .. "'")
   assert(parts[3] is "", "Expected empty string for first part, got '" .. parts[3] .. "'")

   -- Basic comma split
   parts = string.split("a,b,c", ",")
   assert(#parts is 3, "Expected 3 parts, got " .. #parts)
   assert(parts[0] is "a", "Expected 'a', got '" .. parts[0] .. "'")
   assert(parts[1] is "b", "Expected 'b', got '" .. parts[1] .. "'")
   assert(parts[2] is "c", "Expected 'c', got '" .. parts[2] .. "'")

   -- Whitespace split (default)
   words = string.split("hello world\ttab\nnewline")
   assert(#words is 4, "Expected 4 words, got " .. #words)
   assert(words[0] is "hello", "Expected 'hello', got '" .. words[0] .. "'")
   assert(words[1] is "world", "Expected 'world', got '" .. words[1] .. "'")
   assert(words[2] is "tab", "Expected 'tab', got '" .. words[2] .. "'")
   assert(words[3] is "newline", "Expected 'newline', got '" .. words[3] .. "'")

   -- Multi-character separator
   multi = string.split("one::two::three", "::")
   assert(#multi is 3, "Expected 3 parts with :: separator, got " .. #multi)
   assert(multi[0] is "one", "Expected 'one', got '" .. multi[0] .. "'")
   assert(multi[1] is "two", "Expected 'two', got '" .. multi[1] .. "'")
   assert(multi[2] is "three", "Expected 'three', got '" .. multi[2] .. "'")

   -- Empty string
   empty = string.split("")
   assert(#empty is 0, "Empty string split should return empty table, got " .. #empty)

   -- No separator found
   nosep = string.split("hello", ",")
   assert(#nosep is 1, "No separator should return single item, got " .. #nosep)
   assert(nosep[0] is "hello", "Expected 'hello', got '" .. nosep[0] .. "'")
end

@Test function testTrim()
   -- Basic trim
   trimmed = string.trim("  hello world  ")
   assert(trimmed is "hello world", "Expected 'hello world', got '" .. trimmed .. "'")

   -- Left whitespace only
   left = string.trim("  hello")
   assert(left is "hello", "Expected 'hello', got '" .. left .. "'")

   -- Right whitespace only
   right = string.trim("hello  ")
   assert(right is "hello", "Expected 'hello', got '" .. right .. "'")

   -- Mixed whitespace types
   mixed = string.trim("\t\n  hello world  \r\n\t")
   assert(mixed is "hello world", "Expected 'hello world', got '" .. mixed .. "'")

   -- All whitespace
   allspace = string.trim("   \t\n\r   ")
   assert(allspace is "", "All whitespace should return empty string, got '" .. allspace .. "'")

   -- Empty string
   empty = string.trim("")
   assert(empty is "", "Empty string should remain empty, got '" .. empty .. "'")

   -- No whitespace
   none = string.trim("hello")
   assert(none is "hello", "No whitespace should be unchanged, got '" .. none .. "'")
end

@Test function testRTrim()
   -- Basic right trim
   trimmed = string.rtrim("hello world  ")
   assert(trimmed is "hello world", "Expected 'hello world', got '" .. trimmed .. "'")

   -- Left whitespace preserved
   left = string.rtrim("  hello world  ")
   assert(left is "  hello world", "Expected '  hello world', got '" .. left .. "'")

   -- Mixed whitespace types
   mixed = string.rtrim("hello world  \r\n\t")
   assert(mixed is "hello world", "Expected 'hello world', got '" .. mixed .. "'")

   -- All whitespace
   allspace = string.rtrim("   \t\n\r   ")
   assert(allspace is "", "All whitespace should return empty string, got '" .. allspace .. "'")

   -- Empty string
   empty = string.rtrim("")
   assert(empty is "", "Empty string should remain empty, got '" .. empty .. "'")

   -- No whitespace
   none = string.rtrim("hello")
   assert(none is "hello", "No whitespace should be unchanged, got '" .. none .. "'")
end

@Test function testJoin()
   -- Basic join
   joined = string.join({"hello", "world"}, " ")
   assert(joined is "hello world", "Expected 'hello world', got '" .. joined .. "'")

   -- CSV style
   csv = string.join({"a", "b", "c"}, ",")
   assert(csv is "a,b,c", "Expected 'a,b,c', got '" .. csv .. "'")

   -- No separator
   concat = string.join({"a", "b", "c"})
   assert(concat is "abc", "Expected 'abc', got '" .. concat .. "'")

   -- Mixed types (numbers should be converted)
   mixed = string.join({1, "hello", 2.5, "world"}, "-")
   assert(mixed is "1-hello-2.5-world", "Expected '1-hello-2.5-world', got '" .. mixed .. "'")

   -- Empty table
   empty = string.join({}, ",")
   assert(empty is "", "Empty table should return empty string, got '" .. empty .. "'")

   -- Single item
   single = string.join({"hello"}, ",")
   assert(single is "hello", "Single item should return 'hello', got '" .. single .. "'")

   -- Empty strings in table
   withEmpty = string.join({"a", "", "b"}, ",")
   assert(withEmpty is "a,,b", "Expected 'a,,b', got '" .. withEmpty .. "'")
end

@Test function testStartsWith()
   -- Basic positive case
   assert(string.startsWith("hello world", "hello"), "Should start with 'hello'")

   -- Basic negative case
   assert(not string.startsWith("hello world", "world"), "Should not start with 'world'")

   -- Empty prefix (should always match)
   assert(string.startsWith("hello", ""), "Should match empty prefix")

   -- Prefix longer than string
   assert(not string.startsWith("hi", "hello"), "Should not match longer prefix")

   -- Exact match
   assert(string.startsWith("hello", "hello"), "Should match exact string")

   -- Empty string with empty prefix
   assert(string.startsWith("", ""), "Empty string should match empty prefix")

   -- Empty string with non-empty prefix
   assert(not string.startsWith("", "hello"), "Empty string should not match non-empty prefix")

   -- Case sensitive
   assert(not string.startsWith("Hello", "hello"), "Should be case sensitive")
end

@Test function testEndsWith()
   -- Basic positive case
   assert(string.endsWith("hello world", "world"), "Should end with 'world'")

   -- Basic negative case
   assert(not string.endsWith("hello world", "hello"), "Should not end with 'hello'")

   -- Empty suffix (should always match)
   assert(string.endsWith("hello", ""), "Should match empty suffix")

   -- Suffix longer than string
   assert(not string.endsWith("hi", "hello"), "Should not match longer suffix")

   -- Exact match
   assert(string.endsWith("hello", "hello"), "Should match exact string")

   -- Empty string with empty suffix
   assert(string.endsWith("", ""), "Empty string should match empty suffix")

   -- Empty string with non-empty suffix
   assert(not string.endsWith("", "hello"), "Empty string should not match non-empty suffix")

   -- Case sensitive
   assert(not string.endsWith("Hello", "hello"), "Should be case sensitive")
end

@Test function testCap()
   -- Basic capitalization
   capped = string.cap("hello")
   assert(capped is "Hello", "Expected 'Hello', got '" .. capped .. "'")

   -- Already capitalized
   already = string.cap("Hello")
   assert(already is "Hello", "Expected 'Hello', got '" .. already .. "'")

   -- Single character
   single = string.cap("a")
   assert(single is "A", "Expected 'A', got '" .. single .. "'")

   -- Empty string
   empty = string.cap("")
   assert(empty is "", "Empty string should remain empty, got '" .. empty .. "'")

   -- Non-alphabetic first character
   nonalpha = string.cap("123hello")
   assert(nonalpha is "123hello", "Expected '123hello', got '" .. nonalpha .. "'")

   -- Mixed case
   mixed = string.cap("hELLO")
   assert(mixed is "HELLO", "Expected 'HELLO', got '" .. mixed .. "'")
end

@Test function testDecap()
   -- Basic decapitalization
   decapped = string.decap("Hello")
   assert(decapped is "hello", "Expected 'hello', got '" .. decapped .. "'")

   -- Already lowercase
   already = string.decap("hello")
   assert(already is "hello", "Expected 'hello', got '" .. already .. "'")

   -- Single character
   single = string.decap("A")
   assert(single is "a", "Expected 'a', got '" .. single .. "'")

   -- Empty string
   empty = string.decap("")
   assert(empty is "", "Empty string should remain empty, got '" .. empty .. "'")

   -- Non-alphabetic first character
   nonalpha = string.decap("123Hello")
   assert(nonalpha is "123Hello", "Expected '123Hello', got '" .. nonalpha .. "'")

   -- Mixed case
   mixed = string.decap("HeLLo")
   assert(mixed is "heLLo", "Expected 'heLLo', got '" .. mixed .. "'")
end

@Test function testHash()
   -- Basic hash (case insensitive by default)
   hash1 = string.hash("hello")
   hash2 = string.hash("HELLO")
   assert(hash1 is hash2, "Case insensitive hashes should match: " .. hash1 .. " != " .. hash2)

   -- Case sensitive hash
   hash3 = string.hash("hello", true)
   hash4 = string.hash("HELLO", true)
   assert(hash3 != hash4, "Case sensitive hashes should differ: " .. hash3 .. " is " .. hash4)

   -- Empty string
   emptyHash = string.hash("")
   assert(emptyHash != 0, "Empty string hash should not be 0, got " .. emptyHash)

   -- Same string should produce same hash
   consistent1 = string.hash("test")
   consistent2 = string.hash("test")
   assert(consistent1 is consistent2, "Consistent hashing failed: " .. consistent1 .. " != " .. consistent2)

   -- Different strings should produce different hashes (highly likely)
   diff1 = string.hash("hello")
   diff2 = string.hash("world")
   assert(diff1 != diff2, "Different strings produced same hash (collision): " .. diff1)
end

@Test function testEscXML()
   -- Basic XML escaping
   escaped = string.escXML("Hello & goodbye")
   assert(escaped is "Hello &amp; goodbye", "Expected 'Hello &amp; goodbye', got '" .. escaped .. "'")

   -- Less than and greater than
   brackets = string.escXML("<tag>content</tag>")
   assert(brackets is "&lt;tag&gt;content&lt;/tag&gt;", "Expected '&lt;tag&gt;content&lt;/tag&gt;', got '" .. brackets .. "'")

   -- All three special characters
   all = string.escXML("A & B < C > D")
   assert(all is "A &amp; B &lt; C &gt; D", "Expected 'A &amp; B &lt; C &gt; D', got '" .. all .. "'")

   -- No special characters
   normal = string.escXML("Hello World")
   assert(normal is "Hello World", "Expected 'Hello World', got '" .. normal .. "'")

   -- Empty string
   empty = string.escXML("")
   assert(empty is "", "Empty string should remain empty, got '" .. empty .. "'")

   -- Nil input (should return empty string)
   nilResult = string.escXML(nil)
   assert(nilResult is "", "Nil input should return empty string, got '" .. nilResult .. "'")

   -- Multiple ampersands (should not double-escape)
   amps = string.escXML("A & B & C")
   assert(amps is "A &amp; B &amp; C", "Expected 'A &amp; B &amp; C', got '" .. amps .. "'")

   -- Mixed with quotes (should not escape quotes)
   quotes = string.escXML('Hello "world" & <test>')
   assert(quotes is 'Hello "world" &amp; &lt;test&gt;', "Expected 'Hello \"world\" &amp; &lt;test&gt;', got '" .. quotes .. "'")
end

@Test function testSub()
   -- string.substr() and sub() use exclusive end index (like JavaScript substring/Python slicing)
   -- string.substr(s, start, end) extracts chars from start to end-1
   s = "hello world"

   for i=0,1000 do
      -- Basic substring
      sub = string.substr(s, 0, 5) -- Indices 0,1,2,3,4 (not 5)
      assert(sub is "hello", "Expected 'hello', got '" .. sub .. "'")

      -- Start from middle
      mid = string.substr(s, 6, 11) -- Indices 6,7,8,9,10 (not 11)
      assert(mid is "world", "Expected 'world', got '" .. mid .. "'")

      -- Negative indices (count from end)
      neg = string.substr(s, -5, -1)
      assert(neg is "world", "Expected 'world' from negative indices, got '" .. neg .. "'")

      -- Negative start, positive end
      mixed = string.substr(s, -5, 11)
      assert(mixed is "world", "Expected 'world' from mixed indices, got '" .. mixed .. "'")

      -- Default end
      toEnd = string.substr(s, 6)
      assert(toEnd is "world", "Expected 'world' with default end, got '" .. toEnd .. "'")

      -- Single character
      single = string.substr(s, 0, 1)
      assert(single is "h", "Expected 'h', got '" .. single .. "'")

      -- Empty range
      empty = string.substr(s, 5, 5)
      assert(empty is "", "Expected empty string, got '" .. empty .. "'")

      -- Beyond string length
      beyond = string.substr(s, 0, 100)
      assert(#beyond is #s, "Expected length to match original string length, got " .. #beyond)
      assert(beyond is s, "Expected full string when end exceeds length, got '" .. beyond .. "'")

      -- Empty string
      emptyStr = string.substr("", 0, 0)
      assert(emptyStr is "", "Expected empty string, got '" .. emptyStr .. "'")
   end
end

@Test function testByte()
   for i=0,1000 do
      -- Single character (zero-indexed)
      b = string.byte("hello", 0)
      assert(b is 104, "Expected 104 (h), got " .. b)

      -- Multiple characters
      b1, b2, b3 = string.byte("abc", 0, 2)
      assert(b1 is 97, "Expected 97 (a), got " .. b1)
      assert(b2 is 98, "Expected 98 (b), got " .. b2)
      assert(b3 is 99, "Expected 99 (c), got " .. b3)

      -- Default range (single character at index 0)
      def = string.byte("hello")
      assert(def is 104, "Expected 104 (h) as default, got " .. def)

      -- Negative index (from end)
      neg = string.byte("hello", -1)
      assert(neg is 111, "Expected 111 (o), got " .. neg)

      -- Range with negative end
      b4, b5 = string.byte("hello", -2, -1)
      assert(b4 is 108, "Expected 108 (l), got " .. b4)
      assert(b5 is 111, "Expected 111 (o), got " .. b5)

      -- Empty range
      empty = string.byte("hello", 5, 3)
      assert(empty is nil, "Expected nil for empty range, got " .. tostring(empty))

      -- Single character at last position
      last = string.byte("hello", 4)
      assert(last is 111, "Expected 111 (o), got " .. last)
   end
end

@Test function testChar()
   for i=0,1000 do
      -- Single character
      c = string.char(65)
      assert(c is "A", "Expected 'A', got '" .. c .. "'")

      -- Multiple characters
      multi = string.char(72, 101, 108, 108, 111)
      assert(multi is "Hello", "Expected 'Hello', got '" .. multi .. "'")

      -- Empty (no arguments)
      empty = string.char()
      assert(empty is "", "Expected empty string, got '" .. empty .. "'")

      -- Common characters
      space = string.char(32)
      assert(space is " ", "Expected space, got '" .. space .. "'")

      newline = string.char(10)
      assert(newline is "\n", "Expected newline, got '" .. newline .. "'")

      -- Zero character
      zero = string.char(0)
      assert(#zero is 1, "Expected 1-byte string for null char, got " .. #zero)
   end
end

@Test function testRep()
   for i=0,1000 do
      -- Basic repetition
      rep = string.rep("ab", 3)
      assert(rep is "ababab", "Expected 'ababab', got '" .. rep .. "'")

      -- Single repetition
      single = string.rep("hello", 1)
      assert(single is "hello", "Expected 'hello', got '" .. single .. "'")

      -- Zero repetitions
      zero = string.rep("hello", 0)
      assert(zero is "", "Expected empty string, got '" .. zero .. "'")

      -- With separator
      withSep = string.rep("abc", 3, ",")
      assert(withSep is "abc,abc,abc", "Expected 'abc,abc,abc', got '" .. withSep .. "'")

      -- Separator with single repetition (no separator should appear)
      singleSep = string.rep("hello", 1, ",")
      assert(singleSep is "hello", "Expected 'hello' (no separator), got '" .. singleSep .. "'")

      -- Empty string repetition
      emptyRep = string.rep("", 5)
      assert(emptyRep is "", "Expected empty string, got '" .. emptyRep .. "'")
   end
end

@Test function testReverse()
   -- Basic reverse
   rev = string.reverse("hello")
   assert(rev is "olleh", "Expected 'olleh', got '" .. rev .. "'")

   -- Single character
   single = string.reverse("a")
   assert(single is "a", "Expected 'a', got '" .. single .. "'")

   -- Empty string
   empty = string.reverse("")
   assert(empty is "", "Expected empty string, got '" .. empty .. "'")

   -- With spaces
   spaces = string.reverse("hello world")
   assert(spaces is "dlrow olleh", "Expected 'dlrow olleh', got '" .. spaces .. "'")

   -- Palindrome
   palindrome = string.reverse("racecar")
   assert(palindrome is "racecar", "Expected 'racecar', got '" .. palindrome .. "'")
end

@Test function testLowerUpper()
   -- Lower case
   lower = string.lower("HELLO WORLD")
   assert(lower is "hello world", "Expected 'hello world', got '" .. lower .. "'")

   -- Upper case
   upper = string.upper("hello world")
   assert(upper is "HELLO WORLD", "Expected 'HELLO WORLD', got '" .. upper .. "'")

   -- Mixed case to lower
   mixedLower = string.lower("HeLLo WoRLd")
   assert(mixedLower is "hello world", "Expected 'hello world', got '" .. mixedLower .. "'")

   -- Mixed case to upper
   mixedUpper = string.upper("HeLLo WoRLd")
   assert(mixedUpper is "HELLO WORLD", "Expected 'HELLO WORLD', got '" .. mixedUpper .. "'")

   -- Already lowercase
   alreadyLower = string.lower("hello")
   assert(alreadyLower is "hello", "Expected 'hello', got '" .. alreadyLower .. "'")

   -- Already uppercase
   alreadyUpper = string.upper("HELLO")
   assert(alreadyUpper is "HELLO", "Expected 'HELLO', got '" .. alreadyUpper .. "'")

   -- Empty string
   emptyLower = string.lower("")
   assert(emptyLower is "", "Expected empty string, got '" .. emptyLower .. "'")

   emptyUpper = string.upper("")
   assert(emptyUpper is "", "Expected empty string, got '" .. emptyUpper .. "'")

   -- Non-alphabetic characters
   numbersLower = string.lower("123!@#")
   assert(numbersLower is "123!@#", "Expected '123!@#', got '" .. numbersLower .. "'")

   numbersUpper = string.upper("123!@#")
   assert(numbersUpper is "123!@#", "Expected '123!@#', got '" .. numbersUpper .. "'")
end

@Test function testFind()
   -- Basic find (zero-indexed positions)
   s = "hello world"
   start, finish = string.find(s, "world")
   assert(start is 6, "Expected start at 6, got " .. tostring(start))
   assert(finish is 10, "Expected finish at 10, got " .. tostring(finish))

   -- Find at beginning
   start2, finish2 = string.find(s, "hello")
   assert(start2 is 0, "Expected start at 0, got " .. tostring(start2))
   assert(finish2 is 4, "Expected finish at 4, got " .. tostring(finish2))

   -- Not found
   notFound = string.find(s, "xyz")
   assert(notFound is nil, "Expected nil for not found, got " .. tostring(notFound))

   -- With start position
   start3, finish3 = string.find(s, "o", 5)
   assert(start3 is 7, "Expected start at 7, got " .. tostring(start3))
   assert(finish3 is 7, "Expected finish at 7, got " .. tostring(finish3))

   -- Pattern matching (single character class)
   start4, finish4 = string.find("abc123def", "%d+")
   assert(start4 is 3, "Expected start at 3, got " .. tostring(start4))
   assert(finish4 is 5, "Expected finish at 5, got " .. tostring(finish4))

   -- Plain text search (fourth parameter = true)
   start5, finish5 = string.find("test%dpattern", "%d", 0, true)
   assert(start5 is 4, "Expected start at 4 for plain search, got " .. tostring(start5))
   assert(finish5 is 5, "Expected finish at 5 for plain search, got " .. tostring(finish5))

   -- Find with capture
   start6, finish6, capture = string.find("value=123", "=(%d+)")
   assert(start6 is 5, "Expected start at 5, got " .. tostring(start6))
   assert(finish6 is 8, "Expected finish at 8, got " .. tostring(finish6))
   assert(capture is "123", "Expected capture '123', got '" .. tostring(capture) .. "'")
end

@Test function testMatch()
   -- Basic match
   m = string.match("hello world", "world")
   assert(m is "world", "Expected 'world', got '" .. tostring(m) .. "'")

   -- Pattern with capture
   num = string.match("value=123", "=(%d+)")
   assert(num is "123", "Expected '123', got '" .. tostring(num) .. "'")

   -- Multiple captures
   a, b = string.match("x=10,y=20", "x=(%d+),y=(%d+)")
   assert(a is "10", "Expected '10', got '" .. tostring(a) .. "'")
   assert(b is "20", "Expected '20', got '" .. tostring(b) .. "'")

   -- No match
   noMatch = string.match("hello", "xyz")
   assert(noMatch is nil, "Expected nil for no match, got " .. tostring(noMatch))

   -- Match at specific position (zero-indexed)
   m2 = string.match("hello world", "world", 6)
   assert(m2 is "world", "Expected 'world' at position 6, got '" .. tostring(m2) .. "'")

   -- Pattern classes
   letters = string.match("abc123def", "%a+")
   assert(letters is "abc", "Expected 'abc', got '" .. tostring(letters) .. "'")

   digits = string.match("abc123def", "%d+")
   assert(digits is "123", "Expected '123', got '" .. tostring(digits) .. "'")
end

@Test function testGmatch()
   -- Iterate over words
   s = "hello world test"
   words = {}
   for word in string.gmatch(s, "%S+") do
      words[#words] = word
   end
   assert(#words is 3, "Expected 3 words, got " .. #words)
   assert(words[0] is "hello", "Expected 'hello', got '" .. words[0] .. "'")
   assert(words[1] is "world", "Expected 'world', got '" .. words[1] .. "'")
   assert(words[2] is "test", "Expected 'test', got '" .. words[2] .. "'")

   -- Iterate over numbers
   nums = {}
   for num in string.gmatch("a1b2c3", "%d") do
      nums[#nums] = num
   end
   assert(#nums is 3, "Expected 3 numbers, got " .. #nums)
   assert(nums[0] is "1", "Expected '1', got '" .. nums[0] .. "'")
   assert(nums[1] is "2", "Expected '2', got '" .. nums[1] .. "'")
   assert(nums[2] is "3", "Expected '3', got '" .. nums[2] .. "'")

   -- Iterate with captures
   pairs = {}
   for key, val in string.gmatch("x=1,y=2,z=3", "(%w+)=(%d+)") do
      pairs[#pairs] = {key, val}
   end
   assert(#pairs is 3, "Expected 3 pairs, got " .. #pairs)
   assert(pairs[0][0] is "x" and pairs[0][1] is "1", "Expected x=1")
   assert(pairs[1][0] is "y" and pairs[1][1] is "2", "Expected y=2")
   assert(pairs[2][0] is "z" and pairs[2][1] is "3", "Expected z=3")

   -- Empty matches
   count = 0
   for _ in string.gmatch("", "%S+") do
      count = count + 1
   end
   assert(count is 0, "Expected 0 matches for empty string, got " .. count)
end

@Test function testGsub()
   -- Basic substitution
   result, count = string.gsub("hello world", "world", "Lua")
   assert(result is "hello Lua", "Expected 'hello Lua', got '" .. result .. "'")
   assert(count is 1, "Expected 1 substitution, got " .. count)

   -- Multiple substitutions
   result2, count2 = string.gsub("hello hello hello", "hello", "hi")
   assert(result2 is "hi hi hi", "Expected 'hi hi hi', got '" .. result2 .. "'")
   assert(count2 is 3, "Expected 3 substitutions, got " .. count2)

   -- Limited substitutions
   result3, count3 = string.gsub("hello hello hello", "hello", "hi", 2)
   assert(result3 is "hi hi hello", "Expected 'hi hi hello', got '" .. result3 .. "'")
   assert(count3 is 2, "Expected 2 substitutions, got " .. count3)

   -- Pattern substitution
   result4 = string.gsub("abc123def456", "%d+", "X")
   assert(result4 is "abcXdefX", "Expected 'abcXdefX', got '" .. result4 .. "'")

   -- Substitution with captures
   result5 = string.gsub("x=1,y=2", "(%w+)=(%d+)", "%1:%2")
   assert(result5 is "x:1,y:2", "Expected 'x:1,y:2', got '" .. result5 .. "'")

   -- Function substitution
   result6 = string.gsub("hello world", "%w+", function(w) return #w end)
   assert(result6 is "5 5", "Expected '5 5', got '" .. result6 .. "'")

   -- Table substitution
   replacements = {hello = "hi", world = "Lua"}
   result7 = string.gsub("hello world", "%w+", replacements)
   assert(result7 is "hi Lua", "Expected 'hi Lua', got '" .. result7 .. "'")

   -- No match
   result8, count8 = string.gsub("hello", "xyz", "abc")
   assert(result8 is "hello", "Expected 'hello', got '" .. result8 .. "'")
   assert(count8 is 0, "Expected 0 substitutions, got " .. count8)
end

@Test function testFormat()
   for i=0,1000 do
      -- Basic integer
      f1 = string.format("value: %d", 42)
      assert(f1 is "value: 42", "Expected 'value: 42', got '" .. f1 .. "'")

      -- Floating point
      f2 = string.format("pi: %.2f", 3.14159)
      assert(f2 is "pi: 3.14", "Expected 'pi: 3.14', got '" .. f2 .. "'")

      -- String
      f3 = string.format("hello %s", "world")
      assert(f3 is "hello world", "Expected 'hello world', got '" .. f3 .. "'")

      -- Multiple arguments
      f4 = string.format("%s = %d", "answer", 42)
      assert(f4 is "answer = 42", "Expected 'answer = 42', got '" .. f4 .. "'")

      -- Hexadecimal
      f5 = string.format("0x%x", 255)
      assert(f5 is "0xff", "Expected '0xff', got '" .. f5 .. "'")

      f6 = string.format("0x%X", 255)
      assert(f6 is "0xFF", "Expected '0xFF', got '" .. f6 .. "'")

      -- Padding
      f7 = string.format("%05d", 42)
      assert(f7 is "00042", "Expected '00042', got '" .. f7 .. "'")

      -- Character
      f8 = string.format("char: %c", 65)
      assert(f8 is "char: A", "Expected 'char: A', got '" .. f8 .. "'")

      -- Percent sign
      f9 = string.format("100%%")
      assert(f9 is "100%", "Expected '100%', got '" .. f9 .. "'")

      -- No arguments
      f10 = string.format("hello")
      assert(f10 is "hello", "Expected 'hello', got '" .. f10 .. "'")
   end
end
