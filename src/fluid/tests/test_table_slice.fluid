-- Flute test suite for Table Slice Support (range-based indexing)
----------------------------------------------------------------------------------------------------------------------

-- Basic Exclusive Slicing Tests

@Test function testTableSliceBasicExclusive()
   t = {10, 20, 30, 40, 50}
   result = t[{1..4}]  -- Should be {20, 30, 40}
   assert(#result is 3, "slice should have 3 elements, got " .. #result)
   assert(result[0] is 20, "first element should be 20, got " .. tostring(result[0]))
   assert(result[1] is 30, "second element should be 30, got " .. tostring(result[1]))
   assert(result[2] is 40, "third element should be 40, got " .. tostring(result[2]))
end

@Test function testTableSliceFromStart()
   t = {10, 20, 30, 40, 50}
   result = t[{0..3}]  -- Should be {10, 20, 30}
   assert(#result is 3, "slice from start should have 3 elements")
   assert(result[0] is 10, "first element should be 10")
   assert(result[2] is 30, "third element should be 30")
end

@Test function testTableSliceToEnd()
   t = {10, 20, 30, 40, 50}
   result = t[{2..5}]  -- Should be {30, 40, 50}
   assert(#result is 3, "slice to end should have 3 elements")
   assert(result[0] is 30, "first element should be 30")
   assert(result[2] is 50, "third element should be 50")
end

@Test function testTableSliceFullTable()
   t = {10, 20, 30, 40, 50}
   result = t[{0..5}]  -- Should be {10, 20, 30, 40, 50}
   assert(#result is 5, "full slice should have 5 elements")
   assert(result[0] is 10)
   assert(result[4] is 50)
end

-- Inclusive Slicing Tests

@Test function testTableSliceBasicInclusive()
   t = {10, 20, 30, 40, 50}
   result = t[{1...3}]  -- Should be {20, 30, 40}
   assert(#result is 3, "inclusive slice should have 3 elements, got " .. #result)
   assert(result[0] is 20, "first element should be 20")
   assert(result[1] is 30, "second element should be 30")
   assert(result[2] is 40, "third element should be 40")
end

@Test function testTableSliceInclusiveSingleElement()
   t = {10, 20, 30, 40, 50}
   result = t[{2...2}]  -- Should be {30}
   assert(#result is 1, "single element inclusive slice should have 1 element")
   assert(result[0] is 30, "element should be 30")
end

@Test function testTableSliceInclusiveToEnd()
   t = {10, 20, 30, 40, 50}
   result = t[{3...4}]  -- Should be {40, 50}
   assert(#result is 2, "inclusive slice to end should have 2 elements")
   assert(result[0] is 40)
   assert(result[1] is 50)
end

-- Negative Index Tests

@Test function testTableSliceNegativeIndices()
   t = {10, 20, 30, 40, 50}
   result = t[{-3...-1}]  -- Last 3 elements: {30, 40, 50}
   assert(#result is 3, "negative slice should have 3 elements, got " .. #result)
   assert(result[0] is 30, "first element should be 30")
   assert(result[1] is 40, "second element should be 40")
   assert(result[2] is 50, "third element should be 50")
end

@Test function testTableSliceNegativeStart()
   t = {10, 20, 30, 40, 50}
   -- Negative indices force inclusive mode per design doc
   result = t[{-2..-1}]  -- {40, 50} (inclusive due to negative indices)
   assert(#result is 2, "negative indices slice should have 2 elements, got " .. #result)
   assert(result[0] is 40, "first element should be 40")
   assert(result[1] is 50, "second element should be 50")
end

@Test function testTableSliceNegativeEnd()
   t = {10, 20, 30, 40, 50}
   result = t[{0...-2}]  -- From start to second-to-last (inclusive)
   assert(#result is 4, "slice to negative end should have 4 elements, got " .. #result)
   assert(result[0] is 10)
   assert(result[3] is 40)
end

@Test function testTableSliceMixedIndices()
   t = {10, 20, 30, 40, 50}
   result = t[{1...-1}]  -- From index 1 to last (inclusive)
   assert(#result is 4, "mixed indices slice should have 4 elements, got " .. #result)
   assert(result[0] is 20)
   assert(result[3] is 50)
end

-- Step/Stride Tests

@Test function testTableSliceWithStep()
   t = {10, 20, 30, 40, 50, 60, 70}
   r = range(0, 7, true, 2)  -- Every 2nd element: {10, 30, 50, 70}
   result = t[r]
   assert(#result is 4, "stepped slice should have 4 elements, got " .. #result)
   assert(result[0] is 10, "first element should be 10")
   assert(result[1] is 30, "second element should be 30")
   assert(result[2] is 50, "third element should be 50")
   assert(result[3] is 70, "fourth element should be 70")
end

@Test function testTableSliceWithStepThree()
   t = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
   r = range(0, 9, true, 3)  -- Every 3rd: {0, 3, 6, 9}
   result = t[r]
   assert(#result is 4, "step 3 slice should have 4 elements, got " .. #result)
   assert(result[0] is 0)
   assert(result[1] is 3)
   assert(result[2] is 6)
   assert(result[3] is 9)
end

-- Reverse Iteration Tests

@Test function testTableSliceReverse()
   t = {10, 20, 30, 40, 50}
   result = t[{4..0}]  -- Reverse exclusive: indices 4,3,2,1 (not 0)
   assert(#result is 4, "reverse exclusive slice should have 4 elements, got " .. #result)
   assert(result[0] is 50, "first element should be 50")
   assert(result[1] is 40, "second element should be 40")
   assert(result[2] is 30, "third element should be 30")
   assert(result[3] is 20, "fourth element should be 20")
end

@Test function testTableSliceReversePartial()
   t = {10, 20, 30, 40, 50}
   result = t[{3..1}]  -- Reverse exclusive: indices 3,2 (not 1)
   assert(#result is 2, "reverse partial exclusive slice should have 2 elements, got " .. #result)
   assert(result[0] is 40)
   assert(result[1] is 30)
end

@Test function testTableSliceReverseInclusive()
   t = {10, 20, 30, 40, 50}
   result = t[{4...0}]  -- Reverse inclusive: {50, 40, 30, 20, 10}
   assert(#result is 5, "reverse inclusive slice should have 5 elements")
   assert(result[0] is 50)
   assert(result[4] is 10)
end

@Test function testTableSliceReverseWithStep()
   t = {10, 20, 30, 40, 50, 60, 70}
   r = range(6, 0, true, -2)  -- 6, 4, 2, 0
   result = t[r]
   assert(#result is 4, "reverse stepped slice should have 4 elements, got " .. #result)
   assert(result[0] is 70, "first should be 70")
   assert(result[1] is 50, "second should be 50")
   assert(result[2] is 30, "third should be 30")
   assert(result[3] is 10, "fourth should be 10")
end

-- Out-of-Bounds Handling

@Test function testTableSliceOutOfBoundsEnd()
   t = {10, 20, 30}
   result = t[{0..10}]  -- Should clip to {10, 20, 30}
   assert(#result is 3, "out-of-bounds end slice should clip, got " .. #result)
   assert(result[0] is 10)
   assert(result[2] is 30)
end

@Test function testTableSliceOutOfBoundsStart()
   t = {10, 20, 30}
   result = t[{-10..3}]  -- Should clip start to 0
   assert(#result is 3, "negative out-of-bounds start should clip, got " .. #result)
   assert(result[0] is 10)
   assert(result[2] is 30)
end

@Test function testTableSliceBothOutOfBounds()
   t = {10, 20, 30}
   result = t[{-10..10}]  -- Should clip both
   assert(#result is 3, "both out-of-bounds should clip to full table")
end

-- Empty Range Handling

@Test function testTableSliceEmptyExclusiveRange()
   t = {10, 20, 30}
   result = t[{2..2}]  -- Empty exclusive range
   assert(#result is 0, "empty exclusive range should return empty table, got " .. #result)
end

@Test function testTableSliceEmptyBeyondLength()
   t = {10, 20, 30}
   result = t[{5..10}]  -- Beyond table length
   assert(#result is 0, "beyond-length range should return empty table")
end

@Test function testTableSliceAutoReverseRange()
   t = {10, 20, 30}
   result = t[{2..0}]  -- Auto-detects as reverse range: {30, 20, 10}
   assert(#result is 2, "{2..0} exclusive reverse should have 2 elements, got " .. #result)
   assert(result[0] is 30, "first element should be 30")
   assert(result[1] is 20, "second element should be 20")
end

-- Regular Indexing Unaffected

@Test function testTableRegularNumericIndex()
   t = {10, 20, 30}
   assert(t[0] is 10, "numeric index 0 should work")
   assert(t[1] is 20, "numeric index 1 should work")
   assert(t[2] is 30, "numeric index 2 should work")
end

@Test function testTableRegularStringKey()
   t = {10, 20, 30}
   t.name = "test"
   t.value = 42
   assert(t.name is "test", "string key should work")
   assert(t["name"] is "test", "string key bracket syntax should work")
   assert(t.value is 42, "numeric value with string key should work")
end

@Test function testTableRegularNilAccess()
   t = {10, 20, 30}
   assert(t[10] is nil, "out-of-bounds numeric index should return nil")
   assert(t.nonexistent is nil, "nonexistent key should return nil")
end

-- Mixed Content Tables

@Test function testTableSliceMixedContent()
   t = {"a", 2, "c", 4, "e"}
   result = t[{1..4}]
   assert(#result is 3, "mixed content slice should work")
   assert(result[0] is 2)
   assert(result[1] is "c")
   assert(result[2] is 4)
end

@Test function testTableSliceWithNils()
   t = {10, nil, 30, nil, 50}
   result = t[{0..5}]
   assert(result[0] is 10)
   assert(result[1] is nil)
   assert(result[2] is 30)
   assert(result[3] is nil)
   assert(result[4] is 50)
end

-- Edge Cases

@Test function testTableSliceEmptyTable()
   t = {}
   result = t[{0..5}]
   assert(#result is 0, "slicing empty table should return empty table")
end

@Test function testTableSliceSingleElementTable()
   t = {42}
   result = t[{0..1}]
   assert(#result is 1, "single element slice should have 1 element")
   assert(result[0] is 42)
end

@Test function testTableSliceUsingRangeVariable()
   t = {10, 20, 30, 40, 50}
   r = {1..4}
   result = t[r]
   assert(#result is 3, "slice using range variable should work")
   assert(result[0] is 20)
   assert(result[2] is 40)
end

@Test function testTableSliceUsingRangeConstructor()
   t = {10, 20, 30, 40, 50}
   result = t[range(1, 4)]
   assert(#result is 3, "slice using range() constructor should work")
   assert(result[0] is 20)
   assert(result[2] is 40)
end

-- Verify slice returns a copy, not a view

@Test function testTableSliceReturnsCopy()
   t = {10, 20, 30, 40, 50}
   result = t[{1..4}]

   -- Modify the result
   result[0] = 999

   -- Original should be unchanged
   assert(t[1] is 20, "modifying slice should not affect original table")
end

-- Metatable Interaction Tests

@Test function testTableSliceWithUnrelatedMetatable()
   -- Table with a metatable that defines __len but not __index
   t = {10, 20, 30, 40, 50}
   setmetatable(t, { __len = function() return 100 end })

   -- This should still work even though table has a metatable
   result = t[{1..4}]
   assert(#result is 3, "slice should work even with unrelated metatable, got " .. #result)
   assert(result[0] is 20, "first element should be 20")
   assert(result[1] is 30, "second element should be 30")
   assert(result[2] is 40, "third element should be 40")
end

@Test function testTableSliceWithCustomIndex()
   -- Table with custom __index should use that, not base metatable
   t = {10, 20, 30, 40, 50}
   setmetatable(t, {
      __index = function(tbl, key)
         return 999  -- Always return 999
      end
   })

   -- Custom __index should take precedence
   result = t[{1..4}]
   assert(result is 999, "custom __index should override base metatable")
end
