-- Flute regression tests for the defer keyword

local function join(values)
   return table.concat(values, ',')
end

function testBasicExecution()
   local order = {}
   local function subject()
      defer()
         table.insert(order, 'deferred')
      end
      table.insert(order, 'body')
   end

   subject()
   assert(join(order) is 'body,deferred', "Expected body before deferred handler, got '" .. join(order) .. "'")
end

function testLifoOrder()
   local order = {}
   local function subject()
      defer()
         table.insert(order, 'first')
      end
      defer()
         table.insert(order, 'second')
      end
      defer()
         table.insert(order, 'third')
      end
      table.insert(order, 'body')
   end

   subject()
   assert(join(order) is 'body,third,second,first', "Expected LIFO order for defers, got '" .. join(order) .. "'")
end

local function subjectReturn(order)
   defer()
      table.insert(order, 'deferred')
   end
   table.insert(order, 'before-return')
   return 'result'
end

function testEarlyReturn()
   local order = {}
   local value = subjectReturn(order)

   assert(value is 'result', "Expected subjectReturn result to be 'result', got '" .. tostring(value) .. "'")
   assert(join(order) is 'before-return,deferred', "Expected deferred handler to run after return, got '" .. join(order) .. "'")
end

function testNestedScopes()
   local order = {}

   local function subject()
      defer()
         table.insert(order, 'outer')
      end

      do
         defer()
            table.insert(order, 'inner')
         end
         table.insert(order, 'inner-body')
      end

      table.insert(order, 'after-inner')
   end

   subject()

   assert(join(order) is 'inner-body,inner,after-inner,outer', "Expected inner defer before outer, got '" .. join(order) .. "'")
end

function testBreak()
   local order = {}

   local function subject()
      for i = 1, 3 do
         defer()
            table.insert(order, 'loop-' .. tostring(i))
         end
         table.insert(order, 'before-break-' .. tostring(i))
         break
      end
   end

   subject()
   assert(join(order) is 'before-break-1,loop-1', "Expected loop defer to run on break, got '" .. join(order) .. "'")
end

function testContinue()
   local order = {}

   local function subject()
      for i = 1, 2 do
         defer()
            table.insert(order, 'defer-' .. tostring(i))
         end
         table.insert(order, 'body-' .. tostring(i))
         if i is 1 then
            table.insert(order, 'continue-' .. tostring(i))
            continue
         end
         table.insert(order, 'after-' .. tostring(i))
      end
   end

   subject()
   assert(join(order) is 'body-1,continue-1,defer-1,body-2,after-2,defer-2', "Unexpected continue defer order: '" .. join(order) .. "'")
end

function testUpvalues()
   local captures = {}

   local function subject()
      local value = 10
      defer()
         table.insert(captures, value)
      end
      value = 25
      table.insert(captures, 'body')
      value = 30
   end

   subject()

   assert(join(captures) is 'body,30', "Expected upvalue capture to reflect latest value, got '" .. join(captures) .. "'")
end

function testArgumentSnapshot()
   local events = {}

   local function subject()
      local value = 5

      defer(arg)
         table.insert(events, 'defer-' .. tostring(arg))
      end(value)

      table.insert(events, 'body-' .. tostring(value))
      value += 10
      table.insert(events, 'mutated-' .. tostring(value))
   end

   subject()

   assert(join(events) is 'body-5,mutated-15,defer-5',
      "Deferred argument should snapshot initial value: '" .. join(events) .. "'")
end

function testMultiReturnPreservesLocals()
   local function subject()
      local head = 'alpha'
      local tail = 'omega'

      defer()
         head = 'mutated-alpha'
         tail = 'mutated-omega'
      end

      return head, tail
   end

   local first, second = subject()

   assert(first is 'alpha', "Expected first return value to remain 'alpha', got '" .. tostring(first) .. "'")
   assert(second is 'omega', "Expected second return value to remain 'omega', got '" .. tostring(second) .. "'")
end

function testConditionalScopes()
   local order = {}

   local function subject()
      defer()
         table.insert(order, 'outer')
      end

      if true then
         defer()
            table.insert(order, 'if-block')
         end
         table.insert(order, 'if-body')
      end

      table.insert(order, 'after-if')
   end

   subject()

   assert(join(order) is 'if-body,if-block,after-if,outer', "Unexpected conditional defer order: '" .. join(order) .. "'")
end

function testLoopMultipleDefers()
   local order = {}

   local function subject()
      for i = 1, 2 do
         defer()
            table.insert(order, 'outer-' .. tostring(i))
         end
         do
            defer()
               table.insert(order, 'inner-' .. tostring(i))
            end
            table.insert(order, 'inner-body-' .. tostring(i))
         end
         table.insert(order, 'loop-body-' .. tostring(i))
      end
   end

   subject()
   assert(join(order) is 'inner-body-1,inner-1,loop-body-1,outer-1,inner-body-2,inner-2,loop-body-2,outer-2', "Unexpected nested loop defer order: '" .. join(order) .. "'")
end

function testHandlerError()
   -- Phase 3 placeholder: deferred handler error propagation to be implemented.
end

local function recurse(n, order)
   defer()
      table.insert(order, 'defer-' .. tostring(n))
   end
   table.insert(order, 'enter-' .. tostring(n))
   if n > 1 then
      recurse(n - 1, order)
   end
   table.insert(order, 'leave-' .. tostring(n))
end

function testRecursive()
   local order = {}
   recurse(3, order)

   assert(join(order) is 'enter-3,enter-2,enter-1,leave-1,defer-1,leave-2,defer-2,leave-3,defer-3', "Unexpected recursive defer order: '" .. join(order) .. "'")
end

function testClosureReturn()
   local calls = {}
   local function make()
      local sum = 0
      defer()
         sum += 5
         table.insert(calls, sum)
      end
      sum += 10
      return sum
   end

   local value = make()
   assert(value is 10, "Expected make() to return immediate sum, got " .. tostring(value))
   assert(join(calls) is '15', "Expected deferred closure to observe mutated state, got '" .. join(calls) .. "'")
end

function testResourceCleanupPattern()
   local log = {}

   local function cleanup(resource, token)
      table.insert(log, 'cleanup-' .. resource.name .. '-' .. token)
   end

   local function acquire(name)
      table.insert(log, 'acquire-' .. name)
      return { name = name }
   end

   local function subject()
      local resource = acquire('alpha')
      local label = 'start'

      defer(handler, handle, token)
         handler(handle, token)
      end(cleanup, resource, label .. '-token')

      resource.name = 'beta'
      label = 'updated'
      table.insert(log, 'body-' .. resource.name .. '-' .. label)
   end

   subject()

   assert(join(log) is 'acquire-alpha,body-beta-updated,cleanup-beta-start-token',
      "Resource cleanup should receive original token value: '" .. join(log) .. "'")
end

-----------------------------------------------------------------------------------------------------------------------

   local supportsArgumentSnapshot = true
   local supportsErrorPropagation = false

   local tests = {
      -- PHASE 1: MVP - Basic defer without arguments or error handling
      -- Expected to pass: 10 tests
      'testBasicExecution',      -- Core: defer executes at scope end
      'testLifoOrder',           -- Core: multiple defers execute in reverse order
      'testEarlyReturn',         -- Core: defer executes before return
      'testNestedScopes',        -- Core: nested scopes handle defers correctly
      'testBreak',               -- Core: defer executes on break
      'testContinue',            -- Core: defer executes on continue
      'testUpvalues',            -- Core: defers capture upvalues correctly
      'testConditionalScopes',   -- Core: defers in if/else blocks work
      'testLoopMultipleDefers',  -- Core: complex nested loop scenarios
      'testRecursive',           -- Core: defer works in recursive functions
      'testClosureReturn',       -- Core: defer in closures with upvalues
      'testMultiReturnPreservesLocals'         -- Core: multi-value returns keep snapshots
   }

   if supportsArgumentSnapshot then
      table.insert(tests, 'testArgumentSnapshot')
      table.insert(tests, 'testResourceCleanupPattern')
   end

   if supportsErrorPropagation then
      table.insert(tests, 'testHandlerError')
   end

   return {
      tests = tests
   }
