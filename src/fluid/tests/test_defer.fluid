-- Flute regression tests for the defer keyword

local function join(values)
   return table.concat(values, ',')
end

function testBasicExecution()
   local order = {}
   local function subject()
      defer()
         table.insert(order, 'deferred')
      end
      table.insert(order, 'body')
   end

   subject()
   assert(join(order) is 'body,deferred', "Expected body before deferred handler, got '" .. join(order) .. "'")
end

function testLifoOrder()
   local order = {}
   local function subject()
      defer()
         table.insert(order, 'first')
      end
      defer()
         table.insert(order, 'second')
      end
      defer()
         table.insert(order, 'third')
      end
      table.insert(order, 'body')
   end

   subject()
   assert(join(order) is 'body,third,second,first', "Expected LIFO order for defers, got '" .. join(order) .. "'")
end

local function subjectReturn(order)
   defer()
      table.insert(order, 'deferred')
   end
   table.insert(order, 'before-return')
   return 'result'
end

function testEarlyReturn()
   local order = {}
   local value = subjectReturn(order)

   assert(value is 'result', "Expected subjectReturn result to be 'result', got '" .. tostring(value) .. "'")
   assert(join(order) is 'before-return,deferred', "Expected deferred handler to run after return, got '" .. join(order) .. "'")
end

function testNestedScopes()
   local order = {}

   local function subject()
      defer()
         table.insert(order, 'outer')
      end

      do
         defer()
            table.insert(order, 'inner')
         end
         table.insert(order, 'inner-body')
      end

      table.insert(order, 'after-inner')
   end

   subject()

   assert(join(order) is 'inner-body,inner,after-inner,outer', "Expected inner defer before outer, got '" .. join(order) .. "'")
end

function testBreak()
   local order = {}

   local function subject()
      for i = 1, 3 do
         defer()
            table.insert(order, 'loop-' .. tostring(i))
         end
         table.insert(order, 'before-break-' .. tostring(i))
         break
      end
   end

   subject()
   assert(join(order) is 'before-break-1,loop-1', "Expected loop defer to run on break, got '" .. join(order) .. "'")
end

function testContinue()
   local order = {}

   local function subject()
      for i = 1, 2 do
         defer()
            table.insert(order, 'defer-' .. tostring(i))
         end
         table.insert(order, 'body-' .. tostring(i))
         if i is 1 then
            table.insert(order, 'continue-' .. tostring(i))
            continue
         end
         table.insert(order, 'after-' .. tostring(i))
      end
   end

   subject()
   assert(join(order) is 'body-1,continue-1,defer-1,body-2,after-2,defer-2', "Unexpected continue defer order: '" .. join(order) .. "'")
end

function testUpvalues()
   local captures = {}

   local function subject()
      local value = 10
      defer()
         table.insert(captures, value)
      end
      value = 25
      table.insert(captures, 'body')
      value = 30
   end

   subject()

   assert(join(captures) is 'body,30', "Expected upvalue capture to reflect latest value, got '" .. join(captures) .. "'")
end

function testArgumentSnapshot()
   local snapshots = {}

   local function subject()
      local x = 5
      defer(arg)
         table.insert(snapshots, arg)
      end(x)
      x = 9
      table.insert(snapshots, 'body')
   end

   subject()
   assert(join(snapshots) is 'body,5', "Expected defer arguments to snapshot values, got '" .. join(snapshots) .. "'")
end

function testConditionalScopes()
   local order = {}

   local function subject()
      defer()
         table.insert(order, 'outer')
      end

      if true then
         defer()
            table.insert(order, 'if-block')
         end
         table.insert(order, 'if-body')
      end

      table.insert(order, 'after-if')
   end

   subject()

   assert(join(order) is 'if-body,if-block,after-if,outer', "Unexpected conditional defer order: '" .. join(order) .. "'")
end

function testLoopMultipleDefers()
   local order = {}

   local function subject()
      for i = 1, 2 do
         defer()
            table.insert(order, 'outer-' .. tostring(i))
         end
         do
            defer()
               table.insert(order, 'inner-' .. tostring(i))
            end
            table.insert(order, 'inner-body-' .. tostring(i))
         end
         table.insert(order, 'loop-body-' .. tostring(i))
      end
   end

   subject()
   assert(join(order) is 'inner-body-1,inner-1,loop-body-1,outer-1,inner-body-2,inner-2,loop-body-2,outer-2', "Unexpected nested loop defer order: '" .. join(order) .. "'")
end

function testHandlerError()
   local order = {}
   local ok, err = pcall(function()
      defer()
         table.insert(order, 'first')
      end
      defer()
         table.insert(order, 'second')
         error('boom')
      end
      defer()
         table.insert(order, 'third')
      end
      table.insert(order, 'body')
   end)

   assert(not ok, "Expected error from deferred handler")
   assert(string.find(err, 'boom', 1, true) != nil, "Expected error message to contain 'boom', got '" .. tostring(err) .. "'")
   assert(join(order) is 'body,third,second,first', "Expected handlers to run in order despite error, got '" .. join(order) .. "'")
end

local function recurse(n, order)
   defer()
      table.insert(order, 'defer-' .. tostring(n))
   end
   table.insert(order, 'enter-' .. tostring(n))
   if n > 1 then
      recurse(n - 1, order)
   end
   table.insert(order, 'leave-' .. tostring(n))
end

function testRecursive()
   local order = {}
   recurse(3, order)

   assert(join(order) is 'enter-3,enter-2,enter-1,leave-1,defer-1,leave-2,defer-2,leave-3,defer-3', "Unexpected recursive defer order: '" .. join(order) .. "'")
end

function testClosureReturn()
   local calls = {}
   local function make()
      local sum = 0
      defer()
         sum += 5
         table.insert(calls, sum)
      end
      sum += 10
      return sum
   end

   local value = make()
   assert(value is 10, "Expected make() to return immediate sum, got " .. tostring(value))
   assert(join(calls) is '15', "Expected deferred closure to observe mutated state, got '" .. join(calls) .. "'")
end

function testResourceCleanupPattern()
   local state = { opened = false, closed = false }

   local function open()
      state.opened = true
      return {
         close = function()
            state.closed = true
         end
      }
   end

   local function use()
      local handle = open()
      defer(res)
         res:close()
      end(handle)
   end

   use()

   assert(state.opened is true, "Resource should have been opened")
   assert(state.closed is true, "Deferred close should mark resource closed")
end

-----------------------------------------------------------------------------------------------------------------------

   return {
      tests = {
         'testBasicExecution',
         'testLifoOrder',
         'testEarlyReturn',
         'testNestedScopes',
         'testBreak',
         'testContinue',
         'testUpvalues',
         'testArgumentSnapshot',
         'testConditionalScopes',
         'testLoopMultipleDefers',
         'testHandlerError',
         'testRecursive',
         'testClosureReturn',
         'testResourceCleanupPattern'
      }
   }