-- Flute regression tests for the defer keyword

function join(values)
   return table.concat(values, ',')
end

@Test function testBasicExecution()
   order = {}
   function subject()
      defer
         table.insert(order, 'deferred')
      end
      table.insert(order, 'body')
   end

   subject()
   assert(join(order) is 'body,deferred', "Expected body before deferred handler, got '" .. join(order) .. "'")
end

@Test function testDeferWithoutParens()
   order = {}

   function subject()
      defer
         table.insert(order, 'alpha')
      end

      defer()
         table.insert(order, 'beta')
      end

      table.insert(order, 'body')
   end

   subject()

   assert(join(order) is 'body,beta,alpha', "Expected mix of defer syntaxes to preserve order, got '" .. join(order) .. "'")
end

@Test function testLifoOrder()
   order = {}
   function subject()
      defer
         table.insert(order, 'first')
      end
      defer
         table.insert(order, 'second')
      end
      defer
         table.insert(order, 'third')
      end
      table.insert(order, 'body')
   end

   subject()
   assert(join(order) is 'body,third,second,first', "Expected LIFO order for defers, got '" .. join(order) .. "'")
end

function subjectReturn(order)
   defer
      table.insert(order, 'deferred')
   end
   table.insert(order, 'before-return')
   return 'result'
end

@Test function testEarlyReturn()
   order = {}
   value = subjectReturn(order)

   assert(value is 'result', "Expected subjectReturn result to be 'result', got '" .. tostring(value) .. "'")
   assert(join(order) is 'before-return,deferred', "Expected deferred handler to run after return, got '" .. join(order) .. "'")
end

@Test function testNestedScopes()
   order = {}

   function subject()
      defer
         table.insert(order, 'outer')
      end

      do
         defer
            table.insert(order, 'inner')
         end
         table.insert(order, 'inner-body')
      end

      table.insert(order, 'after-inner')
   end

   subject()

   assert(join(order) is 'inner-body,inner,after-inner,outer', "Expected inner defer before outer, got '" .. join(order) .. "'")
end

@Test function testBreak()
   order = {}

   function subject()
      for i = 1, 3 do
         defer
            table.insert(order, 'loop-' .. tostring(i))
         end
         table.insert(order, 'before-break-' .. tostring(i))
         break
      end
   end

   subject()
   assert(join(order) is 'before-break-1,loop-1', "Expected loop defer to run on break, got '" .. join(order) .. "'")
end

@Test function testContinue()
   order = {}

   function subject()
      for i = 1, 2 do
         defer
            table.insert(order, 'defer-' .. tostring(i))
         end
         table.insert(order, 'body-' .. tostring(i))
         if i is 1 then
            table.insert(order, 'continue-' .. tostring(i))
            continue
         end
         table.insert(order, 'after-' .. tostring(i))
      end
   end

   subject()
   assert(join(order) is 'body-1,continue-1,defer-1,body-2,after-2,defer-2', "Unexpected continue defer order: '" .. join(order) .. "'")
end

@Test function testUpvalues()
   captures = {}

   function subject()
      value = 10
      defer
         table.insert(captures, value)
      end
      value = 25
      table.insert(captures, 'body')
      value = 30
   end

   subject()

   assert(join(captures) is 'body,30', "Expected upvalue capture to reflect latest value, got '" .. join(captures) .. "'")
end

@Test function testArgumentSnapshot()
   events = {}

   function subject()
      value = 5

      defer(arg)
         table.insert(events, 'defer-' .. tostring(arg))
      end(value)

      table.insert(events, 'body-' .. tostring(value))
      value += 10
      table.insert(events, 'mutated-' .. tostring(value))
   end

   subject()

   assert(join(events) is 'body-5,mutated-15,defer-5',
      "Deferred argument should snapshot initial value: '" .. join(events) .. "'")
end

@Test function testMultiReturnPreservesLocals()
   function subject()
      head = 'alpha'
      tail = 'omega'

      defer
         head = 'mutated-alpha'
         tail = 'mutated-omega'
      end

      return head, tail
   end

   first, second = subject()

   assert(first is 'alpha', "Expected first return value to remain 'alpha', got '" .. tostring(first) .. "'")
   assert(second is 'omega', "Expected second return value to remain 'omega', got '" .. tostring(second) .. "'")
end

@Test function testConditionalScopes()
   order = {}

   function subject()
      defer
         table.insert(order, 'outer')
      end

      if true then
         defer
            table.insert(order, 'if-block')
         end
         table.insert(order, 'if-body')
      end

      table.insert(order, 'after-if')
   end

   subject()

   assert(join(order) is 'if-body,if-block,after-if,outer', "Unexpected conditional defer order: '" .. join(order) .. "'")
end

@Test function testLoopMultipleDefers()
   order = {}

   function subject()
      for i = 1, 2 do
         defer
            table.insert(order, 'outer-' .. tostring(i))
         end
         do
            defer
               table.insert(order, 'inner-' .. tostring(i))
            end
            table.insert(order, 'inner-body-' .. tostring(i))
         end
         table.insert(order, 'loop-body-' .. tostring(i))
      end
   end

   subject()
   assert(join(order) is 'inner-body-1,inner-1,loop-body-1,outer-1,inner-body-2,inner-2,loop-body-2,outer-2', "Unexpected nested loop defer order: '" .. join(order) .. "'")

   total = 0
   step = 1
   repeat
      defer
         total = total + step
      end
      total = total + step
   until total > 5

   assert(total is 6, "Expected total to be 6 after loop")
end

@Test function testHandlerError()
   -- Phase 3 placeholder: deferred handler error propagation to be implemented.
end

function recurse(n, order)
   defer
      table.insert(order, 'defer-' .. tostring(n))
   end
   table.insert(order, 'enter-' .. tostring(n))
   if n > 1 then
      recurse(n - 1, order)
   end
   table.insert(order, 'leave-' .. tostring(n))
end

@Test function testRecursive()
   order = {}
   recurse(3, order)

   assert(join(order) is 'enter-3,enter-2,enter-1,leave-1,defer-1,leave-2,defer-2,leave-3,defer-3', "Unexpected recursive defer order: '" .. join(order) .. "'")
end

@Test function testClosureReturn()
   calls = {}
   function make()
      sum = 0
      defer
         sum += 5
         table.insert(calls, sum)
      end
      sum += 10
      return sum
   end

   value = make()
   assert(value is 10, "Expected make() to return immediate sum, got " .. tostring(value))
   assert(join(calls) is '15', "Expected deferred closure to observe mutated state, got '" .. join(calls) .. "'")
end

@Test function testResourceCleanupPattern()
   log = {}

   function cleanup(resource, token)
      table.insert(log, 'cleanup-' .. resource.name .. '-' .. token)
   end

   function acquire(name)
      table.insert(log, 'acquire-' .. name)
      return { name = name }
   end

   function subject()
      resource = acquire('alpha')
      label = 'start'

      defer(handler, handle, token)
         handler(handle, token)
      end(cleanup, resource, label .. '-token')

      resource.name = 'beta'
      label = 'updated'
      table.insert(log, 'body-' .. resource.name .. '-' .. label)
   end

   subject()

   assert(join(log) is 'acquire-alpha,body-beta-updated,cleanup-beta-start-token',
      "Resource cleanup should receive original token value: '" .. join(log) .. "'")
end
