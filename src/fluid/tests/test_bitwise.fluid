-- Comprehensive tests for bitwise operators and compound assignments.

@BeforeEach(hotpath=true)
function enforce_hotpath() end

function returns6_99()
   return 6, 99
end

@Test function UnaryBnot()
   assert(~0 is bit.bnot(0), '~ should map to bit.bnot')
   assert(~1 is bit.bnot(1), '~ should invert all bits')
   x = 0x7fffffff
   assert(~x is bit.bnot(x), '~ should work for large ints')
   -- Coercion: numbers are coerced via tobit semantics
   assert(~3.7 is bit.bnot(3.7), '~ should coerce numbers via tobit')
end

@Test function BinaryBitwiseBasics()
   -- AND, OR, XOR
   band_result = bit.band(5, 3)
   assert((5 & 3) is band_result, '& should map to bit.band')
   assert((5 | 2) is bit.bor(5, 2), '| should map to bit.bor')
   assert((5 ~ 1) is bit.bxor(5, 1), '~ binary should be XOR')
   -- Negative values and coercion
   assert((-1 & 0xff) is 0xff, 'AND should mask bits with negative left operand')
end

-- This test confirms that a series of operators returns only one value.

@Test function ChainedOperators()
   single_value, second_value = 1 | 2 | 4
   assert(single_value, 'Expected value, got ' .. tostring(single_value))
   assert(second_value is nil, 'Unexpected second value, got ' .. tostring(second_value))

   single_value, second_value = 1 & 2 | 4
   assert(single_value, 'Expected value, got ' .. tostring(single_value))
   assert(second_value is nil, 'Unexpected second value, got ' .. tostring(second_value))
end

@Test function BitwisePrecedenceAndGrouping()
   -- Parentheses control
   assert((1 | (2 & 4)) is (1 | bit.band(2, 4)), 'AND groups inside OR with parens')
   -- Power stays as exponentiation, not XOR
   assert(2 ^ 3 is 8, '^ remains power operator')
   -- Not-equals unaffected
   assert(3 ~= 4, '~= remains not-equal')
end

@Test function CStylePrecedence()
   -- Test C-style precedence: AND > XOR > OR
   -- XOR should bind tighter than OR
   result1 = 1 | 2 ~ 3
   expected1 = bit.bor(1, bit.bxor(2, 3))  -- 1 | (2 ~ 3) = 1 | 1 = 1
   assert(result1 is expected1, 'XOR should bind tighter than OR: 1 | 2 ~ 3 should be 1 | (2 ~ 3)')

   -- Reverse order
   result2 = 1 ~ 2 | 3
   expected2 = bit.bor(bit.bxor(1, 2), 3)  -- (1 ~ 2) | 3 = 3 | 3 = 3
   assert(result2 is expected2, 'Left-to-right within same precedence: 1 ~ 2 | 3 should be (1 ~ 2) | 3')
end

@Test function CStylePrecedenceAND()
   -- AND should bind tighter than OR
   result3 = 1 | 2 & 3
   expected3 = bit.bor(1, bit.band(2, 3))  -- 1 | (2 & 3) = 1 | 2 = 3
   assert(result3 is expected3, 'AND should bind tighter than OR: 1 | 2 & 3 should be 1 | (2 & 3)')

   -- AND should bind tighter than XOR
   result4 = 7 & 5 ~ 3
   expected4 = bit.bxor(bit.band(7, 5), 3)  -- (7 & 5) ~ 3 = 5 ~ 3 = 6
   assert(result4 is expected4, 'AND should bind tighter than XOR: 7 & 5 ~ 3 should be (7 & 5) ~ 3')
end

@Test function CStylePrecedenceComplex()
   -- Complex expression with all three
   result5 = 8 | 4 ~ 2 & 1
   expected5 = bit.bor(8, bit.bxor(4, bit.band(2, 1)))  -- 8 | (4 ~ (2 & 1)) = 8 | (4 ~ 0) = 8 | 4 = 12
   assert(result5 is expected5, 'Complex: 8 | 4 ~ 2 & 1 should follow AND > XOR > OR precedence')

   -- Shifts bind tighter than bitwise AND
   result6 = 5 & 1 << 1
   expected6 = bit.band(5, bit.lshift(1, 1))  -- 5 & (1 << 1) = 5 & 2 = 0
   assert(result6 is expected6, 'Shift should bind tighter than AND: 5 & 1 << 1 should be 5 & (1 << 1)')
end

@Test function ShiftBitwiseBinding()
   result1 = 1 << 2 & 3
   expected1 = bit.band(bit.lshift(1, 2), 3)  -- (1 << 2) & 3 = 4 & 3 = 0
   assert(result1 is expected1, 'Shift should bind tighter than AND: 1 << 2 & 3 should be (1 << 2) & 3')

   result2 = 1 << 1 | 2
   expected2 = bit.bor(bit.lshift(1, 1), 2)  -- (1 << 1) | 2 = 2 | 2 = 2
   assert(result2 is expected2, 'Shift should bind tighter than OR: 1 << 1 | 2 should be (1 << 1) | 2')

   result3 = 1 << 2 ~ 3
   expected3 = bit.bxor(bit.lshift(1, 2), 3)  -- (1 << 2) ~ 3 = 4 ~ 3 = 7
   assert(result3 is expected3, 'Shift should bind tighter than XOR: 1 << 2 ~ 3 should be (1 << 2) ~ 3')
end

@Test function RHSFunctionCallsAndRegisterPreservation()
   t = { 1, 2, 3 }
   i = 2
   function f(a)
      return bit.lshift(a, 1)
   end
   t[i] = t[i] | f(i)
   assert(t[2] is bit.bor(3, bit.lshift(3, 1)), 'indexed |= with function RHS should preserve base/index')
   -- Use index register on RHS too
   u = { 1, 2, 4 }
   t[i] = t[i] & u[i]
   assert(t[2] is bit.band(bit.bor(3, bit.lshift(3, 1)), u[2]), 'indexed & RHS index usage is safe')
end

@Test function MultipleReturnLHS()
   -- Test multi-return on LHS of bitwise AND
   band_cmp = bit.band(6, 1)  -- 6 & 1 = 0
   x = returns6_99() & 1      -- Should use first return value (6)
   assert(x is band_cmp, 'band multi-return LHS failed: ' .. x .. ' vs ' .. band_cmp)

   -- Test multi-return on RHS of shift (shift count)
   shift_cmp = bit.lshift(1, 6)  -- 1 << 6 = 64
   x2 = 1 << returns6_99()       -- Should use first return value (6) as shift count
   assert(x2 is shift_cmp, 'lshift multi-return RHS failed: ' .. x2 .. ' vs ' .. shift_cmp)

   -- Test multi-return on LHS of shift (value to shift)
   shift_lhs_cmp = bit.lshift(6, 1)  -- 6 << 1 = 12
   x3 = returns6_99() << 1           -- Should use first return value (6) as value
   assert(x3 is shift_lhs_cmp, 'lshift multi-return LHS failed: ' .. x3 .. ' vs ' .. shift_lhs_cmp)

   -- Test multi-return on RHS of right shift
   rshift_cmp = bit.rshift(64, 6)  -- 64 >> 6 = 1
   x4 = 64 >> returns6_99()        -- Should use first return value (6) as shift count
   assert(x4 is rshift_cmp, 'rshift multi-return RHS failed: ' .. x4 .. ' vs ' .. rshift_cmp)
end

@Test function MultipleReturnRHS()
   cmp = bit.band(1, 6)
   x = 1 & 6
   assert(x is cmp, 'band literal failed: ' .. x .. ' vs ' .. cmp)

   x2 = 1 & returns6_99()
   assert(x2 is cmp, 'band multi-return failed: ' .. x2 .. ' vs ' .. cmp)

   x = 1 | returns6_99()
   assert(x is bit.bor(1, 6), '| must use first return value')

   x = 1 ~ 6
   x2 = 1 ~ returns6_99()
   cmp = bit.bxor(1, 6)
   assert(x is cmp, 'bxor failed: ' .. x .. ' vs ' .. cmp)
   assert(x2 is cmp, 'bxor failed: ' .. x2 .. ' vs ' .. cmp)
end

@Test function ByteStringKeysWithBitwise()
   o = { a = 1, [5] = 2 }
   o['a'] = o['a'] | 2
   assert(o.a is 3, 'string key | should work')
   o[5] = o[5] & 3
   assert(o[5] is 2, 'byte/numeric key & should work')
end

@Test function BitwiseInParameters()
   -- Intentionally global variables
   P1 = 0x1
   P2 = 0x2
   P4 = 0x4

   call = function(A, Func)
      assert(A is 7, 'Bitwise OR in parameter failed, got ' .. tostring(A))
      assert(type(Func) is 'function', 'Function parameter not passed correctly, got ' .. type(Func))
   end

   -- Test direct literals
   call(0x1 | 0x2 | 0x4, function() print('A') end)

   -- Test variables
   call(P1 | P2 | P4, function() print('B') end)
end
