-- Flute tests for the catch() function

@BeforeEach(hotpath=true)
function enforce_hotpath() end

----------------------------------------------------------------------------------------------------------------------
-- Check that catch() does nothing if no error is raised.

@Test function testCatchClean()
   err, a, b, c = catch(function()
      i = 1
      return 1, 2, 3, 4
   end,
   function(Exception)
      error(Exception.line .. ": An exception was raised despite doing nothing.")
   end)

   assert(err is ERR_Okay, "Expected the error code to be ERR_Okay")
   assert(a is 1 and b is 2 and c is 3, "Did not receive expected results from the successful function.")

   err, hello, world = catch(function()
      return 'hello', 'world'
   end)

   assert(hello is 'hello' and world is 'world', "Invalid results detected.")
end

----------------------------------------------------------------------------------------------------------------------
-- Check that a standard error() will result in the exception being caught.

@Test function testCatch()
   exception_raised = false

   err = catch(function()
      error("Catch this! (Exception raised on purpose)")
   end,
   function(Exception)
      print(Exception.line .. ": Caught exception '" .. Exception.message .. "'")
      exception_raised = true
   end)

   assert(err is ERR_Exception, "Expected the error code to be ERR_Exception")
   assert(exception_raised, "Failed to catch the raised exception.")
end

----------------------------------------------------------------------------------------------------------------------
-- Check that an ERROR result other than ERR_Okay will result in the generation of an exception.

@Test function testCatchErrorCode()
   exception_raised = false

   err, result = catch(function()
      mSys.AllocMemory(-10, 0)
   end,
   function(Exception)
      print(Exception.line .. ": Caught exception as expected, error code #" .. Exception.code .. " '" .. Exception.message .. "'")
      exception_raised = true
   end)

   assert(result is nil, "The result is not empty.")
   assert(err is ERR_Args, "Expected the error code to be ERR_Args")
   assert(exception_raised is true, "Failed to catch the raised exception.")
end

----------------------------------------------------------------------------------------------------------------------
-- Check that obj.new() raises exceptions correctly.

@Test function testCatchObject()
   exception_raised = false

   err, result = catch(function()
      fl = obj.new("file", { path="File does not exist" })
   end,
   function(Exception)
      print(Exception.line .. ": Caught exception as expected, error code #" .. Exception.code .. " '" .. Exception.message .. "'")
      exception_raised = true
   end)

   assert(exception_raised is true, "Failed to catch the raised exception.")
end

----------------------------------------------------------------------------------------------------------------------
-- Check that object actions raise exceptions correctly.

@Test function testCatchObjectAction()
   exception_raised = false

   err, result = catch(function()
      time = obj.new("time", { })
      time.acUndo()
   end,
   function(Exception)
      print(Exception.line .. ": Caught exception as expected, error code #" .. Exception.code .. " '" .. Exception.message .. "'")
      exception_raised = true
   end)

   assert(exception_raised is true, "Failed to catch the raised exception.")
end

----------------------------------------------------------------------------------------------------------------------
-- Check that errors returned from writing to object fields are caught.

@Test function testSetField()
   exception_raised = false

   err, result = catch(function()
      time = obj.new("time", { })
      time.madeup_field = -1
   end,
   function(Exception)
      print(Exception.line .. ": Caught exception as expected, error code #" .. Exception.code .. " '" .. Exception.message .. "'")
      exception_raised = true
   end)

   assert(exception_raised is true, "Failed to catch the raised exception.")
end

----------------------------------------------------------------------------------------------------------------------
-- Test that filtering for error codes works.

@Test function testCatchFilter()
   catch(function()
      catch(function()
         pic, err = obj.new("xml", { src="nowhere:nofile.xml" })
         print("Received error " .. err)
      end,
      { ERR_CreateObject, ERR_Init, ERR_File },
      function(Exception)
         print(Exception.line .. ": Caught filtered exception #" .. Exception.code)
      end)
   end,
   function(Exception) -- This will be triggered if the filter doesn't catch the specified error codes.
      error("Failed to filter for the expected error code, received code " .. Exception.code)
   end)
end

----------------------------------------------------------------------------------------------------------------------
-- Test that unfiltered errors are thrown to the parent block.

@Test function testMissedFilter()
   status, msg = pcall(function()
      catch(function()
         xml = obj.new("xml", { flags="NEW" })
         xml.acDraw()
         print("This must not be reached.")
      end,
      { ERR_Failed }, -- Filter for the wrong error code.
      function(Exception)
         -- Do nothing
      end)
   end)

   if (status is false) then
      -- Exception has been thrown to the parent as expected
   else
      error("The exception was not thrown to the parent block.")
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Test simple catch() with no function defined to handle the exception.

@Test function testNoThrow()
   ex, result = catch(function()
      error("Catch this! (Exception raised on purpose)")
   end)

   assert(ex, "Exception table was not returned.")
   print("Received line " .. ex.line .. ", code " .. (ex.code ?? "LUA") .. ", msg: " .. ex.message)
end

----------------------------------------------------------------------------------------------------------------------
-- This test exercises deep nesting of exception handlers to reliably trigger frame chain issues

@Test function testDeepNesting1()
   result = {}

   catch(function()
      catch(function()
         catch(function()
            catch(function()
               error("Deeply nested error")
            end,
            { ERR_Failed },  -- Wrong filter
            function(Exception)
               table.insert(result, "level4")
            end)
         end,
         { ERR_Failed },  -- Wrong filter
         function(Exception)
            table.insert(result, "level3")
         end)
      end,
      { ERR_Failed },  -- Wrong filter
      function(Exception)
         table.insert(result, "level2")
      end)
   end,
   { ERR_Exception },  -- Correct filter
   function(Exception)
      table.insert(result, "level1")
   end)

   assert(#result is 1 and result[0] is "level1", "Deep nesting filter failed")
end

----------------------------------------------------------------------------------------------------------------------

@Test function testCrossLuaC1()
   result = {}

   catch(function()
      catch(function()
         xml = obj.new("xml", { flags="NEW" })
         xml.acDraw()  -- Raises error from C
      end,
      { ERR_Failed },  -- Wrong filter
      function(Exception)
         print('Caught in inner filter')
         table.insert(result, "inner")
      end)
   end,
   { ERR_NoAction },  -- Correct filter
   function(Exception)
      print('Caught in outer filter')
      table.insert(result, "outer")
   end)

   assert(#result is 1 and result[0] is "outer", "Lua-C cross boundary exception failed")
end

----------------------------------------------------------------------------------------------------------------------

@Test function testMultipleFilterLevels()
   result = {}

   catch(function()
      catch(function()
         catch(function()
            xml = obj.new("xml", { flags="NEW" })
            xml.acDraw()  -- Raises from C
         end,
         { ERR_Failed },  -- Wrong
         function(Exception)
            table.insert(result, "inner")
         end)
      end,
      { ERR_Init },  -- Also wrong
      function(Exception)
         table.insert(result, "middle")
      end)
   end,
   { ERR_NoAction },  -- Correct
   function(Exception)
      table.insert(result, "outer")
   end)

   assert(#result is 1 and result[0] is "outer", "Multi-filter exception failed")
end

----------------------------------------------------------------------------------------------------------------------

@Test function testMixedLuaErrors()
   result = {}

   catch(function()
      catch(function()
         catch(function()
            error("Lua error 1")
         end,
         { ERR_Failed },
         function(Exception)
            table.insert(result, "level3")
         end)

         error("Lua error 2")
      end,
      { ERR_Failed },
      function(Exception)
         table.insert(result, "level2")
      end)

      error("Lua error 3")
   end,
   { ERR_Exception },
   function(Exception)
      table.insert(result, "level1")
   end)

   assert(#result is 1 and result[0] is "level1", "Mixed Lua errors failed")
end

----------------------------------------------------------------------------------------------------------------------

@Test function testFilterChaining()
   -- Test the specific pattern from testMissedFilter
   status, msg = pcall(function()
      catch(function()
         xml = obj.new("xml", { flags="NEW" })
         xml.acDraw()
      end,
      { ERR_Failed },  -- Filter for the wrong error code
      function(Exception)
         -- Do nothing
      end)
   end)

   assert(status is false, "Filter chaining test failed - exception should propagate")
end

----------------------------------------------------------------------------------------------------------------------

@Test function testObjectMethodErrors()
   result = {}

   catch(function()
      catch(function()
         time = obj.new("time", {})
         time.acUndo()  -- Unsupported action
      end,
      { ERR_Failed },
      function(Exception)
         table.insert(result, "wrong")
      end)
   end,
   { ERR_NoAction },
   function(Exception)
      table.insert(result, "correct")
   end)

   assert(#result is 1 and result[0] is "correct", "Object method error failed")
end

----------------------------------------------------------------------------------------------------------------------

@Test function testChainedObjectCalls()
   result = {}

   catch(function()
      catch(function()
         catch(function()
            time1 = obj.new("time", {})
            time1.acUndo()
         end,
         { ERR_Failed },
         function(Exception)
            table.insert(result, "level3")
         end)

         time2 = obj.new("time", {})
         time2.acUndo()
      end,
      { ERR_Failed },
      function(Exception)
         table.insert(result, "level2")
      end)
   end,
   { ERR_NoAction },
   function(Exception)
      table.insert(result, "level1")
   end)

   assert(#result is 1 and result[0] is "level1", "Chained object calls failed")
end

----------------------------------------------------------------------------------------------------------------------
-- Test scope isolation: nested function calls within catch() should NOT throw exceptions.
-- The catch() behavior should only apply to DIRECT calls within the catch block, not to
-- functions called from within those functions.

@Test function testScopeIsolation()
   helper_called = false
   helper_error = nil

   -- Helper function that returns an error code normally
   function helper()
      helper_called = true
      -- This should return error normally, NOT throw, because we're in a nested call
      helper_error = mSys.AllocMemory(-10, 0)  -- Returns ERR::Args
      return helper_error
   end

   exception_from_helper = false
   exception_from_direct = false

   ex = catch(function()
      -- Call helper - this should NOT throw even though it returns an error
      result = helper()
      -- This direct call SHOULD throw
      mSys.AllocMemory(-10, 0)
   end,
   function(Exception)
      -- We should only get here from the direct call, not from helper()
      if helper_error != nil then
         exception_from_direct = true
      else
         exception_from_helper = true
      end
   end)

   assert(helper_called, "Helper function should have been called")
   assert(helper_error is ERR_Args, "Helper should have returned ERR_Args, got: " .. tostring(helper_error))
   assert(exception_from_direct, "Exception should have been raised from direct call")
   assert(not exception_from_helper, "Exception should NOT have been raised from helper()")
end

----------------------------------------------------------------------------------------------------------------------
-- Test that object method errors in nested functions don't throw

@Test function testScopeIsolationObjectMethod()
   helper_result = nil

   function helper_with_action()
      time = obj.new("time", {})
      helper_result = time.acUndo()  -- Returns ERR::NoAction
      return helper_result
   end

   direct_exception = false

   ex = catch(function()
      -- Call helper - should NOT throw
      err = helper_with_action()
      -- Direct call - SHOULD throw
      time = obj.new("time", {})
      time.acUndo()
   end,
   function(Exception)
      if helper_result != nil then
         direct_exception = true
      end
   end)

   assert(helper_result is ERR_NoAction, "Helper should have returned ERR_NoAction, got: " .. tostring(helper_result))
   assert(direct_exception, "Exception should have been raised from direct action call")
end

----------------------------------------------------------------------------------------------------------------------
-- Test multiple levels of nested function calls

@Test function testDeepNestedFunctions()
   level1_called = false
   level2_called = false
   level3_error = nil

   function level3()
      level3_error = mSys.AllocMemory(-10, 0)  -- Should NOT throw
      return level3_error
   end

   function level2()
      level2_called = true
      return level3()
   end

   function level1()
      level1_called = true
      return level2()
   end

   direct_threw = false

   ex = catch(function()
      result = level1()  -- Deep nesting - should NOT throw
      mSys.AllocMemory(-10, 0)  -- Direct call - SHOULD throw
   end,
   function(Exception)
      direct_threw = true
   end)

   assert(level1_called, "level1 should have been called")
   assert(level2_called, "level2 should have been called")
   assert(level3_error is ERR_Args, "level3 should have returned ERR_Args")
   assert(direct_threw, "Direct call should have thrown")
end
