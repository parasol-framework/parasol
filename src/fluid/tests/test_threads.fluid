-- Test the use of action threading (asynchronous callbacks) by loading multiple pictures simultaneously.
--
-- The  testParallel() function executes the threads and then waits for them to complete by calling proc.sleep()
-- until picLoaded() sends a signal().

   require 'io/filesearch'

   proc = processing.new(5.0)
   glPicsProcessed = 0
   glPictures = { }
   mGfx ?= mod.load('display') -- Required for the 'icons:' volume

@BeforeAll function init()

   folder = 'icons:programs/'
   list = ''
   print('Scanning "' .. folder .. '" for SVGs')
   file.search(folder, {
      nameFilter = '.+%.svg',
      nameWild   = 'lua',
      matchFeedback = function(Path, FileName, File)
         list ..= FileName .. ' '
         table.insert(glPictures, { path=Path .. FileName })
      end
   })

   print('Found ' .. #glPictures .. ' SVG files: ' .. list)

   if #glPictures is 0 then error('Failed to find any SVG files.') end
end

function initPictures()
   for k, v in ipairs(glPictures) do
      v.pic = obj.new('picture', { path=v.path, flags='QUERY' } )
   end
end

function freePictures()
   for k, v in ipairs(glPictures) do
      if v.pic != nil then
         v.pic = nil
      end
   end
end

-----------------------------------------------------------------------------------------------------------------------
-- This callback function is called every time that a thread completes its Activate() action.

function picProcessed(ActionID, pic, Error, Key)
   if nz(Error) then
      print('Failed to load picture, error: ' .. mSys.GetErrorMsg(Error))
   end

   glPicsProcessed++

   if glPicsProcessed >= #glPictures then
      --print('All pictures have been processed, exiting now.')
      proc.signal()
   end
end

-----------------------------------------------------------------------------------------------------------------------

@Test function testParallel()
   initPictures()

   glPicsProcessed = 0
   count = 0

   for k, v in ipairs(glPictures) do
      if v.pic then
         thread.action(v.pic, 'Activate', picProcessed, k)
         count++
      end
   end

   -- Wait for threads to complete

   if count > 0 then
      err = proc.sleep()
   end

   freePictures()
end

-----------------------------------------------------------------------------------------------------------------------
-- This is the control test for demonstrating how fast parallel execution can actually be versus sequential execution.

@Test function testSequential()
   initPictures()

   for k, v in ipairs(glPictures) do
      if v.pic != nil then
         v.pic.acActivate()
      end
   end

   freePictures()
end

-----------------------------------------------------------------------------------------------------------------------
-- Create two dummy objects and use them to confirm that the signalling of multiple objects works.

@Test function testMultipleSignals()
   signal_a = obj.new('xml', { flags='NEW' })
   signal_b = obj.new('xml', { flags='NEW' })

   for i=1,2 do -- Run enough times to sufficiently test thread locking
      msg('Iteration ' .. i)
      -- Because the thread code is parsed as a string it won't see variables outside of its scope
      thread.script([[
         msg('Thread is now in session.')
      ]],
      function()
         msg('Thread has been executed.')
         signal_a.acSignal()
         signal_b.acSignal()
      end)

      proc = processing.new({ timeout=1.0, signals = { signal_a, signal_b } })
      msg('Sleeping....')
      err = proc.sleep()
      assert(err is ERR_Okay, "Unexpected error: " .. mSys.GetErrorMsg(err))
   end
end
