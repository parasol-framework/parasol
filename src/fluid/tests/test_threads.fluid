-- Test the use of action threading (asynchronous callbacks) by loading multiple pictures simultaneously.
--
-- The  testParallel() function executes the threads and then waits for them to complete by calling proc.sleep()
-- until picLoaded() sends a signal().

   import 'io/filesearch'

   proc = processing.new(5.0)
   glPicsProcessed = 0
   glPictures = { }

@BeforeAll function init()
   mGfx ?? return

   folder = 'icons:programs/'
   list = ''
   print(f'Scanning "{folder}" for SVGs')
   file.search(folder, {
      nameFilter = regex.new('.+\\.svg'),
      matchFeedback = function(Path:str, FileName:str, File)
         list ..= FileName .. ' '
         table.insert(glPictures, { path=Path .. FileName })
      end
   })

   print(f'Found {#glPictures} SVG files: {list}')

   assert(#glPictures > 0, 'Failed to find any SVG files.')
end

function initPictures()
   for v in values(glPictures) do
      v.pic = obj.new('picture', { path=v.path, flags=PCF_QUERY } )
   end
end

function freePictures()
   for v in values(glPictures) do
      if v.pic then v.pic = nil end
   end
end

-----------------------------------------------------------------------------------------------------------------------
-- This callback function is called every time that a thread completes its Activate() action.

function picProcessed(ActionID, pic, Error, Key)
   if Error != ERR_Okay then
      print('Failed to load picture, error: ' .. mSys.GetErrorMsg(Error))
   end

   glPicsProcessed++

   if glPicsProcessed >= #glPictures then
      --print('All pictures have been processed, exiting now.')
      proc.signal()
   end
end

-----------------------------------------------------------------------------------------------------------------------

@Test(priority=1); @Requires(display=true) function Parallel()
   initPictures()

   glPicsProcessed = 0
   count = 0

   for k, v in ipairs(glPictures) do
      if v.pic then
         thread.action(v.pic, 'Activate', picProcessed, k)
         count++
      end
   end

   -- Wait for threads to complete

   if count > 0 then
      err = proc.sleep()
   end

   freePictures()
end

-----------------------------------------------------------------------------------------------------------------------
-- This is the control test for demonstrating how fast parallel execution can actually be versus sequential execution.

@Test(priority=2); @Requires(display=true) function Sequential()
   initPictures()

   for v in values(glPictures) do
      v.pic?.acActivate()
   end

   freePictures()
end

-----------------------------------------------------------------------------------------------------------------------
-- Create two dummy objects and use them to confirm that the signalling of multiple objects works.

@Test(priority=3) function MultipleSignals()
   signal_a = obj.new('xml', { flags=XMF_NEW })
   signal_b = obj.new('xml', { flags=XMF_NEW })

   for i=1,2 do -- Run enough times to sufficiently test thread locking
      msg('Iteration ' .. i)
      -- Because the thread code is parsed as a string it won't see variables outside of its scope
      thread.script([[
         msg('Thread is now in session.')
      ]],
      function()
         msg('Thread has been executed.')
         signal_a.acSignal()
         signal_b.acSignal()
      end)

      try
         proc = processing.new({ timeout=1.0, signals = { signal_a, signal_b } })
         msg('Sleeping....')
         err = proc.sleep()
         assert(err is ERR_Okay, "Unexpected error: " .. mSys.GetErrorMsg(err))
      except e
         error('Error during MultipleSignals test: ' .. e.message)
      end
   end
end
