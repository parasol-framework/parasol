-- Flute tests for thunk functions

@BeforeEach(hotpath=true)
function enforce_hotpath() end

@Test function testThunkBasicExecution()
   -- Thunk body should not execute on call
   executed = false

   thunk lazy_value():str
      executed = true
      return "hello"
   end

   value = lazy_value()
   assert(executed is false, "Thunk body should not execute on call, but executed was " .. tostring(executed))

   -- Accessing value should execute body - now direct comparison works transparently
   assert(value is "hello", "Thunk should return 'hello'")
   assert(executed is true, "Thunk body should execute on access")
end

----------------------------------------------------------------------------------------------------------------------

@Test function testGlobalThunkVar()
   thunk get_str():str
      return 'hello'
   end

   global_var_a = get_str() -- Does resolution work with global variables?
   x = type(global_var_a)
   -- Direct comparison with string constant now works transparently
   assert(global_var_a is 'hello', 'Expected hello')
end

----------------------------------------------------------------------------------------------------------------------

@Test function testThunkParameterCapture()
   -- Thunk with parameters - capture at call time
   call_count = 0

   thunk capture_test(x, y):num
      call_count++
      return x + y
   end

   a = 10
   b = 20
   thunk_result = capture_test(a, b)

   -- Modify original variables
   a = 100
   b = 200

   -- Access the thunk result - must resolve explicitly for arithmetic
   thunk_result = resolve(thunk_result)
   final_result = thunk_result + 0
   assert(final_result is 30, "Should use captured values (10 + 20 = 30), got " .. final_result)
   assert(call_count is 1, "Body should execute exactly once, but call_count is " .. call_count)

   -- Access again - already resolved, should not re-execute
   result2 = thunk_result + 0
   assert(call_count is 1, "Body should not re-execute, but call_count is " .. call_count)
end

----------------------------------------------------------------------------------------------------------------------

@Test function testLocalThunk()
   exec_local = false

   thunk local_lazy():str
      exec_local = true
      return "local"
   end

   local_val = local_lazy()
   assert(exec_local is false, "Local thunk should not execute on call")

   -- Direct comparison now works transparently
   assert(local_val is "local", "Local thunk should return 'local'")
   assert(exec_local is true, "Local thunk should execute on access")
end

----------------------------------------------------------------------------------------------------------------------

@Test function testAnonymousThunk()
   executed = false

   -- Anonymous thunk assigned to variable
   lazy_fn = thunk(x):num
      executed = true
      return x * 2
   end

   result = lazy_fn(21)
   assert(executed is false, "Anonymous thunk should not execute on call")

   result = resolve(result)  -- Explicit resolution required for arithmetic
   resolved = result + 0
   assert(executed is true, "Anonymous thunk should execute on access")
   assert(resolved is 42, "Anonymous thunk should return 42, got " .. resolved)
end

----------------------------------------------------------------------------------------------------------------------

@Test function testAnonymousThunkNoParams()
   counter = 0

   -- Parameterless anonymous thunks are auto-invoked, returning thunk userdata directly
   lazy = thunk():num
      counter++
      return 100
   end

   assert(counter is 0, "Anonymous thunk should not execute on assignment")
   assert(isthunk(lazy), "lazy should be a thunk userdata")

   -- Accessing the thunk triggers resolution
   result = lazy + 0
   assert(counter is 1, "Anonymous thunk should execute once on access")
   assert(result is 100, "Should return 100, got " .. result)

   -- Subsequent access uses cached value
   result2 = lazy + 0
   assert(counter is 1, "Anonymous thunk should not execute again")
   assert(result2 is 100, "Cached value should be 100")
end

----------------------------------------------------------------------------------------------------------------------

@Test function testThunkReturnTypes()
   -- Test explicit return type annotation
   thunk get_string():str
      return "typed"
   end

   thunk get_number():num
      return 42
   end

   thunk get_table():table
      return { key = "value" }
   end

   s = get_string()
   n = get_number()
   t = get_table()

   -- type() should return the declared type without execution
   assert(type(s) is "string", "type() should return 'string' for :str thunk, got " .. type(s))
   assert(type(n) is "number", "type() should return 'number' for :num thunk, got " .. type(n))
   assert(type(t) is "table", "type() should return 'table' for :table thunk, got " .. type(t))

   -- Verify actual values - direct comparison now works transparently
   assert(s is "typed", "String thunk should return 'typed'")
   assert(n is 42, "Number thunk should return 42")
   assert(t.key is "value", "Table thunk should have key='value'")
end

----------------------------------------------------------------------------------------------------------------------

@Test function testThunkControlFlow()
   -- Test thunk with if/else control flow
   thunk conditional(x):num
      if x > 0 then
         return x * 2
      elseif x < 0 then
         return x * -1
      else
         return 0
      end
   end

   pos = conditional(5)
   neg = conditional(-3)
   zero = conditional(0)

   -- Direct number comparison now works transparently
   assert(pos is 10, "Positive path: 5 * 2 = 10")
   assert(neg is 3, "Negative path: -3 * -1 = 3")
   assert(zero is 0, "Zero path should return 0")
end

----------------------------------------------------------------------------------------------------------------------

@Test function testThunkWithLoop()
   -- Test thunk containing a loop
   thunk sum_to(n):num
      total = 0
      for i = 1, n do
         total += i
      end
      return total
   end

   result = sum_to(5)
   assert(result is 15, "sum_to(5) should be 15")
end

----------------------------------------------------------------------------------------------------------------------

@Test function testThunkUpvalueCapture()
   -- Test that thunks properly capture upvalues
   multiplier = 10

   thunk multiply(x):num
      return x * multiplier
   end

   result = multiply(5)

   -- Change multiplier after thunk creation
   multiplier = 100

   -- Thunk should use the captured value at call time (10), not current (100)
   -- Note: This tests parameter capture, but upvalues are captured by reference
   -- so the result depends on when resolution happens
   resolved = result + 0
   assert(resolved is 50 or resolved is 500, "Result should be 50 or 500 depending on capture semantics")
end

----------------------------------------------------------------------------------------------------------------------

@Test function testThunkDefaultReturnType()
   -- Thunk without return type defaults to 'any'
   thunk untyped_thunk()
      return "default"
   end

   val = untyped_thunk()
   -- Direct comparison now works transparently
   assert(val is "default", "Untyped thunk should work")
end

----------------------------------------------------------------------------------------------------------------------

@Test function testThunkWithTableAccess()
   -- Test thunk result used for table access (tests lj_meta_tget resolution)
   thunk get_config():table
      return { name = "test", value = 42 }
   end

   config = get_config()
   assert(config.name is "test", "Should access table field 'name'")
   assert(config.value is 42, "Should access table field 'value'")
end

----------------------------------------------------------------------------------------------------------------------

@Test function testRecursiveThunk()
   -- Test recursive thunk (each call creates new thunk)
   thunk factorial(n):num
      if n <= 1 then
         return 1
      end
      sub = factorial(n - 1)
      return n * (sub + 0)
   end

   result = factorial(5)
   assert(result is 120, "factorial(5) should be 120")
end

----------------------------------------------------------------------------------------------------------------------

@Test function testMultipleThunkResolutions()
   -- Test that multiple thunks can be resolved independently
   count_a, count_b = 0, 0

   thunk thunk_a():num
      count_a++
      return 10
   end

   thunk thunk_b():num
      count_b++
      return 20
   end

   a = thunk_a()
   b = thunk_b()

   assert(count_a is 0 and count_b is 0, "Neither thunk should execute yet")

   sum = (a + 0) + (b + 0)
   assert(count_a is 1, "thunk_a should execute once")
   assert(count_b is 1, "thunk_b should execute once")
   assert(sum is 30, "Sum should be 30, got " .. sum)
end

----------------------------------------------------------------------------------------------------------------------

@Test function testThunkArithmeticOperators()
   -- Test all arithmetic metamethods
   thunk get_ten():num return 10 end
   thunk get_three():num return 3 end

   a = get_ten()
   b = get_three()

   -- Subtraction
   assert(a - b is 7, "10 - 3 should be 7")

   -- Multiplication
   assert(a * b is 30, "10 * 3 should be 30")

   -- Division
   assert(a / b > 3.3 and a / b < 3.4, "10 / 3 should be ~3.33")

   -- Modulo
   assert(a % b is 1, "10 % 3 should be 1")

   -- Power
   assert(b ^ 2 is 9, "3 ^ 2 should be 9")

   -- Unary minus
   assert(-a is -10, "-10 should be -10")
end

----------------------------------------------------------------------------------------------------------------------

@Test function testThunkConcatenation()
   -- Test string concatenation metamethod
   thunk get_hello():str return "Hello" end
   thunk get_world():str return "World" end

   a = get_hello()
   b = get_world()

   result = a .. " " .. b
   assert(result is "Hello World", "Concatenation should produce 'Hello World', got '" .. result .. "'")
end

----------------------------------------------------------------------------------------------------------------------

@Test function testThunkComparison()
   -- Test comparison metamethods (thunk vs thunk)
   thunk cmp_get_five():num return 5 end
   thunk cmp_get_ten():num return 10 end
   thunk cmp_get_five_again():num return 5 end

   a = cmp_get_five()
   b = cmp_get_ten()
   c = cmp_get_five_again()

   -- Less than
   assert(a < b, "5 should be < 10")
   assert(not (b < a), "10 should not be < 5")

   -- Less than or equal
   assert(a <= b, "5 should be <= 10")
   assert(a <= c, "5 should be <= 5")

   -- Equality (thunk vs thunk - both must be thunks for __eq to trigger)
   assert(a is c, "Two thunks returning 5 should be equal") -- Note: This only works if both are thunks
end

----------------------------------------------------------------------------------------------------------------------

@Test function testThunkNewindex()
   -- Test table field assignment through thunk
   thunk newindex_get_table():table return { x = 1 } end

   t = newindex_get_table()
   t.y = 2  -- __newindex should resolve and assign

   assert(t.x is 1, "Original field should be accessible")
   assert(t.y is 2, "New field should be assigned")
end

----------------------------------------------------------------------------------------------------------------------

@Test function testThunkLength()
   -- Test length operator
   thunk len_get_array():table return {1, 2, 3, 4, 5} end
   thunk len_get_string():str return "hello" end

   arr = len_get_array()
   str = len_get_string()

   assert(#arr is 5, "Array length should be 5, got " .. #arr)
   assert(#str is 5, "String length should be 5, got " .. #str)
end

----------------------------------------------------------------------------------------------------------------------

@Test function testThunkCall()
   -- Test calling a thunk that resolves to a function
   -- Note: Direct call thunk(args) doesn't propagate return values correctly
   -- Use resolve() to get the function, then call it
   thunk get_adder():func
      return function(x, y) return x + y end
   end

   adder = get_adder()
   fn = resolve(adder)
   result = fn(3, 4)

   assert(result is 7, "Calling resolved function should return 7, got " .. tostring(result))
end

----------------------------------------------------------------------------------------------------------------------

@Test function testIsthunkFunction()
   -- Test the isthunk() helper function
   thunk get_value():num return 42 end

   thunk_val = get_value()
   regular_val = 42
   regular_str = "hello"
   regular_table = {}

   assert(isthunk(thunk_val) is true, "isthunk should return true for thunk")
   assert(isthunk(regular_val) is false, "isthunk should return false for number")
   assert(isthunk(regular_str) is false, "isthunk should return false for string")
   assert(isthunk(regular_table) is false, "isthunk should return false for table")
   assert(isthunk(nil) is false, "isthunk should return false for nil")
end

----------------------------------------------------------------------------------------------------------------------

@Test function testThunkGCSurvival()
   -- Test that thunks and their resolved values survive garbage collection
   thunk get_data():table return { value = "persistent" } end

   t = get_data()

   -- Force resolution
   val = t.value
   assert(val is "persistent", "Value should be 'persistent' before GC")

   -- Force multiple GC cycles
   collectgarbage()
   collectgarbage()
   collectgarbage()

   -- Access again after GC
   val_after = t.value
   assert(val_after is "persistent", "Value should still be 'persistent' after GC")
end

----------------------------------------------------------------------------------------------------------------------

@Test function testThunkBoolReturnType()
   -- Test boolean return type
   thunk is_positive(x):bool
      return x > 0
   end

   result_true = is_positive(5)
   result_false = is_positive(-5)

   assert(type(result_true) is "boolean", "type() should return 'boolean' for :bool thunk")
   assert(type(result_false) is "boolean", "type() should return 'boolean' for :bool thunk")

   -- Note: Thunks are always truthy in conditionals (userdata are truthy)
   -- Must use resolve() or tostring() to get the actual boolean value
   resolved_true = resolve(result_true)
   resolved_false = resolve(result_false)

   assert(resolved_true is true, "is_positive(5) should resolve to true")
   assert(resolved_false is false, "is_positive(-5) should resolve to false")
end

----------------------------------------------------------------------------------------------------------------------

@Test function testThunkWithNilReturn()
   -- Test thunk that returns nil (uses default/any type since :nil isn't a valid annotation)
   thunk get_nil()
      return nil
   end

   val = get_nil()
   -- Direct comparison with nil now works transparently
   assert(val is nil, "Thunk returning nil should compare equal to nil")
end

----------------------------------------------------------------------------------------------------------------------

@Test function testThunkCachingBehavior()
   -- Verify that thunks cache their result and don't re-execute
   exec_count = 0

   thunk cached_value():num
      exec_count++
      return 42
   end

   t = cached_value()

   -- Multiple accesses should only execute once
   r1 = t + 0
   r2 = t + 0
   r3 = t + 0
   r4 = tostring(t)
   r5 = t * 2

   assert(exec_count is 1, "Thunk body should execute exactly once, but executed " .. exec_count .. " times")
   assert(r1 is 42, "First access should return 42")
   assert(r2 is 42, "Second access should return 42")
   assert(r5 is 84, "Multiplication should work with cached value")
end
