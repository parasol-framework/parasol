-- Flute tests for thunk functions

function testThunkBasicExecution()
   -- Thunk body should not execute on call
   local executed = false

   thunk lazy_value():str
      executed = true
      return "hello"
   end

   local value = lazy_value()
   assert(executed is false, "Thunk body should not execute on call, but executed was " .. tostring(executed))

   -- Accessing value should execute body
   local result = tostring(value)
   assert(executed is true, "Thunk body should execute on access, but executed was " .. tostring(executed))
   assert(result is "hello", "Thunk should return 'hello', got '" .. result .. "'")
end

----------------------------------------------------------------------------------------------------------------------

function testThunkParameterCapture()
   -- Thunk with parameters - capture at call time
   local call_count = 0

   thunk capture_test(x, y):num
      call_count++
      return x + y
   end

   local a = 10
   local b = 20
   local thunk_result = capture_test(a, b)

   -- Modify original variables
   a = 100
   b = 200

   -- Access the thunk result - must resolve explicitly for arithmetic
   thunk_result = resolve(thunk_result)
   local final_result = thunk_result + 0
   assert(final_result is 30, "Should use captured values (10 + 20 = 30), got " .. final_result)
   assert(call_count is 1, "Body should execute exactly once, but call_count is " .. call_count)

   -- Access again - already resolved, should not re-execute
   local result2 = thunk_result + 0
   assert(call_count is 1, "Body should not re-execute, but call_count is " .. call_count)
end

----------------------------------------------------------------------------------------------------------------------

function testLocalThunk()
   local exec_local = false

   local thunk local_lazy():str
      exec_local = true
      return "local"
   end

   local local_val = local_lazy()
   assert(exec_local is false, "Local thunk should not execute on call")

   local local_result = tostring(local_val)
   assert(exec_local is true, "Local thunk should execute on access, but exec_local is " .. tostring(exec_local))
   assert(local_result is "local", "Local thunk should return 'local', got '" .. local_result .. "'")
end

----------------------------------------------------------------------------------------------------------------------

function testAnonymousThunk()
   local executed = false

   -- Anonymous thunk assigned to variable
   local lazy_fn = thunk(x):num
      executed = true
      return x * 2
   end

   local result = lazy_fn(21)
   assert(executed is false, "Anonymous thunk should not execute on call")

   result = resolve(result)  -- Explicit resolution required for arithmetic
   local resolved = result + 0
   assert(executed is true, "Anonymous thunk should execute on access")
   assert(resolved is 42, "Anonymous thunk should return 42, got " .. resolved)
end

----------------------------------------------------------------------------------------------------------------------

function testAnonymousThunkNoParams()
   local counter = 0

   local lazy = thunk():num
      counter++
      return 100
   end

   local val = lazy()
   assert(counter is 0, "Anonymous thunk (no params) should not execute on call")

   local result = val + 0
   assert(counter is 1, "Anonymous thunk should execute once")
   assert(result is 100, "Should return 100, got " .. result)
end

----------------------------------------------------------------------------------------------------------------------

function testThunkReturnTypes()
   -- Test explicit return type annotation
   thunk get_string():str
      return "typed"
   end

   thunk get_number():num
      return 42
   end

   thunk get_table():table
      return { key = "value" }
   end

   local s = get_string()
   local n = get_number()
   local t = get_table()

   -- type() should return the declared type without execution
   assert(type(s) is "string", "type() should return 'string' for :str thunk")
   assert(type(n) is "number", "type() should return 'number' for :num thunk")
   assert(type(t) is "table", "type() should return 'table' for :table thunk")

   -- Verify actual values after resolution
   assert(tostring(s) is "typed", "String thunk should return 'typed'")
   assert(n + 0 is 42, "Number thunk should return 42")
   assert(t.key is "value", "Table thunk should have key='value'")
end

----------------------------------------------------------------------------------------------------------------------

function testThunkControlFlow()
   -- Test thunk with if/else control flow
   thunk conditional(x):num
      if x > 0 then
         return x * 2
      elseif x < 0 then
         return x * -1
      else
         return 0
      end
   end

   local pos = conditional(5)
   local neg = conditional(-3)
   local zero = conditional(0)

   assert(pos + 0 is 10, "Positive path: 5 * 2 = 10, got " .. (pos + 0))
   assert(neg + 0 is 3, "Negative path: -3 * -1 = 3, got " .. (neg + 0))
   assert(zero + 0 is 0, "Zero path should return 0, got " .. (zero + 0))
end

----------------------------------------------------------------------------------------------------------------------

function testThunkWithLoop()
   -- Test thunk containing a loop
   thunk sum_to(n):num
      local total = 0
      for i = 1, n do
         total += i
      end
      return total
   end

   local result = sum_to(5)
   assert(result + 0 is 15, "sum_to(5) should be 15, got " .. (result + 0))
end

----------------------------------------------------------------------------------------------------------------------

function testThunkUpvalueCapture()
   -- Test that thunks properly capture upvalues
   local multiplier = 10

   thunk multiply(x):num
      return x * multiplier
   end

   local result = multiply(5)

   -- Change multiplier after thunk creation
   multiplier = 100

   -- Thunk should use the captured value at call time (10), not current (100)
   -- Note: This tests parameter capture, but upvalues are captured by reference
   -- so the result depends on when resolution happens
   local resolved = result + 0
   assert(resolved is 50 or resolved is 500, "Result should be 50 or 500 depending on capture semantics")
end

----------------------------------------------------------------------------------------------------------------------

function testThunkDefaultReturnType()
   -- Thunk without return type defaults to 'any'
   thunk untyped_thunk()
      return "default"
   end

   local val = untyped_thunk()
   local result = tostring(val)
   assert(result is "default", "Untyped thunk should work, got '" .. result .. "'")
end

----------------------------------------------------------------------------------------------------------------------

function testThunkWithTableAccess()
   -- Test thunk result used for table access (tests lj_meta_tget resolution)
   thunk get_config():table
      return { name = "test", value = 42 }
   end

   local config = get_config()
   assert(config.name is "test", "Should access table field 'name'")
   assert(config.value is 42, "Should access table field 'value'")
end

----------------------------------------------------------------------------------------------------------------------

function testRecursiveThunk()
   -- Test recursive thunk (each call creates new thunk)
   thunk factorial(n):num
      if n <= 1 then
         return 1
      end
      local sub = factorial(n - 1)
      return n * (sub + 0)
   end

   local result = factorial(5)
   assert(result + 0 is 120, "factorial(5) should be 120, got " .. (result + 0))
end

----------------------------------------------------------------------------------------------------------------------

function testMultipleThunkResolutions()
   -- Test that multiple thunks can be resolved independently
   local count_a, count_b = 0, 0

   thunk thunk_a():num
      count_a++
      return 10
   end

   thunk thunk_b():num
      count_b++
      return 20
   end

   local a = thunk_a()
   local b = thunk_b()

   assert(count_a is 0 and count_b is 0, "Neither thunk should execute yet")

   local sum = (a + 0) + (b + 0)
   assert(count_a is 1, "thunk_a should execute once")
   assert(count_b is 1, "thunk_b should execute once")
   assert(sum is 30, "Sum should be 30, got " .. sum)
end

----------------------------------------------------------------------------------------------------------------------

return {
   tests = {
      'testThunkBasicExecution',
      'testThunkParameterCapture',
      'testLocalThunk',
      'testAnonymousThunk',
      'testAnonymousThunkNoParams',
      'testThunkReturnTypes',
      'testThunkControlFlow',
      'testThunkWithLoop',
      'testThunkUpvalueCapture',
      'testThunkDefaultReturnType',
      'testThunkWithTableAccess',
      'testRecursiveThunk',
      'testMultipleThunkResolutions'
   }
}
