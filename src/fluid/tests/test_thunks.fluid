-- Flute tests for thunk functions

function testThunkBasicExecution()
   -- Thunk body should not execute on call
   local executed = false

   thunk lazy_value():str
      executed = true
      return "hello"
   end

   local value = lazy_value()
   assert(executed is false, "Thunk body should not execute on call, but executed was " .. tostring(executed))

   -- Accessing value should execute body - now direct comparison works transparently
   assert(value is "hello", "Thunk should return 'hello'")
   assert(executed is true, "Thunk body should execute on access")
end

----------------------------------------------------------------------------------------------------------------------

function testGlobalThunkVar()
   thunk get_str():str
      return 'hello'
   end

   global_var_a = get_str() -- Does resolution work with global variables?
   local x = type(global_var_a)
   -- Direct comparison with string constant now works transparently
   assert(global_var_a is 'hello', 'Expected hello')
end

----------------------------------------------------------------------------------------------------------------------

function testThunkParameterCapture()
   -- Thunk with parameters - capture at call time
   local call_count = 0

   thunk capture_test(x, y):num
      call_count++
      return x + y
   end

   local a = 10
   local b = 20
   local thunk_result = capture_test(a, b)

   -- Modify original variables
   a = 100
   b = 200

   -- Access the thunk result - must resolve explicitly for arithmetic
   thunk_result = resolve(thunk_result)
   local final_result = thunk_result + 0
   assert(final_result is 30, "Should use captured values (10 + 20 = 30), got " .. final_result)
   assert(call_count is 1, "Body should execute exactly once, but call_count is " .. call_count)

   -- Access again - already resolved, should not re-execute
   local result2 = thunk_result + 0
   assert(call_count is 1, "Body should not re-execute, but call_count is " .. call_count)
end

----------------------------------------------------------------------------------------------------------------------

function testLocalThunk()
   local exec_local = false

   local thunk local_lazy():str
      exec_local = true
      return "local"
   end

   local local_val = local_lazy()
   assert(exec_local is false, "Local thunk should not execute on call")

   -- Direct comparison now works transparently
   assert(local_val is "local", "Local thunk should return 'local'")
   assert(exec_local is true, "Local thunk should execute on access")
end

----------------------------------------------------------------------------------------------------------------------

function testAnonymousThunk()
   local executed = false

   -- Anonymous thunk assigned to variable
   local lazy_fn = thunk(x):num
      executed = true
      return x * 2
   end

   local result = lazy_fn(21)
   assert(executed is false, "Anonymous thunk should not execute on call")

   result = resolve(result)  -- Explicit resolution required for arithmetic
   local resolved = result + 0
   assert(executed is true, "Anonymous thunk should execute on access")
   assert(resolved is 42, "Anonymous thunk should return 42, got " .. resolved)
end

----------------------------------------------------------------------------------------------------------------------

function testAnonymousThunkNoParams()
   local counter = 0

   local lazy = thunk():num
      counter++
      return 100
   end

   local val = lazy()
   assert(counter is 0, "Anonymous thunk (no params) should not execute on call")

   local result = val + 0
   assert(counter is 1, "Anonymous thunk should execute once")
   assert(result is 100, "Should return 100, got " .. result)
end

----------------------------------------------------------------------------------------------------------------------

function testThunkReturnTypes()
   -- Test explicit return type annotation
   thunk get_string():str
      return "typed"
   end

   thunk get_number():num
      return 42
   end

   thunk get_table():table
      return { key = "value" }
   end

   local s = get_string()
   local n = get_number()
   local t = get_table()

   -- type() should return the declared type without execution
   assert(type(s) is "string", "type() should return 'string' for :str thunk, got " .. type(s))
   assert(type(n) is "number", "type() should return 'number' for :num thunk, got " .. type(n))
   assert(type(t) is "table", "type() should return 'table' for :table thunk, got " .. type(t))

   -- Verify actual values - direct comparison now works transparently
   assert(s is "typed", "String thunk should return 'typed'")
   assert(n is 42, "Number thunk should return 42")
   assert(t.key is "value", "Table thunk should have key='value'")
end

----------------------------------------------------------------------------------------------------------------------

function testThunkControlFlow()
   -- Test thunk with if/else control flow
   thunk conditional(x):num
      if x > 0 then
         return x * 2
      elseif x < 0 then
         return x * -1
      else
         return 0
      end
   end

   local pos = conditional(5)
   local neg = conditional(-3)
   local zero = conditional(0)

   -- Direct number comparison now works transparently
   assert(pos is 10, "Positive path: 5 * 2 = 10")
   assert(neg is 3, "Negative path: -3 * -1 = 3")
   assert(zero is 0, "Zero path should return 0")
end

----------------------------------------------------------------------------------------------------------------------

function testThunkWithLoop()
   -- Test thunk containing a loop
   thunk sum_to(n):num
      local total = 0
      for i = 1, n do
         total += i
      end
      return total
   end

   local result = sum_to(5)
   assert(result is 15, "sum_to(5) should be 15")
end

----------------------------------------------------------------------------------------------------------------------

function testThunkUpvalueCapture()
   -- Test that thunks properly capture upvalues
   local multiplier = 10

   thunk multiply(x):num
      return x * multiplier
   end

   local result = multiply(5)

   -- Change multiplier after thunk creation
   multiplier = 100

   -- Thunk should use the captured value at call time (10), not current (100)
   -- Note: This tests parameter capture, but upvalues are captured by reference
   -- so the result depends on when resolution happens
   local resolved = result + 0
   assert(resolved is 50 or resolved is 500, "Result should be 50 or 500 depending on capture semantics")
end

----------------------------------------------------------------------------------------------------------------------

function testThunkDefaultReturnType()
   -- Thunk without return type defaults to 'any'
   thunk untyped_thunk()
      return "default"
   end

   local val = untyped_thunk()
   -- Direct comparison now works transparently
   assert(val is "default", "Untyped thunk should work")
end

----------------------------------------------------------------------------------------------------------------------

function testThunkWithTableAccess()
   -- Test thunk result used for table access (tests lj_meta_tget resolution)
   thunk get_config():table
      return { name = "test", value = 42 }
   end

   local config = get_config()
   assert(config.name is "test", "Should access table field 'name'")
   assert(config.value is 42, "Should access table field 'value'")
end

----------------------------------------------------------------------------------------------------------------------

function testRecursiveThunk()
   -- Test recursive thunk (each call creates new thunk)
   thunk factorial(n):num
      if n <= 1 then
         return 1
      end
      local sub = factorial(n - 1)
      return n * (sub + 0)
   end

   local result = factorial(5)
   assert(result is 120, "factorial(5) should be 120")
end

----------------------------------------------------------------------------------------------------------------------

function testMultipleThunkResolutions()
   -- Test that multiple thunks can be resolved independently
   local count_a, count_b = 0, 0

   thunk thunk_a():num
      count_a++
      return 10
   end

   thunk thunk_b():num
      count_b++
      return 20
   end

   local a = thunk_a()
   local b = thunk_b()

   assert(count_a is 0 and count_b is 0, "Neither thunk should execute yet")

   local sum = (a + 0) + (b + 0)
   assert(count_a is 1, "thunk_a should execute once")
   assert(count_b is 1, "thunk_b should execute once")
   assert(sum is 30, "Sum should be 30, got " .. sum)
end

----------------------------------------------------------------------------------------------------------------------

function testThunkArithmeticOperators()
   -- Test all arithmetic metamethods
   thunk get_ten():num return 10 end
   thunk get_three():num return 3 end

   local a = get_ten()
   local b = get_three()

   -- Subtraction
   assert(a - b is 7, "10 - 3 should be 7")

   -- Multiplication
   assert(a * b is 30, "10 * 3 should be 30")

   -- Division
   assert(a / b > 3.3 and a / b < 3.4, "10 / 3 should be ~3.33")

   -- Modulo
   assert(a % b is 1, "10 % 3 should be 1")

   -- Power
   assert(b ^ 2 is 9, "3 ^ 2 should be 9")

   -- Unary minus
   assert(-a is -10, "-10 should be -10")
end

----------------------------------------------------------------------------------------------------------------------

function testThunkConcatenation()
   -- Test string concatenation metamethod
   thunk get_hello():str return "Hello" end
   thunk get_world():str return "World" end

   local a = get_hello()
   local b = get_world()

   local result = a .. " " .. b
   assert(result is "Hello World", "Concatenation should produce 'Hello World', got '" .. result .. "'")
end

----------------------------------------------------------------------------------------------------------------------

function testThunkComparison()
   -- Test comparison metamethods (thunk vs thunk)
   thunk cmp_get_five():num return 5 end
   thunk cmp_get_ten():num return 10 end
   thunk cmp_get_five_again():num return 5 end

   local a = cmp_get_five()
   local b = cmp_get_ten()
   local c = cmp_get_five_again()

   -- Less than
   assert(a < b, "5 should be < 10")
   assert(not (b < a), "10 should not be < 5")

   -- Less than or equal
   assert(a <= b, "5 should be <= 10")
   assert(a <= c, "5 should be <= 5")

   -- Equality (thunk vs thunk - both must be thunks for __eq to trigger)
   assert(a is c, "Two thunks returning 5 should be equal") -- Note: This only works if both are thunks
end

----------------------------------------------------------------------------------------------------------------------

function testThunkNewindex()
   -- Test table field assignment through thunk
   thunk newindex_get_table():table return { x = 1 } end

   local t = newindex_get_table()
   t.y = 2  -- __newindex should resolve and assign

   assert(t.x is 1, "Original field should be accessible")
   assert(t.y is 2, "New field should be assigned")
end

----------------------------------------------------------------------------------------------------------------------

function testThunkLength()
   -- Test length operator
   thunk len_get_array():table return {1, 2, 3, 4, 5} end
   thunk len_get_string():str return "hello" end

   local arr = len_get_array()
   local str = len_get_string()

   assert(#arr is 5, "Array length should be 5, got " .. #arr)
   assert(#str is 5, "String length should be 5, got " .. #str)
end

----------------------------------------------------------------------------------------------------------------------

function testThunkCall()
   -- Test calling a thunk that resolves to a function
   -- Note: Direct call thunk(args) doesn't propagate return values correctly
   -- Use resolve() to get the function, then call it
   thunk get_adder():func
      return function(x, y) return x + y end
   end

   local adder = get_adder()
   local fn = resolve(adder)
   local result = fn(3, 4)

   assert(result is 7, "Calling resolved function should return 7, got " .. tostring(result))
end

----------------------------------------------------------------------------------------------------------------------

function testIsthunkFunction()
   -- Test the isthunk() helper function
   thunk get_value():num return 42 end

   local thunk_val = get_value()
   local regular_val = 42
   local regular_str = "hello"
   local regular_table = {}

   assert(isthunk(thunk_val) is true, "isthunk should return true for thunk")
   assert(isthunk(regular_val) is false, "isthunk should return false for number")
   assert(isthunk(regular_str) is false, "isthunk should return false for string")
   assert(isthunk(regular_table) is false, "isthunk should return false for table")
   assert(isthunk(nil) is false, "isthunk should return false for nil")
end

----------------------------------------------------------------------------------------------------------------------

function testThunkGCSurvival()
   -- Test that thunks and their resolved values survive garbage collection
   thunk get_data():table return { value = "persistent" } end

   local t = get_data()

   -- Force resolution
   local val = t.value
   assert(val is "persistent", "Value should be 'persistent' before GC")

   -- Force multiple GC cycles
   collectgarbage()
   collectgarbage()
   collectgarbage()

   -- Access again after GC
   local val_after = t.value
   assert(val_after is "persistent", "Value should still be 'persistent' after GC")
end

----------------------------------------------------------------------------------------------------------------------

function testThunkBoolReturnType()
   -- Test boolean return type
   thunk is_positive(x):bool
      return x > 0
   end

   local result_true = is_positive(5)
   local result_false = is_positive(-5)

   assert(type(result_true) is "boolean", "type() should return 'boolean' for :bool thunk")
   assert(type(result_false) is "boolean", "type() should return 'boolean' for :bool thunk")

   -- Note: Thunks are always truthy in conditionals (userdata are truthy)
   -- Must use resolve() or tostring() to get the actual boolean value
   local resolved_true = resolve(result_true)
   local resolved_false = resolve(result_false)

   assert(resolved_true is true, "is_positive(5) should resolve to true")
   assert(resolved_false is false, "is_positive(-5) should resolve to false")
end

----------------------------------------------------------------------------------------------------------------------

function testThunkWithNilReturn()
   -- Test thunk that returns nil (uses default/any type since :nil isn't a valid annotation)
   thunk get_nil()
      return nil
   end

   local val = get_nil()
   -- Direct comparison with nil now works transparently
   assert(val is nil, "Thunk returning nil should compare equal to nil")
end

----------------------------------------------------------------------------------------------------------------------

function testThunkCachingBehavior()
   -- Verify that thunks cache their result and don't re-execute
   local exec_count = 0

   thunk cached_value():num
      exec_count++
      return 42
   end

   local t = cached_value()

   -- Multiple accesses should only execute once
   local r1 = t + 0
   local r2 = t + 0
   local r3 = t + 0
   local r4 = tostring(t)
   local r5 = t * 2

   assert(exec_count is 1, "Thunk body should execute exactly once, but executed " .. exec_count .. " times")
   assert(r1 is 42, "First access should return 42")
   assert(r2 is 42, "Second access should return 42")
   assert(r5 is 84, "Multiplication should work with cached value")
end

----------------------------------------------------------------------------------------------------------------------

return {
   tests = {
      'testThunkBasicExecution',
      'testGlobalThunkVar',
      'testThunkParameterCapture',
      'testLocalThunk',
      'testAnonymousThunk',
      'testAnonymousThunkNoParams',
      'testThunkReturnTypes',
      'testThunkControlFlow',
      'testThunkWithLoop',
      'testThunkUpvalueCapture',
      'testThunkDefaultReturnType',
      'testThunkWithTableAccess',
      'testRecursiveThunk',
      'testMultipleThunkResolutions',
      'testThunkArithmeticOperators',
      'testThunkConcatenation',
      'testThunkComparison',
      'testThunkNewindex',
      'testThunkLength',
      'testThunkCall',
      'testIsthunkFunction',
      'testThunkGCSurvival',
      'testThunkBoolReturnType',
      'testThunkWithNilReturn',
      'testThunkCachingBehavior'
   }
}
