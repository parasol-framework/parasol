-- Flute tests for the compound operators

@Test function testCompoundAssignment()
   value = 5
   value += 3
   assert(value is 8, 'value += 3 should add to value')
   value -= 2
   assert(value is 6, 'value -= 2 should subtract from value')
   value *= 4
   assert(value is 24, 'value *= 4 should multiply value')
   value /= 3
   assert(value is 8, 'value /= 3 should divide value')
   value %= 3
   assert(value is 2, 'value %= 3 should keep remainder')

   text = 'hello'
   text ..= ' world'
   assert(text is 'hello world', 'text ..= should concatenate strings')

   store = { count = 10, list = { 3, 5, 7 } }
   store.count -= 4
   assert(store.count is 6, 'table field compound assignments should store results')
   store.list[1] *= 2
   assert(store.list[1] is 10, 'indexed table compound assignments should store results')
end

@Test function testIfEmptyAssignment()
   count = 5
   count ?= 1
   assert(count is 5, 'count ?= should leave truthy values unchanged')

   local missing
   missing ?= 42
   assert(missing is 42, 'nil LHS should receive the default value')

   zero = 0
   zero ?= 7
   assert(zero is 7, 'zero should trigger ?= assignment')

   empty = ''
   empty ?= 'fallback'
   assert(empty is 'fallback', 'empty string should trigger ?= assignment')

   store = { retries = 0, label = 'ready', slots = { '' } }
   store.retries ?= 3
   assert(store.retries is 3, 'table field ?= should assign when falsey')

   store.label ?= 'idle'
   assert(store.label is 'ready', 'table field ?= should skip when truthy')

   store.slots[1] ?= 'filled'
   assert(store.slots[1] is 'filled', 'indexed ?= should assign when entry is falsey')

   store.slots[1] ?= 'ignored'
   assert(store.slots[1] is 'filled', 'indexed ?= should not reassign when entry is truthy')
end

@Test function testIfEmptyShortCircuit()
   calls = 0
   function fallback()
      calls++
      return 'value'
   end

   present = 'has data'
   present ?= fallback()
   assert(calls is 0, 'truthy ?= should not evaluate the RHS')
   assert(present is 'has data', 'truthy ?= should keep the existing value')

   blank = ''
   blank ?= fallback()
   assert(blank is 'value', 'falsey ?= should evaluate the RHS')
   assert(calls is 1, 'falsey ?= should evaluate the RHS exactly once')
end

@Test function testIncrement()
   counter = 0
   counter++
   assert(counter is 1, 'counter++ should increment value once')
   counter++
   assert(counter is 2, 'counter++ should allow repeated increments')

   object = { tally = 4 }
   object.tally++
   assert(object.tally is 5, 'table field ++ should store incremented value')

   data = { 1, 2, 3 }
   data[2]++
   assert(data[2] is 4, 'indexed ++ should store incremented value')
end

@Test function testContinue()
   total = 0
   index = 0

   while index < 6 do
      index++
      if index % 2 is 0 then
         continue
      end
      total += index
   end
   assert(total is 9, 'continue should skip to next loop iteration')

   seen = {}
   for i = 0, 4 do
      if i is 2 then
         continue
      end
      table.insert(seen, i)
   end
   assert(#seen is 4, 'continue should skip entries in numeric for loop')
   assert(seen[3] is 4, 'continue should skip the value equal to 3')

   attempts = 0
   ready = false
   repeat
      attempts++
      if attempts < 3 then
         continue
      end
      ready = true
   until ready
   assert(attempts is 3, 'continue should jump to repeat condition without executing remainder')
end

@Test function testIndexedWithFunctionRHS()
   t = { 1, 2, 3 }
   i = 1
   function add_three(x)
      return x + 3
   end
   t[i] += add_three(4)
   assert(t[1] is 9, 'indexed += with function RHS should preserve base/index registers')
end

@Test function testFieldWithFunctionRHS()
   store = { count = 5 }
   function delta()
      z = 2
      return z * 4
   end
   store.count -= delta()
   assert(store.count is -3, 'field -= with function RHS should store correct result')
end

@Test function testConcatWithFunctionRHS()
   text = 'a'
   function tail()
      x = 'b'
      return x .. 'c'
   end
   text ..= tail()
   assert(text is 'abc', '..= should concatenate with function result')
end

@Test function testRegisterIndexPreservedAcrossRHS()
   t = { 10, 20, 30 }
   i = 0
   u = { 3, 4, 5 }
   t[i] += u[i] + u[2]
   assert(t[0] is 18, 'indexed += should handle RHS table lookups without corrupting index')
end

@Test function testNestedIndexPreservation()
   u = { { x = 1 }, { x = 2 } }
   i = 1
   function f()
      return 5
   end
   u[i].x += f()
   assert(u[1].x is 7, 'nested indexed field += should preserve inner base/index registers')
end

@Test function testByteAndStringKeyVariants()
   o = { a = 1, b = 'x' }
   o['a'] *= 2
   assert(o.a is 2, "byte/string key compound ops should use correct TSET variant (TSETS/TSETB)")
   o['b'] ..= 'y'
   assert(o.b is 'xy', 'string key ..= should store concatenated value')
   t = {}
   t[5] = 3
   t[5] += 4
   assert(t[5] is 7, 'byte index += should work for numeric constant keys')
end

@Test function testSelfReferentialReadOnRHS()
   t = { 6, 0 }
   i = 0
   t[i] += t[i]
   assert(t[0] is 12, 'indexed += with same element on RHS should double the value')
end

@Test function testMultipleReturnOnlyFirstUsed()
   function multi()
      return 7, 9
   end
   x = 1
   x += multi()
   assert(x is 8, '+= should use only first return value from function')

   function s2()
      return 'w', 'ignored'
   end
   s = 'q'
   s ..= s2()
   assert(s is 'qw', '..= should use only first return value from function')
end

@Test function testIndexRegisterReusedByRHS()
   t = { 1, 2, 3 }
   i = 1
   function f(a, b)
      return a + b
   end
   t[i] *= f(i, t[0]) -- 2 *= f(1, 1)
   assert(t[1] is 4, 'indexed *= RHS using index register should keep index intact')
end

@Test function testBaseReusedByRHS()
   t = { 3, 4 }
   function get_from_same(tbl)
      return tbl[0] + tbl[1]
   end
   t[0] += get_from_same(t)
   assert(t[0] is 10, 'indexed += RHS reading from same table should use original base for store')
end
