-- Flute tests for the compound operators

@Test function testCompoundAssignment()
   value = 5
   value += 3
   assert(value is 8, 'value += 3 should add to value')
   value -= 2
   assert(value is 6, 'value -= 2 should subtract from value')
   value *= 4
   assert(value is 24, 'value *= 4 should multiply value')
   value /= 3
   assert(value is 8, 'value /= 3 should divide value')
   value %= 3
   assert(value is 2, 'value %= 3 should keep remainder')

   text = 'hello'
   text ..= ' world'
   assert(text is 'hello world', 'text ..= should concatenate strings')

   store = { count = 10, list = { 3, 5, 7 } }
   store.count -= 4
   assert(store.count is 6, 'table field compound assignments should store results')
   store.list[1] *= 2
   assert(store.list[1] is 10, 'indexed table compound assignments should store results')
end

@Test function testIfEmptyAssignment()
   count = 5
   count ?= 1
   assert(count is 5, 'count ?= should leave truthy values unchanged')

   local missing
   missing ?= 42
   assert(missing is 42, 'nil LHS should receive the default value')

   zero = 0
   zero ?= 7
   assert(zero is 7, 'zero should trigger ?= assignment')

   empty = ''
   empty ?= 'fallback'
   assert(empty is 'fallback', 'empty string should trigger ?= assignment')

   store = { retries = 0, label = 'ready', slots = { '' } }
   store.retries ?= 3
   assert(store.retries is 3, 'table field ?= should assign when falsey')

   store.label ?= 'idle'
   assert(store.label is 'ready', 'table field ?= should skip when truthy')

   store.slots[1] ?= 'filled'
   assert(store.slots[1] is 'filled', 'indexed ?= should assign when entry is falsey')

   store.slots[1] ?= 'ignored'
   assert(store.slots[1] is 'filled', 'indexed ?= should not reassign when entry is truthy')
end

@Test function testIfEmptyShortCircuit()
   calls = 0
   function fallback()
      calls++
      return 'value'
   end

   present = 'has data'
   present ?= fallback()
   assert(calls is 0, 'truthy ?= should not evaluate the RHS')
   assert(present is 'has data', 'truthy ?= should keep the existing value')

   blank = ''
   blank ?= fallback()
   assert(blank is 'value', 'falsey ?= should evaluate the RHS')
   assert(calls is 1, 'falsey ?= should evaluate the RHS exactly once')
end

@Test function testIncrement()
   counter = 0
   counter++
   assert(counter is 1, 'counter++ should increment value once')
   counter++
   assert(counter is 2, 'counter++ should allow repeated increments')

   object = { tally = 4 }
   object.tally++
   assert(object.tally is 5, 'table field ++ should store incremented value')

   data = { 1, 2, 3 }
   data[2]++
   assert(data[2] is 4, 'indexed ++ should store incremented value')
end

@Test function testContinue()
   total = 0
   index = 0

   while index < 6 do
      index++
      if index % 2 is 0 then
         continue
      end
      total += index
   end
   assert(total is 9, 'continue should skip to next loop iteration')

   seen = {}
   for i = 0, 4 do
      if i is 2 then
         continue
      end
      table.insert(seen, i)
   end
   assert(#seen is 4, 'continue should skip entries in numeric for loop')
   assert(seen[3] is 4, 'continue should skip the value equal to 3')

   attempts = 0
   ready = false
   repeat
      attempts++
      if attempts < 3 then
         continue
      end
      ready = true
   until ready
   assert(attempts is 3, 'continue should jump to repeat condition without executing remainder')
end

@Test function testIndexedWithFunctionRHS()
   t = { 1, 2, 3 }
   i = 1
   function add_three(x)
      return x + 3
   end
   t[i] += add_three(4)
   assert(t[1] is 9, 'indexed += with function RHS should preserve base/index registers')
end

@Test function testFieldWithFunctionRHS()
   store = { count = 5 }
   function delta()
      z = 2
      return z * 4
   end
   store.count -= delta()
   assert(store.count is -3, 'field -= with function RHS should store correct result')
end

@Test function testConcatWithFunctionRHS()
   text = 'a'
   function tail()
      x = 'b'
      return x .. 'c'
   end
   text ..= tail()
   assert(text is 'abc', '..= should concatenate with function result')
end

@Test function testRegisterIndexPreservedAcrossRHS()
   t = { 10, 20, 30 }
   i = 0
   u = { 3, 4, 5 }
   t[i] += u[i] + u[2]
   assert(t[0] is 18, 'indexed += should handle RHS table lookups without corrupting index')
end

@Test function testNestedIndexPreservation()
   u = { { x = 1 }, { x = 2 } }
   i = 1
   function f()
      return 5
   end
   u[i].x += f()
   assert(u[1].x is 7, 'nested indexed field += should preserve inner base/index registers')
end

@Test function testByteAndStringKeyVariants()
   o = { a = 1, b = 'x' }
   o['a'] *= 2
   assert(o.a is 2, "byte/string key compound ops should use correct TSET variant (TSETS/TSETB)")
   o['b'] ..= 'y'
   assert(o.b is 'xy', 'string key ..= should store concatenated value')
   t = {}
   t[5] = 3
   t[5] += 4
   assert(t[5] is 7, 'byte index += should work for numeric constant keys')
end

@Test function testSelfReferentialReadOnRHS()
   t = { 6, 0 }
   i = 0
   t[i] += t[i]
   assert(t[0] is 12, 'indexed += with same element on RHS should double the value')
end

@Test function testMultipleReturnOnlyFirstUsed()
   function multi()
      return 7, 9
   end
   x = 1
   x += multi()
   assert(x is 8, '+= should use only first return value from function')

   function s2()
      return 'w', 'ignored'
   end
   s = 'q'
   s ..= s2()
   assert(s is 'qw', '..= should use only first return value from function')
end

@Test function testIndexRegisterReusedByRHS()
   t = { 1, 2, 3 }
   i = 1
   function f(a, b)
      return a + b
   end
   t[i] *= f(i, t[0]) -- 2 *= f(1, 1)
   assert(t[1] is 4, 'indexed *= RHS using index register should keep index intact')
end

@Test function testBaseReusedByRHS()
   t = { 3, 4 }
   function get_from_same(tbl)
      return tbl[0] + tbl[1]
   end
   t[0] += get_from_same(t)
   assert(t[0] is 10, 'indexed += RHS reading from same table should use original base for store')
end

@Test function testGlobalIfEmptyBasic()
   -- Test global ?= assigns to undefined global
   global gTestVar1 ?= 'assigned'
   assert(gTestVar1 is 'assigned', 'global ?= should assign to undefined global')

   -- Test global ?= does not overwrite existing truthy value
   gTestVar2 = 'existing'
   global gTestVar2 ?= 'ignored'
   assert(gTestVar2 is 'existing', 'global ?= should not overwrite truthy value')
end

@Test function testGlobalIfEmptyFalseyValues()
   -- Test global ?= assigns when value is nil
   global gNilVar = nil
   global gNilVar ?= 'from nil'
   assert(gNilVar is 'from nil', 'global ?= should assign when value is nil')

   -- Test global ?= assigns when value is false
   global gFalseVar = false
   global gFalseVar ?= 'from false'
   assert(gFalseVar is 'from false', 'global ?= should assign when value is false')

   -- Test global ?= assigns when value is zero
   global gZeroVar = 0
   global gZeroVar ?= 99
   assert(gZeroVar is 99, 'global ?= should assign when value is zero')

   -- Test global ?= assigns when value is empty string
   global gEmptyVar = ''
   global gEmptyVar ?= 'from empty'
   assert(gEmptyVar is 'from empty', 'global ?= should assign when value is empty string')
end

@Test function testGlobalIfEmptyWithFunctionCall()
   -- Test global ?= with function call on RHS
   function getDefault()
      return 'default value'
   end
   global gFuncVar ?= getDefault()
   assert(gFuncVar is 'default value', 'global ?= should work with function call RHS')
end

@Test function testGlobalIfEmptyMultiReturn()
   -- Test global ?= takes only first return value from multi-return function
   function multiReturn()
      return 'first', 'second', 'third'
   end
   global gMultiVar ?= multiReturn()
   assert(gMultiVar is 'first', 'global ?= should take only first return value')
end

@Test function testGlobalIfEmptyShortCircuit()
   -- Test global ?= does not evaluate RHS when LHS is truthy
   global gCallCount = 0
   function countedFallback()
      gCallCount++
      return 'fallback'
   end

   global gTruthyVar = 'truthy'
   global gTruthyVar ?= countedFallback()
   assert(gCallCount is 0, 'global ?= should not evaluate RHS when LHS is truthy')
   assert(gTruthyVar is 'truthy', 'global ?= should preserve truthy value')

   -- Now test with falsey value
   global gFalseyVar = 0
   global gFalseyVar ?= countedFallback()
   assert(gCallCount is 1, 'global ?= should evaluate RHS when LHS is falsey')
   assert(gFalseyVar is 'fallback', 'global ?= should assign fallback when LHS is falsey')
end

@Test function testLocalIfEmptyBasic()
   -- Test local ?= assigns to newly declared local
   local lTestVar ?= 'assigned'
   assert(lTestVar is 'assigned', 'local ?= should assign to new local')
end

@Test function testLocalIfEmptyWithFunctionCall()
   -- Test local ?= with function call on RHS
   function getLocalDefault()
      return 123
   end
   local lFuncVar ?= getLocalDefault()
   assert(lFuncVar is 123, 'local ?= should work with function call RHS')
end

@Test function testLocalIfEmptyMultiReturn()
   -- Test local ?= takes only first return value from multi-return function
   function localMultiReturn()
      return 100, 200, 300
   end
   local lMultiVar ?= localMultiReturn()
   assert(lMultiVar is 100, 'local ?= should take only first return value')
end

@Test function testLocalIfEmptyInLoop()
   -- Test local ?= works correctly in loop scope
   results = {}
   for i in {0..3} do
      local loopVar ?= i * 10
      results[i] = loopVar
   end
   assert(results[0] is 0, 'local ?= in loop should assign correctly for i=0')
   assert(results[1] is 10, 'local ?= in loop should assign correctly for i=1')
   assert(results[2] is 20, 'local ?= in loop should assign correctly for i=2')
end

@Test function testLocalIfEmptyInCondition()
   -- Test local ?= works correctly in conditional scope
   function maybeGet(flag)
      if flag then
         local condVar ?= 'from condition'
         return condVar
      end
      return 'not taken'
   end
   assert(maybeGet(true) is 'from condition', 'local ?= in condition should work')
   assert(maybeGet(false) is 'not taken', 'local ?= path not taken should return default')
end
