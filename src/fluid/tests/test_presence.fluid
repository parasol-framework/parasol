-- Flute tests for the postfix ?? operator (presence check)
-- Returns boolean: true if value is truthy, false if falsey (nil, false, 0, "")

function testNil()
   local v = nil
   assert((v??) is false, "Failed nil case: expected false")
end

function testFalse()
   local v = false
   assert((v??) is false, "Failed false case: expected false")
end

function testZero()
   local v = 0
   assert((v??) is false, "Failed zero case: expected false")
end

function testEmptyString()
   local v = ""
   assert((v??) is false, "Failed empty string case: expected false")
end

function testTruthyString()
   local v = "X"
   assert((v??) is true, "Failed truthy string case: expected true")
end

function testTruthyNumber()
   local v = 5
   assert((v??) is true, "Failed truthy number case: expected true")
end

function testTrue()
   local v = true
   assert((v??) is true, "Failed true case: expected true")
end

-- Test in conditionals
function testInConditional()
   local comment = "Hello"
   if comment?? then
      -- Expected path
   else
      error("Should enter if block when comment is truthy")
   end

   local empty = ""
   if empty?? then
      error("Should not enter if block when empty string")
   else
      -- Expected path
   end

   local zero = 0
   if zero?? then
      error("Should not enter if block when zero")
   end
end

-- Test in expressions
function testInExpression()
   local name = "Alice"
   local msg = name?? and "Hello, " .. name or "Hello, Guest"
   assert(msg is "Hello, Alice", "Failed expression test with truthy name")

   local empty_name = ""
   local msg2 = empty_name?? and "Hello, " .. empty_name or "Hello, Guest"
   assert(msg2 is "Hello, Guest", "Failed expression test with empty name")
end

-- Test chaining with logical operators
function testChaining()
   local comment = "Test"
   local author = "User"
   if comment?? and author?? then
      -- Expected path
   else
      error("Should enter if block when both are truthy")
   end

   local empty_comment = ""
   if empty_comment?? and author?? then
      error("Should not enter if block when comment is empty")
   end

   if empty_comment?? or author?? then
      -- Expected path (author is truthy)
   else
      error("Should enter if block when author is truthy")
   end
end

-- Test with parentheses
function testParentheses()
   local x = 5
   local y = 10
   local v = (x + y)??
   assert(v is true, "Failed parentheses test: expected true for non-zero sum")

   local z = -5
   local w = (x + z)??
   assert(w is false, "Failed parentheses test: expected false for zero sum")
end

-- Test with table access
function testTableAccess()
   local t = { name = "Test" }
   local v = t.name??
   assert(v is true, "Failed table access test: expected true for non-empty string")

   local t2 = { name = "" }
   local v2 = t2.name??
   assert(v2 is false, "Failed table access test: expected false for empty string")

   local t3 = { value = 0 }
   local v3 = t3.value??
   assert(v3 is false, "Failed table access test: expected false for zero")
end

-- Test runtime values
function testRuntime()
   local x = 0
   local v = x??
   assert(v is false, "Runtime zero test failed: expected false")

   x = 5
   v = x??
   assert(v is true, "Runtime non-zero test failed: expected true")

   local s = ""
   v = s??
   assert(v is false, "Runtime empty string test failed: expected false")

   s = "Hello"
   v = s??
   assert(v is true, "Runtime non-empty string test failed: expected true")

   local b = false
   v = b??
   assert(v is false, "Runtime false test failed: expected false")

   b = true
   v = b??
   assert(v is true, "Runtime true test failed: expected true")
end

-- Test constant expressions
function testConstants()
   assert((nil??) is false, "Constant nil test failed")
   assert((false??) is false, "Constant false test failed")
   assert((0??) is false, "Constant zero test failed")
   assert((""??) is false, "Constant empty string test failed")
   assert((true??) is true, "Constant true test failed")
   assert((1??) is true, "Constant one test failed")
   assert(("test"??) is true, "Constant string test failed")
   assert((42??) is true, "Constant number test failed")
end

-- Test against nz() function semantics
function testAgainstNz()
   local test_cases = { nil, false, 0, "", "test", 5, true, -1, "0" }
   for _, val in ipairs(test_cases) do
      local nz_result = nz(val) and true or false
      local op_result = (val??)
      assert(nz_result is op_result, "Mismatch with nz() for value: " .. tostring(val))
   end
end

-- Test that ?? returns boolean, not the value
function testReturnsBool()
   local v = "Hello"
   local result = v??
   assert(result is true, "Should return true, not the value")
   assert(result != "Hello", "Should return boolean, not the string value")

   local n = 42
   result = n??
   assert(result is true, "Should return true, not the value")
   assert(result != 42, "Should return boolean, not the numeric value")
end

-- Test chained field access
function testChainedAccess()
   local obj = { user = { name = "Alice" } }
   assert((obj.user.name??) is true, "Failed chained access test")

   local obj2 = { user = { name = "" } }
   assert((obj2.user.name??) is false, "Failed chained access with empty string")
end

-- Test with negative numbers
function testNegativeNumbers()
   local v = -5
   assert((v??) is true, "Failed negative number test: expected true for -5")

   local v2 = -0.0
   assert((v2??) is false, "Failed negative zero test: expected false for -0.0")
end

-- Test with function calls (using nz() as test function)
function testFunctionCalls()
   assert((nz("test")??) is true, "Failed function call test with truthy result")
   assert((nz(nil, "")??) is false, "Failed function call test with falsey result")
end

-- Tests to verify bytecode semantics claimed in PR comment
-- PR comment claims: BC_ISEQP/BC_ISEQN/BC_ISEQS skip next instruction when comparison succeeds
-- These tests verify the actual runtime behavior

-- Test: Verify truthy string returns true (proves jumps don't fire incorrectly)
function testBytecodeSemanticsTruthyString()
   local s = "test"
   local result = s??
   assert(result is true, "Truthy string must return true - if false, BC_ISEQS may be skipping when equal (wrong)")
end

-- Test: Verify truthy number returns true
function testBytecodeSemanticsTruthyNumber()
   local n = 42
   local result = n??
   assert(result is true, "Truthy number must return true - if false, BC_ISEQN may be skipping when equal (wrong)")
end

-- Test: Verify falsey string returns false (proves jumps fire correctly)
function testBytecodeSemanticsFalseyString()
   local s = ""
   local result = s??
   assert(result is false, "Falsey string must return false - if true, BC_ISEQS may not be jumping when equal")
end

-- Test: Verify falsey number returns false
function testBytecodeSemanticsFalseyNumber()
   local n = 0
   local result = n??
   assert(result is false, "Falsey number must return false - if true, BC_ISEQN may not be jumping when equal")
end

-- Test: Verify type mismatch doesn't cause false positives (string vs number comparison)
function testBytecodeSemanticsTypeMismatchStringToNumber()
   local s = "hello"
   -- Comparing string to number (zero check) should not trigger false jump
   local result = s??
   assert(result is true, "String compared to number (zero check) should not trigger false - type mismatch handling")
end

-- Test: Verify type mismatch doesn't cause false positives (number vs string comparison)
function testBytecodeSemanticsTypeMismatchNumberToString()
   local n = 42
   -- Comparing number to string (empty check) should not trigger false jump
   local result = n??
   assert(result is true, "Number compared to string (empty check) should not trigger false - type mismatch handling")
end

-- Test: Verify nil returns false correctly
function testBytecodeSemanticsNil()
   local v = nil
   local result = v??
   assert(result is false, "Nil must return false - verifies BC_ISEQP behavior")
end

-- Test: Verify false returns false correctly
function testBytecodeSemanticsFalse()
   local v = false
   local result = v??
   assert(result is false, "False must return false - verifies BC_ISEQP behavior")
end

-- Test: Comprehensive runtime truthy values
function testBytecodeSemanticsAllTruthyValues()
   local test_cases = {
      {val = "hello", name = "non-empty string"},
      {val = 1, name = "positive number"},
      {val = -1, name = "negative number"},
      {val = 0.5, name = "fractional number"},
      {val = true, name = "boolean true"},
      {val = {}, name = "empty table"},
      {val = {x=1}, name = "non-empty table"}
   }
   for _, tc in ipairs(test_cases) do
      local result = (tc.val)??
      assert(result is true, "Truthy value '" .. tc.name .. "' must return true, got: " .. tostring(result))
   end
end

-- Test: Comprehensive runtime falsey values
function testBytecodeSemanticsAllFalseyValues()
   local test_cases = {
      {val = nil, name = "nil"},
      {val = false, name = "false"},
      {val = 0, name = "zero"},
      {val = "", name = "empty string"}
   }
   for _, tc in ipairs(test_cases) do
      local result = (tc.val)??
      assert(result is false, "Falsey value '" .. tc.name .. "' must return false, got: " .. tostring(result))
   end
end

function testFlags()
   local trigger = 0
   local perm = PERMIT_READ|PERMIT_WRITE
   if (perm & PERMIT_READ)??  then trigger++ end
   if (perm & PERMIT_WRITE)?? then trigger++ end
   if (perm & PERMIT_READ|PERMIT_WRITE)??  then trigger++ end
   if (perm & PERMIT_EXEC)??  then trigger++ end
   assert(trigger is 3, "Expected 3 bit-flags to pass, got " .. trigger)
end

-----------------------------------------------------------------------------------------------------------------------

return {
   tests = {
      'testNil', 'testFalse', 'testZero', 'testEmptyString',
      'testTruthyString', 'testTruthyNumber', 'testTrue', 'testInConditional',
      'testInExpression', 'testChaining', 'testParentheses',
      'testTableAccess', 'testRuntime', 'testConstants', 'testAgainstNz',
      'testReturnsBool', 'testChainedAccess', 'testNegativeNumbers', 'testFunctionCalls',
      'testBytecodeSemanticsTruthyString', 'testBytecodeSemanticsTruthyNumber',
      'testBytecodeSemanticsFalseyString', 'testBytecodeSemanticsFalseyNumber',
      'testBytecodeSemanticsTypeMismatchStringToNumber', 'testBytecodeSemanticsTypeMismatchNumberToString',
      'testBytecodeSemanticsNil', 'testBytecodeSemanticsFalse',
      'testBytecodeSemanticsAllTruthyValues', 'testBytecodeSemanticsAllFalseyValues',
      'testFlags'
   }
}
