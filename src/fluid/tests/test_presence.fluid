-- Flute tests for the postfix ? operator (presence check)
-- Returns boolean: true if value is truthy, false if falsey (nil, false, 0, "")

function testNil()
   local v = nil
   assert((v?) is false, "Failed nil case: expected false")
end

function testFalse()
   local v = false
   assert((v?) is false, "Failed false case: expected false")
end

function testZero()
   local v = 0
   assert((v?) is false, "Failed zero case: expected false")
end

function testEmptyString()
   local v = ""
   assert((v?) is false, "Failed empty string case: expected false")
end

function testTruthyString()
   local v = "X"
   assert((v?) is true, "Failed truthy string case: expected true")
end

function testTruthyNumber()
   local v = 5
   assert((v?) is true, "Failed truthy number case: expected true")
end

function testTrue()
   local v = true
   assert((v?) is true, "Failed true case: expected true")
end

-- Test in conditionals
function testInConditional()
   local comment = "Hello"
   if comment? then
      -- Expected path
   else
      error("Should enter if block when comment is truthy")
   end

   local empty = ""
   if empty? then
      error("Should not enter if block when empty string")
   else
      -- Expected path
   end

   local zero = 0
   if zero? then
      error("Should not enter if block when zero")
   end
end

-- Test in expressions
function testInExpression()
   local name = "Alice"
   local msg = name? and "Hello, " .. name or "Hello, Guest"
   assert(msg is "Hello, Alice", "Failed expression test with truthy name")

   local empty_name = ""
   local msg2 = empty_name? and "Hello, " .. empty_name or "Hello, Guest"
   assert(msg2 is "Hello, Guest", "Failed expression test with empty name")
end

-- Test chaining with logical operators
function testChaining()
   local comment = "Test"
   local author = "User"
   if comment? and author? then
      -- Expected path
   else
      error("Should enter if block when both are truthy")
   end

   local empty_comment = ""
   if empty_comment? and author? then
      error("Should not enter if block when comment is empty")
   end

   if empty_comment? or author? then
      -- Expected path (author is truthy)
   else
      error("Should enter if block when author is truthy")
   end
end

-- Test with parentheses
function testParentheses()
   local x = 5
   local y = 10
   local v = (x + y)?
   assert(v is true, "Failed parentheses test: expected true for non-zero sum")

   local z = -5
   local w = (x + z)?
   assert(w is false, "Failed parentheses test: expected false for zero sum")
end

-- Test with table access
function testTableAccess()
   local t = { name = "Test" }
   local v = t.name?
   assert(v is true, "Failed table access test: expected true for non-empty string")

   local t2 = { name = "" }
   local v2 = t2.name?
   assert(v2 is false, "Failed table access test: expected false for empty string")

   local t3 = { value = 0 }
   local v3 = t3.value?
   assert(v3 is false, "Failed table access test: expected false for zero")
end

-- Test runtime values
function testRuntime()
   local x = 0
   local v = x?
   assert(v is false, "Runtime zero test failed: expected false")

   x = 5
   v = x?
   assert(v is true, "Runtime non-zero test failed: expected true")

   local s = ""
   v = s?
   assert(v is false, "Runtime empty string test failed: expected false")

   s = "Hello"
   v = s?
   assert(v is true, "Runtime non-empty string test failed: expected true")

   local b = false
   v = b?
   assert(v is false, "Runtime false test failed: expected false")

   b = true
   v = b?
   assert(v is true, "Runtime true test failed: expected true")
end

-- Test constant expressions
function testConstants()
   assert((nil?) is false, "Constant nil test failed")
   assert((false?) is false, "Constant false test failed")
   assert((0?) is false, "Constant zero test failed")
   assert((""?) is false, "Constant empty string test failed")
   assert((true?) is true, "Constant true test failed")
   assert((1?) is true, "Constant one test failed")
   assert(("test"?) is true, "Constant string test failed")
   assert((42?) is true, "Constant number test failed")
end

-- Test against nz() function semantics
function testAgainstNz()
   local test_cases = { nil, false, 0, "", "test", 5, true, -1, "0" }
   for _, val in ipairs(test_cases) do
      local nz_result = nz(val) and true or false
      local op_result = (val?)
      assert(nz_result is op_result, "Mismatch with nz() for value: " .. tostring(val))
   end
end

-- Test that ? returns boolean, not the value
function testReturnsBool()
   local v = "Hello"
   local result = v?
   assert(result is true, "Should return true, not the value")
   assert(result != "Hello", "Should return boolean, not the string value")

   local n = 42
   result = n?
   assert(result is true, "Should return true, not the value")
   assert(result != 42, "Should return boolean, not the numeric value")
end

-- Test chained field access
function testChainedAccess()
   local obj = { user = { name = "Alice" } }
   assert((obj.user.name?) is true, "Failed chained access test")

   local obj2 = { user = { name = "" } }
   assert((obj2.user.name?) is false, "Failed chained access with empty string")
end

-- Test with negative numbers
function testNegativeNumbers()
   local v = -5
   assert((v?) is true, "Failed negative number test: expected true for -5")

   local v2 = -0.0
   assert((v2?) is false, "Failed negative zero test: expected false for -0.0")
end

-- Test with function calls (using nz() as test function)
function testFunctionCalls()
   assert((nz("test")?) is true, "Failed function call test with truthy result")
   assert((nz(nil, "")?) is false, "Failed function call test with falsey result")
end

-----------------------------------------------------------------------------------------------------------------------

return {
   tests = {
      'testNil', 'testFalse', 'testZero', 'testEmptyString',
      'testTruthyString', 'testTruthyNumber', 'testTrue', 'testInConditional',
      'testInExpression', 'testChaining', 'testParentheses',
      'testTableAccess', 'testRuntime', 'testConstants', 'testAgainstNz',
      'testReturnsBool', 'testChainedAccess', 'testNegativeNumbers', 'testFunctionCalls'
   }
}
