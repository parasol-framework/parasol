-- Flute tests for array.concat functionality

function testIntegerArrayConcat()
   local int_array = array.new(5, "integer")
   int_array[1] = 10
   int_array[2] = 20
   int_array[3] = 30
   int_array[4] = 40
   int_array[5] = 50

   local result = int_array.concat("%d", ", ")
   if result != "10, 20, 30, 40, 50" then
      error("Integer array concat failed, expected '10, 20, 30, 40, 50', got '" .. result .. "'")
   end

   -- Test without join string
   local result2 = int_array.concat("%d", "")
   if result2 != "1020304050" then
      error("Integer array concat without join failed, expected '1020304050', got '" .. result2 .. "'")
   end
end

function testFloatArrayConcat()
   local float_array = array.new(3, "float")
   float_array[1] = 1.5
   float_array[2] = 2.7
   float_array[3] = 3.14

   local result = float_array.concat("%.2f", " | ")
   if result != "1.50 | 2.70 | 3.14" then
      error("Float array concat failed, expected '1.50 | 2.70 | 3.14', got '" .. result .. "'")
   end
end

function testByteArrayConcat()
   local byte_array = array.new(4, "byte")
   byte_array[1] = 65  -- 'A'
   byte_array[2] = 66  -- 'B'
   byte_array[3] = 67  -- 'C'
   byte_array[4] = 68  -- 'D'

   local result = byte_array.concat("%c", "")
   if result != "ABCD" then
      error("Byte array concat failed, expected 'ABCD', got '" .. result .. "'")
   end

   -- Test with separator
   local result2 = byte_array.concat("%d", "-")
   if result2 != "65-66-67-68" then
      error("Byte array numeric concat failed, expected '65-66-67-68', got '" .. result2 .. "'")
   end
end

function testDoubleArrayConcat()
   local double_array = array.new(2, "double")
   double_array[1] = 3.141592653589793
   double_array[2] = 2.718281828459045

   local result = double_array.concat("%.3f", " and ")
   if result != "3.142 and 2.718" then
      error("Double array concat failed, expected '3.142 and 2.718', got '" .. result .. "'")
   end
end

function testWordArrayConcat()
   local word_array = array.new(3, "word")
   word_array[1] = 1000
   word_array[2] = 2000
   word_array[3] = 3000

   local result = word_array.concat("%04d", ", ")
   if result != "1000, 2000, 3000" then
      error("Word array concat failed, expected '1000, 2000, 3000', got '" .. result .. "'")
   end
end

function testSingleElementConcat()
   local single_array = array.new(1, "integer")
   single_array[1] = 42

   local result = single_array.concat("%d", ", ")
   if result != "42" then
      error("Single element array concat failed, expected '42', got '" .. result .. "'")
   end
end

function testFormatValidation()
   local int_array = array.new(2, "integer")
   int_array[1] = 10
   int_array[2] = 20

   -- Test valid formats work
   local result = int_array.concat("%d", ", ")
   if result != "10, 20" then
      error("Valid format test failed, expected '10, 20', got '" .. result .. "'")
   end

   -- Test multiple format specifiers are rejected
   local success = pcall(function()
      return int_array.concat("%d %s", ", ")
   end)
   if success then
      error("Multiple format specifiers should be rejected")
   end

   -- Test no format specifier is rejected
   local success2 = pcall(function()
      return int_array.concat("no format", ", ")
   end)
   if success2 then
      error("No format specifier should be rejected")
   end

   -- Test incomplete format specifier is rejected
   local success3 = pcall(function()
      return int_array.concat("incomplete %", ", ")
   end)
   if success3 then
      error("Incomplete format specifier should be rejected")
   end

   -- Test escaped %% works
   local result_escaped = int_array.concat("%%d:%d", ", ")
   if result_escaped != "%d:10, %d:20" then
      error("Escaped %% test failed, expected '%d:10, %d:20', got '" .. result_escaped .. "'")
   end
end

function testStringArrayUnsupported()
   -- String arrays should work for concat
   local string_array = array.new(3, "string")
   -- Note: We can't actually set string array values in current implementation
   -- but we can test that the concat method exists and handles the case

   -- This test would need actual string array assignment to work properly
   -- For now, we'll skip this test until string array assignment is implemented
end
-----------------------------------------------------------------------------------------------------------------------
-- Test basic array bounds checking

function testArrayBoundsChecking()
   local arr = array.new(10, "integer")

   -- Test valid access
   arr[1] = 100
   assert(arr[1] == 100, "Valid array access failed")

   -- Test invalid negative index
   local status, err = pcall(function()
      return arr[0]
   end)
   assert(not status, "Should reject negative array index")

   -- Test invalid high index
   local status, err = pcall(function()
      return arr[11]
   end)
   assert(not status, "Should reject index beyond array size")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test array size validation during creation

function testArraySizeValidation()
   -- Test negative size rejection
   local status, err = pcall(function()
      return array.new(-5, "integer")
   end)
   assert(not status, "Should reject negative array size")

   -- Test zero size rejection
   local status, err = pcall(function()
      return array.new(0, "integer")
   end)
   assert(not status, "Should reject zero array size")

   -- Test reasonable size acceptance
   local arr = array.new(100, "integer")
   assert(arr ~= nil, "Should accept reasonable array size")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test getstring bounds checking on byte arrays

function testGetStringBounds()
   local str = "Hello World"
   local arr = array.new(str, "bytestring")

   -- Test valid substring extraction
   local result = arr.getstring(0, 5)
   assert(result == "Hello", "Valid substring extraction failed")

   -- Test invalid start index
   local status, err = pcall(function()
      return arr.getstring(-1, 5)
   end)
   assert(not status, "Should reject negative start index")

   -- Test invalid length (would exceed array bounds)
   local status, err = pcall(function()
      return arr.getstring(5, 100)
   end)
   assert(not status, "Should reject length that exceeds array bounds")

   -- Test negative length
   local status, err = pcall(function()
      return arr.getstring(0, -5)
   end)
   assert(not status, "Should reject negative length")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test array copy bounds checking

function testArrayCopyBounds()
   local dest = array.new(10, "byte")
   local source = "Hello"

   -- Test valid copy (source, destIndex=1 by default)
   dest.copy(source)

   -- Test copy beyond array bounds (start at index 8, source is 5 chars, would exceed size 10)
   local status, err = pcall(function()
      dest.copy(source, 8) -- start at index 8, copy 5 chars = positions 8-12 (exceeds size 10)
   end)
   assert(not status, "Should reject copy that would exceed array bounds")

   -- Test invalid destination index (0 is invalid, should be 1-based)
   local status, err = pcall(function()
      dest.copy(source, 0)
   end)
   assert(not status, "Should reject invalid destination index")

   -- Test destination index beyond array size
   local status, err = pcall(function()
      dest.copy(source, 15) -- Beyond array size 10
   end)
   assert(not status, "Should reject destination index beyond array size")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test write access bounds on arrays

function testArrayWriteBounds()
   local arr = array.new(5, "integer")

   -- Test valid write
   arr[3] = 42
   assert(arr[3] == 42, "Valid array write failed")

   -- Test write beyond bounds
   local status, err = pcall(function()
      arr[6] = 100
   end)
   assert(not status, "Should reject write beyond array bounds")

   -- Test write at invalid index
   local status, err = pcall(function()
      arr[0] = 100
   end)
   assert(not status, "Should reject write at invalid index")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test table to array copying functionality

function testTableToIntegerArrayCopy()
   local arr = array.new(5, "integer")
   local table_data = {10, 20, 30, 40, 50}
   
   -- Test copying entire table to array
   arr.copy(table_data)
   
   -- Verify values were copied correctly
   for i = 1, 5 do
      assert(arr[i] == table_data[i], "Table to integer array copy failed at index " .. i)
   end
end

function testTableToFloatArrayCopy()
   local arr = array.new(4, "float")
   local table_data = {1.5, 2.7, 3.14, 4.8}
   
   arr.copy(table_data)
   
   -- Check with small tolerance for float comparison
   for i = 1, 4 do
      local diff = math.abs(arr[i] - table_data[i])
      assert(diff < 0.0001, "Table to float array copy failed at index " .. i)
   end
end

function testTableToByteArrayCopy()
   local arr = array.new(4, "byte")
   local table_data = {65, 66, 67, 68}  -- ASCII A, B, C, D
   
   arr.copy(table_data)
   
   for i = 1, 4 do
      assert(arr[i] == table_data[i], "Table to byte array copy failed at index " .. i)
   end
end

function testTableToDoubleArrayCopy()
   local arr = array.new(3, "double")
   local table_data = {3.141592653589793, 2.718281828459045, 1.414213562373095}
   
   arr.copy(table_data)
   
   for i = 1, 3 do
      local diff = math.abs(arr[i] - table_data[i])
      assert(diff < 0.000000001, "Table to double array copy failed at index " .. i)
   end
end

function testTableToWordArrayCopy()
   local arr = array.new(3, "word")
   local table_data = {1000, 2000, 3000}
   
   arr.copy(table_data)
   
   for i = 1, 3 do
      assert(arr[i] == table_data[i], "Table to word array copy failed at index " .. i)
   end
end

function testTableCopyWithDestinationIndex()
   local arr = array.new(6, "integer")
   local table_data = {100, 200, 300}
   
   -- Initialize array with different values
   for i = 1, 6 do
      arr[i] = i
   end
   
   -- Copy table starting at index 3
   arr.copy(table_data, 3)
   
   -- Check that first 2 elements are unchanged
   assert(arr[1] == 1, "Element before copy should be unchanged")
   assert(arr[2] == 2, "Element before copy should be unchanged")
   
   -- Check copied elements
   assert(arr[3] == 100, "Copied element 1 incorrect")
   assert(arr[4] == 200, "Copied element 2 incorrect")
   assert(arr[5] == 300, "Copied element 3 incorrect")
   
   -- Check that last element is unchanged
   assert(arr[6] == 6, "Element after copy should be unchanged")
end

function testTableCopyWithLimitedTotal()
   local arr = array.new(5, "integer")
   local table_data = {10, 20, 30, 40, 50}
   
   -- Copy only first 3 elements
   arr.copy(table_data, 1, 3)
   
   assert(arr[1] == 10, "Limited copy element 1 incorrect")
   assert(arr[2] == 20, "Limited copy element 2 incorrect")
   assert(arr[3] == 30, "Limited copy element 3 incorrect")
   
   -- Elements 4 and 5 should be uninitialized (0)
   assert(arr[4] == 0, "Element beyond copy should be 0")
   assert(arr[5] == 0, "Element beyond copy should be 0")
end

function testTableCopyBoundsChecking()
   local arr = array.new(3, "integer")
   local table_data = {10, 20, 30, 40}  -- Table larger than array
   
   -- Test copying to invalid destination index
   local status = pcall(function()
      arr.copy(table_data, 0)  -- Invalid index (0)
   end)
   assert(not status, "Should reject invalid destination index")
   
   -- Test copying beyond array bounds
   local status2 = pcall(function()
      arr.copy(table_data, 2)  -- Start at 2, table has 4 elements, would exceed array size 3
   end)
   assert(not status2, "Should reject copy that would exceed array bounds")
   
   -- Test with empty table
   local empty_table = {}
   local status3 = pcall(function()
      arr.copy(empty_table)
   end)
   assert(not status3, "Should reject empty table")
end

function testTableCopyTypeConversion()
   -- Test copying integers to float array
   local float_arr = array.new(3, "float")
   local int_table = {1, 2, 3}
   
   float_arr.copy(int_table)
   
   assert(math.abs(float_arr[1] - 1.0) < 0.0001, "Integer to float conversion failed")
   assert(math.abs(float_arr[2] - 2.0) < 0.0001, "Integer to float conversion failed")
   assert(math.abs(float_arr[3] - 3.0) < 0.0001, "Integer to float conversion failed")
   
   -- Test copying floats to integer array (truncation)
   local int_arr = array.new(3, "integer")
   local float_table = {1.7, 2.9, 3.1}
   
   int_arr.copy(float_table)
   
   assert(int_arr[1] == 1, "Float to integer conversion failed")
   assert(int_arr[2] == 2, "Float to integer conversion failed") 
   assert(int_arr[3] == 3, "Float to integer conversion failed")
end

-----------------------------------------------------------------------------------------------------------------------

   return {
      tests = {
         'testIntegerArrayConcat',
         'testFloatArrayConcat',
         'testByteArrayConcat',
         'testDoubleArrayConcat',
         'testWordArrayConcat',
         'testSingleElementConcat',
         'testFormatValidation',
         'testStringArrayUnsupported',
         // Array safety
         'testArrayBoundsChecking',
         'testArraySizeValidation',
         'testGetStringBounds',
         'testArrayCopyBounds',
         'testArrayWriteBounds',
         // Table to array copying
         'testTableToIntegerArrayCopy',
         'testTableToFloatArrayCopy',
         'testTableToByteArrayCopy',
         'testTableToDoubleArrayCopy',
         'testTableToWordArrayCopy',
         'testTableCopyWithDestinationIndex',
         'testTableCopyWithLimitedTotal',
         'testTableCopyBoundsChecking',
         'testTableCopyTypeConversion'
      }
   }


