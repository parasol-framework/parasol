-- Flute tests for array functionality

@BeforeEach(hotpath=true)
function enforce_hotpath() end

@Test function IntegerArrayConcat()
   int_array = array.new(5, 'int')
   int_array[0] = 10
   int_array[1] = 20
   int_array[2] = 30
   int_array[3] = 40
   int_array[4] = 50

   result = int_array:concat('%d', ', ')
   assert(result is '10, 20, 30, 40, 50', "Integer array concat failed, expected '10, 20, 30, 40, 50', got '" .. result .. "'")

   -- Test without join string
   result2 = int_array:concat('%d', '')
   assert(result2 is '1020304050', "Integer array concat without join failed, expected '1020304050', got '" .. result2 .. "'")
end

----------------------------------------------------------------------------------------------------------------------

@Test function FloatArrayConcat()
   float_array = array.new(3, 'float')
   float_array[0] = 1.5
   float_array[1] = 2.7
   float_array[2] = 3.14

   result = float_array:concat('%.2f', ' | ')
   assert(result is '1.50 | 2.70 | 3.14', "Float array concat failed, expected '1.50 | 2.70 | 3.14', got '" .. result .. "'")
end

----------------------------------------------------------------------------------------------------------------------

@Test function ByteArrayConcat()
   byte_array = array.new(4, 'byte')
   byte_array[0] = 65  -- 'A'
   byte_array[1] = 66  -- 'B'
   byte_array[2] = 67  -- 'C'
   byte_array[3] = 68  -- 'D'

   result = byte_array:concat('%c', '')
   if result != 'ABCD' then
      error("Byte array concat failed, expected 'ABCD', got '" .. result .. "'")
   end

   -- Test with separator
   result2 = byte_array:concat('%d', '-')
   if result2 != '65-66-67-68' then
      error("Byte array numeric concat failed, expected '65-66-67-68', got '" .. result2 .. "'")
   end
end

----------------------------------------------------------------------------------------------------------------------

@Test function DoubleArrayConcat()
   double_array = array.new(2, 'double')
   double_array[0] = 3.141592653589793
   double_array[1] = 2.718281828459045

   result = double_array:concat('%.3f', ' and ')
   assert(result is '3.142 and 2.718', "Double array concat failed, expected '3.142 and 2.718', got '" .. result .. "'")
end

----------------------------------------------------------------------------------------------------------------------

@Test function WordArrayConcat()
   word_array = array.new(3, 'int16')
   word_array[0] = 1000
   word_array[1] = 2000
   word_array[2] = 3000

   result = word_array:concat('%04d', ', ')
   assert(result is '1000, 2000, 3000', "Word array concat failed, expected '1000, 2000, 3000', got '" .. result .. "'")
end

----------------------------------------------------------------------------------------------------------------------

@Test function SingleElementConcat()
   single_array = array.new(1, 'int')
   single_array[0] = 42

   result = single_array:concat('%d', ', ')
   assert(result is '42', "Single element array concat failed, expected '42', got '" .. result .. "'")
end

----------------------------------------------------------------------------------------------------------------------

@Test function FormatValidation()
   int_array = array.new(2, 'int')
   int_array[0] = 10
   int_array[1] = 20

   -- Test valid formats work
   result = int_array:concat('%d', ', ')
   assert(result is '10, 20', "Valid format test failed, expected '10, 20', got '" .. result .. "'")

   -- Test multiple format specifiers are rejected
   success = pcall(function()
      return int_array:concat('%d %s', ', ')
   end)
   assert(not success, "Multiple format specifiers should be rejected")

   -- Test no format specifier is rejected
   success = pcall(function()
      return int_array:concat('no format', ', ')
   end)
   assert(not success, "No format specifier should be rejected")

   -- Test incomplete format specifier is rejected
   success3 = pcall(function()
      return int_array:concat('incomplete %', ', ')
   end)
   assert(not success3, "Incomplete format specifier should be rejected")

   -- Test escaped %% works
   result_escaped = int_array:concat('%%d:%d', ', ')
   assert(result_escaped is '%d:10, %d:20', "Escaped %% test failed, expected '%d:10, %d:20', got '" .. result_escaped .. "'")
end

----------------------------------------------------------------------------------------------------------------------

@Test function StringArrayUnsupported()
   -- String arrays should work for concat
   string_array = array.new(3, 'string')
   -- Note: We can't actually set string array values in current implementation
   -- but we can test that the concat method exists and handles the case

   -- This test would need actual string array assignment to work properly
   -- For now, we'll skip this test until string array assignment is implemented
end

-----------------------------------------------------------------------------------------------------------------------
-- Test basic array bounds checking

@Test function ArrayBoundsChecking()
   arr = array.new(10, 'int')

   -- Test valid access
   arr[0] = 100
   assert(arr[0] is 100, 'Valid array access failed')

   -- Test invalid negative index
   status, err = pcall(function()
      return arr[-1]
   end)
   assert(not status, 'Should reject negative array index')

   -- Test invalid high index
   status, err = pcall(function()
      return arr[10]
   end)
   assert(not status, 'Should reject index beyond array size')
end

-----------------------------------------------------------------------------------------------------------------------
-- Test array size validation during creation

@Test function ArraySizeValidation()
   -- Test negative size rejection
   status, err = pcall(function()
      return array.new(-5, 'int')
   end)
   assert(not status, 'Should reject negative array size')
end

-----------------------------------------------------------------------------------------------------------------------
-- Test getString bounds checking on byte arrays

@Test function GetStringBounds()
   str = 'Hello World'
   arr = array.new(str, 'byte')

   -- Test valid substring extraction
   result = arr:getString(0, 5)
   assert(result is 'Hello', 'Valid substring extraction failed')

   -- Test invalid start index
   status, err = pcall(function()
      return arr:getString(-1, 5)
   end)
   assert(not status, 'Should reject negative start index')

   -- Test invalid length (would exceed array bounds)
   status, err = pcall(function()
      return arr:getString(5, 100)
   end)
   assert(not status, 'Should reject length that exceeds array bounds')

   -- Test negative length
   status, err = pcall(function()
      return arr:getString(0, -5)
   end)
   assert(not status, 'Should reject negative length')
end

-----------------------------------------------------------------------------------------------------------------------
-- Test array copy bounds checking

@Test function ArrayCopyBounds()
   dest = array.new(10, 'byte')
   source = 'Hello'

   -- Test valid copy
   dest:copy(source)

   -- Test copy beyond array bounds
   status, err = pcall(function()
      dest:copy(source, 8) -- Target index 8, copy 5 chars = positions 8-12 (exceeds size 10)
   end)
   assert(not status, 'Should reject copy that would exceed array bounds')

   status, err = pcall(function()
      dest:copy(source, -1)
   end)
   assert(not status, 'Should reject invalid destination index')

   -- Test destination index beyond array size
   status, err = pcall(function()
      dest:copy(source, 15) -- Beyond array size 10
   end)
   assert(not status, 'Should reject destination index beyond array size')
end

-----------------------------------------------------------------------------------------------------------------------
-- Test write access bounds on arrays

@Test function ArrayWriteBounds()
   arr = array.new(5, 'int')

   -- Test valid write
   arr[3] = 42
   assert(arr[3] is 42, 'Valid array write failed')

   -- Test write beyond bounds
   status, err = pcall(function()
      arr[6] = 100
   end)
   assert(not status, 'Should reject write beyond array bounds')

   -- Test write at invalid index
   status, err = pcall(function()
      arr[-1] = 100
   end)
   assert(not status, 'Should reject write at invalid index')
end

-----------------------------------------------------------------------------------------------------------------------
-- Test table to array copying functionality

@Test function TableToIntegerArrayCopy()
   arr = array.new(5, 'int')
   table_data = {10, 20, 30, 40, 50}

   -- Test copying entire table to array
   arr:copy(table_data)

   -- Verify values were copied correctly
   for i = 0, 4 do
      assert(arr[i] is table_data[i], 'Table to integer array copy failed at index ' .. i)
   end
end

@Test function TableToFloatArrayCopy()
   arr = array.new(4, 'float')
   table_data = {1.5, 2.7, 3.14, 4.8}

   arr:copy(table_data)

   -- Check with small tolerance for float comparison
   for i = 0, 3 do
      diff = math.abs(arr[i] - table_data[i])
      assert(diff < 0.0001, 'Table to float array copy failed at index ' .. i)
   end
end

@Test function TableToByteArrayCopy()
   arr = array.new(4, 'byte')
   table_data = {65, 66, 67, 68}  -- ASCII A, B, C, D

   arr:copy(table_data)

   for i = 0, 3 do
      assert(arr[i] is table_data[i], 'Table to byte array copy failed at index ' .. i)
   end
end

@Test function TableToDoubleArrayCopy()
   arr = array.new(3, 'double')
   table_data = {3.141592653589793, 2.718281828459045, 1.414213562373095}

   arr:copy(table_data)

   for i = 0, 2 do
      diff = math.abs(arr[i] - table_data[i])
      assert(diff < 0.000000001, 'Table to double array copy failed at index ' .. i)
   end
end

@Test function TableToWordArrayCopy()
   arr = array.new(3, 'int16')
   table_data = {1000, 2000, 3000}

   arr:copy(table_data)

   for i = 0, 2 do
      assert(arr[i] is table_data[i], 'Table to int16 array copy failed at index ' .. i)
   end
end

@Test function TableCopyWithDestinationIndex()
   arr = array.new(6, 'int')

   -- Initialize array with different values
   for i = 0, 5 do
      arr[i] = i
   end

   -- Copy table starting at dest index 2
   -- API: arr:copy(source, dest_idx, src_idx, count)
   table_data = {100, 200, 300}
   arr:copy(table_data, 2, 0, 3)

   -- Check that first 2 elements are unchanged
   assert(arr[0] is 0, 'Element before copy should be unchanged')
   assert(arr[1] is 1, 'Element before copy should be unchanged')

   -- Check copied elements
   assert(arr[2] is 100, 'Copied element 1 incorrect')
   assert(arr[3] is 200, 'Copied element 2 incorrect')
   assert(arr[4] is 300, 'Copied element 3 incorrect')

   -- Check that last element is unchanged
   assert(arr[5] is 5, 'Element after copy should be unchanged')
end

@Test function TableCopyWithLimitedTotal()
   arr = array.new(5, 'int')
   arr:clear()

   table_data = {10, 20, 30, 40, 50}

   -- Copy only first 3 elements
   -- API: arr:copy(source, dest_idx, src_idx, count)
   arr:copy(table_data, 0, 0, 3)

   assert(arr[0] is 10, 'Limited copy element 1 incorrect')
   assert(arr[1] is 20, 'Limited copy element 2 incorrect')
   assert(arr[2] is 30, 'Limited copy element 3 incorrect')

   -- Elements 3 and 4 should be uninitialized (0)
   assert(arr[3] is 0, 'Element beyond copy should be 0')
   assert(arr[4] is 0, 'Element beyond copy should be 0')
end

@Test function TableCopyBoundsChecking()
   arr = array.new(3, 'int')
   table_data = {10, 20, 30, 40}  -- Table larger than array

   -- Test copying to invalid destination index
   status = pcall(function()
      arr:copy(table_data, 0)  -- Invalid index (0)
   end)
   assert(not status, 'Should reject invalid destination index')

   -- Test copying beyond array bounds
   status2 = pcall(function()
      arr:copy(table_data, 2)  -- Start at 2, table has 4 elements, would exceed array size 3
   end)
   assert(not status2, 'Should reject copy that would exceed array bounds')

   -- Test with empty table
   empty_table = {}
   status3 = pcall(function()
      arr:copy(empty_table)
   end)
   assert(not status3, 'Should reject empty table')
end

@Test function TableCopyTypeConversion()
   -- Test copying integers to float array
   float_arr = array.new(3, 'float')
   int_table = {1, 2, 3}

   float_arr:copy(int_table)

   assert(math.abs(float_arr[0] - 1.0) < 0.0001, 'Integer to float conversion failed')
   assert(math.abs(float_arr[1] - 2.0) < 0.0001, 'Integer to float conversion failed')
   assert(math.abs(float_arr[2] - 3.0) < 0.0001, 'Integer to float conversion failed')

   -- Test copying floats to integer array (truncation)
   int_arr = array.new(3, 'int')
   float_table = {1.7, 2.9, 3.1}

   int_arr:copy(float_table)

   assert(int_arr[0] is 1, 'Float to integer conversion failed')
   assert(int_arr[1] is 2, 'Float to integer conversion failed')
   assert(int_arr[2] is 3, 'Float to integer conversion failed')
end

@Test function ToString()
   str_array = array.new('hello')
   assert(tostring(str_array) is 'array(5, "char")', "String array toString failed, got '" .. tostring(str_array) .. "'")

   assert(#str_array is 5, "String array length failed, expected 5, got " .. tostring(#str_array))
end

-----------------------------------------------------------------------------------------------------------------------
-- Test array.find() functionality

@Test function ArrayFind()
   arr = array.new(10, 'int')
   for i = 0, 9 do
      arr[i] = i * 10
   end

   -- Find existing values
   assert(arr:find(0) is 0, "find(0) should return 0")
   assert(arr:find(50) is 5, "find(50) should return 5")
   assert(arr:find(90) is 9, "find(90) should return 9")

   -- Find non-existing value
   assert(arr:find(55) is nil, "find(55) should return nil")

   -- Find with start index
   assert(arr:find(50, 5) is 5, "find(50, 5) should return 5")
   assert(arr:find(50, 6) is nil, "find(50, 6) should return nil")
end

@Test function ArrayFindFloat()
   arr = array.new(5, 'float')
   arr[0] = 1.5
   arr[1] = 2.5
   arr[2] = 3.5
   arr[3] = 2.5  -- duplicate
   arr[4] = 4.5

   assert(arr:find(2.5) is 1, "find(2.5) should return 1 (first occurrence)")
   assert(arr:find(3.5) is 2, "find(3.5) should return 2")
   assert(arr:find(5.5) is nil, "find(5.5) should return nil")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test array.reverse() functionality

@Test function ArrayReverse()
   arr = array.new(5, 'int')
   for i = 0, 4 do
      arr[i] = i
   end

   arr:reverse()

   assert(arr[0] is 4, "reverse arr[0] should be 4")
   assert(arr[1] is 3, "reverse arr[1] should be 3")
   assert(arr[2] is 2, "reverse arr[2] should be 2")
   assert(arr[3] is 1, "reverse arr[3] should be 1")
   assert(arr[4] is 0, "reverse arr[4] should be 0")
end

@Test function ArrayReverseOddLength()
   arr = array.new(5, 'int')
   for i = 0, 4 do
      arr[i] = i + 1
   end

   arr:reverse()

   assert(arr[0] is 5, "odd reverse arr[0] should be 5")
   assert(arr[2] is 3, "odd reverse arr[2] should be 3 (middle)")
   assert(arr[4] is 1, "odd reverse arr[4] should be 1")
end

@Test function ArrayReverseEmpty()
   -- Single element array
   arr = array.new(1, 'int')
   arr[0] = 42
   arr:reverse()
   assert(arr[0] is 42, "single element reverse should preserve value")

   -- Two element array
   arr2 = array.new(2, 'int')
   arr2[0] = 1
   arr2[1] = 2
   arr2:reverse()
   assert(arr2[0] is 2, "two element reverse [0] should be 2")
   assert(arr2[1] is 1, "two element reverse [1] should be 1")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test array.slice() functionality with ranges

@Test function ArraySlice()
   arr = array.new(10, 'int')
   for i = 0, 9 do
      arr[i] = i * 10
   end

   -- Slice middle portion using range (exclusive by default)
   sliced = arr:slice({2..5})
   assert(#sliced is 3, "slice({2..5}) should have length 3, got " .. tostring(#sliced))
   assert(sliced[0] is 20, "slice[0] should be 20")
   assert(sliced[1] is 30, "slice[1] should be 30")
   assert(sliced[2] is 40, "slice[2] should be 40")

   -- Slice from start
   sliced2 = arr:slice({0..3})
   assert(#sliced2 is 3, "slice({0..3}) should have length 3")
   assert(sliced2[0] is 0, "slice2[0] should be 0")

   -- Slice to end using inclusive range
   sliced3 = arr:slice({7...9})
   assert(#sliced3 is 3, "slice({7...9}) should have length 3")
   assert(sliced3[0] is 70, "slice3[0] should be 70")
   assert(sliced3[2] is 90, "slice3[2] should be 90")
end

@Test function ArraySliceNegativeIndices()
   arr = array.new(5, 'int')
   for i = 0, 4 do
      arr[i] = i
   end

   -- Slice using negative end index (negative indices are always inclusive)
   sliced = arr:slice({0..-1})
   assert(#sliced is 5, "slice({0..-1}) should have length 5")
   assert(sliced[4] is 4, "slice({0..-1})[4] should be 4")

   -- Slice using negative start index
   sliced2 = arr:slice({-2..-1})
   assert(#sliced2 is 2, "slice({-2..-1}) should have length 2")
   assert(sliced2[0] is 3, "slice({-2..-1})[0] should be 3")
   assert(sliced2[1] is 4, "slice({-2..-1})[1] should be 4")
end

@Test function ArraySliceEdgeCases()
   arr = array.new(5, 'int')
   for i = 0, 4 do
      arr[i] = i
   end

   -- Empty slice (exclusive range where start equals stop)
   sliced = arr:slice({3..3})
   assert(#sliced is 0, "slice({3..3}) should be empty")

   -- Out of bounds (should clamp)
   sliced2 = arr:slice({0..100})
   assert(#sliced2 is 5, "slice({0..100}) should clamp to array length")

   -- Reverse slice using inclusive range (required for reverse)
   sliced3 = arr:slice({4...2})
   assert(#sliced3 is 3, "slice({4...2}) should have length 3 (reverse)")
   assert(sliced3[0] is 4, "reverse slice[0] should be 4")
   assert(sliced3[2] is 2, "reverse slice[2] should be 2")
end

@Test function ArraySliceWithStep()
   arr = array.new(10, 'int')
   for i = 0, 9 do
      arr[i] = i
   end

   -- Slice with step of 2 using range.new(start, stop, inclusive, step)
   sliced = arr:slice(range.new(0, 10, false, 2))
   assert(#sliced is 5, "slice with step=2 should have length 5, got " .. tostring(#sliced))
   assert(sliced[0] is 0, "stepped slice[0] should be 0")
   assert(sliced[1] is 2, "stepped slice[1] should be 2")
   assert(sliced[2] is 4, "stepped slice[2] should be 4")
   assert(sliced[3] is 6, "stepped slice[3] should be 6")
   assert(sliced[4] is 8, "stepped slice[4] should be 8")

   -- Reverse slice with step using range.new (inclusive for reverse)
   sliced2 = arr:slice(range.new(9, 1, true, -2))
   assert(#sliced2 is 5, "reverse slice with step=-2 should have length 5, got " .. tostring(#sliced2))
   assert(sliced2[0] is 9, "reverse stepped slice[0] should be 9")
   assert(sliced2[1] is 7, "reverse stepped slice[1] should be 7")
   assert(sliced2[4] is 1, "reverse stepped slice[4] should be 1")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test array.sort() functionality

@Test function ArraySortAscending()
   arr = array.new(5, 'int')
   arr[0] = 30
   arr[1] = 10
   arr[2] = 50
   arr[3] = 20
   arr[4] = 40

   arr:sort()

   assert(arr[0] is 10, "sorted arr[0] should be 10")
   assert(arr[1] is 20, "sorted arr[1] should be 20")
   assert(arr[2] is 30, "sorted arr[2] should be 30")
   assert(arr[3] is 40, "sorted arr[3] should be 40")
   assert(arr[4] is 50, "sorted arr[4] should be 50")
end

@Test function ArraySortDescending()
   arr = array.new(5, 'int')
   arr[0] = 30
   arr[1] = 10
   arr[2] = 50
   arr[3] = 20
   arr[4] = 40

   arr:sort(true)

   assert(arr[0] is 50, "desc sorted arr[0] should be 50")
   assert(arr[1] is 40, "desc sorted arr[1] should be 40")
   assert(arr[2] is 30, "desc sorted arr[2] should be 30")
   assert(arr[3] is 20, "desc sorted arr[3] should be 20")
   assert(arr[4] is 10, "desc sorted arr[4] should be 10")
end

@Test function ArraySortFloat()
   arr = array.new(5, 'float')
   arr[0] = 3.14
   arr[1] = 1.41
   arr[2] = 2.71
   arr[3] = 0.57
   arr[4] = 1.73

   arr:sort()

   assert(arr[0] < arr[1], "sorted floats should be in order: arr[0] < arr[1]")
   assert(arr[1] < arr[2], "sorted floats should be in order: arr[1] < arr[2]")
   assert(arr[2] < arr[3], "sorted floats should be in order: arr[2] < arr[3]")
   assert(arr[3] < arr[4], "sorted floats should be in order: arr[3] < arr[4]")
end

@Test function ArraySortAlreadySorted()
   arr = array.new(5, 'int')
   for i = 0, 4 do
      arr[i] = i
   end

   arr:sort()

   for i = 0, 4 do
      assert(arr[i] is i, "already sorted array should remain unchanged")
   end
end

@Test function ArraySortDuplicates()
   arr = array.new(5, 'int')
   arr[0] = 20
   arr[1] = 10
   arr[2] = 20
   arr[3] = 10
   arr[4] = 30

   arr:sort()

   assert(arr[0] is 10, "sorted with dups arr[0] should be 10")
   assert(arr[1] is 10, "sorted with dups arr[1] should be 10")
   assert(arr[2] is 20, "sorted with dups arr[2] should be 20")
   assert(arr[3] is 20, "sorted with dups arr[3] should be 20")
   assert(arr[4] is 30, "sorted with dups arr[4] should be 30")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test array.fill() with range support

@Test function ArrayFillWithRange()
   arr = array.new(10, 'int')
   arr:clear()

   -- Fill with range (exclusive)
   arr:fill(99, {2..5})
   assert(arr[0] is 0, "fill range: arr[0] should be 0")
   assert(arr[1] is 0, "fill range: arr[1] should be 0")
   assert(arr[2] is 99, "fill range: arr[2] should be 99")
   assert(arr[3] is 99, "fill range: arr[3] should be 99")
   assert(arr[4] is 99, "fill range: arr[4] should be 99")
   assert(arr[5] is 0, "fill range: arr[5] should be 0")
end

@Test function ArrayFillWithInclusiveRange()
   arr = array.new(10, 'int')
   arr:clear()

   -- Fill with inclusive range
   arr:fill(77, {2...5})
   assert(arr[1] is 0, "fill inclusive: arr[1] should be 0")
   assert(arr[2] is 77, "fill inclusive: arr[2] should be 77")
   assert(arr[3] is 77, "fill inclusive: arr[3] should be 77")
   assert(arr[4] is 77, "fill inclusive: arr[4] should be 77")
   assert(arr[5] is 77, "fill inclusive: arr[5] should be 77")
   assert(arr[6] is 0, "fill inclusive: arr[6] should be 0")
end

@Test function ArrayFillWithNegativeRange()
   arr = array.new(5, 'int')
   arr:clear()

   -- Fill last 2 elements using negative indices
   arr:fill(55, {-2..-1})
   assert(arr[0] is 0, "fill negative: arr[0] should be 0")
   assert(arr[1] is 0, "fill negative: arr[1] should be 0")
   assert(arr[2] is 0, "fill negative: arr[2] should be 0")
   assert(arr[3] is 55, "fill negative: arr[3] should be 55")
   assert(arr[4] is 55, "fill negative: arr[4] should be 55")
end

@Test function ArrayFillWithSteppedRange()
   arr = array.new(10, 'int')
   arr:clear()

   -- Fill every other element using range.new(start, stop, inclusive, step)
   arr:fill(33, range.new(0, 10, false, 2))
   assert(arr[0] is 33, "fill stepped: arr[0] should be 33")
   assert(arr[1] is 0, "fill stepped: arr[1] should be 0")
   assert(arr[2] is 33, "fill stepped: arr[2] should be 33")
   assert(arr[3] is 0, "fill stepped: arr[3] should be 0")
   assert(arr[4] is 33, "fill stepped: arr[4] should be 33")
   assert(arr[8] is 33, "fill stepped: arr[8] should be 33")
   assert(arr[9] is 0, "fill stepped: arr[9] should be 0")
end

@Test function ArrayFillOriginalSyntax()
   -- Verify original syntax still works
   arr = array.new(10, 'int')
   arr:clear()

   -- Fill starting at index 3, 4 elements
   arr:fill(42, 3, 4)
   assert(arr[2] is 0, "fill original: arr[2] should be 0")
   assert(arr[3] is 42, "fill original: arr[3] should be 42")
   assert(arr[4] is 42, "fill original: arr[4] should be 42")
   assert(arr[5] is 42, "fill original: arr[5] should be 42")
   assert(arr[6] is 42, "fill original: arr[6] should be 42")
   assert(arr[7] is 0, "fill original: arr[7] should be 0")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test array.find() with range support

@Test function ArrayFindWithRange()
   arr = array.new(10, 'int')
   for i = 0, 9 do
      arr[i] = i * 10
   end

   -- Find within a range (exclusive)
   assert(arr:find(30, {0..5}) is 3, "find in range: should find 30 at index 3")
   assert(arr:find(50, {0..5}) is nil, "find in range: 50 should not be found (outside range)")
   assert(arr:find(70, {5..10}) is 7, "find in range: should find 70 at index 7")
end

@Test function ArrayFindWithInclusiveRange()
   arr = array.new(10, 'int')
   for i = 0, 9 do
      arr[i] = i * 10
   end

   -- Find within an inclusive range
   assert(arr:find(50, {0...5}) is 5, "find inclusive: should find 50 at index 5")
   assert(arr:find(50, {0..5}) is nil, "find exclusive: 50 should not be found at boundary")
end

@Test function ArrayFindWithNegativeRange()
   arr = array.new(5, 'int')
   arr[0] = 10
   arr[1] = 20
   arr[2] = 30
   arr[3] = 20  -- duplicate
   arr[4] = 40

   -- Find in last 3 elements using negative indices
   assert(arr:find(20, {-3..-1}) is 3, "find negative: should find 20 at index 3")
   assert(arr:find(10, {-3..-1}) is nil, "find negative: 10 should not be found in last 3")
end

@Test function ArrayFindWithReverseRange()
   arr = array.new(5, 'int')
   arr[0] = 10
   arr[1] = 20
   arr[2] = 30
   arr[3] = 20  -- duplicate
   arr[4] = 40

   -- Find searching backwards (should find the later occurrence first)
   assert(arr:find(20, {4...0}) is 3, "find reverse: should find 20 at index 3 (searching from end)")
end

@Test function ArrayFindWithSteppedRange()
   arr = array.new(10, 'int')
   for i = 0, 9 do
      arr[i] = (i % 2 is 0) ? 100 :> i * 10
   end
   -- arr = {100, 10, 100, 30, 100, 50, 100, 70, 100, 90}

   -- Find only checking odd indices
   assert(arr:find(30, range.new(1, 9, false, 2)) is 3, "find stepped: should find 30 at index 3")
   assert(arr:find(100, range.new(1, 9, false, 2)) is nil, "find stepped: 100 not at odd indices")
end

@Test function ArrayFindOriginalSyntax()
   -- Verify original syntax still works
   arr = array.new(10, 'int')
   for i = 0, 9 do
      arr[i] = i * 10
   end

   assert(arr:find(0) is 0, "find original: should find 0 at index 0")
   assert(arr:find(50) is 5, "find original: should find 50 at index 5")
   assert(arr:find(50, 6) is nil, "find original: 50 should not be found starting at 6")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test array.type() functionality

@Test function ArrayType()
   int_arr = array.new(5, 'int')
   assert(int_arr:type() is 'int', "int array type should be 'int'")

   float_arr = array.new(5, 'float')
   assert(float_arr:type() is 'float', "float array type should be 'float'")

   double_arr = array.new(5, 'double')
   assert(double_arr:type() is 'double', "double array type should be 'double'")

   byte_arr = array.new(5, 'byte')
   assert(byte_arr:type() is 'char', "byte array type should be 'char'")

   char_arr = array.new(5, 'char')
   assert(char_arr:type() is 'char', "char array type should be 'char'")

   int16_arr = array.new(5, 'int16')
   assert(int16_arr:type() is 'int16', "int16 array type should be 'int16'")

   int64_arr = array.new(5, 'int64')
   assert(int64_arr:type() is 'int64', "int64 array type should be 'int64'")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test array.readOnly() functionality

@Test function ArrayReadOnly()
   arr = array.new(5, 'int')
   -- Normal arrays should not be read-only
   assert(arr:readOnly() is false, "normal array should not be read-only")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test int64 array type

@Test function Int64Array()
   arr = array.new(3, 'int64')
   arr[0] = 1234567890123
   arr[1] = -9876543210987
   arr[2] = 0

   assert(arr[0] is 1234567890123, "int64 array should store large positive value")
   assert(arr[1] is -9876543210987, "int64 array should store large negative value")
   assert(arr[2] is 0, "int64 array should store zero")
   assert(arr:type() is 'int64', "int64 array type should be 'int64'")
end

@Test function Int64ArraySort()
   arr = array.new(5, 'int64')
   arr[0] = 3000000000000
   arr[1] = 1000000000000
   arr[2] = 5000000000000
   arr[3] = 2000000000000
   arr[4] = 4000000000000

   arr:sort()

   assert(arr[0] is 1000000000000, "sorted int64 arr[0] should be smallest")
   assert(arr[4] is 5000000000000, "sorted int64 arr[4] should be largest")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test empty array edge cases

@Test function EmptyArrayEdgeCases()
   -- Create zero-length arrays of different types
   empty_int = array.new(0, 'int')
   assert(#empty_int is 0, "empty int array should have length 0")
   assert(empty_int:type() is 'int', "empty int array should have type 'int'")

   empty_float = array.new(0, 'float')
   assert(#empty_float is 0, "empty float array should have length 0")

   -- concat on empty array should return empty string
   result = empty_int:concat('%d', ', ')
   assert(result is '', "concat on empty array should return empty string")

   -- find on empty array should return nil
   found = empty_int:find(42)
   assert(found is nil, "find on empty array should return nil")

   -- reverse on empty array should not error
   empty_int:reverse()
   assert(#empty_int is 0, "reverse on empty array should keep length 0")

   -- sort on empty array should not error
   empty_int:sort()
   assert(#empty_int is 0, "sort on empty array should keep length 0")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test array created from string

@Test function ArrayFromString()
   str = 'Hello'
   arr = array.new(str)

   assert(#arr is 5, "array from string should have correct length")
   assert(arr:type() is 'char', "array from string should be char type")
   assert(arr[0] is 72, "arr[0] should be 'H' (72)")
   assert(arr[1] is 101, "arr[1] should be 'e' (101)")
   assert(arr[4] is 111, "arr[4] should be 'o' (111)")

   -- Test getString on array created from string
   extracted = arr:getString(0, 5)
   assert(extracted is 'Hello', "getString should extract original string")
end

-----------------------------------------------------------------------------------------------------------------------
-- Test large array operations

@Test function LargeArrayOperations()
   -- Create a larger array
   arr = array.new(1000, 'int')

   -- Fill it
   for i = 0, 999 do
      arr[i] = i
   end

   -- Verify first and last elements
   assert(arr[0] is 0, "large array first element should be 0")
   assert(arr[999] is 999, "large array last element should be 999")

   -- Test find on large array
   found = arr:find(500)
   assert(found is 500, "find on large array should work")

   -- Test reverse on large array
   arr:reverse()
   assert(arr[0] is 999, "reversed large array first element should be 999")
   assert(arr[999] is 0, "reversed large array last element should be 0")
end

@Test function LargeArraySort()
   arr = array.new(100, 'int')

   -- Fill with descending values
   for i = 0, 99 do
      arr[i] = 99 - i
   end

   arr:sort()

   -- Verify sorted order
   for i = 0, 99 do
      assert(arr[i] is i, "sorted large array element " .. i .. " should be " .. i)
   end
end
