-- Flute tests for the ?? operator (if-empty: nil, false, 0, "")

function testNil()
   local v = nil ?? "A"
   assert(v is "A", "Failed nil case: expected 'A', got '" .. nz(v, 'NIL') .. "'")

   local Options = { quit = nil }
   local v = (Options.quit ?? nil)
   assert(v is nil, "Expected nil, got " .. tostring(v))

   Options.quit = true
   local v = (Options.quit ?? nil)
   assert(v is true, "Expected true, got " .. tostring(v))
end

function testFalse()
   local v = false ?? "A"
   assert(v is "A", "Failed false case: expected 'A', got '" .. tostring(v) .. "'")
end

function testZero()
   local v = 0 ?? "A"
   assert(v is "A", "Failed zero case: expected 'A', got '" .. tostring(v) .. "'")
end

function testEmptyString()
   local v = "" ?? "A"
   assert(v is "A", "Failed empty string case: expected 'A', got '" .. tostring(v) .. "'")
end

function testTruthyString()
   local v = "X" ?? "A"
   assert(v is "X", "Failed truthy string case: expected 'X', got '" .. tostring(v) .. "'")
end

function testTruthyNumber()
   local v = 5 ?? "A"
   assert(v is 5, "Failed truthy number case: expected 5, got '" .. tostring(v) .. "'")
end

----------------------------------------------------------------------------------------------------------------------
-- Basic checks with a function on either side

function testFunction()
   local function returnString()
      return "Result"
   end

   local v = returnString('ignore') ?? "A"
   assert(v is "Result", "Failed function case 1, got '" .. tostring(v) .. "'")

   local v = nil ?? returnString('ignore')
   assert(v is "Result", "Failed function case 2, got '" .. tostring(v) .. "'")
end

----------------------------------------------------------------------------------------------------------------------
-- Test if-empty in conjunction with concatenation - note that bugs raised could be in either feature or in
-- combination of both

function testConcat()
   local function returnString()
      return "Result"
   end

   local v = 'start ' .. (nil ?? returnString('ignore')) .. ' end'
   assert(v is "start Result end", "Failed concat-function 1, got '" .. tostring(v) .. "'")

   local val
   local v = '' .. (val ?? returnString('ignore'))
   assert(v is "Result", "Failed concat-function 2, got '" .. tostring(v) .. "'")
end

----------------------------------------------------------------------------------------------------------------------
-- This unusual test has been observed as throwing errors in some cases

function testConcatMsg()
   local function fakeFunction(value)
      assert(value is 1, "Expected LHS to be preserved, got '" .. tostring(value) .. "'")
      return nil
   end
   local Number = 1
   fakeFunction(Number ?? 2) -- Our own function
   msg(Number ?? 2) -- A built-in function
   msg('<' .. (Number ?? 2) .. '>') -- A built-in function with concatenation
end

----------------------------------------------------------------------------------------------------------------------

function testTable()
   local t = { a=1, b=2, c=3}
   local v = t ?? 'Nothing'
   assert(v['a'] is 1, "Failed table case: expected table, got '" .. tostring(v) .. "'")

   local v = 'x' ?? { 'Nothing' }
   assert(v is 'x', "Failed table case: expected table, got '" .. tostring(v) .. "'")

   local v = t ?? { 'Nothing' }
   assert(v['a'] is 1, "Failed table case: expected table, got '" .. tostring(v) .. "'")
end

----------------------------------------------------------------------------------------------------------------------

function testTableAccessLHS()
   local t = { }
   table.insert(t, 10)
   table.insert(t, 20)
   table.insert(t, 30)
   table.insert(t, 40)

   local one = (t[0] ?? 0)
   local two = (t[1] ?? 0)

   assert(one is 10, "Array access LHS test failed for first element: expected 10, got '" .. tostring(one) .. "'")
   assert(two is 20, "Array access LHS test failed for second element: expected 20, got '" .. tostring(two) .. "'")

   local str = (0 ?? -1)
   assert(str is -1, "Array access LHS test failed for zero value: expected -1, got '" .. tostring(str) .. "'")

   -- Ternary version - establishes a benchmark
   status = t.missing ? 'exists' :> 'missing'
   assert(status is 'missing', "Failed table key test: expected 'ok', got '" .. tostring(status) .. "'")

   status = t.missing ?? 'missing'
   assert(status is 'missing', "Failed table key test: expected 'missing', got '" .. tostring(status) .. "'")
end

----------------------------------------------------------------------------------------------------------------------
-- Ensure RHS is not evaluated when LHS is truthy

function testShortCircuitTruth()
   local function rhs()
      error("RHS should not be evaluated when LHS is truthy")
   end
   local v = "X" ?? rhs()
   assert(v is "X", "Failed short-circuit truth: expected 'X', got '" .. tostring(v) .. "'")
end

----------------------------------------------------------------------------------------------------------------------
-- Ensure RHS is not evaluated when LHS is a RUNTIME truthy value (not compile-time constant)

function testShortCircuitRuntimeTruthy()
   local call_count = 0
   local function rhs()
      call_count = call_count + 1
      return "RHS"
   end

   -- Use a function to get the LHS value so it's not a compile-time constant
   local function getLHS()
      return "Hello"
   end

   local lhs_value = getLHS()
   local result = lhs_value ?? rhs()

   assert(result is "Hello", "Failed runtime short-circuit: expected 'Hello', got '" .. tostring(result) .. "'")
   assert(call_count is 0, "BUG: RHS was evaluated " .. tostring(call_count) .. " times when LHS was runtime truthy")
end

----------------------------------------------------------------------------------------------------------------------
-- Ensure RHS is evaluated exactly once when LHS is extended-falsey

function testRHSOnce()
   local count = 0
   local function rhs()
      count += 1
      return "Y"
   end
   local v = 0 ?? rhs()
   assert(v is "Y", "Failed RHS once value: expected 'Y', got '" .. tostring(v) .. "'")
   assert(count is 1, "Failed RHS once count: expected 1, got " .. tostring(count))
end

----------------------------------------------------------------------------------------------------------------------
-- Chaining behaviour

function testChaining()
   local v1 = "" ?? 0 ?? "A"
   assert(v1 is "A", "Failed chaining case 1: expected 'A', got '" .. tostring(v1) .. "'")

   local v2 = "X" ?? "" ?? "A"
   assert(v2 is "X", "Failed chaining case 2: expected 'X', got '" .. tostring(v2) .. "'")
end

----------------------------------------------------------------------------------------------------------------------
-- Interaction with logical or: ensure semantics differ (0 and "" are treated as truthy by Lua or)

function testDifferenceFromLuaOr()
   local a = 0 or "B"      -- Lua or: 0 is truthy
   local b = 0 ?? "B"        -- ??: 0 is falsey
   assert(a is 0, "Sanity: Lua 'or' should keep 0; got '" .. tostring(a) .. "'")
   assert(b is "B", "?? should replace 0 with RHS; got '" .. tostring(b) .. "'")

   local c = "" or "C"      -- Lua or: empty string is truthy
   local d = "" ?? "C"       -- ??: empty string is falsey
   assert(c is "", "Sanity: Lua 'or' should keep empty string; got '" .. tostring(c) .. "'")
   assert(d is "C", "?? should replace empty string with RHS; got '" .. tostring(d) .. "'")
end

function testRuntimeZero()
   local x = 0
   local v = x ?? "A"
   assert(v is "A", "Runtime zero test failed: expected 'A', got '" .. tostring(v) .. "'")
end

----------------------------------------------------------------------------------------------------------------------
-- Test the use of if-empty within a function

function testIfEmptyArgumentLeakCapture()
   local Function = { status = 'Hello' }
   local record = { count = 0, first = nil, second = nil }

   local function capture(...)
      local args = { ... }
      record.count = #args
      record.first = args[0]
      record.second = args[1]
   end

   capture(Function.status ?? 'then')

   assert(record.count is 1, "Expected a single argument after fixing the leak, got '" .. tostring(record.count) .. "'")
   assert(record.first is 'Hello', "Expected first argument to remain 'Hello', got '" .. tostring(record.first) .. "'")
   assert(record.second is nil, "Expected leaked slot to be cleared, got '" .. tostring(record.second) .. "'")
end

function testIfEmptyStringFindError()
   local Function = { status = 'Hello' }

   local ok, start_index, end_index = pcall(function()
      return string.find((Function.status ?? 'then'), 'e')
   end)

   assert(ok is true, "string.find should succeed once the argument leak is fixed")
   assert(start_index is 1, "Expected search to start at index 1, got '" .. tostring(start_index) .. "'")
   assert(end_index is 1, "Expected search to end at index 1, got '" .. tostring(end_index) .. "'")
end

function testMethodCallInOptionalForm()
   local obj = {
      getValue = function(self)
         return "method_result"
      end
   }
   local v = obj:getValue() ?? "default"
   assert(v is "method_result", "Failed method call in optional form: expected 'method_result', got " .. tostring(v))
end

function testNestedOptional()
   local v = (nil ?? "A") ?? "B"
   -- First: nil ?? "A" = "A"
   -- Then: "A" ?? "B" = "A"
   assert(v is "A", "Failed nested optional: expected 'A', got " .. tostring(v))
end

function testOptionalReturnValue()
   local function test()
      return nil ?? "default"
   end
   local result = test()
   assert(result is "default", "Failed optional return value: expected 'default', got " .. tostring(result))
end

function testOptionalTableField()
   local t = { msg = "Hello" }
   local v = t.msg ?? "default"
   assert(v is "Hello", "Failed optional table field: expected 'Hello', got " .. tostring(v))
end

function testOptionalMissingField()
   local t = {}
   local v = t.missing ?? "default"
   assert(v is "default", "Failed optional missing field: expected 'default', got " .. tostring(v))
end

-- Optional - falsey condition (empty string)
function testOptionalEmptyString()
   local name = "" ?? "Anonymous"
   assert(name is "Anonymous", "Failed optional empty string: expected 'Anonymous', got " .. tostring(name))
end

-- Optional - short-circuit
function testOptionalShortCircuit()
   local called = false
   local function expensive()
      called = true
      return "default"
   end
   local msg = "Hello" ?? expensive()
   assert(msg is "Hello", "Failed optional short-circuit: expected 'Hello', got " .. tostring(msg))
   assert(not called, "Expensive function should not be called")
end

-- Optional - runtime condition
function testOptionalRuntimeTruthy()
   local x = 10
   local result = x ?? 0
   assert(result is 10, "Failed optional runtime truthy: expected 10, got " .. tostring(result))
end

function testOptionalRuntimeFalsey()
   local x = 0
   local result = x ?? 100
   assert(result is 100, "Failed optional runtime falsey: expected 100, got " .. tostring(result))
end

-- Optional - truthy condition
function testOptionalTruthyString()
   local msg = "Hello" ?? "No message"
   assert(msg is "Hello", "Failed optional truthy string: expected 'Hello', got " .. tostring(msg))
end

function testOptionalTruthyNumber()
   local count = 5 ?? 0
   assert(count is 5, "Failed optional truthy number: expected 5, got " .. tostring(count))
end

function testOptionalTruthyNegative()
   local num = -10 ?? 0
   assert(num is -10, "Failed optional truthy negative: expected -10, got " .. tostring(num))
end

-- Optional - falsey condition (nil)
function testOptionalNil()
   local msg = nil ?? "No message given"
   assert(msg is "No message given", "Failed optional nil: expected 'No message given', got " .. tostring(msg))
end

-- Optional - falsey condition (false)
function testOptionalFalse()
   local msg = false ?? "No message given"
   assert(msg is "No message given", "Failed optional false: expected 'No message given', got " .. tostring(msg))
end

-- Optional - falsey condition (0)
function testOptionalZero()
   local count = 0 ?? 1
   assert(count is 1, "Failed optional zero: expected 1, got " .. tostring(count))
end

function testInFunction()
   local Function = { status = 'Hello' }

   -- If-empty operator within a function
   local result = string.find((Function.status ?? 'then'), 'e')
   assert(result is 1, "Failed test: expected 1, got " .. tostring(result))
end

function testShortHand()
   local not_true = false
   local returned_early = true
   local function test()
      not_true ?? return
      returned_early = false
   end

   test()
   assert(returned_early is true, "Failed shorthand optional early return test")
end

-- Test return with value
function testShortHandReturnValue()
   local function getValue(input)
      input ?? return "default"
      return input
   end

   assert(getValue(nil) is "default", "nil should return default")
   assert(getValue(false) is "default", "false should return default")
   assert(getValue(0) is "default", "0 should return default")
   assert(getValue("") is "default", "empty string should return default")
   assert(getValue("hello") is "hello", "truthy should return input")
   assert(getValue(42) is 42, "truthy number should return input")
end

-- Test break in loop
function testShortHandBreak()
   local iterations = 0
   local values = { 1, 2, 0, 4, 5 }  -- 0 at index 2 should break

   for i = 0, #values - 1 do
      values[i] ?? break
      iterations += 1
   end

   assert(iterations is 2, "Should break after 2 iterations, got " .. tostring(iterations))
end

-- Test continue in loop
function testShortHandContinue()
   local sum = 0
   local values = { 1, 0, 2, "", 3 }  -- Skip falsey values

   for i = 0, #values - 1 do
      values[i] ?? continue
      sum += values[i]
   end

   assert(sum is 6, "Sum should be 6 (1+2+3), got " .. tostring(sum))
end

-- Test with runtime values (not compile-time constants)
function testShortHandRuntimeCondition()
   local function getCondition()
      return nil
   end

   local executed_body = false
   local function test()
      getCondition() ?? return
      executed_body = true
   end

   test()
   assert(executed_body is false, "Body should not execute when condition is falsey")
end

-- Test truthy condition does not execute body
function testShortHandTruthySkipsBody()
   local body_executed = false
   local function test()
      "truthy" ?? return
      body_executed = true
   end

   test()
   assert(body_executed is true, "Body should execute when condition is truthy")
end

----------------------------------------------------------------------------------------------------------------------

   return {
      tests = {
         'testNil', 'testFalse', 'testZero', 'testEmptyString', 'testTruthyString', 'testTruthyNumber',
         'testShortCircuitTruth', 'testShortCircuitRuntimeTruthy', 'testRHSOnce', 'testChaining', 'testDifferenceFromLuaOr',
         'testRuntimeZero', 'testTable', 'testFunction', 'testConcat', 'testConcatMsg',
         'testTableAccessLHS', 'testIfEmptyArgumentLeakCapture', 'testIfEmptyStringFindError',
         'testMethodCallInOptionalForm', 'testNestedOptional', 'testOptionalReturnValue',
         'testOptionalTableField', 'testOptionalMissingField', 'testOptionalEmptyString',
         'testOptionalShortCircuit', 'testOptionalRuntimeTruthy', 'testOptionalRuntimeFalsey',
         'testOptionalTruthyString', 'testOptionalTruthyNumber', 'testOptionalTruthyNegative',
         'testOptionalNil', 'testOptionalFalse', 'testOptionalZero', 'testInFunction', 'testShortHand',
         'testShortHandReturnValue', 'testShortHandBreak', 'testShortHandContinue',
         'testShortHandRuntimeCondition', 'testShortHandTruthySkipsBody'
      }
   }
