-- Flute tests for the ? operator (if-empty: nil, false, 0, "")

function testNil()
   local v = nil ? "A"
   assert(v is "A", "Failed nil case: expected 'A', got '" .. nz(v, 'NIL') .. "'")

   local Options = { quit = nil }
   local v = (Options.quit ? nil)
   assert(v is nil, "Expected nil, got " .. tostring(v))

   Options.quit = true
   local v = (Options.quit ? nil)
   assert(v is true, "Expected true, got " .. tostring(v))
end

function testFalse()
   local v = false ? "A"
   assert(v is "A", "Failed false case: expected 'A', got '" .. tostring(v) .. "'")
end

function testZero()
   local v = 0 ? "A"
   assert(v is "A", "Failed zero case: expected 'A', got '" .. tostring(v) .. "'")
end

function testEmptyString()
   local v = "" ? "A"
   assert(v is "A", "Failed empty string case: expected 'A', got '" .. tostring(v) .. "'")
end

function testTruthyString()
   local v = "X" ? "A"
   assert(v is "X", "Failed truthy string case: expected 'X', got '" .. tostring(v) .. "'")
end

function testTruthyNumber()
   local v = 5 ? "A"
   assert(v is 5, "Failed truthy number case: expected 5, got '" .. tostring(v) .. "'")
end

----------------------------------------------------------------------------------------------------------------------
-- Basic checks with a function on either side

function testFunction()
   local function returnString()
      return "Result"
   end

   local v = returnString('ignore') ? "A"
   assert(v is "Result", "Failed function case 1, got '" .. tostring(v) .. "'")
   
   local v = nil ? returnString('ignore')
   assert(v is "Result", "Failed function case 2, got '" .. tostring(v) .. "'")
end

----------------------------------------------------------------------------------------------------------------------
-- Test if-empty in conjunction with concatenation - note that bugs raised could be in either feature or in 
-- combination of both

function testConcat()
   local function returnString()
      return "Result"
   end

   local v = 'start ' .. (nil ? returnString('ignore')) .. ' end'
   assert(v is "start Result end", "Failed concat-function 1, got '" .. tostring(v) .. "'")
   
   local val
   local v = '' .. (val ? returnString('ignore'))
   assert(v is "Result", "Failed concat-function 2, got '" .. tostring(v) .. "'")
end

----------------------------------------------------------------------------------------------------------------------
-- This unusual test has been observed as throwing errors in some cases 

function testConcatMsg()
   local function fakeFunction(value)
      assert(value is 1, "Expected LHS to be preserved, got '" .. tostring(value) .. "'")
      return nil
   end
   local Number = 1
   fakeFunction(Number ? 2) -- Our own function
   msg(Number ? 2) -- A built-in function
   msg('<' .. (Number ? 2) .. '>') -- A built-in function with concatenation
end

----------------------------------------------------------------------------------------------------------------------

function testTable()
   local t = { a=1, b=2, c=3}
   local v = t ? 'Nothing'
   assert(v['a'] is 1, "Failed table case: expected table, got '" .. tostring(v) .. "'")

   local v = 'x' ? { 'Nothing' }
   assert(v is 'x', "Failed table case: expected table, got '" .. tostring(v) .. "'")

   local v = t ? { 'Nothing' }
   assert(v['a'] is 1, "Failed table case: expected table, got '" .. tostring(v) .. "'")
end

----------------------------------------------------------------------------------------------------------------------
-- Ensure RHS is not evaluated when LHS is truthy

function testShortCircuitTruth()
   local function rhs()
      error("RHS should not be evaluated when LHS is truthy")
   end
   local v = "X" ? rhs()
   assert(v is "X", "Failed short-circuit truth: expected 'X', got '" .. tostring(v) .. "'")
end

----------------------------------------------------------------------------------------------------------------------
-- Ensure RHS is evaluated exactly once when LHS is extended-falsey

function testRHSOnce()
   local count = 0
   local function rhs()
      count += 1
      return "Y"
   end
   local v = 0 ? rhs()
   assert(v is "Y", "Failed RHS once value: expected 'Y', got '" .. tostring(v) .. "'")
   assert(count is 1, "Failed RHS once count: expected 1, got " .. tostring(count))
end

----------------------------------------------------------------------------------------------------------------------
-- Chaining behaviour

function testChaining()
   local v1 = "" ? 0 ? "A"
   assert(v1 is "A", "Failed chaining case 1: expected 'A', got '" .. tostring(v1) .. "'")

   local v2 = "X" ? "" ? "A"
   assert(v2 is "X", "Failed chaining case 2: expected 'X', got '" .. tostring(v2) .. "'")
end

----------------------------------------------------------------------------------------------------------------------
-- Interaction with logical or: ensure semantics differ (0 and "" are treated as truthy by Lua or)

function testDifferenceFromLuaOr()
   local a = 0 or "B"      -- Lua or: 0 is truthy
   local b = 0 ? "B"        -- ?: 0 is falsey
   assert(a is 0, "Sanity: Lua 'or' should keep 0; got '" .. tostring(a) .. "'")
   assert(b is "B", "? should replace 0 with RHS; got '" .. tostring(b) .. "'")

   local c = "" or "C"      -- Lua or: empty string is truthy
   local d = "" ? "C"       -- ?: empty string is falsey
   assert(c is "", "Sanity: Lua 'or' should keep empty string; got '" .. tostring(c) .. "'")
   assert(d is "C", "? should replace empty string with RHS; got '" .. tostring(d) .. "'")
end

function testRuntimeZero()
   local x = 0
   local v = x ? "A"
   assert(v is "A", "Runtime zero test failed: expected 'A', got '" .. tostring(v) .. "'")
end

----------------------------------------------------------------------------------------------------------------------
-- This test is formally maintained in test_if_complex, but enabling the commented section occasionally can reveal 
-- parser issues with the exception 'function or expression too complex'

function testComplex()
   local first = "Hello World"
   local second = nil
--[[
   local inject = [[<table columns="50,0" width="100%" vspacing="4">]]
      .. [[<row><cell>Name:</cell><cell><input name="txtName" string="]] .. (first ? '') .. [[" procedure="dlgResponse" object="[dlgCustom]" args="8"/></input></cell></row>]]
      .. [[<row><cell>Path:</cell><cell><p nowrap><input name="txtPath" string="]] .. (second ? '') .. [[" </cell></row>]]
      .. [[</table>]]
--]]
   msg(inject)
end

----------------------------------------------------------------------------------------------------------------------

   return {
      tests = {
         'testNil', 'testFalse', 'testZero', 'testEmptyString', 'testTruthyString', 'testTruthyNumber',
         'testShortCircuitTruth', 'testRHSOnce', 'testChaining', 'testDifferenceFromLuaOr',
         'testRuntimeZero', 'testTable', 'testFunction', 'testConcat', 'testConcatMsg',
         'testComplex'
      }
   }
