-- $FLUID
-- Comprehensive test suite for the URL module

   url = require('net/url')

-----------------------------------------------------------------------------------------------------------------------
-- Test URL encoding/decoding

function testEncoding()
   -- Basic encoding
   assert(url.encode('hello world') == 'hello%20world', 'Basic space encoding failed')
   assert(url.encode('hello+world') == 'hello%2Bworld', 'Plus sign encoding failed')
   assert(url.encode('user@example.com') == 'user%40example.com', 'At sign encoding failed')
   assert(url.encode('path/to/file') == 'path%2Fto%2Ffile', 'Slash encoding failed')

   -- Special characters
   assert(url.encode('!@#$%^&*()') == '%21%40%23%24%25%5E%26%2A%28%29', 'Special chars encoding failed')

   -- Empty/nil handling
   assert(url.encode('') == '', 'Empty string encoding failed')
   assert(url.encode(nil) == nil, 'Nil encoding should return nil')

   -- Plus encoding for forms
   assert(url.encodePlus('hello world') == 'hello+world', 'Plus space encoding failed')
   assert(url.encodePlus('test+case') == 'test%2Bcase', 'Plus sign in plus encoding failed')
end

function testDecoding()
   -- Basic decoding
   assert(url.decode('hello%20world') == 'hello world', 'Basic space decoding failed')
   assert(url.decode('user%40example.com') == 'user@example.com', 'At sign decoding failed')
   assert(url.decode('path%2Fto%2Ffile') == 'path/to/file', 'Slash decoding failed')

   -- Case insensitive hex
   assert(url.decode('test%2a') == 'test*', 'Lowercase hex decoding failed')
   assert(url.decode('test%2A') == 'test*', 'Uppercase hex decoding failed')

   -- Plus decoding for forms
   assert(url.decodePlus('hello+world') == 'hello world', 'Plus space decoding failed')
   assert(url.decodePlus('test%2Bcase') == 'test+case', 'Encoded plus decoding failed')

   -- Empty/nil handling
   assert(url.decode('') == '', 'Empty string decoding failed')
   assert(url.decode(nil) == nil, 'Nil decoding should return nil')

   -- Round-trip test
   local original = 'Hello World! @#$%^&*()'
   local encoded = url.encode(original)
   local decoded = url.decode(encoded)
   assert(decoded == original, 'Round-trip encoding/decoding failed')
end

-----------------------------------------------------------------------------------------------------------------------
-- Test query string parsing

function testQueryParsing()
   -- Basic query parsing
   local params = url.parseQuery('name=John&age=30&city=New%20York')
   assert(params.name == 'John', 'Basic query param failed')
   assert(params.age == '30', 'Numeric query param failed')
   assert(params.city == 'New York', 'Encoded query param failed')

   -- Empty query
   local empty = url.parseQuery('')
   assert(type(empty) == 'table' and next(empty) == nil, 'Empty query should return empty table')

   -- Query with no values
   local novals = url.parseQuery('flag1&flag2')
   assert(novals.flag1 == '', 'No-value param should be empty string')
   assert(novals.flag2 == '', 'No-value param should be empty string')

   -- Duplicate keys
   local dups = url.parseQuery('tag=red&tag=blue&tag=green')
   assert(type(dups.tag) == 'table', 'Duplicate keys should create table')
   assert(#dups.tag == 3, 'Should have 3 values for duplicate key')
   assert(dups.tag[1] == 'red' and dups.tag[2] == 'blue' and dups.tag[3] == 'green', 'Duplicate values incorrect')

   -- Plus encoding in query
   local plus = url.parseQuery('message=hello+world&name=John+Doe')
   assert(plus.message == 'hello world', 'Plus decoding in query failed')
   assert(plus.name == 'John Doe', 'Plus decoding in name failed')
end

function testQueryList()
   -- Parse as list to preserve order
   local list = url.parseQueryList('first=1&second=2&first=3')
   assert(#list == 3, 'Query list should have 3 items')
   assert(list[1].key == 'first' and list[1].value == '1', 'First item incorrect')
   assert(list[2].key == 'second' and list[2].value == '2', 'Second item incorrect')
   assert(list[3].key == 'first' and list[3].value == '3', 'Third item incorrect')
end

function testQueryBuilding()
   -- Build from table
   local params = { name = 'John Doe', age = 30, active = true }
   local query = url.buildQuery(params)

   -- Parse back to verify
   local parsed = url.parseQuery(query)
   assert(parsed.name == 'John Doe', 'Built query name incorrect')
   assert(parsed.age == '30', 'Built query age incorrect')
   assert(parsed.active == 'true', 'Built query boolean incorrect')

   -- Build from list
   local list = {
      { key = 'first', value = '1' },
      { key = 'second', value = '2' },
      { key = 'first', value = '3' }
   }
   local listQuery = url.buildQuery(list)
   assert(listQuery == 'first=1&second=2&first=3', 'List query building failed')

   -- Build with special characters
   local special = { }
   special['hello world'] = 'test&value'
   special['key=name'] = 'John+Doe'

   local specialQuery = url.buildQuery(special)
   local specialParsed = url.parseQuery(specialQuery)
   assert(specialParsed['hello world'] == 'test&value', 'Special char key failed')
   assert(specialParsed['key=name'] == 'John+Doe', 'Special char value failed')
end

-----------------------------------------------------------------------------------------------------------------------
-- Test URL parsing

function testBasicParsing()
   -- Simple HTTP URL
   local parts = url.parse('https://example.com/path?query=value#section')
   assert(parts.scheme == 'https', 'Scheme parsing failed')
   assert(parts.host == 'example.com', 'Host parsing failed')
   assert(parts.path == '/path', 'Path parsing failed')
   assert(parts.query == 'query=value', 'Query parsing failed')
   assert(parts.fragment == 'section', 'Fragment parsing failed')

   -- URL with port
   local withPort = url.parse('http://localhost:8080/api/test')
   assert(withPort.scheme == 'http', 'Port URL scheme failed')
   assert(withPort.host == 'localhost', 'Port URL host failed')
   assert(withPort.port == 8080, 'Port parsing failed')
   assert(withPort.path == '/api/test', 'Port URL path failed')

   -- URL with auth
   local withAuth = url.parse('ftp://user:pass@ftp.example.com/files/')
   assert(withAuth.scheme == 'ftp', 'Auth URL scheme failed')
   assert(withAuth.auth == 'user:pass', 'Auth parsing failed')
   assert(withAuth.host == 'ftp.example.com', 'Auth URL host failed')
   assert(withAuth.path == '/files/', 'Auth URL path failed')
end

function testIPv6Parsing()
   -- IPv6 host
   local ipv6 = url.parse('http://[2001:db8::1]:8080/path')
   assert(ipv6.host == '2001:db8::1', 'IPv6 host parsing failed')
   assert(ipv6.port == 8080, 'IPv6 port parsing failed')
   assert(ipv6.path == '/path', 'IPv6 path parsing failed')

   -- IPv6 without port
   local ipv6NoPort = url.parse('http://[::1]/test')
   assert(ipv6NoPort.host == '::1', 'IPv6 localhost parsing failed')
   assert(ipv6NoPort.port == nil, 'IPv6 no port should be nil')
end

function testRelativeURLs()
   -- Path-only URL
   local pathOnly = url.parse('/path/to/resource')
   assert(pathOnly.scheme == nil, 'Path-only should have no scheme')
   assert(pathOnly.host == nil, 'Path-only should have no host')
   assert(pathOnly.path == '/path/to/resource', 'Path-only path failed')

   -- Query-only URL
   local queryOnly = url.parse('?query=value')
   assert(queryOnly.path == '', 'Query-only path should be empty')
   assert(queryOnly.query == 'query=value', 'Query-only query failed')

   -- Fragment-only URL
   local fragOnly = url.parse('#section')
   assert(fragOnly.path == '', 'Fragment-only path should be empty')
   assert(fragOnly.fragment == 'section', 'Fragment-only fragment failed')
end

function testURLUnparsing()
   -- Round-trip test
   local original = 'https://user:pass@example.com:8080/path/to/resource;param=value?query=test&foo=bar#section'
   local parsed = url.parse(original)
   local reconstructed = url.unparse(parsed)

   -- Parse both to compare components (order might differ in query)
   local origParts = url.parse(original)
   local reconParts = url.parse(reconstructed)

   assert(origParts.scheme == reconParts.scheme, 'Round-trip scheme failed')
   assert(origParts.host == reconParts.host, 'Round-trip host failed')
   assert(origParts.port == reconParts.port, 'Round-trip port failed')
   assert(origParts.path == reconParts.path, 'Round-trip path failed')
   assert(origParts.fragment == reconParts.fragment, 'Round-trip fragment failed')
end

-----------------------------------------------------------------------------------------------------------------------
-- Test URL joining

function testURLJoining()
   -- Basic relative URL joining
   local joined = url.join('https://example.com/api/', 'users/123')
   assert(joined == 'https://example.com/api/users/123', 'Basic joining failed')

   -- Absolute path joining
   local absJoined = url.join('https://example.com/api/old', '/new/path')
   assert(absJoined == 'https://example.com/new/path', 'Absolute path joining failed')

   -- Parent directory navigation
   local parentJoined = url.join('https://example.com/api/v1/', '../v2/users')
   assert(parentJoined == 'https://example.com/api/v2/users', 'Parent directory joining failed')

   -- Query and fragment handling
   local queryJoined = url.join('https://example.com/base', '?query=value')
   assert(queryJoined == 'https://example.com/base?query=value', 'Query joining failed')

   local fragJoined = url.join('https://example.com/page', '#section')
   assert(fragJoined == 'https://example.com/page#section', 'Fragment joining failed')

   -- Absolute URL overrides base
   local absOverride = url.join('https://old.com/path', 'https://new.com/other')
   assert(absOverride == 'https://new.com/other', 'Absolute URL override failed')
end

function testPathNormalization()
   -- Basic normalization
   assert(url.normalize('/a/b/../c') == '/a/c', 'Basic .. normalization failed')
   assert(url.normalize('/a/./b') == '/a/b', 'Basic . normalization failed')
   assert(url.normalize('/a//b') == '/a/b', 'Double slash normalization failed')

   -- Complex normalization
   assert(url.normalize('/a/b/../../c') == '/c', 'Complex .. normalization failed')
   assert(url.normalize('a/../b') == 'b', 'Relative .. normalization failed')

   -- Edge cases
   assert(url.normalize('/..') == '/', 'Root .. should become /')
   assert(url.normalize('../../a') == '../../a', 'Relative .. beyond root should remain')

   -- Preserve trailing slash
   assert(url.normalize('/a/b/') == '/a/b/', 'Trailing slash should be preserved')
end

-----------------------------------------------------------------------------------------------------------------------
-- Test utility functions

function testUtilities()
   -- Absolute/relative detection
   assert(url.isAbsolute('https://example.com') == true, 'HTTP URL should be absolute')
   assert(url.isAbsolute('ftp://ftp.example.com') == true, 'FTP URL should be absolute')
   assert(url.isAbsolute('/path/to/file') == false, 'Path should be relative')
   assert(url.isAbsolute('relative/path') == false, 'Relative path should be relative')

   assert(url.isRelative('/path') == true, 'Path should be relative')
   assert(url.isRelative('https://example.com') == false, 'HTTP URL should not be relative')

   -- Component extraction
   assert(url.getScheme('https://example.com') == 'https', 'Scheme extraction failed')
   assert(url.getScheme('/path/only') == nil, 'Path-only should have no scheme')

   assert(url.getHost('https://example.com/path') == 'example.com', 'Host extraction failed')
   assert(url.getHost('http://user@localhost:8080') == 'localhost', 'Host with auth/port failed')

   -- Port extraction with defaults
   assert(url.getPort('https://example.com:8080') == 8080, 'Explicit port extraction failed')
   assert(url.getPort('https://example.com') == nil, 'No explicit port should return nil')
   assert(url.getPort('https://example.com', 443) == 443, 'Default port should be used')
   assert(url.getPort('http://example.com') == nil, 'HTTP default should not be auto-added')
end

-----------------------------------------------------------------------------------------------------------------------
-- Test edge cases and error handling

function testEdgeCases()
   -- Empty/nil URLs
   local nilResult = url.parse(nil)
   assert(nilResult == nil, 'Nil URL should return nil')

   local emptyResult = url.parse('')
   assert(emptyResult == nil, 'Empty URL should return nil')

   -- Malformed URLs
   local malformed = url.parse('ht!tp://bad-scheme.com')
   assert(malformed.scheme == nil, 'Bad scheme should not be parsed as scheme')

   -- URL with only scheme
   local schemeOnly = url.parse('file:')
   assert(schemeOnly.scheme == 'file', 'Scheme-only parsing failed')
   assert(schemeOnly.path == '', 'Scheme-only should have empty path')

   -- URLs with special characters
   local special = url.parse('https://example.com/path with spaces?query=value with spaces')
   assert(special.path == '/path with spaces', 'Path with spaces should be preserved')
   assert(special.query == 'query=value with spaces', 'Query with spaces should be preserved')

   -- Very long URLs
   local longPath = string.rep('a', 1000)
   local longURL = 'https://example.com/' .. longPath
   local longParsed = url.parse(longURL)
   assert(longParsed.host == 'example.com', 'Long URL host parsing failed')
   assert(longParsed.path == '/' .. longPath, 'Long URL path parsing failed')
end

function testDefrag()
   -- URL with fragment
   local base, frag = url.defrag('https://example.com/path#section')
   assert(base == 'https://example.com/path', 'Defrag base incorrect')
   assert(frag == 'section', 'Defrag fragment incorrect')

   -- URL without fragment
   local noFragBase, noFragFragment = url.defrag('https://example.com/path')
   assert(noFragBase == 'https://example.com/path', 'No-frag base should be unchanged')
   assert(noFragFragment == nil, 'No-frag fragment should be nil')

   -- Empty fragment
   local emptyFragBase, emptyFrag = url.defrag('https://example.com/path#')
   assert(emptyFragBase == 'https://example.com/path', 'Empty frag base incorrect')
   assert(emptyFrag == '', 'Empty fragment should be empty string')
end

-----------------------------------------------------------------------------------------------------------------------

return {
   tests = {
      'testEncoding',
      'testDecoding',
      'testQueryParsing',
      'testQueryList',
      'testQueryBuilding',
      'testBasicParsing',
      'testIPv6Parsing',
      'testRelativeURLs',
      'testURLUnparsing',
      'testURLJoining',
      'testPathNormalization',
      'testUtilities',
      'testEdgeCases',
      'testDefrag'
   },
   init = function(Folder)
      -- No special initialization needed
   end,
   cleanup = function()
      -- No cleanup needed
   end
}