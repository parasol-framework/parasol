-- Test shadow function transformation for assert()
-- The parser should transform assert(cond, msg) to if not cond then error(msg) end
-- This avoids evaluating the message when the assertion passes.

-- Basic assert that passes (message should not be evaluated)

function testAssertPassesNoEval()
   local message_evaluated = false
   local function get_message()
      message_evaluated = true
      return 'This should not be evaluated'
   end

   assert(true, get_message())
   assert(message_evaluated is false, 'Message was evaluated when assertion passed')
end

-- Basic assert that fails

function testAssertFails()
   local success, err = pcall(function()
      assert(false, 'Custom error message')
   end)

   assert(success is false, 'Assert should have failed')
   assert(err:find('Custom error message') != nil, 'Error message should contain custom message')
end

-- Assert with no message (uses default)

function testAssertDefaultMessage()
   local success, err = pcall(function()
      assert(false)
   end)

   assert(success is false, 'Assert should have failed')
   assert(err:find('assertion failed') != nil, 'Error should contain default message')
end

-- Assert with complex condition
function testAssertComplexCondition()
   local x = 10
   local y = 20
   assert(x < y, 'x should be less than y')
end

-- Assert with expression that has side effects in condition
function testAssertConditionSideEffects()
   local counter = 0
   local function increment()
      counter++
      return true
   end

   assert(increment(), 'Should not fail')
   assert(counter is 1, 'Condition should be evaluated once')
end

-- Multiple asserts in sequence
function testMultipleAsserts()
   assert(1 is 1)
   assert(2 is 2, 'two is two')
   assert(true)
   assert(not false, 'not false is true')
end

-- Assert with string concatenation in message (lazy evaluation test)
function testAssertExpensiveMessage()
   local expensive_called = false
   local function expensive_operation()
      expensive_called = true
      return 'expensive result'
   end

   assert(true, 'Error: ' .. expensive_operation())
   assert(expensive_called is false, 'Expensive operation should not be called when assertion passes')
end

-- Assert with nil condition
function testAssertNil()
   local success, err = pcall(function()
      assert(nil, 'nil is falsey')
   end)

   assert(success is false, 'Assert on nil should fail')
end

-- Assert with 0 (which is truthy in Lua)
function testAssertZero()
   assert(0, 'zero is truthy')
end

-- Assert with empty string (which is truthy in Lua)
function testAssertEmptyString()
   assert('', 'empty string is truthy')
end

-- Assert does NOT return values (shadow optimization always applies)
function testAssertNoReturn()
   -- Shadow function: assert() returns no values in all contexts.
   -- Unlike standard Lua where assert returns all its arguments, the shadow
   -- assert is optimised to never evaluate or return the message.

   local a, b = assert(true, 'message')

   -- Both a and b should be nil since shadow assert() returns nothing
   if type(a) != 'nil' or type(b) != 'nil' then
      error('Shadow assert() should return no values, got ' .. tostring(a) .. ' and ' .. tostring(b))
   end
end

return {
   tests = {
      'testAssertPassesNoEval',
      'testAssertFails',
      'testAssertDefaultMessage',
      'testAssertComplexCondition',
      'testAssertConditionSideEffects',
      'testMultipleAsserts',
      'testAssertExpensiveMessage',
      'testAssertNil',
      'testAssertZero',
      'testAssertEmptyString',
      'testAssertNoReturn'
   }
}
