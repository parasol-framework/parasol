-- Flute test suite for Fluid Pipe Iteration feature
-- Tests the {range} |> function syntax for automatic iteration

@Test function testPipeIterationBasic()
   -- Basic pipe iteration: {1..6} |> func calls func for each value
   sum = 0
   {1..6} |> i => do sum += i end
   assert(sum is 15, "pipe iteration should sum to 15 (1+2+3+4+5), got " .. sum)
end

@Test function testPipeIterationInclusive()
   -- Inclusive range pipe iteration
   sum = 0
   {1...5} |> i => do sum += i end
   assert(sum is 15, "pipe iteration of {1...5} should sum to 15, got " .. sum)
end

@Test function testPipeIterationWithPrint()
   -- Capture values via pipe iteration
   captured = {}
   {0..3} |> function(i) captured[#captured] = i end
   assert(#captured is 3, "should capture 3 values, got " .. #captured)
   assert(captured[0] is 0, "first captured should be 0")
   assert(captured[2] is 2, "last captured should be 2")
end

@Test function testPipeIterationChaining()
   -- Chaining: pipe returns range for chaining
   log1 = {}
   log2 = {}
   {1..4} |> function(i) log1[#log1] = i end
          |> function(i) log2[#log2] = i * 2 end
   assert(#log1 is 3, "log1 should have 3 elements, got " .. #log1)
   assert(#log2 is 3, "log2 should have 3 elements, got " .. #log2)
   assert(log2[0] is 2, "log2[0] should be 2, got " .. tostring(log2[0]))
   assert(log2[2] is 6, "log2[2] should be 6, got " .. tostring(log2[2]))
end

@Test function testPipeIterationEarlyTermination()
   -- Return false from callback to stop iteration
   count = 0
   {1..100} |> function(i)
      count++
      if i >= 5 then return false end
   end
   assert(count is 5, "should stop after 5 iterations, got " .. count)
end

@Test function testPipeIterationReverse()
   -- Reverse range pipe iteration
   result = {}
   {5...1} |> function(i) result[#result] = i end
   assert(#result is 5, "reverse range should have 5 elements, got " .. #result)
   assert(result[0] is 5, "first element should be 5")
   assert(result[4] is 1, "last element should be 1")
end

@Test function testPipeIterationEmpty()
   -- Empty range should not iterate
   count = 0
   {5..5} |> function(i) count++ end
   assert(count is 0, "empty range should not iterate, got " .. count)
end

@Test function testPipeIterationWithClosure()
   -- Closure variables accessible in callback
   multiplier = 3
   results = {}
   {1..4} |> function(i) results[#results] = i * multiplier end
   assert(results[0] is 3, "results[0] should be 3, got " .. tostring(results[0]))
   assert(results[2] is 9, "results[2] should be 9, got " .. tostring(results[2]))
end

@Test function testPipeIterationReturnValue()
   -- Pipe iteration should return original range for chaining
   -- NOTE: When using a variable, use :each() directly since parser can't detect range type
   r = {1..5}
   returned = r:each(function(i) end)
   assert(returned is r, "pipe iteration should return original range")
end

@Test function testPipeNormalBehaviour()
   -- Non-range pipes should work as before
   function double(x) return x * 2 end
   result = 5 |> double()
   assert(result is 10, "normal pipe should still work, got " .. tostring(result))
end

@Test function testPipeWithRangeVariable()
   -- Pipe iteration with range stored in variable
   -- NOTE: When using a variable, use :each() directly since parser can't detect range type
   r = {1..6}
   sum = 0
   r:each(function(i) sum += i end)
   assert(sum is 15, "sum should be 15, got " .. sum)
end

@Test function testPipeIterationWithIdentifier()
   -- Pipe iteration with function stored in identifier
   sum = 0
   function accumulate(Value) sum += Value end
   {1..6} |> accumulate
   assert(sum is 15, "pipe to identifier should sum to 15, got " .. sum)
end

@Test function testPipeIterationNested()
   -- Nested pipe iteration
   combinations = {}
   {1..3} |> function(i)
      {1..3} |> function(j)
         combinations[#combinations] = i * 10 + j
      end
   end
   assert(#combinations is 4, "nested iteration should produce 4 combinations, got " .. #combinations)
   -- Combinations: 11, 12, 21, 22
   assert(combinations[0] is 11, "first combination should be 11, got " .. tostring(combinations[0]))
   assert(combinations[3] is 22, "last combination should be 22, got " .. tostring(combinations[3]))
end

@Test function testPipeIterationSingleElement()
   -- Single element inclusive range
   count = 0
   value = nil
   {5...5} |> function(i)
      count++
      value = i
   end
   assert(count is 1, "single element range should iterate once, got " .. count)
   assert(value is 5, "value should be 5, got " .. tostring(value))
end

@Test function testPipeIterationNegativeValues()
   -- Negative values in range
   result = {}
   {-3..2} |> function(i) result[#result] = i end
   assert(#result is 5, "should have 5 elements, got " .. #result)
   assert(result[0] is -3, "first should be -3")
   assert(result[4] is 1, "last should be 1")
end

@Test function testPipeIterationContinuesOnTrue()
   -- Returning true should NOT terminate
   sum = 0
   {1..6} |> function(i)
      sum += i
      return true
   end
   assert(sum is 15, "returning true should complete iteration, got " .. sum)
end

@Test function testPipeIterationContinuesOnNil()
   -- No return (nil) should continue
   count = 0
   {1..6} |> function(i)
      count++
   end
   assert(count is 5, "no return should complete iteration, got " .. count)
end

@Test function testPipeWithArrowFunction()
   -- Arrow functions should work for pipe iteration
   sum = 0
   {1..6} |> (i => do sum += i end)
   assert(sum is 15, "arrow function should sum to 15, got " .. sum)
end
