-- Flute tests for parser-based annotation syntax

----------------------------------------------------------------------------------------------------------------------
-- Test basic @Test annotation on a function

function testParserBasicAnnotation()
   @Test(name="Basic Test")
   function myTestFunc()
      return "test"
   end

   entry = debug.anno.get(myTestFunc)
   assert(entry != nil, "Parser-based annotation should register function in _ANNO")
   assert(entry.name is "myTestFunc", "Expected function name 'myTestFunc', got '" .. tostring(entry.name) .. "'")
   assert(#entry.annotations is 1, "Expected 1 annotation, got " .. #entry.annotations)
   assert(entry.annotations[0].name is "Test", "Expected annotation name 'Test', got '" .. tostring(entry.annotations[0].name) .. "'")
   assert(entry.annotations[0].args.name is "Basic Test", "Expected name 'Basic Test'")
end

----------------------------------------------------------------------------------------------------------------------
-- Test annotation with no arguments

function testParserNoArgsAnnotation()
   @Disabled
   function disabledFunc()
      return "disabled"
   end

   entry = debug.anno.get(disabledFunc)
   assert(entry != nil, "No-args annotation should work")
   assert(entry.annotations[0].name is "Disabled", "Expected annotation name 'Disabled'")
end

----------------------------------------------------------------------------------------------------------------------
-- Test multiple annotations on a single function

function testParserMultipleAnnotations()
   @Test(name="Multi Test")
   @Requires(network=false)
   function multiAnnoFunc()
      return "multi"
   end

   entry = debug.anno.get(multiAnnoFunc)
   assert(entry != nil, "Multiple annotations should work")
   assert(#entry.annotations is 2, "Expected 2 annotations, got " .. #entry.annotations)
   assert(entry.annotations[0].name is "Test", "Expected first annotation 'Test'")
   assert(entry.annotations[1].name is "Requires", "Expected second annotation 'Requires'")
   assert(entry.annotations[1].args.network is false, "Expected network=false")
end

----------------------------------------------------------------------------------------------------------------------
-- Test annotations with array values

function testParserArrayAnnotation()
   @Test(labels=["unit", "smoke", "critical"])
   function arrayLabelFunc()
      return "array"
   end

   entry = debug.anno.get(arrayLabelFunc)
   assert(entry != nil, "Array annotation should work")
   labels = entry.annotations[0].args.labels
   assert(labels != nil, "Expected labels array")
   assert(#labels is 3, "Expected 3 labels, got " .. #labels)
   assert(labels[0] is "unit", "Expected 'unit'")
   assert(labels[1] is "smoke", "Expected 'smoke'")
   assert(labels[2] is "critical", "Expected 'critical'")
end

----------------------------------------------------------------------------------------------------------------------
-- Test annotations with numeric values

function testParserNumericAnnotation()
   @Test(timeoutMs=5000, priority=1)
   function numericFunc()
      return 42
   end

   entry = debug.anno.get(numericFunc)
   assert(entry != nil, "Numeric annotation should work")
   local args = entry.annotations[0].args
   assert(args.timeoutMs is 5000, "Expected timeoutMs=5000, got " .. tostring(args.timeoutMs))
   assert(args.priority is 1, "Expected priority=1, got " .. tostring(args.priority))
end

----------------------------------------------------------------------------------------------------------------------
-- Test annotations with boolean values

function testParserBooleanAnnotation()
   @Requires(gfx=true, network=false)
   function boolFunc()
      return true
   end

   entry = debug.anno.get(boolFunc)
   assert(entry != nil, "Boolean annotation should work")
   local args = entry.annotations[0].args
   assert(args.gfx is true, "Expected gfx=true")
   assert(args.network is false, "Expected network=false")
end

----------------------------------------------------------------------------------------------------------------------
-- Test annotation with bare identifiers (flags)

function testParserBareIdentifiers()
   @SuppressWarnings(unused, deprecated)
   function bareIdFunc()
      return "bare"
   end

   entry = debug.anno.get(bareIdFunc)
   assert(entry != nil, "Bare identifier annotation should work")
   local args = entry.annotations[0].args
   assert(args.unused is true, "Expected unused=true")
   assert(args.deprecated is true, "Expected deprecated=true")
end

----------------------------------------------------------------------------------------------------------------------
-- Test annotation on local function

function testParserLocalFunction()
   @Test(name="Local Function Test")
   local function localFunc()
      return "local"
   end

   entry = debug.anno.get(localFunc)
   assert(entry != nil, "Local function annotation should work")
   assert(entry.name is "localFunc", "Expected function name 'localFunc', got '" .. tostring(entry.name) .. "'")
   assert(entry.annotations[0].name is "Test", "Expected annotation name 'Test'")
end

----------------------------------------------------------------------------------------------------------------------
-- Test annotation on global function with explicit 'global' keyword

function testParserGlobalFunction()
   @Test(name="Global Function Test")
   global function explicitGlobalFunc()
      return "global"
   end

   entry = debug.anno.get(explicitGlobalFunc)
   assert(entry != nil, "Global function annotation should work")
   assert(entry.name is "explicitGlobalFunc", "Expected function name 'explicitGlobalFunc'")
end

----------------------------------------------------------------------------------------------------------------------
-- Test annotation with mixed types

function testParserMixedAnnotation()
   @Test(name="Mixed Test", labels=["a", "b"], timeoutMs=3000, enabled=true)
   function mixedFunc()
      return "mixed"
   end

   entry = debug.anno.get(mixedFunc)
   assert(entry != nil, "Mixed type annotation should work")
   local args = entry.annotations[0].args
   assert(args.name is "Mixed Test", "Expected name 'Mixed Test'")
   assert(#args.labels is 2, "Expected 2 labels")
   assert(args.timeoutMs is 3000, "Expected timeoutMs=3000")
   assert(args.enabled is true, "Expected enabled=true")
end

----------------------------------------------------------------------------------------------------------------------
-- Test annotations with semicolon separator on same line

function testParserSemicolonSeparator()
   @BeforeEach; @Requires(network=true)
   function setupFunc()
      return "setup"
   end

   entry = debug.anno.get(setupFunc)
   assert(entry != nil, "Semicolon-separated annotations should work")
   assert(#entry.annotations is 2, "Expected 2 annotations, got " .. #entry.annotations)
   assert(entry.annotations[0].name is "BeforeEach", "Expected first annotation 'BeforeEach'")
   assert(entry.annotations[1].name is "Requires", "Expected second annotation 'Requires'")
end

----------------------------------------------------------------------------------------------------------------------
-- Test source file is captured correctly

function testParserSourceCapture()
   @Test(name="Source Test")
   function sourceFunc()
      return "source"
   end

   entry = debug.anno.get(sourceFunc)
   assert(entry != nil, "Source capture should work")
   assert(entry.source != nil, "Expected source to be set")
   -- Source should contain the test file name
   assert(string.find(entry.source, "test_parser_annotations") != nil,
      "Expected source to contain 'test_parser_annotations', got '" .. tostring(entry.source) .. "'")
end

----------------------------------------------------------------------------------------------------------------------
-- Test annotated function is discoverable via debug.anno.list()

function testParserListDiscovery()
   @Test(name="Discoverable Test")
   function discoverableFunc()
      return "discover"
   end

   all = debug.anno.list()
   found = false
   for func, entry in pairs(all) do
      if entry.name is "discoverableFunc" then
         found = true
         break
      end
   end
   assert(found, "Annotated function should be discoverable via debug.anno.list()")
end

----------------------------------------------------------------------------------------------------------------------
-- Test annotations with thunk function

function testParserThunkAnnotation()
   @Test(name="Thunk Test")
   thunk thunkFunc()
      return "thunk"
   end

   entry = debug.anno.get(thunkFunc)
   assert(entry != nil, "Thunk function annotation should work")
   assert(entry.name is "thunkFunc", "Expected function name 'thunkFunc'")
   assert(entry.annotations[0].name is "Test", "Expected annotation name 'Test'")
end

----------------------------------------------------------------------------------------------------------------------

return {
   tests = {
      testParserBasicAnnotation,
      testParserNoArgsAnnotation,
      testParserMultipleAnnotations,
      testParserArrayAnnotation,
      testParserNumericAnnotation,
      testParserBooleanAnnotation,
      testParserBareIdentifiers,
      testParserLocalFunction,
      testParserGlobalFunction,
      testParserMixedAnnotation,
      testParserSemicolonSeparator,
      testParserSourceCapture,
      testParserListDiscovery,
      testParserThunkAnnotation
   }
}
