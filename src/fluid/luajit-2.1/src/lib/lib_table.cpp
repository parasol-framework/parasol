// Table library.
// Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
//
// Major portions taken verbatim or adapted from the Lua interpreter.
// Copyright (C) 1994-2008 Lua.org, PUC-Rio. See Copyright Notice in lua.h

#define lib_table_c
#define LUA_LIB

#include "lua.h"
#include "lauxlib.h"
#include "lualib.h"

#include "lj_obj.h"
#include "lj_gc.h"
#include "lj_err.h"
#include "lj_buf.h"
#include "lj_tab.h"
#include "lj_ff.h"
#include "lj_strfmt.h"
#include "lib.h"
#include "lib_utils.h"
#include "lib_range.h"

#define LJLIB_MODULE_table

// Code is generated by genlibbc.lua for LJ_LIB declarations.

//********************************************************************************************************************

LJLIB_CF(table_getn)
{
   GCtab *t = lj_lib_checktab(L, 1);
   lua_pushinteger(L, (lua_Integer)lj_tab_len(t));
   return 1;
}

//********************************************************************************************************************

LJLIB_CF(table_insert)      LJLIB_REC(.)
{
   GCtab* t = lj_lib_checktab(L, 1);
   int32_t n, i = (int32_t)lj_tab_len(t);  // 0-based: next index = len
   int nargs = (int)((char*)L->top - (char*)L->base);
   if (nargs != 2 * sizeof(TValue)) {
      if (nargs != 3 * sizeof(TValue))
         lj_err_caller(L, ErrMsg::TABINS);
      // NOBARRIER: This just moves existing elements around.
      for (n = lj_lib_checkint(L, 2); i > n; i--) {
         // The set may invalidate the get pointer, so need to do it first!
         TValue* dst = lj_tab_setint(L, t, i);
         cTValue* src = lj_tab_getint(t, i - 1);
         copy_or_nil(L, dst, src);
      }
      i = n;
   }

   TValue* dst = lj_tab_setint(L, t, i);
   copyTV(L, dst, L->top - 1);  //  Set new value.
   lj_gc_barriert(L, t, dst);
   return 0;
}

//********************************************************************************************************************

LJLIB_CF(table_remove)
{
   GCtab *t = lj_lib_checktab(L, 1);
   auto len = (int32_t)lj_tab_len(t);
   int32_t pos;

   if (L->base + 1 >= L->top) {  // No position argument
      if (len == 0) return 0;  // Empty table, return nothing
      pos = len - 1;  // 0-based: last element at len-1
   }
   else {
      pos = lj_lib_checkint(L, 2);
      if (pos < 0 or pos >= len) return 0;  // Out of bounds, return nothing
   }

   // Get the element to return
   cTValue* src = lj_tab_getint(t, pos);
   copy_or_nil(L, L->top++, src);

   // Shift elements down (if not removing the last element)
   auto last = len - 1;
   for (int32_t i = pos; i < last; i++) {
      TValue* dst = lj_tab_setint(L, t, i);
      src = lj_tab_getint(t, i + 1);
      copy_or_nil(L, dst, src);
   }

   TValue* dst = lj_tab_setint(L, t, last);
   setnilV(dst); // Remove the last element by setting it to nil

   return 1;
}

//********************************************************************************************************************

LJLIB_CF(table_move)
{
   GCtab *a1 = lj_lib_checktab(L, 1);
   int32_t f = lj_lib_checkint(L, 2);  // Start index
   int32_t e = lj_lib_checkint(L, 3);  // End index
   int32_t t = lj_lib_checkint(L, 4);  // Target index

   // If a2 is nil, use a1 as destination
   GCtab *a2;
   if (lua_isnoneornil(L, 5)) {
      a2 = a1;
      lua_pushvalue(L, 1);  // Push a1 as return value
   }
   else {
      a2 = lj_lib_checktab(L, 5);
      lua_pushvalue(L, 5);  // Push a2 as return value
   }

   if (e >= f) {
      int32_t d = t - f;
      // Choose iteration direction to handle overlapping regions correctly
      if (t > e or t <= f or a2 != a1) {
         // Forward iteration: no overlap or different tables
         for (int32_t i = f; i <= e; i++) {
            lua_rawgeti(L, 1, i);  // Get a1[i]
            lua_rawseti(L, (a2 IS a1) ? 1 : 5, i + d);  // Set a2[i+d]
         }
      }
      else {
         // Backward iteration: overlapping region requires reverse copy
         for (int32_t i = e; i >= f; i--) {
            lua_rawgeti(L, 1, i);  // Get a1[i]
            lua_rawseti(L, 1, i + d);  // Set a1[i+d] (same table)
         }
      }
   }

   return 1;  // Return a2
}

//********************************************************************************************************************

LJLIB_CF(table_concat) LJLIB_REC(.)
{
   GCtab* t = lj_lib_checktab(L, 1);
   GCstr* sep = lj_lib_optstr(L, 2);
   int32_t i = lj_lib_optint(L, 3, 0);  // 0-based: default start
   int32_t e = (L->base + 3 < L->top and !tvisnil(L->base + 3)) ? lj_lib_checkint(L, 4) : (int32_t)lj_tab_len(t) - 1;  // 0-based: last index = len-1
   SBuf* sb = lj_buf_tmp_(L);
   SBuf* sbx = lj_buf_puttab(sb, t, sep, i, e);
   if (LJ_UNLIKELY(!sbx)) {  // Error: bad element type.
      int32_t idx = (int32_t)(intptr_t)sb->w;
      cTValue* o = lj_tab_getint(t, idx);
      lj_err_callerv(L, ErrMsg::TABCAT, lj_obj_itypename[o ? itypemap(o) : ~LJ_TNIL], idx);
   }
   setstrV(L, L->top - 1, lj_buf_str(L, sbx));
   lj_gc_check(L);
   return 1;
}

//********************************************************************************************************************

static void set2(lua_State *L, int i, int j)
{
   lua_rawseti(L, 1, i);
   lua_rawseti(L, 1, j);
}

//********************************************************************************************************************

static int sort_comp(lua_State *L, int a, int b)
{
   if (!lua_isnil(L, 2)) {  // function?
      int res;
      lua_pushvalue(L, 2);
      lua_pushvalue(L, a - 1);  //  -1 to compensate function
      lua_pushvalue(L, b - 2);  //  -2 to compensate function and `a'
      lua_call(L, 2, 1);
      res = lua_toboolean(L, -1);
      lua_pop(L, 1);
      return res;
   }
   else {  // a < b?
      return lua_lessthan(L, a, b);
   }
}

//********************************************************************************************************************

static void auxsort(lua_State *L, int l, int u)
{
   while (l < u) {  // for tail recursion
      int i, j;
      // sort elements a[l], a[(l+u)/2] and a[u]
      lua_rawgeti(L, 1, l);
      lua_rawgeti(L, 1, u);
      if (sort_comp(L, -1, -2))  //  a[u] < a[l]?
         set2(L, l, u);  //  swap a[l] - a[u]
      else lua_pop(L, 2);
      if (u - l == 1) break;  //  only 2 elements
      i = (l + u) / 2;
      lua_rawgeti(L, 1, i);
      lua_rawgeti(L, 1, l);
      if (sort_comp(L, -2, -1)) {  // a[i]<a[l]?
         set2(L, i, l);
      }
      else {
         lua_pop(L, 1);  //  remove a[l]
         lua_rawgeti(L, 1, u);
         if (sort_comp(L, -1, -2))  //  a[u]<a[i]?
            set2(L, i, u);
         else lua_pop(L, 2);
      }
      if (u - l == 2) break;  //  only 3 elements
      lua_rawgeti(L, 1, i);  //  Pivot
      lua_pushvalue(L, -1);
      lua_rawgeti(L, 1, u - 1);
      set2(L, i, u - 1);
      // a[l] <= P == a[u-1] <= a[u], only need to sort from l+1 to u-2
      i = l; j = u - 1;
      for (;;) {  // invariant: a[l..i] <= P <= a[j..u]
         // repeat ++i until a[i] >= P
         while (lua_rawgeti(L, 1, ++i), sort_comp(L, -1, -2)) {
            if (i >= u) lj_err_caller(L, ErrMsg::TABSORT);
            lua_pop(L, 1);  //  remove a[i]
         }
         // repeat --j until a[j] <= P
         while (lua_rawgeti(L, 1, --j), sort_comp(L, -3, -1)) {
            if (j <= l) lj_err_caller(L, ErrMsg::TABSORT);
            lua_pop(L, 1);  //  remove a[j]
         }
         if (j < i) {
            lua_pop(L, 3);  //  pop pivot, a[i], a[j]
            break;
         }
         set2(L, i, j);
      }
      lua_rawgeti(L, 1, u - 1);
      lua_rawgeti(L, 1, i);
      set2(L, u - 1, i);  //  swap pivot (a[u-1]) with a[i]
      // a[l..i-1] <= a[i] == P <= a[i+1..u]
      // adjust so that smaller half is in [j..i] and larger one in [l..u]
      if (i - l < u - i) {
         j = l; i = i - 1; l = i + 2;
      }
      else {
         j = i + 1; i = u; u = j - 2;
      }
      auxsort(L, j, i);  //  call recursively the smaller one
   }  // repeat the routine for the larger one
}

//********************************************************************************************************************

LJLIB_CF(table_sort)
{
   GCtab *t = lj_lib_checktab(L, 1);
   int32_t n = (int32_t)lj_tab_len(t);
   lua_settop(L, 2);
   if (!tvisnil(L->base + 1)) lj_lib_checkfunc(L, 2);
   auxsort(L, 0, n - 1);  // 0-based: sort indices 0 to len-1
   return 0;
}

//********************************************************************************************************************

LJLIB_NOREG LJLIB_CF(table_new) LJLIB_REC(.)
{
   int32_t a = lj_lib_checkint(L, 1);
   int32_t h = lj_lib_checkint(L, 2);
   lua_createtable(L, a, h);
   return 1;
}

//********************************************************************************************************************
// table.empty(t)
// Returns true if the given table is empty. If the argument is nil, it is treated as empty and returns true. This
// mirrors the emptiness check used in Parasol's user-facing helpers, but implemented natively.

[[maybe_unused]] static int lj_cf_table_empty(lua_State *L);

LJLIB_CF(table_empty)
{
   GCtab *t = lj_lib_checktabornil(L, 1);
   if (!t) {
      setboolV(L->top - 1, 1);
      return 1;
   }

   if (lj_tab_len(t) != 0) {
      setboolV(L->top - 1, 0);
      return 1;
   }

   TValue key, kv[2];
   setnilV(&key);
   if (lj_tab_next(t, &key, kv)) setboolV(L->top - 1, 0);  //  Found at least one entry.
   else setboolV(L->top - 1, 1);  //  Confirmed empty.

   return 1;
}

//********************************************************************************************************************

LJLIB_CF(table_clear)   LJLIB_REC(.)
{
   lj_tab_clear(lj_lib_checktab(L, 1));
   return 0;
}

//********************************************************************************************************************
// Table slicing: returns a new table with elements from the specified range.
// Usage: table.slice(t, range) -> table
// Delegates to range.slice() for the actual implementation.

LJLIB_CF(table_slice)
{
   lj_lib_checktab(L, 1);  // Validate first arg is a table
   return lj_range_slice(L);
}

//********************************************************************************************************************
// Iterator closure for table.sortByKeys(). Upvalues:
//   [0] = original table
//   [1] = sorted keys array
//   [2] = current index (integer)

static int table_sortbykeys_iter(lua_State *L)
{
   GCfunc *fn   = curr_func(L);
   GCtab *t     = tabV(&fn->c.upvalue[0]);
   GCtab *keys  = tabV(&fn->c.upvalue[1]);
   TValue *idx_tv = &fn->c.upvalue[2];

   int32_t idx = numberVint(idx_tv);
   if (idx >= (int32_t)lj_tab_len(keys)) return 0;

   cTValue *key = lj_tab_getint(keys, idx);
   if (!key or tvisnil(key)) return 0;

   copyTV(L, L->top++, key);                    // Return key
   cTValue *val = lj_tab_get(L, t, key);
   copyTV(L, L->top++, val);                    // Return value
   setintV(idx_tv, idx + 1);                    // Advance index
   return 2;
}

//********************************************************************************************************************
// table.sortByKeys(t [, f])
// Returns an iterator that yields key-value pairs from table t in sorted key order.
// The optional comparison function f controls sort order (default: ascending).
// Usage: for k, v in table.sortByKeys(t) do ... end

[[maybe_unused]] static int lj_cf_table_sortByKeys(lua_State *L);

LJLIB_CF(table_sortByKeys)
{
   lj_lib_checktab(L, 1);
   lua_settop(L, 2);
   if (!tvisnil(L->base + 1)) lj_lib_checkfunc(L, 2);

   // Stack: [1]=t, [2]=f_or_nil

   lua_newtable(L);  // [3] = keys array

   int32_t n = 0;
   lua_pushnil(L);
   while (lua_next(L, 1)) {
      lua_pop(L, 1);               // Remove value, keep key
      lua_pushvalue(L, -1);        // Duplicate key
      lua_rawseti(L, 3, n);        // keys[n] = key
      n++;
   }

   // Stack: [1]=t, [2]=f_or_nil, [3]=keys

   if (n > 1) {
      // Sort the keys using auxsort, which expects [1]=table, [2]=comparator.
      // Temporarily swap keys into position 1, saving the original table.
      lua_pushvalue(L, 1);         // [4] = t (saved)
      lua_pushvalue(L, 3);         // [5] = keys ref
      lua_replace(L, 1);           // [1]=keys, [2]=f, [3]=keys, [4]=t

      auxsort(L, 0, n - 1);

      // Build closure: upvalue 0=t, upvalue 1=sorted keys, upvalue 2=index(0)
      lua_pushvalue(L, 4);         // Original table
      lua_pushvalue(L, 1);         // Sorted keys (same table object)
      lua_pushinteger(L, 0);
      lua_pushcclosure(L, table_sortbykeys_iter, 3);
   }
   else {
      // 0 or 1 keys - no sorting needed
      lua_pushvalue(L, 1);         // Original table
      lua_pushvalue(L, 3);         // Keys array
      lua_pushinteger(L, 0);
      lua_pushcclosure(L, table_sortbykeys_iter, 3);
   }

   return 1;
}

//********************************************************************************************************************
// Helpers for table.toXML()

// Append XML-escaped content (escapes &, <, >) to the buffer.

static void buf_xml_escape(SBuf* Sb, const char* Str, MSize Len)
{
   for (MSize i = 0; i < Len; i++) {
      switch (Str[i]) {
         case '&': lj_buf_putmem(Sb, "&amp;", 5); break;
         case '<': lj_buf_putmem(Sb, "&lt;", 4); break;
         case '>': lj_buf_putmem(Sb, "&gt;", 4); break;
         default:  lj_buf_putb(Sb, Str[i]); break;
      }
   }
}

// Append a numeric TValue as text to the buffer.

static void buf_put_numtv(SBuf* Sb, cTValue* Val)
{
   if (tvisint(Val)) lj_strfmt_putint(Sb, intV(Val));
   else lj_strfmt_putfnum(Sb, STRFMT_G14, numV(Val));
}

// Append XML-escaped text representation of a TValue to the buffer.

static void buf_xml_escape_tv(SBuf* Sb, cTValue* Val)
{
   if (tvisstr(Val)) {
      GCstr* s = strV(Val);
      buf_xml_escape(Sb, strdata(s), s->len);
   }
   else if (tvisint(Val) or tvisnum(Val)) buf_put_numtv(Sb, Val);
   else if (tvistrue(Val))  lj_buf_putmem(Sb, "true", 4);
   else if (tvisfalse(Val)) lj_buf_putmem(Sb, "false", 5);
}

//********************************************************************************************************************
// Recursive element processing for table.toXML(). Emits <tag attrs>children</> or <tag attrs/>.
// The element definition table (Def) is iterated in two passes:
//   Pass 1: string-keyed entries with scalar values become attributes.
//   Pass 2: numeric-keyed entries become child content; string-keyed entries with non-scalar values are fallback content.

static void toxml_element(lua_State* L, SBuf* Sb, cTValue* Tag, GCtab* Def)
{
   lj_buf_putb(Sb, '<');
   if (tvisstr(Tag)) {
      GCstr* s = strV(Tag);
      lj_buf_putmem(Sb, strdata(s), s->len);
   }
   else if (tvisint(Tag) or tvisnum(Tag)) buf_put_numtv(Sb, Tag);

   // Pass 1: attributes (string-keyed entries with string/number/boolean values)
   TValue ak_key;
   setnilV(&ak_key);
   TValue akv[2];

   while (lj_tab_next(Def, &ak_key, akv)) {
      copyTV(L, &ak_key, &akv[0]);
      if (!tvisstr(&akv[0])) continue;
      GCstr* ak = strV(&akv[0]);

      if (tvisstr(&akv[1])) {
         lj_buf_putb(Sb, ' ');
         lj_buf_putmem(Sb, strdata(ak), ak->len);
         lj_buf_putmem(Sb, "=\"", 2);
         GCstr* av = strV(&akv[1]);
         buf_xml_escape(Sb, strdata(av), av->len);
         lj_buf_putb(Sb, '"');
      }
      else if (tvisint(&akv[1]) or tvisnum(&akv[1])) {
         lj_buf_putb(Sb, ' ');
         lj_buf_putmem(Sb, strdata(ak), ak->len);
         lj_buf_putb(Sb, '=');
         buf_put_numtv(Sb, &akv[1]);
      }
      else if (tvistrue(&akv[1])) {
         lj_buf_putb(Sb, ' ');
         lj_buf_putmem(Sb, strdata(ak), ak->len);
      }
   }

   // Save position after attributes, then optimistically write '>'
   MSize pos_after_attrs = sbuflen(Sb);
   lj_buf_putb(Sb, '>');
   MSize pos_after_gt = sbuflen(Sb);

   // Pass 2: child content
   setnilV(&ak_key);
   while (lj_tab_next(Def, &ak_key, akv)) {
      copyTV(L, &ak_key, &akv[0]);

      if (tvisint(&akv[0]) or tvisnum(&akv[0])) {
         // Numeric key: child tag or content
         if (tvistab(&akv[1])) {
            // Iterate child table for nested elements/content
            GCtab* child_tab = tabV(&akv[1]);
            TValue ck_key;
            setnilV(&ck_key);
            TValue ckv[2];
            while (lj_tab_next(child_tab, &ck_key, ckv)) {
               copyTV(L, &ck_key, &ckv[0]);
               if (tvistab(&ckv[1])) toxml_element(L, Sb, &ckv[0], tabV(&ckv[1]));
               else buf_xml_escape_tv(Sb, &ckv[1]);
            }
         }
         else buf_xml_escape_tv(Sb, &akv[1]);
      }
      else if (tvisstr(&akv[0])) {
         // String key with non-attribute value type becomes fallback child content
         if (!tvisstr(&akv[1]) and !(tvisint(&akv[1]) or tvisnum(&akv[1])) and !tvisbool(&akv[1])) {
            buf_xml_escape_tv(Sb, &akv[1]);
         }
      }
   }

   // Finalise: if no children were written, replace '>' with '/>'
   if (sbuflen(Sb) IS pos_after_gt) {
      Sb->w = Sb->b + pos_after_attrs;
      lj_buf_putmem(Sb, "/>", 2);
   }
   else lj_buf_putmem(Sb, "</>", 3);
}

//********************************************************************************************************************
// Top-level table processing for table.toXML(). Iterates the table and emits each entry as an element.

static void toxml_table(lua_State* L, SBuf* Sb, GCtab* Table)
{
   TValue key;
   setnilV(&key);
   TValue kv[2];

   while (lj_tab_next(Table, &key, kv)) {
      copyTV(L, &key, &kv[0]);
      if (tvistab(&kv[1])) {
         toxml_element(L, Sb, &kv[0], tabV(&kv[1]));
      }
      else {
         lj_buf_putb(Sb, '<');
         if (tvisstr(&kv[0])) {
            GCstr* s = strV(&kv[0]);
            lj_buf_putmem(Sb, strdata(s), s->len);
         }
         else if (tvisint(&kv[0]) or tvisnum(&kv[0])) buf_put_numtv(Sb, &kv[0]);
         lj_buf_putmem(Sb, "/>", 2);
      }
   }
}

//********************************************************************************************************************
// table.toXML(t)
// Converts a table to an XML string. Table keys become element tag names, string-keyed entries in the element
// definition table become attributes, and numeric-keyed entries become child content.

[[maybe_unused]] static int lj_cf_table_toXML(lua_State* L);

LJLIB_CF(table_toXML)
{
   GCtab* t = lj_lib_checktab(L, 1);
   SBuf* sb = lj_buf_tmp_(L);
   toxml_table(L, sb, t);
   setstrV(L, L->top - 1, lj_buf_str(L, sb));
   lj_gc_check(L);
   return 1;
}

//********************************************************************************************************************

static int luaopen_table_new(lua_State *L)
{
   return lj_lib_postreg(L, lj_cf_table_new, FF_table_new, "new");
}

//********************************************************************************************************************

#include "lj_libdef.h"
#include "lj_proto_registry.h"

extern int luaopen_table(lua_State *L)
{
   LJ_LIB_REG(L, "table", table);
   // unpack() has been deprecated, retaining this only as an example of routing to global functions
   // result1, result2, ... = table.unpack(someTable)
   //lua_getglobal(L, "unpack");
   //lua_setfield(L, -2, "unpack");
   lj_lib_prereg(L, "table.new", luaopen_table_new, tabV(L->top - 1));

   // Register table interface prototypes for compile-time type inference
   reg_iface_prototype("table", "getn", { FluidType::Num }, { FluidType::Table });
   reg_iface_prototype("table", "insert", {}, { FluidType::Table, FluidType::Any });
   reg_iface_prototype("table", "remove", { FluidType::Any }, { FluidType::Table, FluidType::Num });
   reg_iface_prototype("table", "move", { FluidType::Table }, { FluidType::Table, FluidType::Num, FluidType::Num, FluidType::Num, FluidType::Table });
   reg_iface_prototype("table", "concat", { FluidType::Str }, { FluidType::Table, FluidType::Str, FluidType::Num, FluidType::Num });
   reg_iface_prototype("table", "sort", {}, { FluidType::Table, FluidType::Func });
   reg_iface_prototype("table", "new", { FluidType::Table }, { FluidType::Num, FluidType::Num });
   reg_iface_prototype("table", "empty", { FluidType::Bool }, { FluidType::Table });
   reg_iface_prototype("table", "clear", {}, { FluidType::Table });
   reg_iface_prototype("table", "slice", { FluidType::Table }, { FluidType::Table, FluidType::Any });
   reg_iface_prototype("table", "sortByKeys", { FluidType::Func }, { FluidType::Table, FluidType::Func });
   reg_iface_prototype("table", "toXML", { FluidType::Str }, { FluidType::Table });

   return 1;
}
