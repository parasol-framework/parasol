// Table library.
// Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
//
// Major portions taken verbatim or adapted from the Lua interpreter.
// Copyright (C) 1994-2008 Lua.org, PUC-Rio. See Copyright Notice in lua.h

#define lib_table_c
#define LUA_LIB

#include "lua.h"
#include "lauxlib.h"
#include "lualib.h"

#include "lj_obj.h"
#include "lj_gc.h"
#include "lj_err.h"
#include "lj_buf.h"
#include "lj_tab.h"
#include "lj_ff.h"
#include "lj_meta.h"
#include "lib.h"
#include "lib_utils.h"
#include "lib_range.h"

#define LJLIB_MODULE_table

// Code is generated by genlibbc.lua for LJ_LIB declarations.

//********************************************************************************************************************

LJLIB_LUA(table_foreachi) /*
  function(t, f)
    CHECK_tab(t)
    CHECK_func(f)
    for i=0,#t-1 do
      local r = f(i, t[i])
      if r ~= nil then return r end
    end
  end
*/

//********************************************************************************************************************

LJLIB_LUA(table_foreach) /*
  function(t, f)
    CHECK_tab(t)
    CHECK_func(f)
    for k, v in PAIRS(t) do
      local r = f(k, v)
      if r ~= nil then return r end
    end
  end
*/

//********************************************************************************************************************

LJLIB_LUA(table_getn) /*
  function(t)
    CHECK_tab(t)
    return #t
  end
*/

//********************************************************************************************************************

LJLIB_CF(table_insert)      LJLIB_REC(.)
{
   GCtab* t = lj_lib_checktab(L, 1);
   int32_t n, i = (int32_t)lj_tab_len(t);  // 0-based: next index = len
   int nargs = (int)((char*)L->top - (char*)L->base);
   if (nargs != 2 * sizeof(TValue)) {
      if (nargs != 3 * sizeof(TValue))
         lj_err_caller(L, ErrMsg::TABINS);
      // NOBARRIER: This just moves existing elements around.
      for (n = lj_lib_checkint(L, 2); i > n; i--) {
         // The set may invalidate the get pointer, so need to do it first!
         TValue* dst = lj_tab_setint(L, t, i);
         cTValue* src = lj_tab_getint(t, i - 1);
         copy_or_nil(L, dst, src);
      }
      i = n;
   }

   TValue* dst = lj_tab_setint(L, t, i);
   copyTV(L, dst, L->top - 1);  //  Set new value.
   lj_gc_barriert(L, t, dst);
   return 0;
}

//********************************************************************************************************************

LJLIB_CF(table_remove)
{
   GCtab *t = lj_lib_checktab(L, 1);
   auto len = (int32_t)lj_tab_len(t);
   int32_t pos;

   if (L->base + 1 >= L->top) {  // No position argument
      if (len == 0) return 0;  // Empty table, return nothing
      pos = len - 1;  // 0-based: last element at len-1
   }
   else {
      pos = lj_lib_checkint(L, 2);
      if (pos < 0 or pos >= len) return 0;  // Out of bounds, return nothing
   }

   // Get the element to return
   cTValue* src = lj_tab_getint(t, pos);
   copy_or_nil(L, L->top++, src);

   // Shift elements down (if not removing the last element)
   auto last = len - 1;
   for (int32_t i = pos; i < last; i++) {
      TValue* dst = lj_tab_setint(L, t, i);
      src = lj_tab_getint(t, i + 1);
      copy_or_nil(L, dst, src);
   }

   TValue* dst = lj_tab_setint(L, t, last);
   setnilV(dst); // Remove the last element by setting it to nil

   return 1;
}

//********************************************************************************************************************

LJLIB_LUA(table_move) /*
  function(a1, f, e, t, a2)
    CHECK_tab(a1)
    CHECK_int(f)
    CHECK_int(e)
    CHECK_int(t)
    if a2 == nil then a2 = a1 end
    CHECK_tab(a2)
    if e >= f then
      local d = t - f
      if t > e or t <= f or a2 ~= a1 then
   for i=f,e do a2[i+d] = a1[i] end
      else
   for i=e,f,-1 do a2[i+d] = a1[i] end
      end
    end
    return a2
  end
*/

//********************************************************************************************************************

LJLIB_CF(table_concat) LJLIB_REC(.)
{
   GCtab* t = lj_lib_checktab(L, 1);
   GCstr* sep = lj_lib_optstr(L, 2);
   int32_t i = lj_lib_optint(L, 3, 0);  // 0-based: default start
   int32_t e = (L->base + 3 < L->top and !tvisnil(L->base + 3)) ? lj_lib_checkint(L, 4) : (int32_t)lj_tab_len(t) - 1;  // 0-based: last index = len-1
   SBuf* sb = lj_buf_tmp_(L);
   SBuf* sbx = lj_buf_puttab(sb, t, sep, i, e);
   if (LJ_UNLIKELY(!sbx)) {  // Error: bad element type.
      int32_t idx = (int32_t)(intptr_t)sb->w;
      cTValue* o = lj_tab_getint(t, idx);
      lj_err_callerv(L, ErrMsg::TABCAT, lj_obj_itypename[o ? itypemap(o) : ~LJ_TNIL], idx);
   }
   setstrV(L, L->top - 1, lj_buf_str(L, sbx));
   lj_gc_check(L);
   return 1;
}

//********************************************************************************************************************

static void set2(lua_State* L, int i, int j)
{
   lua_rawseti(L, 1, i);
   lua_rawseti(L, 1, j);
}

//********************************************************************************************************************

static int sort_comp(lua_State* L, int a, int b)
{
   if (!lua_isnil(L, 2)) {  // function?
      int res;
      lua_pushvalue(L, 2);
      lua_pushvalue(L, a - 1);  //  -1 to compensate function
      lua_pushvalue(L, b - 2);  //  -2 to compensate function and `a'
      lua_call(L, 2, 1);
      res = lua_toboolean(L, -1);
      lua_pop(L, 1);
      return res;
   }
   else {  // a < b?
      return lua_lessthan(L, a, b);
   }
}

//********************************************************************************************************************

static void auxsort(lua_State* L, int l, int u)
{
   while (l < u) {  // for tail recursion
      int i, j;
      // sort elements a[l], a[(l+u)/2] and a[u]
      lua_rawgeti(L, 1, l);
      lua_rawgeti(L, 1, u);
      if (sort_comp(L, -1, -2))  //  a[u] < a[l]?
         set2(L, l, u);  //  swap a[l] - a[u]
      else lua_pop(L, 2);
      if (u - l == 1) break;  //  only 2 elements
      i = (l + u) / 2;
      lua_rawgeti(L, 1, i);
      lua_rawgeti(L, 1, l);
      if (sort_comp(L, -2, -1)) {  // a[i]<a[l]?
         set2(L, i, l);
      }
      else {
         lua_pop(L, 1);  //  remove a[l]
         lua_rawgeti(L, 1, u);
         if (sort_comp(L, -1, -2))  //  a[u]<a[i]?
            set2(L, i, u);
         else lua_pop(L, 2);
      }
      if (u - l == 2) break;  //  only 3 elements
      lua_rawgeti(L, 1, i);  //  Pivot
      lua_pushvalue(L, -1);
      lua_rawgeti(L, 1, u - 1);
      set2(L, i, u - 1);
      // a[l] <= P == a[u-1] <= a[u], only need to sort from l+1 to u-2
      i = l; j = u - 1;
      for (;;) {  // invariant: a[l..i] <= P <= a[j..u]
         // repeat ++i until a[i] >= P
         while (lua_rawgeti(L, 1, ++i), sort_comp(L, -1, -2)) {
            if (i >= u) lj_err_caller(L, ErrMsg::TABSORT);
            lua_pop(L, 1);  //  remove a[i]
         }
         // repeat --j until a[j] <= P
         while (lua_rawgeti(L, 1, --j), sort_comp(L, -3, -1)) {
            if (j <= l) lj_err_caller(L, ErrMsg::TABSORT);
            lua_pop(L, 1);  //  remove a[j]
         }
         if (j < i) {
            lua_pop(L, 3);  //  pop pivot, a[i], a[j]
            break;
         }
         set2(L, i, j);
      }
      lua_rawgeti(L, 1, u - 1);
      lua_rawgeti(L, 1, i);
      set2(L, u - 1, i);  //  swap pivot (a[u-1]) with a[i]
      // a[l..i-1] <= a[i] == P <= a[i+1..u]
      // adjust so that smaller half is in [j..i] and larger one in [l..u]
      if (i - l < u - i) {
         j = l; i = i - 1; l = i + 2;
      }
      else {
         j = i + 1; i = u; u = j - 2;
      }
      auxsort(L, j, i);  //  call recursively the smaller one
   }  // repeat the routine for the larger one
}

//********************************************************************************************************************

LJLIB_CF(table_sort)
{
   GCtab *t = lj_lib_checktab(L, 1);
   int32_t n = (int32_t)lj_tab_len(t);
   lua_settop(L, 2);
   if (!tvisnil(L->base + 1)) lj_lib_checkfunc(L, 2);
   auxsort(L, 0, n - 1);  // 0-based: sort indices 0 to len-1
   return 0;
}

//********************************************************************************************************************

LJLIB_PUSH("n")
LJLIB_CF(table_pack)
{
   TValue *array, *base = L->base;
   MSize n = (uint32_t)(L->top - base);
   GCtab *t = lj_tab_new(L, n, 1);  // 0-based: asize = n for n elements
   // NOBARRIER: The table is new (marked white).
   setintV(lj_tab_setstr(L, t, strV(lj_lib_upvalue(L, 1))), (int32_t)n);
   array = tvref(t->array);
   copy_range(L, array, base, n);  // 0-based: copy all n elements starting at array[0]
   settabV(L, base, t);
   L->top = base + 1;
   lj_gc_check(L);
   return 1;
}

//********************************************************************************************************************

LJLIB_NOREG LJLIB_CF(table_new) LJLIB_REC(.)
{
   int32_t a = lj_lib_checkint(L, 1);
   int32_t h = lj_lib_checkint(L, 2);
   lua_createtable(L, a, h);
   return 1;
}

//********************************************************************************************************************
// table.empty(t)
// Returns true if the given table is empty. If the argument is nil, it is treated as empty and returns true. This
// mirrors the emptiness check used in Parasol's user-facing helpers, but implemented natively.

[[maybe_unused]] static int lj_cf_table_empty(lua_State* L);

LJLIB_CF(table_empty)
{
   GCtab *t = lj_lib_checktabornil(L, 1);
   if (!t) {
      setboolV(L->top - 1, 1);
      return 1;
   }

   if (lj_tab_len(t) != 0) {
      setboolV(L->top - 1, 0);
      return 1;
   }

   TValue key, kv[2];
   setnilV(&key);
   if (lj_tab_next(t, &key, kv)) setboolV(L->top - 1, 0);  //  Found at least one entry.
   else setboolV(L->top - 1, 1);  //  Confirmed empty.

   return 1;
}

//********************************************************************************************************************

LJLIB_CF(table_clear)   LJLIB_REC(.)
{
   lj_tab_clear(lj_lib_checktab(L, 1));
   return 0;
}

//********************************************************************************************************************

//********************************************************************************************************************
// Helper to check if a TValue is a range userdata and extract it

static fluid_range* get_range_from_tvalue(lua_State* L, cTValue* tv)
{
   if (not tvisudata(tv)) return nullptr;

   GCudata* ud = udataV(tv);
   GCtab* mt = tabref(ud->metatable);
   if (not mt) return nullptr;

   // Get the expected metatable for ranges
   lua_getfield(L, LUA_REGISTRYINDEX, RANGE_METATABLE);
   if (lua_isnil(L, -1)) {
      lua_pop(L, 1);
      return nullptr;
   }
   GCtab* range_mt = tabV(L->top - 1);
   lua_pop(L, 1);

   // Compare metatables
   if (mt != range_mt) return nullptr;

   return (fluid_range*)uddata(ud);
}

//********************************************************************************************************************
// Custom __index handler for tables
// Handles range userdata keys for table slicing, delegates other keys to raw table access

static int table_index_handler(lua_State* L)
{
   // Argument 1: the table
   // Argument 2: the key (range userdata or other)

   if (not tvistab(L->base)) {
      lua_pushnil(L);
      return 1;
   }

   GCtab* t = tabV(L->base);
   cTValue* key = L->base + 1;

   // Check for range userdata (table slicing)
   fluid_range* r = get_range_from_tvalue(L, key);
   if (r) {
      int32_t len = (int32_t)lj_tab_len(t);
      int32_t start = r->start;
      int32_t stop = r->stop;
      int32_t step = r->step;

      // Handle negative indices (always inclusive for negative ranges, per design doc)
      // This matches string slicing behaviour
      bool use_inclusive = r->inclusive;
      if (start < 0 or stop < 0) {
         use_inclusive = true;  // Negative indices ignore inclusive flag
         if (start < 0) start += len;
         if (stop < 0) stop += len;
      }

      // Determine iteration direction based on resolved indices, not original step
      // This allows {1...-1} to iterate forward from 1 to the last element
      bool forward = (start <= stop);
      if (step IS 0) step = forward ? 1 : -1;

      // For forward iteration, we need positive step; for reverse, negative step
      // If the step sign doesn't match direction, use default
      if (forward and step < 0) step = 1;
      if (not forward and step > 0) step = -1;

      // Calculate effective stop for exclusive ranges
      int32_t effective_stop = stop;
      if (not use_inclusive) {
         if (forward) effective_stop = stop - 1;
         else effective_stop = stop + 1;
      }

      // Bounds clipping
      if (forward) {
         if (start < 0) start = 0;
         if (effective_stop >= len) effective_stop = len - 1;
      }
      else {
         if (start >= len) start = len - 1;
         if (effective_stop < 0) effective_stop = 0;
      }

      // Check for empty/invalid ranges
      if (forward and start > effective_stop) {
         lua_createtable(L, 0, 0);
         return 1;
      }
      if (not forward and start < effective_stop) {
         lua_createtable(L, 0, 0);
         return 1;
      }

      // Calculate result size for pre-allocation
      int32_t result_size = 0;
      if (forward) {
         result_size = ((effective_stop - start) / step) + 1;
      }
      else {
         result_size = ((start - effective_stop) / (-step)) + 1;
      }

      // Create result table with pre-allocated size
      lua_createtable(L, result_size, 0);
      int result_table_idx = lua_gettop(L);
      int32_t result_idx = 0;

      // Copy elements using Lua API for safety
      if (forward) {
         for (int32_t i = start; i <= effective_stop; i += step) {
            cTValue* src = lj_tab_getint(t, i);
            if (src and not tvisnil(src)) {
               copyTV(L, L->top, src);
               L->top++;
               lua_rawseti(L, result_table_idx, result_idx++);
            }
            else {
               lua_pushnil(L);
               lua_rawseti(L, result_table_idx, result_idx++);
            }
         }
      }
      else {
         for (int32_t i = start; i >= effective_stop; i += step) {
            cTValue* src = lj_tab_getint(t, i);
            if (src and not tvisnil(src)) {
               copyTV(L, L->top, src);
               L->top++;
               lua_rawseti(L, result_table_idx, result_idx++);
            }
            else {
               lua_pushnil(L);
               lua_rawseti(L, result_table_idx, result_idx++);
            }
         }
      }

      return 1;
   }

   // Not a range - perform raw table access
   lua_rawget(L, 1);
   return 1;
}

//********************************************************************************************************************

static int luaopen_table_new(lua_State* L)
{
   return lj_lib_postreg(L, lj_cf_table_new, FF_table_new, "new");
}

//********************************************************************************************************************

#include "lj_libdef.h"

extern int luaopen_table(lua_State* L)
{
   LJ_LIB_REG(L, "table", table);
   lua_getglobal(L, "unpack");
   lua_setfield(L, -2, "unpack");
   lj_lib_prereg(L, "table.new", luaopen_table_new, tabV(L->top - 1));

   // Create metatable for table type with __index handler for range slicing
   GCtab* mt = lj_tab_new(L, 0, 1);
   global_State* g = G(L);

   // Set as base metatable for tables
   // NOBARRIER: basemt is a GC root.
   setgcref(basemt_it(g, LJ_TTAB), obj2gco(mt));

   // Create the __index handler function and set it in the metatable
   lua_pushcfunction(L, table_index_handler);
   TValue* index_slot = lj_tab_setstr(L, mt, mmname_str(g, MM_index));
   setfuncV(L, index_slot, funcV(L->top - 1));
   lua_pop(L, 1);

   // Update the metatable's negative-metamethod cache to indicate __index is present
   mt->nomm = (uint8_t)(~(1u << MM_index));

   return 1;
}
