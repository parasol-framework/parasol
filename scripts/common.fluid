-- Common utility functions are kept in this module.

------------------------------------------------------------------------------
-- Serialise the key-values of a table into an XML string.

table.toXML = function(t)
   local out = ''
   for tag,v in pairs(t) do
      if type(v) is 'table' then -- tag
         out ..= '<' .. tag
         local child = ''
         for ak,av in pairs(v) do
            if type(ak) is 'number' then -- key-less, can be child tag or content
               if type(av) is 'table' then
                  for ck,cv in pairs(av) do
                     if type(cv) is 'table' then
                        child ..= table.toXML({ [ck] = cv })
                     else
                        child ..= string.escXML(cv)
                     end
                  end
               else
                  child ..= string.escXML(tostring(av)) -- content
               end
            elseif type(av) is 'string' then -- attribute
               out ..= ' ' .. ak .. '="' .. string.escXML(av) .. '"'
            elseif type(av) is 'number' then -- attribute
               out ..= ' ' .. ak .. '=' .. av
            elseif type(av) is 'boolean' then -- attribute
               if av is true then
                  out ..= ' ' .. ak
               end
            else
               child ..= string.escXML(tostring(av)) -- content
            end
         end

         if child?? then
            out ..= '>' .. child .. '</>'
         else
            out ..= '/>'
         end
      else
         out = '<' .. tag .. '/>'
      end
   end
   return out
end

------------------------------------------------------------------------------
-- Usage: for k,v in table.sortByKeys(the_table) do

table.sortByKeys = function(t, f)
   local a = {}
   for n in pairs(t) do table.insert(a, n) end
   table.sort(a, f)
   local i = -1
   local iter = function()
      i++
      if not a[i] then return nil
      else return a[i], t[a[i]]
      end
   end
   return iter
end

------------------------------------------------------------------------------

file ?= { ui = { } }

-- Read an entire file as a string.
-- Will throw an exception if the file is not found or the complete data cannot be read.

file.readAll = function(Path)
   local ex, fl = catch(function() return obj.new('file', { flags='READ', path=Path } ) end)
   assert(not ex, <{ 'Failed to open file "' .. tostring(Path) .. '": ' .. ex.message }>)

   local file_buffer = string.alloc(fl.size)
   local err, bytes_read = fl.acRead(file_buffer)
   fl.free()
   assert(err is ERR_Okay and bytes_read is #file_buffer, 'Failed to read ' .. #file_buffer .. ' bytes from "' .. Path .. '"')
   return file_buffer
end

------------------------------------------------------------------------------

file.writeAll = function(Path, Content)
   local fl = obj.new('file', { path = Path, flags = 'WRITE|NEW' })
   fl.acWrite(Content)
   fl.free()
end

------------------------------------------------------------------------------

file.isFolder = function(Path)
   local e = string.sub(Path, -1)
   if (e is '/') or (e is '\\') or (e is ':') then return true end
   return false
end

------------------------------------------------------------------------------

file.splitPath = function(Path)
   if not Path then return nil, nil end
   local path, fl = string.match(Path, '^(.+[/:\\])(.+)$')
   if not path then return nil, Path end
   return path, fl
end

------------------------------------------------------------------------------

file.sanitisePath = function(Path)
   return string.gsub(Path, '[:/\\][:/\\]+', function(n) return n:sub(0,1) end)
end
