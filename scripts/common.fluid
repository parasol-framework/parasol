-- Common utility functions are kept in this module.

------------------------------------------------------------------------------
-- Serialise the key-values of a table into an XML string.

table.toXML = function(t:table):str
   out = ''
   for tag,v in pairs(t) do
      if type(v) is 'table' then -- tag
         out ..= f'<{tag}'
         local child = ''
         for ak,av in pairs(v) do
            if type(ak) is 'number' then -- key-less, can be child tag or content
               if type(av) is 'table' then
                  for ck,cv in pairs(av) do
                     if type(cv) is 'table' then
                        child ..= table.toXML({ [ck] = cv })
                     else
                        child ..= string.escXML(cv)
                     end
                  end
               else
                  child ..= string.escXML(tostring(av)) -- content
               end
            elseif type(av) is 'string' then -- attribute
               out ..= f' {ak}="{string.escXML(av)}"'
            elseif type(av) is 'number' then -- attribute
               out ..= f' {ak}={av}'
            elseif type(av) is 'boolean' then -- attribute
               if av is true then
                  out ..= ' ' .. ak
               end
            else
               child ..= string.escXML(tostring(av)) -- content
            end
         end

         if child?? then
            out ..= f'>{child}</>'
         else
            out ..= '/>'
         end
      else
         out = f'<{tag}/>'
      end
   end
   return out
end

------------------------------------------------------------------------------
-- Usage: for k,v in table.sortByKeys(the_table) do

table.sortByKeys = function(t:table, f:func):func
   a = {}
   for n in pairs(t) do table.insert(a, n) end
   table.sort(a, f)
   i = -1
   iter = function()
      i++
      if not a[i] then return nil
      else return a[i], t[a[i]]
      end
   end
   return iter
end

------------------------------------------------------------------------------

global file <const> ?= { ui = { } }

-- Read an entire file as a string.
-- Will throw an exception if the file is not found or the complete data cannot be read.

file.readAll = function(Path:str):str
   local fl
   try
      fl = obj.new('file', { flags='READ', path=Path } )
   except ex
      error(f'Failed to open {Path}: {ex.message}')
   end

   file_buffer = string.alloc(fl.size)
   err, bytes_read = fl.acRead(file_buffer)
   fl.free()
   assert(err is ERR_Okay and bytes_read is #file_buffer, 'Failed to read ' .. #file_buffer .. ' bytes from "' .. Path .. '"')
   return file_buffer
end

------------------------------------------------------------------------------

file.writeAll = function(Path:str, Content:str)
   fl = obj.new('file', { path = Path, flags = FL_WRITE|FL_NEW })
   fl.acWrite(Content)
   fl.free()
end

------------------------------------------------------------------------------

file.isFolder = function(Path:str):bool
   e = string.substr(Path, -1)
   if (e is '/') or (e is '\\') or (e is ':') then return true end
   return false
end

------------------------------------------------------------------------------

rx_split_path = <{ regex.new([[^(.+[\/:\\])(.*)$]]) }>

file.splitPath = function(Path:str):<str,str>
   Path ?? return nil, nil
   path, fl = rx_split_path.extract(Path)
   path ?? return nil, Path
   return path, fl
end

------------------------------------------------------------------------------
-- Sanitise a path by dropping repeated folder characters

rx_sanitise = <{ regex.new([[^(.*?[:\/\\])[:\/\\]+(.*)$]]) }>

file.sanitisePath = function(Path:str):str
   while true do
      rep = rx_sanitise.replace(Path, '$1$2')
      if #rep != #Path then
         Path = rep
      else
         break
      end
   end

   return Path
end
