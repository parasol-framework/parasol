-- Common interface for benchmarking

   namespace 'bmark'

   _LIB[_NS] = {
      ['null'] = {}
   }

   bmark = _LIB[_NS]

-- Benchmarks a provided Callback function and returns a table of the results

bmark.run = function(Duration:num, WarmupCalls:num, FeedbackRate:num, Feedback:func, Callback:func):table
   Feedback ?= function() end
   FeedbackRate ??= 100

   local results = {}
   local task = processing.task()

   results.totalCalls = 0
   results.warmupCount = 0

   local call_times   = array<double>
   local mem_usage    = array<int64>
   local start_time   = mSys.PreciseTime()
   local end_time     = start_time + (Duration * 1000000) -- Convert to microseconds
   local benchmarkStartTime = start_time

   -- Set high process priority and CPU affinity for consistent benchmarking

   local restore_priority = task.priority
   try
      task.priority = 20 -- Highest priority
   except ex
      Feedback(f'Warning: Failed to set high process priority: {ex.message}')
   success
      Feedback('Process priority set to HIGH for benchmarking')
      defer
         task.priority = restore_priority
      end
   end

   -- Set CPU affinity to cores 1-2 (avoid core 0 which handles system interrupts)
   -- AffinityMask = 6 (binary 0110) = cores 1 and 2

   local restore_affinity = task.affinityMask
   local aff_mask = 6
   try
       task.affinityMask = aff_mask
   except ex
      Feedback(f'Warning: Failed to set CPU affinity: {ex.message}')
   success
      Feedback(f'CPU affinity set to mask {aff_mask} for consistent benchmarking')
      defer
         task.affinityMask = restore_affinity
      end
   end

   Feedback('')

   processing.sleep(0.1) -- Consume messages

   while mSys.PreciseTime() < end_time do
      op_start = mSys.PreciseTime()
      Callback()
      op_end = mSys.PreciseTime()

      results.totalCalls++
      callTime = (op_end - op_start) / 1000 -- Convert to milliseconds

      -- Determine if this is a warmup cycle or benchmark cycle
      if results.warmupCount < WarmupCalls then
         results.warmupCount++
         if results.warmupCount is WarmupCalls then
            -- Warmup complete, reset timing and memory baseline
            benchmarkStartTime = mSys.PreciseTime()
            results.initialMemory = mSys.GetResource(RES_MEMORY_USAGE)
            results.peakMemory = results.initialMemory
            Feedback(string.format('Warmup completed (%d calls). Starting benchmark measurement...', WarmupCalls))
         end
      else -- This is a benchmark call, include in statistics
         call_times:push(callTime)
      end

      -- Track memory usage every 10 calls to avoid performance impact
      if results.totalCalls % 10 is 0 then
         currentMemory = mSys.GetResource(RES_MEMORY_USAGE)
         if results.warmupCount >= WarmupCalls then
            -- Only track memory during actual benchmark phase
            mem_usage:push(currentMemory)
            if currentMemory > results.peakMemory then
               results.peakMemory = currentMemory
            end
         end
      end

      -- Print progress every FeedbackRate cycles

      if results.totalCalls % FeedbackRate is 0 then
         elapsed    = (mSys.PreciseTime() - start_time) / 1000000
         currentMem = mSys.GetResource(RES_MEMORY_USAGE)
         status     = results.warmupCount < WarmupCalls and "Warmup" or "Benchmark"
         Feedback(string.format('%s: %d calls in %.1f seconds (%.1f calls/sec) | Memory: %.1f MB',
            status, results.totalCalls, elapsed, results.totalCalls / elapsed, currentMem / (1024*1024)))
      end
   end

   results.totalTime      = (mSys.PreciseTime() - start_time) / 1000000
   results.benchmarkTime  = (mSys.PreciseTime() - benchmarkStartTime) / 1000000
   results.benchmarkCalls = #call_times
   results.callsPerSecond = results.benchmarkCalls / results.benchmarkTime

   results.stats = bmark.stats(call_times)

   -- Final memory check
   results.finalMemory = mSys.GetResource(RES_MEMORY_USAGE)
   results.totalMemoryGrowth = results.finalMemory - results.initialMemory

   -- Calculate memory growth pattern
   results.memoryLeakRate = 0
   if #mem_usage > 1 and results.benchmarkTime > 0 then
      results.memoryLeakRate = results.totalMemoryGrowth / results.benchmarkTime -- bytes per second
   end

   return results
end

-- Returns statistical information for an array<double> of values (e.g. timing information)

bmark.stats = function(Values:array):table
   if #Values is 0 then
      return { min = 0, max = 0, median = 0, p95 = 0, p99 = 0, stddev = 0 }
   end

   -- Sort values for percentile calculations
   local sortedValues = {}
   for i, value in ipairs(Values) do
      sortedValues[i] = value
   end
   table.sort(sortedValues)

   -- Min and Max
   local minTime = sortedValues[0]
   local maxTime = sortedValues[#sortedValues-1]

   -- Median
   local median
   local n = #sortedValues
   if n % 2 is 0 then
      median = (sortedValues[n/2] + sortedValues[n/2 + 1]) / 2
   else
      median = sortedValues[math.ceil(n/2)]
   end

   -- Percentiles
   function getPercentile(values, p)
      index = math.ceil(p * #values / 100)
      if index < 1 then index = 1 end
      if index > #values then index = #values end
      return values[index]
   end

   p95 = getPercentile(sortedValues, 95)
   p99 = getPercentile(sortedValues, 99)

   -- Standard deviation
   sum = 0
   for value in values(Values) do
      sum += value
   end
   mean = sum / #Values

   variance = 0
   for value in values(Values) do
      variance += (value - mean) ^ 2
   end
   variance /= #Values
   stddev = math.sqrt(variance)

   return {
      min = minTime, max = maxTime, median = median, p95 = p95, p99 = p99, stddev = stddev, mean = mean
   }
end

-- Generate a text report from benchmark statistics

bmark.textReport = function(Results:table):array
   local msg = array<string>
   msg:push('=== BENCHMARK RESULTS ===')
   msg:push(string.format('Total calls:    %d (%d warmup + %d benchmark)', Results.totalCalls, Results.warmupCount, Results.benchmarkCalls))
   msg:push(string.format('Total time:     %.2f seconds', Results.totalTime))
   msg:push(string.format('Benchmark time: %.2f seconds', Results.benchmarkTime))
   msg:push(string.format('Overall rate:   %.2f calls per second', Results.totalCalls / Results.totalTime))
   msg:push(string.format('Benchmark rate: %.2f calls per second', Results.callsPerSecond))
   msg:push('')
   msg:push('=== CALL STATISTICS (ms) ===')
   msg:push(string.format('Average:    %.3f ms', Results.stats.mean))
   msg:push(string.format('Median:     %.3f ms', Results.stats.median))
   msg:push(string.format('Minimum:    %.3f ms', Results.stats.min))
   msg:push(string.format('Maximum:    %.3f ms', Results.stats.max ?? 0))
   msg:push(string.format('95th %%ile: %.3f ms', Results.stats.p95))
   msg:push(string.format('99th %%ile: %.3f ms', Results.stats.p99))
   msg:push(string.format('Std Dev:    %.3f ms', Results.stats.stddev))
   msg:push('')
   msg:push(string.format('Consistency: %.1f%% (lower is more consistent)', (Results.stats.stddev / Results.stats.mean) * 100))
   msg:push('')
   msg:push('=== MEMORY USAGE STATISTICS ===')
   msg:push(string.format('Initial:    %.2f MB', Results.initialMemory / (1024*1024)))
   msg:push(string.format('Peak:       %.2f MB', Results.peakMemory / (1024*1024)))
   msg:push(string.format('Final:      %.2f MB', Results.finalMemory / (1024*1024)))
   msg:push(string.format('Growth:     %.2f MB', Results.totalMemoryGrowth / (1024*1024)))
   return msg
end
