-- Refer to the Wiki for usage.
--
-- local hslib = require 'net/httpserver'
-- local httpServer = hslib.start({ Options... })
-- httpServer.stop()

   include 'network'
   local json = require('json')
   
   local glTime = obj.new('time')

   local httpServer = { }

   local glStatusTexts = {
       [200] = 'OK', [201] = 'Created', [204] = 'No Content',
       [301] = 'Moved Permanently', [302] = 'Found', [304] = 'Not Modified',
       [400] = 'Bad Request', [401] = 'Unauthorized', [403] = 'Forbidden',
       [404] = 'Not Found', [405] = 'Method Not Allowed', [429] = 'Too Many Requests',
       [500] = 'Internal Server Error', [501] = 'Not Implemented', [502] = 'Bad Gateway'
   }

   local glMimeTypes = {
      -- Text
      html = 'text/html',
      htm = 'text/html',
      css = 'text/css',
      js = 'application/javascript',
      mjs = 'application/javascript',
      json = 'application/json',
      xml = 'application/xml',
      txt = 'text/plain',
      md = 'text/markdown',
      csv = 'text/csv',

      -- Images
      png = 'image/png',
      jpg = 'image/jpeg',
      jpeg = 'image/jpeg',
      gif = 'image/gif',
      svg = 'image/svg+xml',
      ico = 'image/x-icon',
      webp = 'image/webp',
      bmp = 'image/bmp',
      tiff = 'image/tiff',

      -- Documents
      pdf = 'application/pdf',
      doc = 'application/msword',
      docx = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',

      -- Fonts
      woff = 'font/woff',
      woff2 = 'font/woff2',
      ttf = 'font/ttf',
      otf = 'font/otf',

      -- Audio/Video
      mp3 = 'audio/mpeg',
      wav = 'audio/wav',
      ogg = 'audio/ogg',
      mp4 = 'video/mp4',
      webm = 'video/webm',
      avi = 'video/x-msvideo',

      -- Archives
      zip = 'application/zip',
      tar = 'application/x-tar',
      gz = 'application/gzip'
   }

----------------------------------------------------------------------------------------------------------------------

local function validatePort(port)
   local portNum = tonumber(port)
   if not portNum or portNum < 1 or portNum > 65535 then
      return false
   end
   return true
end

----------------------------------------------------------------------------------------------------------------------
-- Decode percent-encoded characters in URLs

local function urlDecode(str)
   if not str then return str end
   str = str:gsub('+', ' ') -- Replace + with space
   str = str:gsub('%%(%x%x)', function(hex)
      return string.char(tonumber(hex, 16))
   end)
   return str
end

----------------------------------------------------------------------------------------------------------------------
-- Canonicalize path to prevent directory traversal attacks

local function canonicalizePath(self, Path)
   if not Path then return nil end

   Path = Path:gsub('[%c]', '')   -- Remove any null bytes
   Path = urlDecode(Path)         -- Decode URL encoding first
   Path = Path:match("([^?#]*)")  -- Remove query parameters and fragments

   -- Normalize slashes
   Path = Path:gsub('\\', '/')
   Path = Path:gsub('/+', '/')

   -- Split into components
   local components = {}
   for component in Path:gmatch('[^/]+') do
      if component == '..' then
         -- Attempt to go up - block this
         logMessage(self, 'Security: Blocked directory traversal attempt with ..')
         return nil
      elseif component != '.' and component != '' then
         table.insert(components, component)
      end
   end

   -- Rebuild clean path
   local cleanPath = '/' .. table.concat(components, '/')
   if Path:sub(-1) == '/' and cleanPath != '/' then
      cleanPath = cleanPath .. '/'
   end

   return cleanPath
end

----------------------------------------------------------------------------------------------------------------------

local function getMimeType(Filename)
   local extension = Filename:match("%.([^%.]+)$")
   if not extension then return 'application/octet-stream' end
   return glMimeTypes[extension:lower()] or 'application/octet-stream'
end

----------------------------------------------------------------------------------------------------------------------

local function timestamp()
   glTime.acQuery()
   return string.format('%04d-%02d-%02d %02d:%02d:%02d', glTime.year, glTime.month, glTime.day, glTime.hour, glTime.minute, glTime.second)
end

local function logMessage(self, message)
   if self.logMessage then
      self.logMessage('[' .. timestamp() .. '] ' .. message)
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Process chunked request body incrementally
-- Returns true when chunking is complete, false if still reading

local function processChunkedBody(state, server)
   while #state.buffer > 0 do
      if state.chunk_state == 'SIZE' then
         -- Look for chunk size line ending with \r\n
         local line_end = state.buffer:find('\r\n')
         if not line_end then
            return false -- Need more data for chunk size line
         end
         
         local size_line = state.buffer:sub(1, line_end - 1)
         state.buffer = state.buffer:sub(line_end + 2) -- Remove \r\n
         
         -- Parse chunk size (ignore extensions after semicolon)
         local hex_size = size_line:match('^([0-9a-fA-F]+)')
         if not hex_size then
            logMessage(server, 'Invalid chunk size format: ' .. size_line)
            return false -- Invalid format
         end
         
         state.chunk_size = tonumber(hex_size, 16)
         if not state.chunk_size then
            logMessage(server, 'Could not parse chunk size: ' .. hex_size)
            return false -- Invalid hex
         end
         
         logMessage(server, 'Chunk size: ' .. state.chunk_size .. ' bytes')
         
         if state.chunk_size == 0 then -- End of chunks
            state.chunk_state = 'TRAILER'
         else
            state.chunk_state = 'DATA'
            state.chunk_received = 0
         end
         
      elseif state.chunk_state == 'DATA' then
         -- Read chunk data
         local needed = state.chunk_size - state.chunk_received
         local available = #state.buffer
         
         if available == 0 then
            return false -- Need more data
         end
         
         local to_take = math.min(available, needed)
         state.request.body = state.request.body .. state.buffer:sub(1, to_take)
         state.buffer = state.buffer:sub(to_take + 1)
         state.chunk_received = state.chunk_received + to_take
         state.body_received = state.body_received + to_take
         
         if state.chunk_received >= state.chunk_size then
            -- Chunk data complete, expect trailing \r\n
            state.chunk_state = 'CRLF'
         end
         
      elseif state.chunk_state == 'CRLF' then
         -- Expect \r\n after chunk data
         if #state.buffer < 2 then return false end -- Need more data
         
         if state.buffer:sub(1, 2) == '\r\n' then
            state.buffer = state.buffer:sub(3)
            state.chunk_state = 'SIZE' -- Ready for next chunk
         else
            -- Be lenient - some clients might not send proper CRLF
            logMessage(server, 'Warning: Missing CRLF after chunk, continuing')
            state.chunk_state = 'SIZE'
         end
         
      elseif state.chunk_state == 'TRAILER' then
         -- Look for final \r\n (trailer headers are ignored for now)
         local trailer_end = state.buffer:find('\r\n')
         if trailer_end then
            state.buffer = state.buffer:sub(trailer_end + 2)
            return true -- Chunked reading complete
         else
            return false -- Need more data for trailer
         end
      end
   end
   
   return false -- Need more data
end

----------------------------------------------------------------------------------------------------------------------

local function readRequestWithTimeout(client, maxSize, timeoutSeconds)
   local buffer = string.alloc(1024) -- Start with 1KB buffer
   local requestData = ''
   local totalRead = 0
   local startTime = mSys.PreciseTime()

   while totalRead < maxSize do
      local err, bytes_read = client.acRead(buffer, 1024)

      if err != ERR_Okay then
         if err == ERR_TimeOut then
            logMessage(self, 'Request timeout after ' .. (mSys.PreciseTime() - startTime)/1000000 .. ' seconds')
            return nil, 'timeout'
         else
            logMessage(self, 'Failed to read request: ' .. mSys.GetErrorMsg(err))
            return nil, 'read_error'
         end
      end

      if bytes_read == 0 then
         break -- No more data
      end

      requestData = requestData .. buffer:sub(1, bytes_read)
      totalRead = totalRead + bytes_read

      -- Check for end of HTTP headers (\r\n\r\n)
      if requestData:find('\r\n\r\n') then
         break
      end

      -- Check timeout
      if (mSys.PreciseTime() - startTime)/1000000 > timeoutSeconds then
         logMessage(self, 'Request timeout exceeded')
         return nil, 'timeout'
      end
   end

   if totalRead >= maxSize then
      logMessage(self, 'Request too large: ' .. totalRead .. ' bytes')
      return nil, 'too_large'
   end

   return requestData, nil
end

----------------------------------------------------------------------------------------------------------------------
-- Read chunked request body (Transfer-Encoding: chunked)
-- Returns body, error_msg, connection_status

local function readChunkedRequestBody(client, maxSize, timeoutSeconds)
   local body = ''
   local totalSize = 0
   local startTime = mSys.PreciseTime()
   local buffer = string.alloc(8192) -- Buffer for reading
   local earlyTermination = false

   while true do
      -- Check timeout
      if (mSys.PreciseTime() - startTime)/1000000 > timeoutSeconds then
         return nil, 'timeout', false
      end

      -- Read chunk size line (hexadecimal number followed by optional extensions and CRLF)
      local chunkSizeLine = ''
      local char = ''
      while not chunkSizeLine:match('\r\n$') do
         local err, bytes_read = client.acRead(buffer, 1)
         if err != ERR_Okay then
            if err == ERR_TimeOut then
               return nil, 'timeout', false
            elseif err == ERR_Disconnected then
               -- Connection closed - treat as valid termination if we have data
               if #body > 0 then
                  return body, nil, true  -- Mark as early termination
               else
                  return nil, 'connection_closed', false
               end
            else
               return nil, 'read_error', false
            end
         end
         if bytes_read == 0 then
            -- No more data available - treat as valid termination if we have data
            if #body > 0 then
               return body, nil, true  -- Mark as early termination
            else
               return nil, 'unexpected_end', false
            end
         end
         chunkSizeLine = chunkSizeLine .. buffer:sub(1, 1)
         
         -- Prevent infinite line reading
         if #chunkSizeLine > 100 then
            return nil, 'invalid_chunk_size', false
         end
      end

      -- Parse chunk size (ignore chunk extensions after semicolon if present)
      local chunkSizeHex = chunkSizeLine:match('^([0-9a-fA-F]+)')
      if not chunkSizeHex then
         return nil, 'invalid_chunk_format', false
      end
      
      local chunkSize = tonumber(chunkSizeHex, 16)
      if not chunkSize then
         return nil, 'invalid_chunk_size', false
      end

      -- If chunk size is 0, we've reached the end
      if chunkSize == 0 then
         -- Read trailing CRLF after last chunk (if present)
         local err, bytes_read = client.acRead(buffer, 2)
         -- Ignore any errors here - the 0 chunk is sufficient termination
         break  -- Normal termination
      end

      -- Check if total size would exceed limit
      totalSize = totalSize + chunkSize
      if totalSize > maxSize then
         return nil, 'body_too_large', false
      end

      -- Read chunk data
      local chunkData = ''
      local chunkRead = 0
      while chunkRead < chunkSize do
         local toRead = math.min(8192, chunkSize - chunkRead)
         local err, bytes_read = client.acRead(buffer, toRead)
         if err != ERR_Okay then
            if err == ERR_TimeOut then
               return nil, 'timeout', false
            elseif err == ERR_Disconnected then
               -- Connection closed while reading chunk data
               -- Return what we have so far if it's valid
               if chunkRead > 0 then
                  body = body .. chunkData:sub(1, chunkRead)
               end
               if #body > 0 then
                  return body, nil, true  -- Mark as early termination
               else
                  return nil, 'connection_closed', false
               end
            else
               return nil, 'read_error', false
            end
         end
         if bytes_read == 0 then
            -- No more data - return what we have
            if chunkRead > 0 then
               body = body .. chunkData:sub(1, chunkRead)
            end
            if #body > 0 then
               return body, nil, true  -- Mark as early termination
            else
               return nil, 'unexpected_end', false
            end
         end
         chunkData = chunkData .. buffer:sub(1, bytes_read)
         chunkRead = chunkRead + bytes_read
      end

      body = body .. chunkData

      -- Read trailing CRLF after chunk data
      local crlf = ''
      local crlfAttempts = 0
      while #crlf < 2 and crlfAttempts < 2 do
         local err, bytes_read = client.acRead(buffer, 1)
         crlfAttempts = crlfAttempts + 1
         if err != ERR_Okay then
            if err == ERR_TimeOut then
               return nil, 'timeout', false
            elseif err == ERR_Disconnected then
               -- Connection closed - we got the chunk data, that's good enough
               -- Mark as early termination but continue
               earlyTermination = true
               break
            else
               -- For other errors, be lenient if we have the chunk data
               break
            end
         end
         if bytes_read == 0 then
            -- No CRLF but we have the chunk data - continue
            earlyTermination = true
            break
         end
         crlf = crlf .. buffer:sub(1, 1)
      end
      
      -- Be lenient about CRLF validation - some clients may not send it properly
      -- or the connection may close before sending it
   end

   -- Note: We're ignoring any trailing headers after the last chunk for now
   -- A full implementation would read headers until an empty line is found

   return body, nil, earlyTermination
end

----------------------------------------------------------------------------------------------------------------------
-- Parse query string into key-value pairs

local function parseQueryString(QueryString)
   local query = {}
   if not QueryString or QueryString == '' then
      return query
   end

   for pair in QueryString:gmatch('[^&]+') do
      local key, value = pair:match('([^=]+)=(.+)')
      if key and value then
         key = urlDecode(key)
         value = urlDecode(value)
         if query[key] then
            -- Handle multiple values for same key by converting to array
            if type(query[key]) != 'table' then
               query[key] = { query[key] }
            end
            table.insert(query[key], value)
         else
            query[key] = value
         end
      elseif key then -- Handle keys without values (e.g., ?debug&verbose)
         query[urlDecode(key)] = true
      end
   end

   return query
end

----------------------------------------------------------------------------------------------------------------------
-- Parse JSON body

local function parseJsonBody(Body)
   if not Body or Body == '' then
      return {}
   end

   local success, result = pcall(function()
      return json.decode(Body)
   end)

   if success then
      return result
   else
      return {}
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Parse form-encoded body (application/x-www-form-urlencoded)

local function parseFormBody(Body)
   return parseQueryString(Body) -- Same parsing logic as query strings
end

----------------------------------------------------------------------------------------------------------------------
-- Parse cookies from Cookie header

local function parseCookies(CookieHeader)
   local cookies = {}
   if not CookieHeader then
      return cookies
   end

   for cookie in CookieHeader:gmatch('[^;]+') do
      local name, value = cookie:match('%s*([^=]+)=(.+)')
      if name and value then
         -- Trim whitespace manually
         name = name:match('^%s*(.-)%s*$')
         value = value:match('^%s*(.-)%s*$')
         cookies[name] = value
      end
   end

   return cookies
end

----------------------------------------------------------------------------------------------------------------------
-- Returns: { method, path, fullPath, version, headers[k,v], query[k,v], cookies[k,v], params[k,v], body, parsedBody, range }

local function parseHttpRequest(Req)
   local lines = {}
   for line in Req:gmatch("[^\r\n]+") do
      table.insert(lines, line)
   end

   if #lines == 0 then return nil end

   local req_line = lines[1]
   local method, full_path, version = req_line:match("(%S+)%s+(%S+)%s+(%S+)")

   if (not method) or (not full_path) then return nil end

   -- Separate path from query string
   local path, queryString = full_path:match("([^?]*)%??(.*)")
   if not path then
      path = full_path
      queryString = ''
   end

   local headers = {}
   for i = 2, #lines do
      local line = lines[i]
      local name, value = line:match("([^:]+):%s*(.+)")
      if name and value then
         headers[name:lower()] = value
      end
   end

   local query = parseQueryString(queryString)

   local cookies = parseCookies(headers['cookie'])

   return {
      method = method,
      path = path,
      fullPath = full_path,
      version = version,
      headers = headers,
      query = query,
      cookies = cookies,
      params = {}, -- Will be populated by route matching
      body = nil, -- Raw body string
      parsedBody = {}, -- Will be populated with parsed body data
      range = headers['range'], -- Store range header for partial content
      brokenConnection = false -- Will be set to true if chunked transfer terminated early
   }
end

----------------------------------------------------------------------------------------------------------------------

local function sendHttpResponse(self, client, statusCode, statusText, headers, body)
   local response = "HTTP/1.1 " .. statusCode .. " " .. statusText .. "\r\n"

   if (not headers['content-length']) and (body) then headers['content-length'] = tostring(#body)end

   if (not headers['connection']) then headers['connection'] = 'close' end

   -- Add security headers
   if self.enableCSP then
      if not headers['content-security-policy'] then
         headers['content-security-policy'] = "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data:"
      end
      if not headers['x-content-type-options'] then
         headers['x-content-type-options'] = 'nosniff'
      end
      if not headers['x-frame-options'] then
         headers['x-frame-options'] = 'SAMEORIGIN'
      end
      if not headers['referrer-policy'] then
         headers['referrer-policy'] = 'strict-origin-when-cross-origin'
      end
   end

   for name, value in pairs(headers) do
      response = response .. name .. ": " .. value .. "\r\n"
   end

   response = response .. "\r\n"

   if body then response = response .. body end

   local err, written = client.acWrite(response)
   if err != ERR_Okay then
      logMessage(self, 'Failed to send response: ' .. mSys.GetErrorMsg(err))
   end
   
   if headers['connection'] == 'close' then -- The HTTP server is responsible for socket closure, so do it now. 
      msg('Closing client socket per connection: close')
      client.acDeactivate()
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Create enhanced response object with helper methods

local function createResponseObject(self, client)
   local res = {
      _self = self,
      _client = client,
      _statusCode = 200,
      _statusText = 'OK',
      _headers = {},
      _sent = false
   }

   -- Set status code and optional status text
   res.status = function(code, text)
      if res._sent then
         error('Cannot set status after response sent')
      end
      res._statusCode = code
      if text then
         res._statusText = text
      else
         -- Set default status text based on common codes
         res._statusText = glStatusTexts[code] or 'Unknown'
      end
      return res
   end

   -- Set response header
   res.header = function(name, value)
      if res._sent then
         error('Cannot set headers after response sent')
      end
      res._headers[name:lower()] = value
      return res
   end

   -- Set cookie
   res.cookie = function(name, value, options)
      if res._sent then
         error('Cannot set cookies after response sent')
      end
      options = options or {}
      local cookieStr = name .. '=' .. tostring(value)

      if options.maxAge then
         cookieStr = cookieStr .. '; Max-Age=' .. tostring(options.maxAge)
      end
      if options.expires then
         cookieStr = cookieStr .. '; Expires=' .. tostring(options.expires)
      end
      if options.path then
         cookieStr = cookieStr .. '; Path=' .. tostring(options.path)
      end
      if options.domain then
         cookieStr = cookieStr .. '; Domain=' .. tostring(options.domain)
      end
      if options.secure then
         cookieStr = cookieStr .. '; Secure'
      end
      if options.httpOnly then
         cookieStr = cookieStr .. '; HttpOnly'
      end
      if options.sameSite then
         cookieStr = cookieStr .. '; SameSite=' .. tostring(options.sameSite)
      end

      -- Handle multiple cookies by making set-cookie an array
      local existing = res._headers['set-cookie']
      if existing then
         if type(existing) != 'table' then
            existing = { existing }
         end
         table.insert(existing, cookieStr)
         res._headers['set-cookie'] = existing
      else
         res._headers['set-cookie'] = cookieStr
      end
      return res
   end

   -- Send JSON response
   res.json = function(data)
      if res._sent then
         error('Response already sent')
      end
      local jsonStr
      if type(data) == 'string' then
         jsonStr = data
      else
         jsonStr = json.encode(data)
      end

      res._headers['content-type'] = 'application/json'
      sendHttpResponse(res._self, res._client, res._statusCode, res._statusText, res._headers, jsonStr)
      res._sent = true
      return res
   end

   -- Send redirect response
   res.redirect = function(url, code)
      if res._sent then
         error('Response already sent')
      end
      code = code or 302
      res._headers['location'] = url
      res:status(code)
      sendHttpResponse(res._self, res._client, res._statusCode, res._statusText, res._headers)
      res._sent = true
      return res
   end

   -- Send text response
   res.send = function(body, contentType)
      if res._sent then
         error('Response already sent')
      end
      contentType = contentType or 'text/html'
      res._headers['content-type'] = contentType
      sendHttpResponse(res._self, res._client, res._statusCode, res._statusText, res._headers, tostring(body))
      res._sent = true
      return res
   end

   return res
end

----------------------------------------------------------------------------------------------------------------------

local function createErrorPage(statusCode, statusText, message, details)
   local html = '<!DOCTYPE html>\n<html>\n<head>\n'
      .. '<meta charset="utf-8">\n'
      .. '<title>' .. statusCode .. ' ' .. statusText .. '</title>\n'
      .. '<style>\n'
      .. 'body { font-family: Arial, sans-serif; margin: 40px; background: #f5f5f5; }\n'
      .. '.error-container { background: white; padding: 40px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); max-width: 600px; margin: 0 auto; }\n'
      .. 'h1 { color: #d32f2f; margin-top: 0; }\n'
      .. 'p { color: #666; line-height: 1.6; }\n'
      .. '.details { background: #f9f9f9; padding: 15px; border-radius: 4px; margin: 20px 0; font-family: monospace; }\n'
      .. '</style>\n'
      .. '</head>\n<body>\n'
      .. '<div class="error-container">\n'
      .. '<h1>' .. statusCode .. ' ' .. statusText .. '</h1>\n'
      .. '<p>' .. message .. '</p>\n'
   if details then
      html = html .. '<div class="details">' .. details .. '</div>\n'
   end
   html = html .. '<p><a href="/">Return to home</a></p>\n'
   html = html .. '</div>\n</body>\n</html>\n'
   return html
end

----------------------------------------------------------------------------------------------------------------------

local function serveFile(self, ClientSocket, FilePath, Request)
   local ex, file = catch(function() return obj.new('file', { path = FilePath, flags = 'READ' }) end)
   if not file then
      local errorBody
      if Request.method != 'HEAD' then
         errorBody = createErrorPage(404, 'Not Found', 'The requested file was not found.', 'Path: ' .. FilePath)
      end
      sendHttpResponse(self, ClientSocket, 404, "Not Found", {
         ['content-type'] = 'text/html'
      }, errorBody)
      return
   end

   local fileSize = file.size
   local mimeType = getMimeType(FilePath)

   -- For HEAD requests, only send headers without body
   if Request.method == 'HEAD' then
      sendHttpResponse(self, ClientSocket, 200, "OK", {
         ['content-type'] = mimeType,
         ['content-length'] = tostring(fileSize),
         ['accept-ranges'] = 'bytes'
      })
      return
   end

   -- Stream large files in chunks
   if fileSize > self.fileChunkSize then
      sendHttpResponse(self, ClientSocket, 200, "OK", {
         ['content-type'] = mimeType,
         ['content-length'] = tostring(fileSize),
         ['accept-ranges'] = 'bytes'
      })

      local buffer = string.alloc(self.fileChunkSize)
      local totalSent = 0

      while totalSent < fileSize do
         local toRead = math.min(self.fileChunkSize, fileSize - totalSent)
         local err, bytes_read = file.acRead(buffer, toRead)

         if err != ERR_Okay then
            logMessage(self, 'Error streaming file: ' .. mSys.GetErrorMsg(err))
            return
         end

         if bytes_read > 0 then
            err = ClientSocket.acWrite(buffer:sub(1, bytes_read))
            if err != ERR_Okay then
               logMessage(self, 'Error writing to ClientSocket: ' .. mSys.GetErrorMsg(err))
               return
            end
            totalSent = totalSent + bytes_read
         else
            break
         end
      end
   else
      -- Small files: read all at once
      local buffer = string.alloc(fileSize)
      local err, bytes_read = file.acRead(buffer)

      if err != ERR_Okay then
         local errorBody = createErrorPage(500, 'Internal Server Error', 'Error reading file.', 'Read error: ' .. mSys.GetErrorMsg(err))
         sendHttpResponse(self, ClientSocket, 500, "Internal Server Error", {
            ['content-type'] = 'text/html'
         }, errorBody)
         return
      end

      if bytes_read < fileSize then
         logMessage(self, 'Warning: Read ' .. bytes_read .. ' bytes, expected ' .. fileSize)
      end

      sendHttpResponse(self, ClientSocket, 200, "OK", {
         ['content-type'] = mimeType
      }, buffer:sub(1, bytes_read))
   end
end

----------------------------------------------------------------------------------------------------------------------

local function formatFileSize(Bytes)
   if Bytes < 1024 then
      return tostring(Bytes) .. ' B'
   elseif Bytes < 1024 * 1024 then
      return string.format('%.1f KB', Bytes / 1024)
   elseif Bytes < 1024 * 1024 * 1024 then
      return string.format('%.1f MB', Bytes / (1024 * 1024))
   else
      return string.format('%.1f GB', Bytes / (1024 * 1024 * 1024))
   end
end

----------------------------------------------------------------------------------------------------------------------

local function printableTime(Time)
   return string.format('%04d-%02d-%02d %02d:%02d:%02d',
      Time.Year, Time.Month, Time.Day, Time.Hour, Time.Minute, Time.Second)
end

----------------------------------------------------------------------------------------------------------------------

local function generateDirectoryListing(self, DirPath, URIPath)
   -- HTML escape function for security
   local function escapeHtml(str)
      if not str then return '' end
      str = tostring(str)
      str = str:gsub('&', '&amp;')
      str = str:gsub('<', '&lt;')
      str = str:gsub('>', '&gt;')
      str = str:gsub('"', '&quot;')
      str = str:gsub("'", '&#39;')
      return str
   end

   local safeUrlPath = escapeHtml(URIPath)
   local html = '<!DOCTYPE html>\n<html>\n<head>\n'
   html = html .. '<meta charset="utf-8">\n'
   html = html .. '<title>Directory listing for ' .. safeUrlPath .. '</title>\n'
   html = html .. '<style>\n'
   html = html .. 'body { font-family: Arial, sans-serif; margin: 40px; }\n'
   html = html .. 'h1 { color: #333; }\n'
   html = html .. 'table { border-collapse: collapse; width: 100%; }\n'
   html = html .. 'th, td { text-align: left; padding: 8px 12px; border-bottom: 1px solid #ddd; }\n'
   html = html .. 'th { background-color: #f5f5f5; font-weight: bold; }\n'
   html = html .. 'tr:hover { background-color: #f9f9f9; }\n'
   html = html .. 'a { text-decoration: none; color: #0066cc; }\n'
   html = html .. 'a:hover { text-decoration: underline; }\n'
   html = html .. '.dir { font-weight: bold; }\n'
   html = html .. '.size { text-align: right; }\n'
   html = html .. '</style>\n'
   html = html .. '</head>\n<body>\n'
   html = html .. '<h1>Directory listing for ' .. safeUrlPath .. '</h1>\n'
   html = html .. '<table>\n'
   html = html .. '<thead>\n<tr><th>Name</th><th>Size</th><th>Last Modified</th></tr>\n</thead>\n'
   html = html .. '<tbody>\n'

   -- Add parent directory link if not root
   if URIPath != '/' then
      local parentPath = URIPath:match('(.+)/.+/')
      if not parentPath then parentPath = '/' end
      html = html .. '<tr><td><a href="' .. parentPath .. '" class="dir">../</a></td><td>-</td><td>-</td></tr>\n'
   end

   -- List directory contents
   logMessage(self, 'Scanning folder ' .. DirPath)
   local err, dir = mSys.OpenDir(DirPath, bit.bor(RDF_FOLDERS, RDF_FILES, RDF_PERMISSIONS, RDF_DATE, RDF_SIZE, RDF_TAGS))
   if err == ERR_Okay then
      local count = 0
      local maxEntries = 1000 -- Limit directory entries to prevent DoS
      while mSys.ScanDir(dir) == ERR_Okay and count < maxEntries do
         local info = dir.info
         local name = info.Name

         -- Skip hidden files and system files for security
         if name:sub(1,1) != '.' then
            local isFolder = bit.band(info.flags, RDF_FOLDER) != 0
            local size
            if isFolder then
               size = '-'
            else
               size = formatFileSize(info.size)
            end
            local modTime = printableTime(info.modified)

            local href = URIPath
            href = href .. name
            if isFolder then href = href .. '/' end

         local displayName = escapeHtml(name)
         if isFolder then displayName = displayName .. '/' end

         local safeHref = escapeHtml(href)
         local cssClass = ''
         if isFolder then
            cssClass = ' class="dir"'
         end
         html = html .. '<tr><td><a href="' .. safeHref .. '"' .. cssClass .. '>' .. displayName .. '</a></td>'
            html = html .. '<td class="size">' .. escapeHtml(size) .. '</td>'
            html = html .. '<td>' .. escapeHtml(modTime) .. '</td></tr>\n'
            count = count + 1
         end
      end

      if count >= maxEntries then
         html = html .. '<tr><td colspan="3"><em>Directory listing truncated at ' .. maxEntries .. ' entries</em></td></tr>\n'
      end
   else
      logMessage(self, 'Failed to open folder ' .. nz(DirPath,'NIL'))
   end

   html = html .. '</tbody>\n</table>\n'
   html = html .. '</body>\n</html>\n'

   return html
end

----------------------------------------------------------------------------------------------------------------------

local function serveDirectory(self, Client, DirPath, URIPath, Request)
   -- Check for configured index files in order
   for _, indexFile in ipairs(self.indexFiles) do
      local indexPath = DirPath .. indexFile
      local err, type = mSys.AnalysePath(indexPath)
      if type == LOC_FILE then
         logMessage(self, 'Serving index file: ' .. indexFile)
         serveFile(self, Client, indexPath, Request)
         return
      end
   end

   -- If no index file found and auto-indexing is enabled, generate directory listing
   if self.autoIndex then
      logMessage(self, 'No index file found, generating directory listing for: ' .. URIPath)
      local html
      if Request.method != 'HEAD' then
         html = generateDirectoryListing(self, DirPath, URIPath)
      end
      sendHttpResponse(self, Client, 200, 'OK', {
         ['content-type'] = 'text/html; charset=utf-8'
      }, html)
   else
      -- Auto-indexing disabled, return 403 Forbidden
      local errorBody
      if Request.method != 'HEAD' then
         errorBody = createErrorPage(403, 'Forbidden', 'Directory listing is disabled.', 'Path: ' .. URIPath)
      end
      sendHttpResponse(self, Client, 403, 'Forbidden', {
         ['content-type'] = 'text/html'
      }, errorBody)
   end
end

----------------------------------------------------------------------------------------------------------------------
-- MIDDLEWARE SYSTEM

-- Execute middleware pipeline with next() chaining

local function executeMiddleware(middlewareList, request, response, finalCallback)
   local currentIndex = 1

   local function next(error)
      if error then
         if not response._sent then
            local errorBody = createErrorPage(500, 'Internal Server Error', 'Middleware error.', 'Error: ' .. tostring(error))
            sendHttpResponse(response._self, response._client, 500, "Internal Server Error", {
               ['content-type'] = 'text/html'
            }, errorBody)
         end
         return
      end

      if currentIndex > #middlewareList then -- All middleware executed, call final callback
         if finalCallback then finalCallback(request, response) end
         return
      end

      local middleware = middlewareList[currentIndex]
      currentIndex = currentIndex + 1

      -- Execute middleware function safely
      local success, result = pcall(function()
         return middleware(request, response, next)
      end)

      if not success then -- Middleware failed, pass error to next()
         next(result)
      end
   end

   next()
end

-- Built-in CORS middleware

local function corsMiddleware(request, response, next)
   -- Set CORS headers
   response.header('Access-Control-Allow-Origin', '*')
   response.header('Access-Control-Allow-Methods', 'GET, HEAD, POST, PUT, DELETE, PATCH, OPTIONS')
   response.header('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-Requested-With')
   response.header('Access-Control-Max-Age', '86400')

   -- Handle preflight requests
   if request.method == 'OPTIONS' then
      response.status(200).send('')
      return
   end

   next()
end

-- Built-in request logging middleware

local function loggingMiddleware(request, response, next)
   local startTime = mSys.PreciseTime()

   logMessage(nil, '[' .. timestamp() .. '] ' .. request.method .. ' ' .. request.path .. ' from ' .. (request.ip or 'unknown'))

   -- Wrap response.send to log completion
   local originalSend = response.send
   local originalJson = response.json
   local originalRedirect = response.redirect

   local function logResponse()
      local duration = (mSys.PreciseTime() - startTime) / 1000 -- Convert to milliseconds
      logMessage(nil, '[' .. timestamp() .. '] ' .. response._statusCode .. ' ' .. request.path .. ' (' .. string.format('%.2f', duration) .. 'ms)')
   end

   response.send = function(...)
      local result = originalSend(...)
      logResponse()
      return result
   end

   response.json = function(...)
      local result = originalJson(...)
      logResponse()
      return result
   end

   response.redirect = function(...)
      local result = originalRedirect(...)
      logResponse()
      return result
   end

   next()
end

-- Built-in authentication middleware template

local function authMiddleware(options)
   options = options or {}
   local tokenHeader = options.header or 'authorization'
   local tokenPrefix = options.prefix or 'Bearer '

   return function(request, response, next)
      local authHeader = request.headers[tokenHeader:lower()]

      if not authHeader then
         response.status(401).json({ error = 'Missing authorization header' })
         return
      end

      local token = authHeader
      if tokenPrefix and authHeader:find('^' .. tokenPrefix) then
         token = authHeader:sub(#tokenPrefix + 1)
      end

      if not token or token == '' then
         response.status(401).json({ error = 'Invalid authorization token' })
         return
      end

      -- Add token to request for use in route handlers
      request.auth = {
         token = token,
         user = nil -- Can be populated by custom validation logic
      }

      -- In a real implementation, you would validate the token here
      -- For now, just pass through
      next()
   end
end

----------------------------------------------------------------------------------------------------------------------
-- ROUTING SYSTEM

-- Add a route with method, pattern, callback, and optional middleware to a server instance

local function addRoute(self, route)
   if not self._routes then self._routes = {} end

   if route.pattern and route.method and route.handler then
      local method = route.method:upper()
      local pattern = tostring(route.pattern)

      if not self._routes[method] then self._routes[method] = {} end

      if type(route.handler) == 'function' then
         -- Validate route-specific middleware
         if type(route.middleware) == 'table' then
            for j, mw in ipairs(route.middleware) do
               if type(mw) != 'function' then
                  error('Invalid middleware for route ' .. method .. ' ' .. pattern .. ' at index ' .. j .. ' - must be a function')
               end
            end
         end

         table.insert(self._routes[method], {
            pattern = pattern,
            callback = route.handler,
            validateHeader = route.validateHeader,
            middleware = route.middleware,
            compiledRegex = nil -- Will be set when first used
         })

         msg('Route registered: ' .. method .. ' ' .. pattern)
      else
         error('Invalid handler for route ' .. method .. ' ' .. pattern .. ' - must be a function')
      end
   else
      error('Invalid route configuration - missing pattern, method, or handler')
   end
end

-- Extract parameters from a matched path using route pattern and regex match results

local function extractParams(pattern, matchResults)
   local params = {}

   -- Extract parameter names from the original pattern
   local paramNames = {}
   for paramName in pattern:gmatch(':([%w_]+)') do
      table.insert(paramNames, paramName)
   end

   -- Map parameter names to captured group values (skip index 1 which is full match)
   for i, name in ipairs(paramNames) do
      if matchResults[i + 1] then
         params[name] = urlDecode(matchResults[i + 1])
      end
   end

   return params
end

-- Find matching route for a request from a server instance

local function matchRoute(serverInstance, method, path)
   if not serverInstance._routes then return nil end

   local methodRoutes = serverInstance._routes[method]
   if not methodRoutes then return nil end

   for i, route in ipairs(methodRoutes) do
      local pattern = route.pattern

      if not route.compiledRegex then
         -- Convert route pattern to proper regex pattern
         -- :param becomes ([^/]+), * becomes (.*), escape regex special chars
         local regexPattern = pattern
         regexPattern = regexPattern:gsub('([%.%+%-%*%?%[%]%(%)])', '\\%1') -- Escape regex chars
         regexPattern = regexPattern:gsub(':([%w_]+)', '([^/]+)') -- :param -> ([^/]+)
         regexPattern = regexPattern:gsub('\\%*', '(.*)') -- \* -> (.*)
         regexPattern = '^' .. regexPattern .. '$'

         catch(function()
            route.compiledRegex = regex.new(regexPattern)
         end,
         function(Exception)
            error('matchRoute: Failed to compile regex: ' .. Exception.message)
         end)
      end

      -- Test if path matches this route (skip invalid regex patterns)

      if route.compiledRegex then
         local testResult = route.compiledRegex.test(path)

         if testResult then -- Get capture groups for parameter extraction
            local matchResults = route.compiledRegex.match(path)
            local params = extractParams(pattern, matchResults)
            return route, params
         end
      end
   end

   return nil
end

----------------------------------------------------------------------------------------------------------------------
-- Check rate limiting for client IP

local function checkRateLimit(self, IP)
   if not self.rateLimit or self.rateLimit <= 0 then
      return true -- Rate limiting disabled
   end

   local currentTime = mSys.PreciseTime() / 1000000 -- Convert to seconds

   -- Clean up old entries every minute
   if currentTime - self._lastCleanup > 60 then
      local cutoff = currentTime - self.rateLimitWindow
      for ip, data in pairs(self._rateLimits) do
         local newRequests = {}
         for _, timestamp in ipairs(data.requests) do
            if timestamp > cutoff then
               table.insert(newRequests, timestamp)
            end
         end
         if #newRequests == 0 then
            self._rateLimits[ip] = nil
         else
            data.requests = newRequests
         end
      end
      self._lastCleanup = currentTime
   end

   -- Check this client's rate
   if not self._rateLimits[IP] then
      self._rateLimits[IP] = { requests = {} }
   end

   local clientData = self._rateLimits[IP]
   local cutoff = currentTime - self.rateLimitWindow

   -- Count recent requests
   local recentRequests = {}
   for _, timestamp in ipairs(clientData.requests) do
      if timestamp > cutoff then
         table.insert(recentRequests, timestamp)
      end
   end

   if #recentRequests >= self.rateLimit then
      logMessage(self, 'Rate limit exceeded for ' .. IP)
      return false
   end

   -- Add current request
   table.insert(recentRequests, currentTime)
   clientData.requests = recentRequests

   return true
end

----------------------------------------------------------------------------------------------------------------------
-- This is the incoming data handler for client sockets.  acRead() is used to read data from the ClientSocket.

local function serverIncoming(self, ClientSocket)
   local state = ClientSocket._state()
   
   if not state.initialised then
      state.buffer = ''
      state.phase = 'READING_HEADERS'
      state.headers_complete = false
      state.content_length = nil
      state.body_received = 0
      state.start_time = mSys.PreciseTime()
      state.request = nil
      state.initialised = true
      state.transfer_encoding = nil
      state.chunk_state = 'SIZE' -- For chunked encoding: SIZE, DATA, TRAILER
      state.chunk_size = 0
      state.chunk_received = 0
      
      -- Get client IP for rate limiting
      local ip_array = ClientSocket.client.ip
      state.ip = ip_array[1] .. '.' .. ip_array[2] .. '.' .. ip_array[3] .. '.' .. ip_array[4]
      
      -- Check rate limit
      if not checkRateLimit(self, state.ip) then
         local errorBody = createErrorPage(429, 'Too Many Requests', 'Rate limit exceeded. Please try again later.', 'Limit: ' .. self.rateLimit .. ' requests per ' .. self.rateLimitWindow .. ' seconds')
         sendHttpResponse(self, ClientSocket, 429, "Too Many Requests", {
            ['content-type'] = 'text/html',
            ['retry-after'] = tostring(self.rateLimitWindow)
         }, errorBody)
         return
      end
   end
   
   -- Check for timeout
   if (mSys.PreciseTime() - state.start_time)/1000000 > self.timeout then
      local errorBody = createErrorPage(408, 'Request Timeout', 'The server did not receive a complete request within the timeout period.', 'Timeout: ' .. self.timeout .. ' seconds')
      sendHttpResponse(self, ClientSocket, 408, "Request Timeout", {
         ['content-type'] = 'text/html'
      }, errorBody)
      return
   end
   
   local buffer = string.alloc(8192)
   local err, bytes_read = ClientSocket.acRead(buffer, 8192)
   
   if err != ERR_Okay then
      logMessage(self, 'Failed to read from client: ' .. mSys.GetErrorMsg(err))
      return
   end
   
   if bytes_read == 0 then return end -- Sometimes happens with SSL sockets
   
   -- Accumulate data

   state.buffer = state.buffer .. buffer:sub(1, bytes_read)  
   if #state.buffer > self.maxRequestSize then
      local errorBody = createErrorPage(413, 'Payload Too Large', 'Request exceeds maximum allowed size.', 'Maximum size: ' .. self.maxRequestSize .. ' bytes')
      sendHttpResponse(self, ClientSocket, 413, "Payload Too Large", {
         ['content-type'] = 'text/html'
      }, errorBody)
      return
   end
   
   -- Read and parse headers
   if state.phase == 'READING_HEADERS' then
      -- Look for end of headers marker
      local header_end = state.buffer:find('\r\n\r\n')
      if not header_end then return end -- Wait for more data
      
      -- Extract header section
      local header_section = state.buffer:sub(1, header_end + 3) -- Include the \r\n\r\n
      state.request = parseHttpRequest(header_section)
      
      if not state.request then
         local errorBody = createErrorPage(400, 'Bad Request', 'Invalid HTTP request format.', 'The request could not be parsed as valid HTTP.')
         sendHttpResponse(self, ClientSocket, 400, "Bad Request", {
            ['content-type'] = 'text/html'
         }, errorBody)
         return
      end
      
      logMessage(self, '[' .. timestamp() .. '] ' .. state.request.method .. ' ' .. state.request.path)
      if self.verbose then
         logMessage(self, 'Headers:')
         for k, v in pairs(state.request.headers) do
            logMessage(self, '  ' .. k .. ': ' .. v)
         end
      end
      
      -- Check if method is supported
      local supportedMethods = { 'GET', 'HEAD', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS' }
      local methodSupported = false
      for _, method in ipairs(supportedMethods) do
         if state.request.method == method then
            methodSupported = true
            break
         end
      end
      
      if not methodSupported then
         local errorBody = createErrorPage(405, 'Method Not Allowed', 'HTTP method not supported.', 'Requested method: ' .. state.request.method)
         sendHttpResponse(self, ClientSocket, 405, "Method Not Allowed", {
            ['content-type'] = 'text/html',
            ['allow'] = 'GET, HEAD, POST, PUT, DELETE, PATCH, OPTIONS'
         }, errorBody)
         return
      end
      
      -- Remove processed headers from buffer
      state.buffer = state.buffer:sub(header_end + 4) -- Remove \r\n\r\n as well
      state.headers_complete = true
      
      -- Determine if we need to read a body
      state.content_length = tonumber(state.request.headers['content-length'])
      state.transfer_encoding = state.request.headers['transfer-encoding']
      
      if state.request.method == 'POST' or state.request.method == 'PUT' or state.request.method == 'PATCH' then
         if (state.transfer_encoding and state.transfer_encoding:lower():find('chunked')) or 
            (state.content_length and state.content_length > 0) then
            -- Need to read body
            state.phase = 'READING_BODY'
            state.request.body = ''
            -- Continue processing in body reading phase
         else -- No body expected
            state.phase = 'PROCESSING'
         end
      else -- GET, HEAD, DELETE, OPTIONS don't typically have bodies
         state.phase = 'PROCESSING'
      end
   end
   
   -- Read request body
   if state.phase == 'READING_BODY' then
      if state.transfer_encoding and state.transfer_encoding:lower():find('chunked') then
         if not processChunkedBody(state, self) then
            return -- Still reading chunks or error occurred
         end
      elseif state.content_length and state.content_length > 0 then
         -- Accumulate body data from buffer
         local needed = state.content_length - state.body_received
         local available = #state.buffer
         
         if available > 0 then
            local to_take = math.min(available, needed)
            state.request.body = state.request.body .. state.buffer:sub(1, to_take)
            state.buffer = state.buffer:sub(to_take + 1)
            state.body_received = state.body_received + to_take
            
            logMessage(self, 'Body progress: ' .. state.body_received .. '/' .. state.content_length .. ' bytes')
         end
         
         if state.body_received < state.content_length then
            return -- Still need more body data
         end
      end
      
      -- Body reading complete, parse it
      if state.request.body then
         local contentType = state.request.headers['content-type'] or ''
         if contentType:find('application/json') then
            logMessage(self, 'Parsing JSON encoded data')
            state.request.parsedBody = parseJsonBody(state.request.body)
         elseif contentType:find('application/x%-www%-form%-urlencoded') then
            logMessage(self, 'Parsing URL-encoded form data')
            state.request.parsedBody = parseFormBody(state.request.body)
         else
            -- Keep raw body for other content types
            state.request.parsedBody = { _raw = state.request.body }
         end
      end
      
      state.phase = 'PROCESSING'
   end
   
   -- Process complete request
   if state.phase == 'PROCESSING' then
      local request = state.request
      
      -- Handle OPTIONS requests for CORS
      if request.method == 'OPTIONS' then
         sendHttpResponse(self, ClientSocket, 200, "OK", {
            ['access-control-allow-origin'] = '*',
            ['access-control-allow-methods'] = 'GET, HEAD, POST, PUT, DELETE, PATCH, OPTIONS',
            ['access-control-allow-headers'] = 'Content-Type, Authorization',
            ['access-control-max-age'] = '86400'
         })
         return
      end

      -- Canonicalize and validate path
      local URIPath = canonicalizePath(self, request.path)
      if not URIPath then
         local errorBody = createErrorPage(400, 'Bad Request', 'Invalid path in request.', 'Original path: ' .. request.path)
         logMessage(self, 'Security: Invalid path blocked: ' .. request.path)
         sendHttpResponse(self, ClientSocket, 400, "Bad Request", {
            ['content-type'] = 'text/html'
         }, errorBody)
         return
      end

      -- Add client IP to request for middleware
      request.ip = state.ip

      -- Try to match against registered routes first
      local matchedRoute, params = matchRoute(self, request.method, URIPath)
      if matchedRoute then
         logMessage(self, 'Found matching route: ' .. matchedRoute.pattern)
         -- Populate request params and create response object
         request.params = params
         local response = createResponseObject(self, ClientSocket)

         -- Combine global middleware with route-specific middleware
         local middlewareChain = {}

         -- Add global middleware first
         if self._middleware then
            for _, middleware in ipairs(self._middleware) do
               table.insert(middlewareChain, middleware)
            end
         end

         -- Add route-specific middleware
         if matchedRoute.middleware then
            for _, middleware in ipairs(matchedRoute.middleware) do
               table.insert(middlewareChain, middleware)
            end
         end

         -- Execute middleware pipeline followed by route handler
         local function routeHandler(req, res)
            local success, result = pcall(function()
               return matchedRoute.callback(req, res)
            end)

            if not success then
               -- Route callback failed, send 500 error
               logMessage(self, 'Route handler error: ' .. tostring(result))
               if not res._sent then
                  local errorBody = createErrorPage(500, 'Internal Server Error', 'Route handler failed.', 'Error: ' .. tostring(result))
                  sendHttpResponse(self, ClientSocket, 500, "Internal Server Error", {
                     ['content-type'] = 'text/html'
                  }, errorBody)
               end
            elseif not res._sent then
               -- Route executed successfully but didn't send a response
               logMessage(self, 'Warning: Route handler completed without sending response')
               local errorBody = createErrorPage(500, 'Internal Server Error', 'Route handler did not send a response.', 'Path: ' .. URIPath)
               sendHttpResponse(self, ClientSocket, 500, "Internal Server Error", {
                  ['content-type'] = 'text/html'
               }, errorBody)
            end
         end

         -- Execute middleware chain
         executeMiddleware(middlewareChain, request, response, routeHandler)

         return -- Route was handled, don't continue to static file serving
      end

      -- Validate path doesn't contain dangerous patterns
      local dangerous = {
         '%.%./', '%.%.\\', -- Directory traversal
         '^%.', '/%.', -- Hidden files
         '%.exe$', '%.bat$', '%.cmd$', '%.ps1$', -- Executables
         '%.dll$', '%.so$', -- Libraries
         '%.ini$', '%.conf$', '%.config$', -- Config files
      }

      for _, pattern in ipairs(dangerous) do
         if URIPath:find(pattern) then
            local errorBody = createErrorPage(403, 'Forbidden', 'Access to this file type is forbidden.', 'Path: ' .. URIPath)
            logMessage(self, 'Security: Blocked access to dangerous path: ' .. URIPath)
            sendHttpResponse(self, ClientSocket, 403, "Forbidden", {
               ['content-type'] = 'text/html'
            }, errorBody)
            return
         end
      end

      local file_path = self.folder .. URIPath

      -- Check if path exists and determine if it's a file or directory
      local err, fileType = mSys.AnalysePath(file_path)
      if err != ERR_Okay then
         local errorBody = createErrorPage(404, 'Not Found', 'The requested resource was not found.', 'Path: ' .. URIPath .. '\nResolved to: ' .. file_path)
         sendHttpResponse(self, ClientSocket, 404, "Not Found", {
            ['content-type'] = 'text/html'
         }, errorBody)
         return
      end

      if request.method != 'GET' and request.method != 'HEAD' then
         local errorBody = createErrorPage(405, 'Method Not Allowed',
            'This method is not allowed for static file serving. Use routing system for API endpoints.',
            'Method: ' .. request.method .. ', Path: ' .. URIPath)
         sendHttpResponse(self, ClientSocket, 405, "Method Not Allowed", {
            ['content-type'] = 'text/html',
            ['allow'] = 'GET, HEAD'
         }, errorBody)
         return
      end

      if fileType == LOC_FOLDER then
         -- Ensure directory URLs end with /
         if not URIPath:match('/$') then
            sendHttpResponse(self, ClientSocket, 301, 'Moved Permanently', {
               ['location'] = URIPath .. '/'
            })
            return
         end
         serveDirectory(self, ClientSocket, file_path, URIPath, request)
      else
         serveFile(self, ClientSocket, file_path, request)
      end
   end -- End of PROCESSING phase
end

----------------------------------------------------------------------------------------------------------------------

httpServer.start = function(Options)
   local self = {
      port            = 8080,   -- Server port number
      folder          = nil,    -- Path from which to serve files
      bind            = nil,    -- Bind to specific address (e.g., '127.0.0.1', '0.0.0.0', or specific IP)
      maxRequestSize  = 65536,  -- 64KB max request size
      fileChunkSize   = 65536,  -- 64KB chunks for file streaming
      timeout         = 30,     -- 30 second timeout
      verbose         = false,  -- Enable verbose logging
      indexFiles      = {'index.html', 'index.htm', 'default.html', 'default.htm'}, -- Default index files to serve
      autoIndex       = true,   -- Enable automatic directory listing if no index file found
      rateLimit       = 100,    -- Max requests per minute per IP
      rateLimitWindow = 60,     -- Rate limit window in seconds
      enableCSP       = true,    -- Enable Content-Security-Policy headers
      _socket         = nil,
      -- Rate limiting
      _lastCleanup = 0,
      _rateLimits = {}
   }

   if Options.port then
      if validatePort(Options.port) then
         self.port = tonumber(Options.port)
      else
         error('Invalid port number: ' .. Options.port .. '. Port must be between 1 and 65535.')
      end
   end

   if Options.folder then
      -- Validate folder input
      local folder = Options.folder
      if folder:find('%.%.') or folder:find('^~') then
         error('Invalid folder path: security violation')
      end

      local err, resolvedPath = mSys.ResolvePath(folder)
      if err == ERR_Okay then
         self.folder = resolvedPath
      end

      local err, filetype = mSys.AnalysePath(self.folder)
      if filetype != LOC_FOLDER then
         error('Error: folder "' .. nz(self.folder,'NIL') .. '" does not exist')
      end
   end

   if not self.folder then
      error('The folder option is required')
   end

   if Options.verbose then
      if type(Options.verbose) == 'boolean' then
         self.verbose = Options.verbose
      else
         local verbose = tostring(Options.verbose):lower()
         self.verbose = (verbose == 'true' or verbose == '1')
      end
   end

   if Options.timeout then
      local timeout = tonumber(Options.timeout)
      if timeout and (timeout > 0) and (timeout <= 300) then
         self.timeout = timeout
      else
         error('Invalid timeout: must be between 1 and 300 seconds')
      end
   end

   if Options.autoIndex then
      if type(Options.autoIndex) == 'boolean' then
         self.autoIndex = Options.autoIndex
      else
         local autoindex = tostring(Options.autoIndex):lower()
         self.autoIndex = (autoindex == 'true' or autoindex == '1')
      end
   end

   if Options.rateLimit then
      local limit = tonumber(Options.rateLimit)
      if limit and (limit >= 0) and (limit <= 1000) then
         self.rateLimit = limit
      end
   end

   if Options.bind then
      self.bind = Options.bind
   end

   if Options.logMessage then
      if type(Options.logMessage) == 'function' then
         self.logMessage = Options.logMessage
      else
         error('logMessage option must be a function')
      end
   end

   -- Process middleware configuration
   local middlewareCount = 0
   if Options.middleware then
      if type(Options.middleware) == 'table' then
         self._middleware = {}
         for i, middleware in ipairs(Options.middleware) do
            if type(middleware) == 'function' then
               table.insert(self._middleware, middleware)
               middlewareCount = middlewareCount + 1
               logMessage(self, 'Global middleware configured at index ' .. i)
            else
               error('Invalid middleware at index ' .. i .. ' - must be a function')
            end
         end
      else
         error('middleware option must be a table')
      end
   end

   -- Process routes configuration
   local routeCount = 0
   if Options.routes then
      if type(Options.routes) == 'table' then
         for i, route in ipairs(Options.routes) do
            if (type(route) == 'table') then
               addRoute(self, route)
               routeCount = routeCount + 1
            end
         end
      else
         error('routes option must be a table')
      end
   end

   local bindMsg = ''
   if self.bind then
      bindMsg = ' bound to ' .. self.bind
   end
   msg('\nStarting HTTP server on port ' .. self.port .. bindMsg)
   msg('Serving files from: ' .. self.folder)
   msg('Configuration:')
   msg('  Port: ' .. self.port)
   msg('  Bind address: ' .. (self.bind or 'all interfaces'))
   msg('  Folder: ' .. self.folder)
   msg('  Max request size: ' .. self.maxRequestSize .. ' bytes')
   msg('  File chunk size: ' .. self.fileChunkSize .. ' bytes')
   msg('  Timeout: ' .. self.timeout .. ' seconds')
   msg('  Verbose logging: ' .. (self.verbose and 'enabled' or 'disabled'))
   msg('  Index files: ' .. table.concat(self.indexFiles, ', '))
   msg('  Auto-indexing: ' .. (self.autoIndex and 'enabled' or 'disabled'))
   msg('  Rate limit: ' .. (self.rateLimit > 0 and (self.rateLimit .. ' requests per ' .. self.rateLimitWindow .. ' seconds') or 'disabled'))
   msg('  Security headers: ' .. (self.enableCSP and 'enabled' or 'disabled'))
   msg('  Global middleware: ' .. middlewareCount)
   msg('  Routes configured: ' .. routeCount)

   local cfg = {
      port = self.port,
      flags = 'SERVER|MULTI_CONNECT',
      feedback = function(Server, ClientSocket, State)
         if State == NTC_CONNECTED then
            -- New client connection
         elseif State == NTC_DISCONNECTED then
            -- Client disconnected
         end
      end,
      incoming = function(Server, ClientSocket)
         serverIncoming(self, ClientSocket)
      end
   }

   if self.bind then
      cfg.address = self.bind
   end

   self._socket = obj.new('netsocket', cfg)

   if not self._socket then
      error('Failed to create server socket')
   end

   self.stop = function()
      if self._socket then
         self._socket = nil
         collectgarbage()
      end
   end

   -- Generic route registration with optional middleware

   self.newRoute = function(Route)
      addRoute(self, Route)
   end

   -- Add global middleware
   self.newMiddleware = function(middleware)
      if not self._middleware then
         self._middleware = {}
      end
      if type(middleware) == 'function' then
         table.insert(self._middleware, middleware)
         logMessage(self, 'Global middleware added')
      else
         error('Middleware must be a function')
      end
   end

   -- Built-in middleware factory functions
   self.middleware = {
      cors = function(options)
         options = options or {}
         return function(request, response, next)
            -- Set CORS headers with custom options
            response.header('Access-Control-Allow-Origin', options.origin or '*')
            response.header('Access-Control-Allow-Methods', options.methods or 'GET, HEAD, POST, PUT, DELETE, PATCH, OPTIONS')
            response.header('Access-Control-Allow-Headers', options.headers or 'Content-Type, Authorization, X-Requested-With')
            response.header('Access-Control-Max-Age', tostring(options.maxAge or 86400))

            if options.credentials then
               response.header('Access-Control-Allow-Credentials', 'true')
            end

            -- Handle preflight requests
            if request.method == 'OPTIONS' then
               response.status(200).send('')
               return
            end

            next()
         end
      end,

      logging = function(options)
         options = options or {}
         return loggingMiddleware
      end,

      auth = function(options)
         return authMiddleware(options)
      end
   }

   return self
end

   return httpServer