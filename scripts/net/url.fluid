-- URL parsing and handling module for Parasol
--
-- Usage:
--   local urllib = require('net/url') -- Choose a name that avoids namespace conflicts
--   local parts = urllib.parse('https://example.com/path?query=value')

    local url
    if url then return url end
    url = { }

    local DEFAULT_PORTS = {
       http = 80,
       https = 443,
       ftp = 21,
       ssh = 22,
       telnet = 23,
       smtp = 25,
       pop3 = 110,
       imap = 143,
       ldap = 389,
       ldaps = 636
    }

    -- Characters that need percent-encoding in different URL contexts

    local RESERVED_CHARS = {
       -- General reserved characters (RFC 3986)
       general = ':/?#[]@!$&\'()*+,;=%',
       -- Additional characters that should be encoded in query strings
       query = ' "<>\\^`{|}',
       -- Characters that should be encoded in path components
       path = ' "?<>#'
    }

----------------------------------------------------------------------------------------------------------------------
-- URL Encoding Functions

-- Percent-encode a string for safe URL use

function url.encode(str, extraChars)
   if not str then return nil end

   local chars_to_encode = RESERVED_CHARS.general .. RESERVED_CHARS.query
   if extraChars then chars_to_encode = chars_to_encode .. extraChars end

   -- Simple character-by-character encoding to avoid pattern issues
   local result = {}
   for i = 1, #str do
      local c = str:sub(i, i)
      if chars_to_encode:find(c, 1, true) then
         table.insert(result, string.format('%%%02X', string.byte(c)))
      else
         table.insert(result, c)
      end
   end

   return table.concat(result)
end

-- Percent-encode with spaces as plus signs (for form data)

function url.encodePlus(str, extraChars)
   if not str then return nil end

   local encoded = url.encode(str, extraChars)
   if encoded then
      encoded = encoded:gsub('%%20', '+')
   end

   return encoded
end

-- Decode percent-encoded string

function url.decode(str)
   if not str then return nil end

   local decoded = str:gsub('%%([0-9A-Fa-f][0-9A-Fa-f])', function(hex)
      return string.char(tonumber(hex, 16))
   end)

   return decoded
end

-- Decode percent-encoded string with plus signs as spaces

function url.decodePlus(str)
   if not str then return nil end
   local decoded = str:gsub('%+', ' ')
   return url.decode(decoded)
end

-- Encode string for use in path components

function url.encodeComponent(str)
   if not str then return nil end
   return url.encode(str, RESERVED_CHARS.path)
end

----------------------------------------------------------------------------------------------------------------------
-- Query String Functions

-- Parse query string into table of key-value pairs

function url.parseQuery(queryString)
   if not queryString or queryString == '' then return {} end

   local params = {}
   for pair in queryString:gmatch('[^&]+') do
      local key, value = pair:match('^([^=]*)=(.*)$')
      if key then
         key = url.decodePlus(key)
         value = url.decodePlus(value)
         if params[key] then
            -- Handle multiple values for same key
            if type(params[key]) != 'table' then
               params[key] = { params[key] }
            end
            table.insert(params[key], value)
         else
            params[key] = value
         end
      else
         -- Handle key without value
         key = url.decodePlus(pair)
         params[key] = ''
      end
   end

   return params
end

-- Parse query string into list of key-value pairs (preserves order and duplicates)

function url.parseQueryList(queryString)
   if not queryString or queryString == '' then return {} end

   local params = {}
   for pair in queryString:gmatch('[^&]+') do
      local key, value = pair:match('^([^=]*)=(.*)$')
      if key then
         key = url.decodePlus(key)
         value = url.decodePlus(value)
         table.insert(params, { key = key, value = value })
      else
         -- Handle key without value
         key = url.decodePlus(pair)
         table.insert(params, { key = key, value = '' })
      end
   end

   return params
end

-- Build query string from table or list of parameters

function url.buildQuery(params)
   if not params then return '' end

   local parts = {}

   if #params > 0 then
      -- Array-like table (list of key-value pairs)
      for _, param in ipairs(params) do
         if type(param) == 'table' and param.key then
            local key = url.encodePlus(tostring(param.key))
            local value = url.encodePlus(tostring(param.value or ''))
            table.insert(parts, key .. '=' .. value)
         end
      end
   else
      -- Hash-like table
      for key, value in pairs(params) do
         key = url.encodePlus(tostring(key))
         if type(value) == 'table' then
            -- Handle multiple values for same key
            for _, v in ipairs(value) do
               local encodedValue = url.encodePlus(tostring(v))
               table.insert(parts, key .. '=' .. encodedValue)
            end
         else
            local encodedValue = url.encodePlus(tostring(value))
            table.insert(parts, key .. '=' .. encodedValue)
         end
      end
   end

   return table.concat(parts, '&')
end

-- Encode parameters into query string format

function url.encodeParams(params)
   return url.buildQuery(params)
end

----------------------------------------------------------------------------------------------------------------------
-- URL Parsing Functions

-- Parse a URL into its components

function url.parse(urlString)
   if not urlString or urlString == '' then
      return nil, 'Empty URL string'
   end

   local components = {
      scheme = nil,
      auth = nil,
      host = nil,
      port = nil,
      path = '',
      params = nil,
      query = nil,
      fragment = nil
   }

   local remaining = urlString

   local fragPos = remaining:find('#')
   if fragPos then
      components.fragment = remaining:sub(fragPos + 1)
      remaining = remaining:sub(1, fragPos - 1)
   end

   local queryPos = remaining:find('?', 1, true)
   if queryPos then
      components.query = remaining:sub(queryPos + 1)
      remaining = remaining:sub(1, queryPos - 1)
   end

   local schemeMatch = remaining:match('^([%w+.-]+):(.*)')
   if schemeMatch then
      components.scheme = schemeMatch:lower()
      remaining = remaining:match('^[%w+.-]+:(.*)')
   end

   -- Handle authority (//host:port or //user:pass@host:port)
   if remaining:sub(1, 2) == '//' then
      remaining = remaining:sub(3) -- Remove //

      -- Find the end of authority (next /, ?, #, or end of string)
      local pathStart = remaining:find('/') or (#remaining + 1)
      local authority = remaining:sub(1, pathStart - 1)
      remaining = remaining:sub(pathStart)

      -- Extract auth (user:pass@)
      local authEnd = authority:find('@')
      if authEnd then
         components.auth = authority:sub(1, authEnd - 1)
         authority = authority:sub(authEnd + 1)
      end

      -- Handle IPv6 addresses [host]:port
      local ipv6Match = authority:match('^%[([^%]]+)%]:?(%d*)$')
      if ipv6Match then
         components.host = ipv6Match
         local portStr = authority:match('^%[[^%]]+%]:(%d+)$')
         if portStr and portStr != '' then
            components.port = tonumber(portStr)
         end
      else
         -- Handle regular host:port
         local colonPos = authority:find(':', 1, true)
         if colonPos then
            components.host = authority:sub(1, colonPos - 1)
            local portStr = authority:sub(colonPos + 1)
            if portStr != '' then
               components.port = tonumber(portStr)
            end
         else
            components.host = authority
         end
      end
   end

   if remaining != '' then
      components.path = remaining
   elseif components.host then
      components.path = '/'
   end

   if components.path then
      local paramPos = components.path:find(';')
      if paramPos then
         components.params = components.path:sub(paramPos + 1)
         components.path = components.path:sub(1, paramPos - 1)
      end
   end

   return components
end

-- Reconstruct URL from components

function url.unparse(components)
   if not components then return '' end

   local parts = {}

   if components.scheme then table.insert(parts, components.scheme .. ':') end

   if components.host then
      table.insert(parts, '//')

      if components.auth then table.insert(parts, components.auth .. '@') end

      if components.host:find(':') then
         table.insert(parts, '[' .. components.host .. ']')
      else
         table.insert(parts, components.host)
      end

      if components.port then table.insert(parts, ':' .. components.port) end
   end

   if components.path then table.insert(parts, components.path) end
   if components.params then table.insert(parts, ';' .. components.params) end
   if components.query then table.insert(parts, '?' .. components.query) end
   if components.fragment then table.insert(parts, '#' .. components.fragment) end

   return table.concat(parts)
end

-- Split URL into 5 components (no params)

function url.split(urlString)
   local components = url.parse(urlString)
   if not components then return nil end

   return {
      scheme = components.scheme,
      netloc = url._buildNetloc(components),
      path = components.path,
      query = components.query,
      fragment = components.fragment
   }
end

-- Reconstruct URL from split components

function url.unsplit(components)
   if not components then return '' end
   local parts = {}
   if components.scheme then table.insert(parts, components.scheme .. ':') end
   if components.netloc then table.insert(parts, '//' .. components.netloc) end
   if components.path then table.insert(parts, components.path) end
   if components.query then table.insert(parts, '?' .. components.query) end
   if components.fragment then table.insert(parts, '#' .. components.fragment) end
   return table.concat(parts)
end

-- Helper to build netloc from components

function url._buildNetloc(components)
   if not components.host then return nil end
   local netloc = {}
   if components.auth then table.insert(netloc, components.auth .. '@') end
   if components.host:find(':') then
      table.insert(netloc, '[' .. components.host .. ']')
   else
      table.insert(netloc, components.host)
   end
   if components.port then table.insert(netloc, ':' .. components.port) end
   return table.concat(netloc)
end

-- Remove fragment from URL

function url.defrag(urlString)
   if not urlString then return nil, nil end

   local fragPos = urlString:find('#')
   if fragPos then
      local base = urlString:sub(1, fragPos - 1)
      local fragment = urlString:sub(fragPos + 1)
      return base, fragment
   end

   return urlString, nil
end

----------------------------------------------------------------------------------------------------------------------
-- URL Manipulation Functions

-- Join base URL with relative URL
function url.join(baseUrl, relativeUrl)
   if not baseUrl then return relativeUrl end
   if not relativeUrl then return baseUrl end
   if url.isAbsolute(relativeUrl) then return relativeUrl end

   local base = url.parse(baseUrl)
   if not base then return relativeUrl end

   -- Handle fragment-only URLs
   if relativeUrl:sub(1, 1) == '#' then
      base.fragment = relativeUrl:sub(2)
      return url.unparse(base)
   end

   -- Handle query-only URLs
   if relativeUrl:sub(1, 1) == '?' then
      base.query = relativeUrl:sub(2)
      base.fragment = nil
      return url.unparse(base)
   end

   -- Parse relative URL
   local rel = url.parse(relativeUrl)
   if not rel then return baseUrl end

   -- If relative has authority, use it completely
   if rel.host then
      rel.scheme = rel.scheme or base.scheme
      return url.unparse(rel)
   end

   rel.scheme = base.scheme
   rel.host = base.host
   rel.port = base.port
   rel.auth = base.auth

   -- Handle absolute path
   if rel.path and rel.path:sub(1, 1) == '/' then
      return url.unparse(rel)
   end

   -- Handle relative path
   local basePath = base.path or '/'
   if basePath:sub(-1) != '/' then
      basePath = basePath:match('(.*/)') or '/'
   end

   local newPath = basePath .. (rel.path or '')
   rel.path = url.normalize(newPath)

   return url.unparse(rel)
end

-- Normalize URL path (resolve . and .. components)

function url.normalize(path)
   if not path then return '' end

   local segments = {}
   local isAbsolute = path:sub(1, 1) == '/'

   for segment in path:gmatch('[^/]+') do
      if segment == '..' then
         if #segments > 0 and segments[#segments] != '..' then
            table.remove(segments)
         elseif not isAbsolute then
            table.insert(segments, '..')
         end
      elseif segment != '.' and segment != '' then
         table.insert(segments, segment)
      end
   end

   local result = table.concat(segments, '/')
   if isAbsolute then result = '/' .. result end

   -- Preserve trailing slash
   if path:sub(-1) == '/' and result:sub(-1) != '/' and result != '' then
      result = result .. '/'
   end

   return result
end

----------------------------------------------------------------------------------------------------------------------
-- Utility Functions

-- Check if URL is absolute

function url.isAbsolute(urlString)
   if not urlString then return false end
   return urlString:match('^[%w+.-]+:') != nil
end

-- Check if URL is relative

function url.isRelative(urlString)
   return not url.isAbsolute(urlString)
end

-- Extract scheme from URL

function url.getScheme(urlString)
   if not urlString then return nil end
   return urlString:match('^([%w+.-]+):')
end

-- Extract host from URL

function url.getHost(urlString)
   local components = url.parse(urlString)
   return components and components.host
end

-- Extract port from URL with optional default

function url.getPort(urlString, defaultPort)
   local components = url.parse(urlString)
   if components then
      if components.port then
         return components.port
      elseif defaultPort then
         return defaultPort
      end
   end
   return nil
end

----------------------------------------------------------------------------------------------------------------------

   return url
