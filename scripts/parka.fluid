-- $FLUID:Batch
--
-- Parka generates Parasol archives (PARC files) from a valid parc.xml and release folder containing the files to be
-- packaged.  An RSA private key should also be provided so that the package can be signed (this confirms to the user
-- that the PARC file was generated by you).
--
-- Generate a signed PARC file:
--   parasol-cmd parka.fluid src=release/ dest=parasol-doc.parc key=key.prv signature=parasol-doc.parc.sig
--
-- Verify a signed PARC file:
--   parasol-cmd parka.fluid verify=parasol-doc.parc

   include "xml"
   require "common"

   SIGLEN = 8

------------------------------------------------------------------------------

function parseInfo()
   local infoPath = glLocation .. "parc.xml"

   print("Checking for info file at " .. infoPath)

   local error, type = mSys.AnalysePath(infoPath)
   if (error != ERR_Okay) or (type != LOC_FILE) then
      print("Failed to detect a valid parc.xml file in the source folder.")
      print("Expected file: " .. infoPath)
      return
   end

   glInfoXML = obj.new("xml", { path=infoPath })
   if (glInfoXML == nil) then
      print("Failed to parse the parc.xml file at " .. infoPath)
      return
   end

   local error, infoIndex = glInfoXML.mtFindTag("/info");

   local info = {
      name        = glInfoXML.var("content:/info/name"),
      author      = glInfoXML.var("/info/author"),
      version     = glInfoXML.var("/info/version"),
      built       = glInfoXML.var("/info/built"),
      short       = glInfoXML.var("/info/short"),
      website     = glInfoXML.var("/info/website"),
      run         = glInfoXML.var("/info/run"),
      copyright   = glInfoXML.var("/info/copyright"),
      license     = glInfoXML.var("/info/license"),
      description = glInfoXML.var("/info/description")
   }

   local error, iArgs = glInfoXML.mtFindTag("/info/args")
   local error, iPermissions = glInfoXML.mtFindTag("/info/permissions")
   info.args = iArgs
   info.permissions = iPermissions

   if not nz(info.built) then
      local now = obj.new("time", { })
      now.acQuery()
      info.built = string.format("%d-%02d-%02d %02d:%02d", now.year, now.month, now.day, now.hour, now.minute)
      local error, index = glInfoXML.mtInsertXML(infoIndex, XMI_CHILD_END, "<built>" .. info.built .. "</built>")
   end

   if nz(glPublicKey) then
      local error, index = glInfoXML.mtInsertXML(infoIndex, XMI_CHILD_END, "<key>" .. glPublicKey .. "</key>")
   end

   return info
end

------------------------------------------------------------------------------

function printPackage()
   print("")
   print("Package Details")
   print("---------------")
   print("Name:      " .. nz(glInfo.name, "NULL"))
   print("Author:    " .. nz(glInfo.author, "NULL"))
   print("Version:   " .. nz(glInfo.version, "NULL"))
   print("Built:     " .. nz(glInfo.built, "NULL"))
   print("WebSite:   " .. nz(glInfo.website, "NULL"))
   print("Short:     " .. nz(glInfo.short, "NULL"))
   print("Run:       " .. nz(glInfo.run, "NULL"))
   print("License:   " .. nz(glInfo.license, "NULL"))
   print("Copyright: " .. nz(glInfo.copyright, "NULL"))
   print("")
end

------------------------------------------------------------------------------

function validateInfo()
   if not nz(glInfo) then print("A name is required in the info header."); return; end


--  <args>
--    <arg name="" type="" default=""/>
--  </args>
   return true
end

------------------------------------------------------------------------------

function zipPackage()
   local zip = obj.new("compression", { src=glTargetFile, flags="!NEW", compressionLevel=0 })
   if (zip == nil) then
      print("Failed to create new zip package at " .. glTargetFile)
      return
   end

   local folder = obj.new("file", { path=glLocation } )
   if not nz(folder) then
      print("Invalid location for packaging.")
      return
   end

   local err, file = folder.mtNext()
   while (err == ERR_Okay) do
      if bit.band(file.flags, FL_FOLDER) != 0 then
         local name = file.path:match("([^:/]+)/-$")
         print("Compressing " .. name)
         zip.mtCompressFile(file.path, "/")
      end
      err, file = folder.mtNext()
   end

   -- Compress glInfoXML as 'parc.xml' in the package's root folder.

   if (glInfoXML != nil) then
      local infoFile = obj.new("file", { path="temp:parc.xml", flags="!NEW|WRITE" })
      if (infoFile != nil) then
         glInfoXML.acSaveToObject(infoFile)
         zip.mtCompressFile("temp:parc.xml", nil)
         infoFile.mtDelete()
      else
         print("Failed to create new XML info file.")
         return
      end
   else
      print("Failed to create new XML object.")
      return
   end

   zip.acFree() -- Release the target file
end

------------------------------------------------------------------------------
-- Use an RSA private key to calculate a signature from a source file.  The signature is then appended to
-- the parc file.
--
-- openssl dgst -sha1 -sign priv.pem program.parc > sig

function signPackage(PrivateKey)
   local file = obj.new("file", { path=glTargetFile, flags="!READ|WRITE" } )
   if (file != nil) then
      local error, sig = mSSL.CalcSigFromObject(file, 0, PrivateKey, glKeyPassword, "sha256")
      if (error == ERR_Okay) then
         print("Writing " .. sig:len() .. " byte signature to end of package.")

         file.acWrite(sig)
         local siglen = mem.alloc(4)
         siglen.setlong(sig:len())
         file.acWrite(siglen, 4)
         file.acWrite("PSIG")
      else
         print("Failed to calculate archive signature: " .. mSys.GetErrorMsg(error))
      end
   else
      print("Failed to open package for signing: " .. glTargetFile)
   end
end

------------------------------------------------------------------------------
-- Returns a memory allocation containing the file's binary signature

function readSignature(Path)
   local PSIG = 0x47495350

   local file = obj.new("file", { path=Path, flags="!READ" })
   if (file != nil) then
      file.acSeek(-SIGLEN, SEEK_END)
      local header = mem.alloc(SIGLEN)
      if (file.acRead(header) == ERR_Okay) then
         header.indextype("integer")
         if (header[1] != PSIG) then
            print("The package has not been signed with an RSA key.")
            return
         end

         local siglen = header[0]
         file.acSeek(-SIGLEN-siglen, SEEK_END)
         local signature = mem.alloc(siglen)
         if (file.acRead(signature) == ERR_Okay) then
            return signature
         else
            print("Failed to read signature of " .. siglen .. " bytes.")
         end
      else
         print("Failed to read the tail signature")
         return
      end
   else
      print("Failed to open the archive at " .. glVerify)
      return
   end
end

------------------------------------------------------------------------------

function verifyPackage()
   local zip = obj.new("compression", { src=glVerify, compressionLevel=0 })
   if (zip == nil) then
      print("Failed to create new zip package at " .. glVerify)
      return
   end

   -- Extract the public key from the parc.xml file

   local fileObject = obj.new("file", { flags="!NEW|BUFFER|WRITE|READ" } )
   zip.mtDecompressObject("parc.xml", fileObject)
   zip.acFree()

   -- Parse the parc.xml data into an XML object

   local xmlInfo = obj.new("xml", { flags="!NEW", statement=fileObject.buffer.getstring() } )
   if (xmlInfo == nil) then
      print("Failed to parse the parc.xml file.")
      return
   end

   local publicKey = xmlInfo.get("/info/key")
   if (publicKey == nil) then
      print("The package is not signed with an RSA key.")
      return
   end

   -- Read the binary signature from the end of the PARC file.

   local signature = readSignature(glVerify)
   if (signature == nil) then return end

   local outsig = obj.new("file", { path="package_out.sig", flags="!NEW|WRITE" } )
   outsig.acWrite(signature)

   -- Use the public key to recalculate the signature from the PARC file.

   local file = obj.new("file", { path=glVerify, flags="!READ" } )
   if (file != nil) then
      local error = mSSL.VerifySig(file, file.size - SIGLEN - signature.size, publicKey, "sha256", signature)
      if (error != ERR_Okay) then print("Signature verification failed: " .. mSys.GetErrorMsg(error))
      else print("Signature verification passed.") end
   end
end

------------------------------------------------------------------------------

   glVerify         = arg("verify")
   glLocation       = arg("src")
   glTargetFile     = arg("dest")
   glPrivateKeyFile = arg("key")
   glSignatureFile  = arg("signature")
   glKeyPassword    = arg("password")

   print("Parka - A PARC generator for Parasol")
   print("")

   mSys = mod.load("core")
   mSSL = mod.load("openssl")

   if nz(glVerify) then
      // Verification mode - check that the signature of an existing package is correct.
      verifyPackage()
      return
   end

   if not nz(glLocation) then
      print("Parka is used to generate Parasol archives (PARC files).  It requires a valid parc.xml file and release")
      print("folder containing the files to be archived.  More information on how to structure a build is documented in the")
      print("parasol-doc package, as well as on the Parasol website.")
      print("")
      print("Example usage:")
      print("")
      print("   parasol-cmd parka.fluid src=release/ dest=AwesomeGame.parc key=AcmeLtd.key")
      print("")
      return
   end

   -- The source must be a folder reference.

   local lastChar = glLocation:sub(-1)
   if ((lastChar != ':') and (lastChar != '/')) then
      glLocation = glLocation .. "/"
   end

   if nz(glPrivateKeyFile) then
      glPrivateKey = file.readAll(glPrivateKeyFile)
      if (glPrivateKey == nil) then
         print("Failed to load RSA key file: " .. glPrivateKeyFile)
         return
      end
   end

   if nz(glPrivateKey) then
      error, glPublicKey = mSSL.GenerateRSAPublicKey(glPrivateKey, glKeyPassword)
      if (glPublicKey == nil) then
         print("Failed to get generate the public key from " .. glPrivateKeyFile .. ", error " .. mSys.GetErrorMsg(error))
         print(glPrivateKey)
      end
   end

   glInfo = parseInfo()
   if (glInfo == nil) then return end

   printPackage()

   if (validateInfo() != true) then return end

   zipPackage()

   if nz(glPrivateKey) then
      signPackage(glPrivateKey)
   else
      print("No RSA private key supplied - the package will not be signed.")
   end


