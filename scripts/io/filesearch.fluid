--[[
The FileSearch interface simplifies the process of searching for files and folders within the file system.
Refer to the Fluid I/O Wiki page for documentation.
--]]

   import 'common'

file.search = function(Path, Options)
   lOptions      = Options
   ADJUST_LOG    = 0
   lStop         = false
   isRegexFilter = false

   function contentMatch(Path)
      lOptions.contentFilter ?? return true

      try
         fl = obj.new('file', { path=Path, flags='READ' } )

         -- By default, symbolic links are not scanned for content unless the scanLinks option is set.

         if (fl.flags & FL_LINK)?? and (lOptions.scanLinks != true) then
            fl.free()
            return false
         end

         bytes = fl.size
         if bytes > 4096 then bytes = 4096 end
         buf = string.alloc(bytes)
         err, totalRead = fl.acRead(buf)

         while (err is ERR_Okay) and (totalRead >= lOptions.contentFilter:len()) do
            if buf:find(lOptions.contentFilter) then return true end
            if fl.position is fl.size then return false end
            fl.acSeek(-lOptions.contentFilter:len(), SEEK_CURRENT)
            err, totalRead = fl.acRead(buf)
         end
      end

      return false
   end

   function fileMatched(Path, FileName, File)
      if lOptions.matchFeedback then
         result = lOptions.matchFeedback(Path, FileName, File)
         if result is ERR_Terminate then lStop = true end
      end
   end

   function dateLessThan(A, B) -- struct DateTime
      if A.Year < B.Year then return true
      elseif A.Year > B.Year then return false end

      -- else years are equal, so test months
      if A.Month < B.Month then return true
      elseif A.Month > B.Month then return false end

      if A.Day < B.Day then return true
      elseif A.Day > B.Day then return false end

      if A.Hour < B.Hour then return true
      elseif A.Hour > B.Hour then return false end

      if A.Minute < B.Minute then return true
      elseif A.Minute > B.Minute then return false end

      if A.Second < B.Second then return true
      elseif A.Second > B.Second then return false end

      return false -- Dates are exactly equal
   end

   function scanPath(Path:str, currentDepth:num)
      if not currentDepth then currentDepth = 0 end
      msg('scanPath() ' .. (Path ?? ':') .. ' (depth: ' .. currentDepth .. ')')

      if lStop then return end

      if lOptions.maxDepth and (currentDepth > lOptions.maxDepth) then return end

      count = 0
      flags = 0
      if not lOptions.matchFolders then flags = flags | FL_EXCLUDE_FOLDERS end
      if lOptions.ignoreFiles then flags = flags | FL_EXCLUDE_FILES end

      local folder
      try
         folder = obj.new('file', { src=Path, flags=flags })
      except ex
         return
      end

      err, fl = folder.mtNext()
      while (err is ERR_Okay) and (not lStop) do
         count++
         processing.sleep(0)

         fileFolder, fileName = file.splitPath(fl.path)

         -- Ensure that the filename matches our filter

         match = true
         if lOptions.nameFilter then
            cmpName = fileName
            if not lOptions.caseSensitive then
               cmpName = cmpName:lower()
            end

            if isRegexFilter then
               if not lOptions.nameFilter.test(cmpName) then
                  match = false
               end
            elseif lOptions.namePattern or lOptions.nameWild then -- nameWild is obsolete
               if string.find(cmpName, lOptions.nameFilter) is nil then
                  match = false
               end
            elseif cmpName != lOptions.nameFilter then -- Exact string match
               match = false
            end
         end

         if lOptions.minSize?? and (lOptions.minSize > 0) and (fl.size < lOptions.minSize) then match = false end
         if lOptions.maxSize and (lOptions.maxSize >= 0) and (fl.size > lOptions.maxSize) then match = false end
         if lOptions.minDateSet and dateLessThan(fl.modified, lOptions.minDate) then match = false end
         if lOptions.maxDateSet and dateLessThan(lOptions.maxDate, fl.modified) then match = false end

         if match and bit.band(fl.flags, FL_FILE) != 0 then
            match = contentMatch(fl.path)
         end

         msg(string.format('Found: %s (count: %d); Match: ' .. tostring(match), fl.path, count))

         if match then
            if lOptions.matchFeedback then
               mSys.AdjustLogLevel(-ADJUST_LOG) -- Temporarily revert debug log so that child behaviour can be analysed

                  result = lOptions.matchFeedback(Path, fileName, fl)
                  if result is ERR_Terminate then lStop = true end

               mSys.AdjustLogLevel(ADJUST_LOG) -- Raise log level again
            end
         elseif lOptions.ignoreFeedback then
            result = lOptions.ignoreFeedback(Path, fileName, fl)
            if result is ERR_Terminate then lStop = true end
         end

         err, fl = folder.mtNext()
      end

      if lStop then return end

      -- Recursively scan directory content (if we haven't reached max depth)

      if not lOptions.maxDepth or currentDepth < lOptions.maxDepth then
         try
            folder = obj.new('file', { src=Path, flags='!ExcludeFiles|Folder' } )

            err, fl = folder.mtNext()
            while (err is ERR_Okay) and (not lStop) do
               count++
               if (fl.flags & FL_LINK)?? then
                  -- Do not scan symbolicly linked directories (possible recursion)
               else
                  processing.sleep(0)
                  scanPath(fl.path, currentDepth + 1)
               end
               err, fl = folder.mtNext()
            end
         end
      end

      if count is 0 then processing.sleep(0) end  -- Message check required if the directory was empty

      collectgarbage()
   end

   function processPath(Path:str)
      msg(f'Path: {Path}, Filter: {Options.nameFilter}, Regex: {isRegexFilter}, Content: {Options.contentFilter}')

      if file.isFolder(Path) then
         mSys.AdjustLogLevel(ADJUST_LOG)
            scanPath(Path, 0)
         mSys.AdjustLogLevel(-ADJUST_LOG)
      else
         -- Single file analysis

         path, fileName = file.splitPath(Path)
         nameMatches = true

         if Options.nameFilter then
            cmpName = fileName
            if not lOptions.caseSensitive then
               cmpName = cmpName:lower()
            end

            if isRegexFilter then
               nameMatches = lOptions.nameFilter.test(cmpName)
            elseif lOptions.namePattern or lOptions.nameWild then -- nameWild is obsolete
               nameMatches = string.find(cmpName, lOptions.nameFilter) != nil
            else
               nameMatches = cmpName is lOptions.nameFilter
            end
         end

         if nameMatches then
            if contentMatch(Path) then
               if lOptions.matchFeedback then
                  lOptions.matchFeedback(path, fileName, obj.new('file', { path=Path }))
               end
            end
         end
      end
   end

   -- Entry point for the search

   if lOptions.nameFilter and type(lOptions.nameFilter) != 'string' then
      -- Check if it's a regex object by testing for regex methods
      if lOptions.nameFilter.test and lOptions.nameFilter.match then
         isRegexFilter = true
      end
   end

   if lOptions.maxDate then
      err, maxDate = mSys.StrReadDate(lOptions.maxDate)
      assert(err is ERR_Okay, 'Invalid maxDate value.')
      lOptions.maxDate = maxDate
   end

   if lOptions.minDate then
      err, minDate = mSys.StrReadDate(lOptions.minDate)
      assert(err is ERR_Okay, 'Invalid minDate value.')
      lOptions.minDate = minDate
   end

   if type(Path) is 'table' or type(Path) is 'array' then
      for v in values(Path) do
         processPath(v)
      end
   else
      processPath(Path)
   end
end
