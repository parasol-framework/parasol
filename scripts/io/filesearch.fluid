--[[
The FileSearch interface simplifies the process of searching for files and folders within the file system.
Refer to the Fluid I/O Wiki page for documentation.
--]]

   require 'common'

file.search = function(Path, Options)
   local lOptions = Options
   local ADJUST_LOG = 0
   local lStop = false
   local isRegexFilter = false

   local function contentMatch(Path)
      if lOptions.contentFilter == nil then
         return true
      end

      local ex, fl = catch(function()
         return obj.new('file', { path=Path, flags='READ' } )
      end)

      if fl then
         -- By default, symbolic links are not scanned for content unless the scanLinks option is set.

         if (bit.bor(fl.flags, FL_LINK) != 0) and (lOptions.scanLinks == true) then
            fl.free()
            return false
         end

         local bytes = fl.size
         if bytes > 4096 then bytes = 4096 end
         local buf = string.alloc(bytes)
         local err, totalRead = fl.acRead(buf)

         while (err == ERR_Okay) and (totalRead >= lOptions.contentFilter:len()) do
            if (buf:find(lOptions.contentFilter) != nil) then return true end
            if fl.position == fl.size then return false end
            fl.acSeek(-lOptions.contentFilter:len(), SEEK_CURRENT)
            err, totalRead = fl.acRead(buf)
         end
      end

      return false
   end

   local function fileMatched(Path, FileName, File)
      if lOptions.matchFeedback then
         local result = lOptions.matchFeedback(Path, FileName, File)
         if result == ERR_Terminate then lStop = true end
      end
   end

   local function dateLessThan(A, B) -- struct DateTime
      if A.Year < B.Year then return true
      elseif A.Year > B.Year then return false end

      -- else years are equal, so test months
      if A.Month < B.Month then return true
      elseif A.Month > B.Month then return false end

      if A.Day < B.Day then return true
      elseif A.Day > B.Day then return false end

      if A.Hour < B.Hour then return true
      elseif A.Hour > B.Hour then return false end

      if A.Minute < B.Minute then return true
      elseif A.Minute > B.Minute then return false end

      if A.Second < B.Second then return true
      elseif A.Second > B.Second then return false end

      return false -- Dates are exactly equal
   end

   local function scanPath(Path, currentDepth)
      if currentDepth == nil then currentDepth = 0 end
      msg('scanPath() ' .. nz(Path,':') .. ' (depth: ' .. currentDepth .. ')')

      if lStop then return end

      if (lOptions.maxDepth) and (currentDepth > lOptions.maxDepth) then return end

      local count = 0
      local flags = 0
      if not lOptions.matchFolders then flags = bit.bor(flags, FL_EXCLUDE_FOLDERS) end
      if lOptions.ignoreFiles then flags = bit.bor(flags, FL_EXCLUDE_FILES) end

      local ex, folder = catch(function()
         return obj.new('file', { src=Path, flags=flags } )
      end)

      if folder == nil then return end

      local err, fl = folder.mtNext()
      while (err == ERR_Okay) and (not lStop) do
         count = count + 1
         processing.sleep(0)

         local fileFolder, fileName = file.splitPath(fl.path)

         -- Ensure that the filename matches our filter

         local match = true
         if lOptions.nameFilter then
            local cmpName = fileName
            if not lOptions.caseSensitive then
               cmpName = cmpName:lower()
            end

            if isRegexFilter then
               if not lOptions.nameFilter.test(cmpName) then
                  match = false
               end
            elseif lOptions.namePattern or lOptions.nameWild then -- nameWild is obsolete
               if string.find(cmpName, lOptions.nameFilter) == nil then
                  match = false
               end
            elseif cmpName != lOptions.nameFilter then -- Exact string match
               match = false
            end
         end

         if nz(lOptions.minSize) and (lOptions.minSize > 0) and (fl.size < lOptions.minSize) then match = false end
         if lOptions.maxSize and (lOptions.maxSize >= 0) and (fl.size > lOptions.maxSize) then match = false end
         if lOptions.minDateSet and dateLessThan(fl.modified, lOptions.minDate) then match = false end
         if lOptions.maxDateSet and dateLessThan(lOptions.maxDate, fl.modified) then match = false end

         if match and bit.band(fl.flags, FL_FILE) != 0 then
            match = contentMatch(fl.path)
         end

         msg(string.format('Found: %s (count: %d); Match: ' .. tostring(match), fl.path, count))

         if match then
            if lOptions.matchFeedback then
               mSys.AdjustLogLevel(-ADJUST_LOG) -- Temporarily revert debug log so that child behaviour can be analysed

                  local result = lOptions.matchFeedback(Path, fileName, fl)
                  if result == ERR_Terminate then lStop = true end

               mSys.AdjustLogLevel(ADJUST_LOG) -- Raise log level again
            end
         elseif lOptions.ignoreFeedback then
            local result = lOptions.ignoreFeedback(Path, fileName, fl)
            if result == ERR_Terminate then lStop = true end
         end

         err, fl = folder.mtNext()
      end

      if lStop then return end

      -- Recursively scan directory content (if we haven't reached max depth)

      if not lOptions.maxDepth or currentDepth < lOptions.maxDepth then
         local ex, folder = catch(function()
            return obj.new('file', { src=Path, flags='!ExcludeFiles|Folder' } )
         end)

         if folder then
            local err, fl = folder.mtNext()
            while (err == ERR_Okay) and (not lStop) do
               count = count + 1
               if bit.band(fl.flags, FL_LINK) != 0 then
                  -- Do not scan symbolicly linked directories (possible recursion)
               else
                  processing.sleep(0)
                  scanPath(fl.path, currentDepth + 1)
               end
               err, fl = folder.mtNext()
            end
         end
      end

      if count == 0 then processing.sleep(0) end  -- Message check required if the directory was empty

      collectgarbage()
   end

   local function processPath(Path)
      msg(string.format('Path: %s, Filter: %s, Regex: %s, Content: %s', Path, Options.nameFilter, tostring(isRegexFilter), Options.contentFilter))

      if file.isFolder(Path) then
         mSys.AdjustLogLevel(ADJUST_LOG)
            scanPath(Path, 0)
         mSys.AdjustLogLevel(-ADJUST_LOG)
      else
         -- Single file analysis

         local path, fileName = file.splitPath(Path)
         local nameMatches = true

         if Options.nameFilter then
            local cmpName = fileName
            if not lOptions.caseSensitive then
               cmpName = cmpName:lower()
            end

            if isRegexFilter then
               nameMatches = lOptions.nameFilter.test(cmpName)
            elseif lOptions.namePattern or lOptions.nameWild then -- nameWild is obsolete
               nameMatches = (string.find(cmpName, lOptions.nameFilter) != nil)
            else
               nameMatches = (cmpName == lOptions.nameFilter)
            end
         end

         if nameMatches then
            if contentMatch(Path) then
               if lOptions.matchFeedback then
                  lOptions.matchFeedback(path, fileName, obj.new('file', { path=Path }))
               end
            end
         end
      end
   end

   -- Entry point for the search

   if lOptions.nameFilter and type(lOptions.nameFilter) != 'string' then
      -- Check if it's a regex object by testing for regex methods
      if lOptions.nameFilter.test and lOptions.nameFilter.match then
         isRegexFilter = true
      end
   end

   if lOptions.maxDate then
      local err, maxDate = mSys.StrReadDate(lOptions.maxDate)
      if err != ERR_Okay then error('Invalid maxDate value.') end
      lOptions.maxDate = maxDate
   end

   if lOptions.minDate then
      local err, minDate = mSys.StrReadDate(lOptions.minDate)
      if err != ERR_Okay then error('Invalid minDate value.') end
      lOptions.minDate = minDate
   end

   if type(Path) == 'table' then
      for k,v in pairs(Path) do
         processPath(v)
      end
   else
      processPath(Path)
   end
end
