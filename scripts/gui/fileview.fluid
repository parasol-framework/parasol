--[[
Documentation is available in the Parasol Wiki.
--]]

   require 'common'
   require 'gui'
   require 'gui/menu'
   require 'gui/dialog'
   require 'gui/toolbar'
   require 'json'
   include 'vector'

local lSys = mSys.GetSystemState()

local copy_list = [[
   require 'gui/file'
   local source_size = arg('source:size')
   if nz(source_size) then
      glList = { }
      for i=1, source_size do
         table.insert(glList, arg('source(' .. (i-1) .. ')'))
      end
   else
      glList = { arg('source') }
   end
   if arg('move') then Move = true end
   file.ui.copy(glList, arg('dest'), { move=Move })
]]

local paste_clipboard = [[
   require 'gui/file'
   file.ui.paste(arg('dest'), arg('cluster'))
]]

----------------------------------------------------------------------------------------------------------------------

local function sortNum(Value)
   return string.format('%014.0f', Value)
end

local function getFileIcon(Path)
   local icon
   catch(function()
      icon = obj.new('file', { path=Path }).icon
      if not icon then icon = 'folders/folder' end
   end)
   return icon
end

local function printableTime(Time)
   return string.format('%04d-%02d-%02d %02d:%02d:%02d',
      Time.Year, Time.Month, Time.Day, Time.Hour, Time.Minute, Time.Second)
end

-- Returns the surface that is acting as the window.  Returns 0 if no window surface == detected.

local function parentWindow(Surface)
   local scan = obj.find(Surface.parent)
   while scan do
      if mSys.GetClassID(mSys.GetOwnerID(scan.id)) == ID_WINDOW then
         return scan
      end
      scan = obj.find(scan.parent)
   end
end

local function convertPermissions(Permissions)
   local out = ''
   if bit.band(Permissions, PERMIT_READ) != 0  then out = out .. 'r' else out = out .. '-' end
   if bit.band(Permissions, PERMIT_WRITE) != 0 then out = out .. 'w' else out = out .. '-' end
   if bit.band(Permissions, PERMIT_EXEC) != 0  then out = out .. 'x' else out = out .. '-' end

   out = out .. ' '

   if bit.band(Permissions, PERMIT_GROUP_READ) != 0  then out = out .. 'r' else out = out .. '-' end
   if bit.band(Permissions, PERMIT_GROUP_WRITE) != 0 then out = out .. 'w' else out = out .. '-' end

   if bit.band(Permissions, PERMIT_GROUPID) != 0 then
      out = out .. 'g'
   elseif bit.band(Permissions, PERMIT_GROUP_EXEC) != 0 then
      out = out .. 'x'
   else
      out = out .. '-'
   end

   out = out .. ' '

   if bit.band(Permissions, PERMIT_OTHERS_READ) != 0  then out = out .. 'r' else out = out .. '-' end
   if bit.band(Permissions, PERMIT_OTHERS_WRITE) != 0 then out = out .. 'w' else out = out .. '-' end
   if bit.band(Permissions, PERMIT_OTHERS_EXEC) != 0  then out = out .. 'x' else out = out .. '-' end

   if bit.band(Permissions, PERMIT_USERID) != 0 then out = out .. ' s' end

   return out
end

local function updateFileAttributes(Item, Info)
   if Item.date then
      if Item.type == 'folder' then
         Item.date.sort = 'D' .. sortNum(Info.timestamp)
      else
         Item.date.sort = 'F' .. sortNum(Info.timestamp)
      end
      Item.date.value = printableTime(Info.modified)
   end

   if Item.size then
      Item.size.sort = sortNum(Info.size)
      Item.size.value = Info.size
   else
      Item.size.sort = sortNum(0)
   end
end

local function defineViewColumns(Path)
   if not Path then
      return {
         { attrib='name',      title='Name',       width=210, showIcons=true },
         { attrib='freespace', title='Free Space', width=90, type='bytesize', align='right' },
         { attrib='totalsize', title='Total Size', width=90, type='bytesize', align='right' }
      }
   elseif (lSys.platform == 'Linux') or (lSys.platform == 'Native') then
      return {
         { attrib='name',        title='Name',        width=210, showIcons=true },
         { attrib='size',        title='Size',        width=90,  type='bytesize', align='right' },
         { attrib='date',        title='Date',        width=100, type='date' },
         { attrib='permissions', title='Permissions', width=90 },
         { attrib='owner',       title='Owner',       width=60 },
         { attrib='group',       title='Group',       width=60 }
      }
   else
      return {
         { attrib='name', title='Name', width=210, showIcons=true },
         { attrib='size', title='Size', width=90,  type='bytesize', align='right' },
         { attrib='date', title='Date', width=120, type='date' }
      }
   end
end

-- Return active filters as a list

local function getFilters(self)
   if self._filters then return self._filters end
   self._filters = { }
   for _, filter in ipairs(self.filterList) do
      if filter.selected then
         if type(filter.pattern) == 'table' then
            for _, pattern in pairs(filter.pattern) do
               table.insert(self._filters, pattern)
            end
         else
            table.insert(self._filters, filter.pattern)
         end
      end
   end
   return self._filters
end

-- Returns true if Filename should be visible

local function filterCheck(self, Filename)
   local Filename = Filename:lower()
   local filters = getFilters(self)
   if #filters == 0 then return true end
   for _, f in pairs(filters) do
      if Filename:endsWith(f) then return true end
   end
   return false
end

-- Re-evaluate the hidden status of each file

local function applyFilters(self)
   local filters = getFilters(self)
   local redraw = false
   if #filters == 0 then -- No filter, all files will be visible
      for _, item in ipairs(self.view.items) do
         if item.hidden then
            item.hidden = nil
            redraw = true
         end
      end
   else
      for _, item in ipairs(self.view.items) do
         if item.type == 'file' then
            if filterCheck(self, item.filename) then
               if item.hidden then
                  item.hidden = nil
                  redraw = true
               end
            elseif not item.hidden then
               item.hidden = true
               redraw = true
            end
         end
      end
   end

   if redraw then
      self.view.rebuild()
   end
end

local function displayFilters(self)
   if #self.filterList < 1 then return end

   if not self.filterViewport then -- Construct the filter list
      local bkgd = gui.interpolateRGB(gui.strToRGB(gui.palette.base), gui.strToRGB(gui.palette.bkgd), 0.1)

      self.filterViewport = self.view.viewport.new('VectorViewport', {
         visibility = VIS_HIDDEN, x = 0, y = self.toolbar.viewport.height, xOffset = 0, height = 1
      })
      self.filterViewport.new('VectorRectangle', { width='100%', height='100%', fill=gui.rgbToSVG(bkgd) })

      local height = 2, text_x, text_y, item_height, descent
      for _, item in ipairs(self.filterList) do
         item.vp = self.filterViewport.new('VectorViewport', { x = 0, y = height, width = '100%', height = 1 })
         item.highlight = item.vp.new('VectorRectangle', { x = 0, y = 0, width='100%', height='100%', fill=gui.palette.prime, visibility = VIS_HIDDEN })
         item.txt = item.vp.new('VectorText', { x=0, y=0, string=item.name, fill=gui.palette.altText, face='Noto Sans', fontSize=12 })
         if not descent then
            descent = math.round(item.txt.descent)
            height = descent
            item.vp.y = height
         end
         if not text_y then text_y = math.round(item.txt.displayHeight + descent) end
         if not text_x then text_x = math.floor(item.txt.displayHeight * 0.5) end
         if not item_height then item_height = math.floor((item.txt.displayHeight + descent) * 1.3) end

         if item.selected then item.highlight.visibility = VIS_VISIBLE end

         item.vp.mtSubscribeInput(JTYPE_BUTTON, function(Viewport, Events)
            local ev = Events
            while ev do
               if bit.band(ev.flags, JTYPE_BUTTON) != 0 then
                  if ev.type == JET_BUTTON_1 and ev.value == 1 then
                     if item.selected then
                        item.highlight.visibility = VIS_HIDDEN
                        item.selected = false
                        self._filters = nil
                     else
                        item.highlight.visibility = VIS_VISIBLE
                        item.selected = true
                        self._filters = nil
                     end
                  end
               end
               ev = ev.next
            end

            applyFilters(self)

            self.view.scene.surface.mtScheduleRedraw()
         end)

         item.txt.x = text_x
         item.txt.y = text_y
         item.vp.height = item_height
         height = height + item_height
      end

      self.filterViewport.height = height + descent
   end

   -- Toggle the filter list

   if self.filterViewport.visibility != VIS_HIDDEN then
      self.filterViewport.visibility = VIS_HIDDEN
      local list_y = self._reserved_height
      self.view.window.y = list_y
      self.view.scrollbar.vbar.viewport.y = list_y
   else
      self.filterViewport.visibility = VIS_VISIBLE
      local list_y = self._reserved_height + self.filterViewport.height
      self.view.window.y = list_y
      self.view.scrollbar.vbar.viewport.y = list_y
   end

   self.view.viewport.acDraw()
end

----------------------------------------------------------------------------------------------------------------------

local lBkgdTasks = { }

-- Paste from a list of files to a destination folder.

local function copyFromList(Folder, List, Move)
   if not file.isFolder(Folder) then error('Invalid folder target of ' .. Folder) end

   catch(function()
      msg('copyFromList("' .. Folder ..  ')')

      local params = { '--dest', Folder }
      if Move then table.insert(params, '--move') end
      table.insert(params, '--source')
      table.insert(params, '{')
      for _, src in pairs(List) do
         table.insert(params, src)
      end
      table.insert(params, '}')

      local task = obj.new('task', {
         location = 'parasol:fluid',
         parameters = params,
         flags = '!Pipe',
         exitCallback = function(Task)
            if not self.watch then self.refresh() end
            lBkgdTasks[Task.id] = nil
         end
      })

      task.acActivate()
      task.acWrite(copy_list)
      task.acWrite(nil)
      lBkgdTasks[task.id] = task
   end,
   function(Exception)
      gui.dialog.error('Copy File Failure', 'File copy attempt failed with exception: ' .. Exception.message, self.window)
   end)
end

-- Paste from a clipboard to a folder

local function pasteFromClipboard(Folder, Cluster)
   if not file.isFolder(Folder) then error('Invalid folder target of ' .. Folder) end

   msg('pasteFromClipboard("' .. Folder ..  '", ' .. nz(Cluster,'nil') .. ')')

   catch(function()
      local params = { '--dest', Folder }
      if Cluster then
         table.insert(params, '--cluster')
         table.insert(params, Cluster)
      end

      local task = obj.new('task', {
         location     = 'parasol:fluid',
         flags        = '!Pipe',
         parameters   = params,
         exitCallback = function(Task)
            if not self.watch then self.refresh() end
            lBkgdTasks[Task.id] = nil
         end
      })

      task.acActivate()
      task.acWrite(paste_clipboard)
      task.acWrite(nil)
      lBkgdTasks[task.id] = task
   end,
   function(Exception)
      gui.dialog.error('File Paste Failure', 'File paste attempt failed with exception: ' .. Exception.message, self.window)
   end)
end

-- Returns a single item structure identifying a file/folder/volume

local function createFileItem(self, Info)
   if not self.showHidden then
      if bit.band(Info.flags, RDF_HIDDEN) != 0 then return end
   end

   msg('createFileItem() ' .. Info.name .. string.format(', $%.8x', Info.flags))

   local new_item
   if bit.band(Info.flags, RDF_VOLUME) != 0 then -- Get the icon to use for displaying the volume
      local icon = getFileIcon(Info.name .. ':')
      if icon == 'icons:folders/folder' then icon = 'folders/folder_shortcut' end
      if not icon then icon = 'folders/folder_shortcut' end
      local colour = 'blue'
      local total_size = nil
      local free_space = nil
      local device = obj.new('storagedevice', { volume = Info.name .. ':' } )
      if bit.band(device.deviceFlags, bit.bor(DEVICE_FLOPPY_DISK, DEVICE_FIXED, DEVICE_HARD_DISK, DEVICE_COMPACT_DISC)) != 0 then
         colour = 'green'
         if device.deviceSize >= 1 then total_size = sortNum(device.deviceSize) end
         if device.bytesFree >= 1 then free_space = sortNum(device.bytesFree) end
      end

      local display_name = Info.name ..':'
      local err, label = mSys.ReadInfoTag(Info, 'Label')
      if err == ERR_Okay then
         display_name = display_name .. ' (' .. label .. ')'
      end

      new_item = {
         type        = 'volume',
         icon        = icon,
         iconColour  = colour,
         sort        = '\x02' .. Info.name:lower(),
         filename    = Info.name, -- Unique
         insensitive = true,
         name        = { value = display_name },
         totalsize   = total_size,
         freespace   = free_space
      }
   elseif bit.band(Info.flags, RDF_FOLDER) != 0 then
      local display_name
      if self.view.noIcons then
         display_name = Info.name
      else
         display_name = Info.name:gsub("^(.-)[:/\\]+$", '%1') -- Strip trailing folder symbols
      end

      if Info.name:sub(-1) != '/' then
         display_name = display_name .. '/'
      end

      new_item = {
         type        = 'folder',
         icon        = getFileIcon(self.path .. Info.name),
         iconColour  = 'yellow',
         sort        = '\x03' .. Info.name:lower(),
         filename    = Info.name,
         name        = { sort = 'D' .. display_name:lower(), value = display_name },
         insensitive = true,
         owner       = mSys.ResolveUserID(Info.UserID),
         group       = mSys.ResolveGroupID(Info.GroupID),
         permissions = convertPermissions(Info.Permissions),
         size        = { sort = sortNum(0), value = nil } -- Dummy required for sorting
      }

      if Info.modified.year != 0 then
         new_item.date = { sort = 'D' .. sortNum(Info.timestamp), value = printableTime(Info.modified) }
      end
   elseif bit.band(Info.Flags, RDF_FILE) != 0 then
      if lNoFiles then return end

      if not lFilter or (string.find(Info.name, lFilter) != nil) then
         local filename
         if lNoExtensions then
            filename = Info.name:gsub('^(.-)%.[^:/\\]+$', '%1')
         else
            filename = Info.name
         end

          new_item = {
            type        = 'file',
            icon        = getFileIcon(self.path .. Info.name),
            name        = { sort = 'F' .. Info.name:lower(), value = Info.name },
            filename    = filename,
            hidden      = not filterCheck(self, filename),
            size        = { sort = sortNum(Info.size), value = Info.size },
            date        = { sort = 'F' .. sortNum(Info.timestamp), value = printableTime(Info.modified) },
            owner       = mSys.ResolveUserID(Info.UserID),
            group       = mSys.ResolveGroupID(Info.GroupID),
            permissions = convertPermissions(Info.Permissions)
         }
      end
   end

   if new_item then
      self._file_table[new_item.filename] = new_item
      return new_item
   end
end

-- Convert file information to an Item and add it to the view

local function addFileItem(self, Info)
   local item = createFileItem(self, Info)

   if item then
      self.view.addItem(item)
   end
end

----------------------------------------------------------------------------------------------------------------------

gui.fileview = function(View, Options)
   local self = {
      view          = View,
      window        = nil,
      path          = Options.path,
      timer         = nil,
      resetTimer    = nil,
      refreshRate   = 0.25, -- Cycles per second
      limitPath     = nz(Options.limitPath),
      showHidden    = nz(Options.showHidden, false),
      showSystem    = nz(Options.showSystem, false),
      showDocs      = nz(Options.showDocs, false),
      enableSysKeys = nz(Options.sysKeys, false),
      pathChanged   = Options.pathChanged,
      filterList    = Options.filterList,
      _reserved_height = 0
   }

   local lOptions = Options
   local lDoc
   local lDir

   local function loadPrefs()
      catch(function()
         local js = file.readAll('user:config/filesystem.json')
         if nz(js) then
            js = json.decode(js)
            if js['showHidden'] then self.showHidden = true end
            if js['showSystem'] then self.showSystem = true end
            if js['showDocs'] then self.showDocs = true end
         end
      end)
   end

   -- Returns the item for a given file or folder name.

   local function findItem(Name)
      if self._file_table[Name] then return self._file_table[Name] end
   end

   local function eventVolumeCreated(Info)
      if self.path then return end

      if not findItem(Info.name) then -- Add missing volume
         local err, info = mSys.GetFileInfo(Info.name .. ':')
         if (err == ERR_Okay) and bit.band(info.flags, RDF_HIDDEN) == 0 then
            addFileItem(self, info)
            self.view.sort()
         end
      end
   end

   local function eventVolumeDeleted(Info)
      if self.path then return end

      --if delete_item(self.view.items[1], self.view, Info.name .. ':') then
      --   self.view.acRefresh()
      --end
   end

   local function deleteItem(File)
      for _, item in pairs(self.view.items) do
         if File == nz(item.name,''):gsub('^(.-)[:/\\]+$', '%1') then
            self.view.removeItem(item)
            return true
         end
      end

      return false
   end

   local function incrementalRefresh(Elapsed, CurrentTime, Current)
      if self.inRefresh or self.watch then return end

      if not lDir then
         local flags = bit.bor(RDF_FOLDERS, RDF_PERMISSIONS, RDF_DATE, RDF_SIZE, RDF_TAGS)
         if not lNoFiles then flags = bit.bor(flags, RDF_FILE) end

         local err
         err, lDir = mSys.OpenDir(nz(self.path, ':'), flags)
         if err != ERR_Okay then
            error('Failed to resolve path ' .. nz(self.path, ':'))
            return
         end
      end

      local refresh = false
      local sort = false

      local dirinfo = lDir
      for filecount=0,5 do
         if mSys.ScanDir(dirinfo) != ERR_Okay then
            -- Reached end of the folder - reset the scan
            lDir = nil
            if self.resetTimer then
               if self.timer then
                  mSys.UpdateTimer(self.timer, 0)
                  self.timer = nil
               end

               if not self.watch and self.path then
                  local err
                  err, self.timer = mSys.SubscribeTimer(self.refreshRate, incrementalRefresh)
               end
            end
            break
         end

         local info = dirinfo.info

         if bit.band(info.Flags, RDF_VOLUME) != 0 and bit.band(info.Flags, RDF_HIDDEN) != 0 then
            -- Ignore hidden volumes
         elseif #self.view.items == 0 then -- Empty view, this is the first file.
            addFileItem(self, info)
            break
         else
            local item = findItem(info.name)
            if item then -- File found, extract the timestamp and test it against the file.
               local timestamp = 0
               local size = 0
               if item.date then timestamp = tonumber(item.date.sort) end
               if item.size then size = tonumber(item.size.sort) end

               if (timestamp != 0 and info.timestamp != timestamp) or (size != info.size) then
                  updateFileAttributes(item, info)
                  refresh = true
               end
            else
               -- File does not exist as an item; add it and re-sort the view
               addFileItem(self, info)
               sort = true
               refresh = true
            end
         end
      end

      if #self.view.items > 0 then -- Check for deleted files
         local path = nz(self.path,'')

         if not self.path then -- Do not resolve the path when at the root view
         else -- Use ResolvePath() to prevent problems with multi-folder volumes
            local err, resolved_path = mSys.ResolvePath(path, RSF_NO_FILE_CHECK)
            if err == ERR_Okay then
               path = resolved_path
            end
         end

         if path:sub(1,2) == '\\\\' then
            -- Windows doesn't cope well when constantly refreshing UNC paths (folders sometimes fail analysis).

         else
            local delete_count = 0
            local restart = true
            while restart == true do
               restart = false

               local vw_items = self.view.items
               if #vw_items == 0 then break end

               if (self._delete_index == nil) or (self._delete_index == 0) or (self._delete_index > #vw_items - 1) then
                  self._delete_index = #vw_items - 1
               end

               local item = vw_items[self._delete_index]
               if not item then break end

               while (delete_count < 10) and item do
                  delete_count = delete_count + 1

                  if item.filename then -- Extract the full name of the file for analysis
                     local item_path = path .. item.filename
                     if item.type == 'volume' then
                        item_path = item_path .. ':'
                     elseif item.type == 'folder' then
                        item_path = item_path .. '/'
                     end
                     if mSys.ResolvePath(item_path, RSF_CASE_SENSITIVE, NULL) != ERR_Okay then
                        self.view.removeItem(item)
                        self._file_table[item.filename] = nil
                        refresh = true
                        restart = true
                        break
                     end
                  end
                  self._delete_index = self._delete_index - 1
                  item = vw_items[self._delete_index]
               end
            end
         end
      end

      if sort then self.view.sort() end
   end

   local function pathWatch(MonitoredFile, Path, Custom, Flags)
      if self.inRefresh then return end

      if Flags == 0 then -- No flags means a change has occurred but the host is unable to tell us what happened.
         self.refresh()
         return
      end

      if not Path then -- If no file is given, the monitored folder was affected by something.
         if (bit.band(Flags, MFF_DELETE) != 0 and bit.band(Flags, MFF_SELF) != 0)
             or bit.band(Flags, MFF_UNMOUNT) != 0 then

            if self.path:sub(1,2) == 'cd' then
            elseif self.path:sub(1,4) == 'disk' then
            else -- Check that the folder is definitely gone and that this is not a mis-report.
               if mSys.AnalysePath(self.path, 0) != ERR_Okay then
                  self.browse(nil)
               end
            end
         end
         return
      end

      local info, info_err
      if bit.band(Flags, MFF_DELETE) == 0 then
         info_err, info = mSys.GetFileInfo(self.path .. nz(Path,''))
         if info_err == ERR_Okay then
            if lNoFiles and bit.band(info.Flags, RDF_FILE) != 0 then return end
            -- Use the true file name with the trailing slash if it is a folder (important
            -- for symbolically linked directories).
            Path = info.name
         end
      else
         info_err = ERR_Failed
      end

      if bit.band(Flags, MFF_CREATE) != 0 then
         if info_err == ERR_Okay then
            addFileItem(self, info)
            self.view.sort()
         end
      elseif bit.band(Flags, MFF_DELETE) != 0 then
         deleteItem(Path)
      elseif bit.band(Flags, MFF_MOVED) != 0 then -- Determine if the file has been moved in or moved out
         if info_err == ERR_Okay then
            -- It is possible that the moved file is replacing an already existing file in
            -- the view (i.e. rename operation), so do a tag-check first.

            if findItem(Path) then deleteItem(Path) end
            addFileItem(self, info)
            self.view.sort()
         else
            deleteItem(Path)
         end
      elseif bit.band(Flags, bit.bor(MFF_ATTRIB, MFF_CLOSED)) != 0 and File then
         if info_err == ERR_Okay then
            local item = findItem(Path)
            if item then
               updateFileAttributes(item, info)
            else
               addFileItem(self, info)
            end
            self.view.sort()
         else
            msg('Attrib change misreported - file does not exist.')
            deleteItem(Path)
         end
      end
   end

   local function shortcutBrowse()
      local txtPath = obj.find('txtPath')

      if nz(txtPath) then
         self.dlgShortcutBrowse = gui.dialog.file({
            title    = 'Select a Folder',
            path     = txtPath.string,
            okText   = 'Select Dir',
            noFiles  = true,
            selectFolder = true,
            feedback = function(Dialog, Path, Files)
               txtPath.string = Path
            end
         })
      end
   end

   -- Execute a command with a given Mode.  All files listed in the Items argument will be passed to the object as
   -- a mass execution operation.

   local function openFiles(Items, Mode)
      if not Items or not self.path then return end

      for _,item in pairs(Items) do
         local err, class_id, command = mSys.IdentifyFile(self.path .. item.name.value, Mode, 0)
         if err == ERR_Okay then
            obj.new('task', { path = command }).acActivate()
         end
      end
   end

   -- Check if there is a document tag associated with the current path.

   local function checkDocView()
      if self.showDocs then
         local docfile = mSys.GetDocView(nz(self.path, ':'))
         if docfile then
            if lDoc then
               lDoc.path = docfile
               self.view.document = lDoc
            else
               lDoc = obj.new('document', {
                  src     = docfile,
                  surface = self.view.layout.surface,
                  flags   = 'Unrestricted'
               })

               self.view.document = lDoc
               lDoc._fileview = self.view.id
            end
         end
      else
         self.view.document = nil
      end
   end

   local function responseRename(Dialog, Response, State)
      if Response.id > 0 then
         local dir = false
         if string.find(Dialog.var.src, '^.+[:/\\]$') then
            dir = true
         end

         local dest = self.path .. State.input

         if Dialog.var.src == dest then return end

         local err, path = mSys.ResolvePath(dest, bit.bor(RSF_NO_FILE_CHECK, RSF_CASE_SENSITIVE))
         if err == ERR_Okay then -- Use ResolvePath() to prevent problems with multi-folder volumes
            err = mSys.AnalysePath(path, 0)
         end

         if err == ERR_Okay then -- The destination exists
            self.dlgRenameReplace = gui.dialog.message({
               title    = 'Confirmation Required',
               message  = 'A file already exists that uses this name.  Are you sure that you want to overwrite it?',
               type     = 'question',
               options  = { { id=-1, text='No', icon='items/cancel' },
                            { id=1, text='Yes', icon='items/checkmark' } },
               popover  = self.window,
               modal    = true,
               feedback = function(Dialog, Response, State)
                  if mSys.MoveFile(Dialog.var.src, Dialog.var.dest) == ERR_Okay then
                     --DelayMsg(AC_Refresh, Self.Head.UniqueID, NULL)
                  else
                     gui.dialog.error('File Rename Failure', 'The rename operation failed.', self.window)
                  end
               end
            })
            self.dlgRenameReplace.var = { table.unpack(Dialog.var), dest=dest }
         else
            catch(function()
               local fl = obj.new('file', { path=Dialog.var.src, flags=FL_READ } )
               if fl.acRename(State.input) == ERR_Okay and not self.watch then
                  local item = findItem(Dialog.var.name)
                  if item then
                     local new_name = State.input
                     if item.type == 'folder' then
                        item.name = new_name .. '/'
                        item.filename = new_name .. '/'
                     elseif item.type == 'volume' then
                        item.name = new_name .. ':'
                        item.filename = new_name .. ':'
                     else
                        item.name = new_name
                        item.filename = new_name
                     end

                     self.view.sort()
                  end
               end
            end,
            function(Exception)
               gui.dialog.error('File Rename Failure', 'Failed to rename the file.  ' .. Exception.message, self.window)
            end)
         end
      end
   end

   self.bytesFree = function()
      if self.deviceInfo then return self.deviceInfo.bytesFree end
   end

   self.bytesUsed = function()
      if self.deviceInfo then return self.deviceInfo.bytesUsed end
   end

   self.byteSize = function()
      if self.deviceInfo then return self.deviceInfo.deviceSize end
   end

   -- Change the current path that is being viewed.

   self.browse = function(Path)
      if not nz(Path) or (Path == ':') then Path = nil end

      if Path == self.path then return self.path end

      msg('fileview.browse("' .. nz(Path, 'NIL') .. '")')

      if Path then
         self.path = file.sanitisePath(Path)
         if not string.find(self.path, '^.+[:/\\]$') then
            self.path = self.path .. '/'
         end
      else
         self.path = nil
      end

      if self.limitPath then -- Limit browsing to the limitPath folder and its sub-folders.
         if not self.path or (self.path:sub(1, self.limitPath:len()) != self.limitPath) then
            self.path = self.limitPath
         end
      end

      lDir = nil
      self.watch = nil

      checkDocView()

      self.refresh()

      if self.timer then
         mSys.UpdateTimer(self.timer, 0)
         self.timer = nil
      end

      if self.path then -- Monitor the new path for changes.  Note that not all platforms support this feature.
         msg('Monitor path "' .. self.path .. '"')
         catch(function()
            self.watch = obj.new('file', { path = self.path })
            if self.watch.mtWatch(pathWatch, 0, bit.bor(MFF_CREATE,MFF_DELETE,MFF_ATTRIB,MFF_CLOSED,MFF_MOVED)) != ERR_Okay then
               self.watch = nil
               local err
               err, self.timer = mSys.SubscribeTimer(self.refreshRate, incrementalRefresh)
               msg('Timer-based file monitoring is enabled.')
            else
               msg('Active file monitoring is enabled.')
            end
         end)
      end

      if self.pathChanged then
         self.pathChanged(self, self.path)
      end

      return self.path
   end

   self.cutFiles = function()
      if not self.path then return end

      local clipboard = obj.new('clipboard')
      clipboard.mtRemove(CLIPTYPE_FILE)
      for _,item in pairs(self.view.selectedItems()) do
         clipboard.mtAddFile(CLIPTYPE_FILE, self.path .. item.name, CEF_DELETE)
      end
   end

   self.copyFiles = function() -- Copy all user-selected files and directories from the view to the clipboard
      if not self.path then return end

      local clipboard = obj.new('clipboard')
      clipboard.mtRemove(CLIPTYPE_FILE)
      for _,item in pairs(self.view.selectedItems()) do
         clipboard.mtAddFile(CLIPTYPE_FILE, self.path .. item.name, CEF_EXTEND)
      end
   end

   -- Copies selected files to a destination path.  This method may return immediately and copy the files in the
   -- background.  If a failure occurs, the user will be notified with an error dialog.

   self.copyFilesTo = function(Dest)
      if self.path and nz(Dest) then
         for _, item in pairs(self.view.selectedItems()) do
            local file_list = { }
            for _,item in pairs(items) do
               table.insert(file_list, self.path .. item.name)
            end
            copyFromList(Dest, file_list)
         end

         self.view.deselectAll()
      end
   end

   -- Jumps to the parent folder of a FileView's current path.

   self.parentFolder = function()
      if not self.path then return end
      if self.limitPath and self.limitPath:lower() == self.path:lower() then return end

      local reduced_path, count = self.path:sub(1, -2):gsub('(.+[:/\\]+).+', '%1', 1)

      if count == 0 then
         self.browse(nil)
      else
         self.browse(reduced_path)
      end
   end

   -- Create a dialog box that prompts the user for a folder name.  If the user types in a valid folder
   -- name then the folder will be created in the current path of the file view.  The user may cancel the process by
   -- closing the dialog window at any time.

   self.createFolder = function()
      if not nz(self.path) then -- Create a new shortcut/volume at the root level
         return self.createShortcut()
      else
         self.dlgFolder = gui.dialog.message({
            title     = 'Create New Folder',
            message   = 'Please enter the name of the new folder to create.',
            image     = 'folders/folder_new',
            type      = 'request',
            options   = { { id=-1, text='Cancel', icon='items/cancel' },
                          { id=1, text='Okay', icon='items/checkmark' } },
            modal     = true,
            popover   = self.window,
            userInput = true,
            inputRequired = true,
            feedback = function(Dialog, Response, State)
               if Response.id > 0 and nz(State.input) then
                  local path = self.path .. State.input .. '/'
                  if mSys.CreateFolder(path, 0) == ERR_Okay then
                     if not self.watch then
                        local err, info = mSys.GetFileInfo(path)
                        if err == ERR_Okay then
                           addFileItem(self, info)
                           self.view.sort()
                        end
                     end
                  else
                     gui.dialog.error('Failed to create dir "' .. path .. '"', self.window)
                  end
               end
            end
         })
      end
   end

   -- Prompt the user with a dialog to create a new shortcut.

   self.createShortcut = function(Message, Shortcut, Path)
      if not nz(Message) then
         Message = [[You can create a personal shortcut that will connect a file path to a named shortcut of your choosing.]] .. '\n'
                .. [[Please enter the name of the shortcut and the folder that you would like to connect it to.]]
      end

      local inject = [[<table columns="50,0" width="100%" vspacing="4">]]
         .. [[<row><cell>Name:</cell><cell><input name="txtName" string="]] .. nz(Shortcut,'') .. [[" flags="!enteractivate|ignorefocus" width="180"><action static method="exec" procedure="dlgResponse" object="[dlgCustom]" args="8"/></input></cell></row>]]
         .. [[<row><cell>Path:</cell><cell><p nowrap><input name="txtPath" string="]] .. nz(Path,'') .. [[" flags="!enteractivate|ignorefocus" width="180"><action static method="exec" procedure="dlgResponse" object="[dlgCustom]" args="8"/></input><a onclick="dlgCustom.shortcutBrowse"><image src="icons:folders/folder(16)" westgap="8"/></a></p></cell></row>]]
         .. [[</table>]]

      self.dlgShortcut = gui.dialog.message({
         title   = 'Create Shortcut',
         image   = 'icons:folders/folder(48)+overlays/link',
         icon    = 'folders/folder',
         message = Message,
         popover = self.window,
         options = {
            { id=1, text='Okay', icon='items/checkmark' },
            { id=-1, text='Cancel', icon='items/cancel' }
         },
         inject = inject,
         feedback = function(Dialog, Response, State)
            if Response.id > 0 then
               local txtName = obj.find('txtName')
               local txtPath = obj.find('txtPath')
               if nz(txtName) and nz(txtPath) then
                  mSys.SetVolume(txtName.string, txtPath.string, nil, nil, nil, bit.bor(ASSIGN_REPLACE, ASSIGN_SAVE))
               end
            end

            obj.find('self')._response = Response.id
         end
      })
   end

   -- Delete all currently selected files, following user confirmation.

   self.deleteFiles = function()
      local items = self.view.selectedItems()

      local msg
      if #items > 1 then
         msg = 'Are you sure that you want to delete the ' .. #items .. ' selected items?'
      else
         local fl = nz(items[1].filename,'NIL')
         local item_type = nz(items[1].type,'NIL')
         msg = "Are you sure that you want to delete the '" .. fl .. "' " .. item_type .. '?'
      end

      self.dlgDelete = gui.dialog.message({
         title    = 'Confirm Deletion',
         image    = 'tools/eraser',
         type     = 'question',
         options  = { { id=-1, text='No', icon='items/cancel' },
                      { id=1, text='Yes', icon='items/checkmark' } },
         message  = msg,
         popover  = self.window,
         modal    = true,
         feedback = function(Dialog, Response, State)
            if Response.id > 0 then
               self.view.deselectAll()

               local statement = ''
               for i,fl in pairs(Dialog.files) do
                  statement = statement .. 'mSys.DeleteFile("' .. fl .. '")\n'
               end

               thread.script(statement,
                  function()
                     if not self.watch then self.refresh() end
                  end)
            end
         end
      })

      self.dlgDelete.files = { }
      for _,item in pairs(items) do
         table.insert(self.dlgDelete.files, nz(self.path,'') .. item.name.value)
      end
   end

   -- Run the edit command for all currently selected files.

   self.editFiles = function()
      openFiles(self.view.selectedItems(), 'Edit')
   end

   -- Apply a file filter using wildcards.  E.g. '.*%.fluid$'

   self.filter = function(Filter)
      lFilter = Filter
      self.refresh()
   end

   -- Moves selected files to a destination path.  The MoveFilesTo method may return immediately following the
   -- initial call and then move the files in the background.  If a failure occurs, the user will be notified with an
   -- error dialog.

   self.moveFilesTo = function(Dest)
      if self.path and nz(Dest) then
         local items = self.view.selectedItems()
         if #items > 0 then
            local file_list = { }
            for _, item in pairs(items) do
               table.insert(file_list, self.path .. item.name.value)
            end
            copyFromList(Dest, file_list, true)
         end

         self.view.deselectAll()
      end
   end

   -- Run the open command for all currently selected files.

   self.openFiles = function()
      openFiles(self.view.selectedItems(), 'Open')
   end

   -- Pastes files from the clipboard to the current path of the file view.

   self.pasteFiles = function()
      pasteFromClipboard(self.path)
   end

   -- Prompt the user to rename the most recently selected item in the file view.

   self.renameFile = function()
      if not nz(self.path) then return end

      local sel = self.selection()
      if not nz(sel) then return end

      self.dlgRename = gui.dialog.message({
         title     = 'Rename',
         message   = 'Please enter the new name for the selected file or folder.',
         image     = 'tools/edit',
         options   = { { id=-1, text='Cancel', icon='items/cancel' },
                       { id=1, text='Okay', icon='items/checkmark' } },
         type      = 'request',
         modal     = true,
         userInput = sel,
         popover   = self.window,
         inputRequired = true,
         feedback  = responseRename
      })

      self.dlgRename.var = { src=self.selectedItemPath(), name=sel, path=self.path }
   end

   -- Run the view command for all currently selected files.

   self.viewFiles = function()
      openFiles(self.view.selectedItems(), 'View')
   end

   -- For refresh(), reads an entire folder and add the items to the target view.
   -- If the source has slow read access, system messages are processsed at regular intervals.
   -- See also incrementalRefresh()

   local function refreshFiles()
      msg('refreshFiles() ' .. nz(self.path,'ROOT') .. ' [Limited Logging]')

      self._file_table = { }
      local msg_time  = mSys.PreciseTime()
      local orig_path = self.path
      local flags     = bit.bor(RDF_READ_ALL, RDF_TAGS)
      if lNoFiles then flags = bit.band(flags, bit.bxor(RDF_FILE)) end
      local err, dir_info = mSys.OpenDir(nz(self.path,':'), flags)
      if err == ERR_Okay then
         mSys.AdjustLogLevel(1)

            local items = { }
            while mSys.ScanDir(dir_info) == ERR_Okay do
               if self.path != orig_path then -- Sanity check in case the user changes the path
                  mSys.AdjustLogLevel(-1)
                  return true
               end

               local item = createFileItem(self, dir_info.info)
               if item then table.insert(items, item) end

               local current_time = mSys.PreciseTime()
               if current_time - msg_time > 20000 then
                  if #items > 1 then
                     self.view.addItems(items)
                     items = { }
                  end
                  msg_time = current_time
                  processing.sleep(0)
               end

            end

            if #items > 0 then self.view.addItems(items) end

         mSys.AdjustLogLevel(-1)
      end

      return false
   end

   -- Slow the refresh timer if the monitored path is on a removable device (probably slower than a typical hard disk).

   local function adjustRefreshTimer()
      if self.timer then
         mSys.UpdateTimer(self.timer, 0)
         self.timer = nil
      end

      local err
      if self.deviceInfo and not self.watch and self.path then
         if bit.band(self.deviceInfo.deviceFlags, DEVICE_REMOVABLE) != 0 then
            if bit.band(self.deviceInfo.deviceFlags, DEVICE_WRITE) == 0 then
               -- Read only device, do not refresh
            elseif bit.band(self.deviceInfo.deviceFlags, bit.bor(DEVICE_FLOPPY_DISK, DEVICE_USB)) then
               -- Slow device, do not refresh
            else
               err, self.timer = mSys.SubscribeTimer(2.0, incrementalRefresh) -- Write/Read access to removable device
            end
         else
            err, self.timer = mSys.SubscribeTimer(self.refreshRate, incrementalRefresh)
         end
      end
   end

   self.refresh = function()
      if self.inRefresh then return end -- Recursion detected, aborting request.

      msg('Performing a full refresh of the file view: ' .. nz(self.path, 'NIL'))

      local success, err = pcall(function()
         if lDir then lDir = nil end

         if nz(self.path) then
            self.deviceInfo = obj.new('storagedevice', { volume = self.path })
         else
            self.deviceInfo = nil
         end

         self.inRefresh = true

         self.view.clear()

         if self.view.setColumns then
            self.view:setColumns(defineViewColumns(self.path))
         end

         if lShowParent and self.path then
            if not (self.limitPath and (self.path == self.limitPath)) then
               self.view.addItem({
                  type = 'parent',
                  icon = 'folders/parent',
                  sort = '\x01...',
                  name = '...',
                  insensitive = true
               })
            end
         end

         adjustRefreshTimer()

         if refreshFiles() then
            -- Complete refresh required due to edge-case of the user changing the folder again.
            mSys.SubscribeTimer(0.1, function()
               self.refresh()
               check(ERR_Terminate)
            end)
         else
            self.view.sort()
         end
      end)

      if not success then
         msg(err)
      end

      self.inRefresh = false

      self.view.viewport.acDraw()
   end

   -- Returns the name of the currently selected item, as it appears to the user (e.g.
   -- the file extension might be stripped).

   self.selection = function()
      if self.view.sItem then
         local name = self.view.sItem.name.value
         return name:gsub('^(.-)[:/\\]+$', '%1') -- Strip trailing folder symbols
      end
   end

   -- Returns the currently selected file or folder (fully-qualified).

   self.selectionFile = function()
      if self.view.sItem then return self.view.sItem.filename end
   end

   -- Return the complete, fully-qualified path of the most recently selected item

   self.selectionPath = function()
      if self.view.sItem then return nz(self.path,'') .. self.view.sItem.filename end
   end

   self.view.viewport.mtSubscribeKeyboard(function(Viewport, Qualifiers, Value, Unicode)
      if bit.band(Qualifiers, KQ_PRESSED) == 0 then return end
      if self.hasFocus != true then return end

      if self.enableSysKeys and bit.band(Qualifiers, KQ_CTRL) != 0 then
         -- NB: Sys-keys should only be enabled if cut/copy/paste support is not implemented in the core
         -- application.

         if Value == KEY_C then
            copy_files()
         elseif Value == KEY_X then
            cut_files()
         elseif Value == KEY_V then
            paste_files()
         elseif Value == KEY_A then
            self.view.selectAll()
         end
      elseif Value == KEY_DELETE then
         self.deleteFiles()
      end
   end)

   self.view.viewport.mtSubscribeFeedback(bit.bor(FM_HAS_FOCUS, FM_CHILD_HAS_FOCUS, FM_LOST_FOCUS), function(Viewport, Event)
      if Event == FM_HAS_FOCUS then
         self.hasFocus = true
      elseif Event == FM_LOST_FOCUS then
         self.hasFocus = false
      end
   end)

   -- Drag and drop support is implemented with help from the Clipboard class.  It allows items to be
   -- requested from the FileView.

   local drag_clipboard = obj.new('clipboard', {
      name  = 'fvDragClipboard',
      flags = '!DragDrop',
      requestHandler = function(Clipboard, Requester, Item, Datatypes)
         if not nz(self.path) then -- Do nothing if we are at the root level
            gui.dialog.error('Drag and Drop Failure', 'Drag and drop from volumes is not supported.', self.window);
            return
         end

         if Datatypes[1] == DATA_FILE then
            local items = self.view.dragItems
            if #items > 0 then
               local files = { }
               for i=1,#items do
                  table.insert(files, { file = { path=self.path .. items[i].name.value } })
               end

               local xml = {
                  receipt = {
                     totalitems = #items,
                     id = Item,
                     files
                  }
               }
               Requester.acDataFeed(Clipboard, DATA_RECEIPT, table.toXML(xml))
            end
         end
      end
   })

   drag_clipboard.detach()
--[[
      self.view.dragSource = drag_clipboard

      self.view.subscribe('dragdrop', function(ScriptID, Args, Reference)
         -- This notification is received when something is dropped onto the viewport.

         local dest_tag = self.view.hItem

         input.requestItem(Args.source, Args.item, 'file', function(Items)
            drag_clipboard.mtRemove(CLIPTYPE_FILE)

            local dest = self.path

            -- If the item is being dropped onto a folder, the destination path will be our Path & the folder name.

            if dest_tag != -1 then
               local tag = self.view.xml.tags[dest_tag+1]
               if 'dir' == tag.attrib.name then
                  dest = nz(self.path,'') .. dest_tag.name
               end
            end

            if not nz(dest) or dest == ':' then return end

            local dev_dest = obj.new('storagedevice', { volume = dest })
            local dest_device_id = dev_dest.deviceID
            local count = 0
            for _, item in pairs(Items) do
               if 'file' == item.item then
                  if item.path != dest then
                     local dev_src = obj.new('storagedevice', { volume = item.path })
                     local src_device_id = dev_src.deviceID

                     local flags = 0
                     if dest_device_id != nil and src_dev_id != nil and dest_device_id == src_device_id then
                        flags = bit.bor(flags, CEF_DELETE)
                     elseif (dev_src.deviceFlags == dev_dest.deviceFlags) and
                            (dev_src.bytesFree == dev_dest.bytesFree) and
                            (dev_src.bytesUsed == dev_dest.bytesUsed) then
                        flags = bit.bor(flags, CEF_DELETE)
                     end

                     if bit.band(flags, CEF_DELETE) != 0 then
                        msg('Move "' .. item.path .. '" to "' .. dest .. '"')
                     else
                        msg('Copy "' .. item.path .. '" to "' .. dest .. '"')
                     end

                     drag_clipboard.mtAddFile(CLIPTYPE_FILE, item.path, bit.bor(flags, CEF_EXTEND))
                     count = count + 1
                  end
               end
            end

            if count > 0 then pasteFromClipboard(dest, drag_clipboard.cluster) end
         end)
      end)
--]]

   -- Browse the currently selected file or folder.

   self.view.itemActivated = function(View, Reason, Item)
      if Item.type == 'folder' then
         self.browse(nz(self.path,'') .. Item.filename .. '/')
      elseif Item.type == 'volume' then
         self.browse(Item.filename .. ':')
      elseif Item.type == 'parent' then -- Parent
         self.parentFolder()
      else -- Activate file
         if lOptions.autoMode then
            local tags = { Item, -1 }

            if tags[1] != -1 then
               if lOptions.autoMode == 'open' then
                  openFiles(tags, 'Open')
               elseif lOptions.autoMode == 'edit' then
                  openFiles(tags, 'Edit')
               elseif lOptions.autoMode == 'view' then
                  openFiles(tags, 'View')
               end
            end
         end

         if lOptions.fileSelected then
            lOptions.fileSelected(self)
         end
      end
   end

   if Options.navigationBar then
      local bkgd = self.view.viewport.new('VectorRectangle', {
         x=0, y=0, xOffset=0, height=1, fill=gui.palette.base
      })

      self.toolbar = gui.toolbar({
         iconTheme = 'pearl',
         target  = self.view.viewport,
         x       = 0,
         y       = 0,
         xOffset = 0,
         flush   = true,
         createItems = function(Bar)
            Bar.addItem(1, 'Root', 'Root Folder', 'devices/harddisk', function()
               self.browse(nil)
            end)

            Bar.addItem(2, 'Parent', 'Parent Folder', 'folders/parent', function()
               self.parentFolder()
            end)

            Bar.addItem(4, 'Prev', 'Previous File', 'arrows/fat_left', function()
               self.view.selectPrev(function (Item) if Item.type == 'file' then return true end end)
            end)

            Bar.addItem(5, 'Next', 'Next File', 'arrows/fat_right', function()
               self.view.selectNext(function (Item) if Item.type == 'file' then return true end end)
            end)

            if self.filterList then
               Bar.addItem(6, 'Filter', 'Filter', 'tools/filter', function()
                  displayFilters(self)
               end)
            end

            Bar.addItem(3, 'Bookmark', 'Create Bookmark', 'items/new_bookmark', function()
               if not self.path or (string.len(self.path) < 3) then return end

               local current_path = self.path

               gui.dialog.message({
                  modal         = true,
                  image         = 'items/new_bookmark',
                  title         = 'Create New Volume',
                  message       = 'Enter a new volume name for the path ' .. self.path,
                  userInput     = '',
                  options = {
                     { id=2, text='Cancel', icon='items/cancel' },
                     { id=1, text='Create Volume', icon='items/checkmark' }
                  },
                  feedback = function(Dialog, Response, State)
                     if Response and Response.id == 1 and string.len(State.input) > 0 then
                        mSys.SetVolume(State.input, current_path, 'items/bookmark', nil, nil, VOLUME_REPLACE)
                     end
                  end
               })
            end)

         end
      })

      bkgd.height = self.toolbar.viewport.height
      self._reserved_height = self.toolbar.viewport.height
      self.view.window.y = self._reserved_height
      self.view.scrollbar.vbar.viewport.y = self._reserved_height
   end

   local err
   err, self.evVolumeCreated = subscribeEvent('filesystem.volume.created', eventVolumeCreated)
   err, self.evVolumeDeleted = subscribeEvent('filesystem.volume.deleted', eventVolumeDeleted)

   checkDocView()

   self.refresh()

   if (not self.watch) and nz(self.path) then
      catch(function()
         self.watch = obj.new('file', { path = self.path })
         self.watch.mtWatch(pathWatch, 0, bit.bor(MFF_CREATE, MFF_DELETE, MFF_ATTRIB, MFF_CLOSED, MFF_MOVED))
      end,
      function(Exception) -- Some systems don't support path watching
         self.watch = nil
         err, self.timer = mSys.SubscribeTimer(self.refreshRate, incrementalRefresh)
      end)
   end

   self.window = parentWindow(self.view.viewport.scene.surface)

   return self
end
