--[[

The Divider interface is used to break up the space between viewports and allow them to be user adjustable.

For a horizontal split the configuration must specify two viewports that are positioned to the left and right of the
divider, or top and bottom for a vertical split.  For the viewport on the far side of the divider, define (x, xOffset)
and (y, yOffset) pairs as necessary to ensure that the viewport is correctly anchored.

Example:

   gui.divider({ left=leftViewport, right=rightViewport, minA=50, minB=50 })

Valid options to use when creating the divider are as follows:

   left:       Viewport on the left (A) side.  Must be paired with a viewport on the right.
   right:      Viewport on the right (B) side.
   top:        Viewport on the top (A) side.  Must be paired with a viewport on the bottom.
   bottom:     Viewport on the bottom (B) side.
   minA/B:     Minimum pixel size of the A or B side.
   maxA/B:     Maximum pixel size of the A or B side.
   fixedSize:  Set if the divider position should remain fixed when the window is resized (default is proportional).
   style:      Set to 'none', 'default' or 'alt' for an alternative divider style.
--]]

   require 'common'
   require 'gui'

   if not mGfx then mGfx = mod.load('display') end

local GAP = 8
local HALF_GAP = GAP / 2

----------------------------------------------------------------------------------------------------------------------

local function arrangeAll(self, Middle)
   local a_len

   if Middle then
      local a_limit = math.floor(self._vp[self._length] - self._minB - GAP)
      a_len = math.floor(Middle - HALF_GAP)
      local minA = math.floor(self._primary[self._anchor] + self._minA)
      local maxA = math.floor(self._primary[self._anchor] + self._maxA)
      if (a_len < minA) then a_len = minA end
      if (a_len > maxA) then a_len = maxA end
      if (a_len > a_limit) then a_len = a_limit end
      self._primary[self._length] = a_len - self._primary[self._anchor]
   else -- (A) side will stay the same, (B) side will be resized
      a_len = self._primary[self._anchor] + self._primary[self._length]
   end

   if (self._orientation == 'h') then
      local margin = GAP
      self._div = { x = a_len+1, y = self._primary.y + margin, width = GAP-2, height = self._primary.height - (margin*2) }
      self._pattern.x = self._vp.absX + a_len
      self._pattern.y = self._primary.absY + margin
   else
      local margin = GAP
      self._div = { x = self._primary.x + margin, y = a_len+1, width = self._primary.width - (margin*2), height = GAP-2 }
      self._pattern.x = self._primary.absX + margin
      self._pattern.y = self._vp.absY + a_len
   end

   self._secondary[self._anchor] = a_len + GAP
   -- It is presumed that _secondary.[x|y]Offset is preset by the client.

   self._dividerVP.acRedimension(self._div.x, self._div.y, 0, self._div.width, self._div.height, 0)

   if self._anchored then -- If pointer is anchored, it must be moved manually.
      if (self._orientation == 'h') then
         mGfx.setCursorPos(self._vp.absX + self._div.x + HALF_GAP, self._vp.absY + self._anchorY)
      else
         mGfx.setCursorPos(self._vp.absX + self._anchorX, self._vp.absY + self._div.y + HALF_GAP)
      end
   end

   self._vp.acDraw()
end

----------------------------------------------------------------------------------------------------------------------

gui.divider = function(Options)
   local self = {
      _pct          = 0.5,
      _proportional = not Options.fixedSize,
      _buttonHeld   = false,
      _minA = nz(Options.minA, 5),
      _minB = nz(Options.minB, 5),
      _maxA = nz(Options.maxA, 8000),
      _maxB = nz(Options.maxB, 8000),
      _div  = { } -- Area of the 'strip' between the opposing regions.
   }

   if (Options.left) and (Options.right) then
      self._orientation = 'h'
      self._primary     = Options.left
      self._secondary   = Options.right
      self._anchor      = 'x'
      self._length      = 'width'

      local sd = self._secondary.dimensions
      if (bit.band(sd, DMF_FIXED_X) == 0) or (bit.band(sd, DMF_FIXED_X_OFFSET) == 0) then
         error('The opposing viewport must use fixed x and xOffset coordinates.')
      end
   elseif (Options.top) and (Options.bottom) then
      self._orientation = 'v'
      self._primary     = Options.top
      self._secondary   = Options.bottom
      self._anchor      = 'y'
      self._length      = 'height'

      local sd = self._secondary.dimensions
      if (bit.band(sd, DMF_FIXED_Y) == 0) or (bit.band(sd, DMF_FIXED_Y_OFFSET) == 0) then
         error('The opposing viewport must use fixed y and yOffset coordinates.')
      end
   else
      error('A left/right or top/bottom pair must be specified.')
   end

   self._vp = self._primary.parent
   if (self._vp.id != self._secondary.parent.id) then
      error('The provided viewports do not share the same parent.')
   end

   local div_name = 'divider-bkgd-' .. self._vp.id
   if (Options.style != 'none') then
      if (self._orientation == 'h') then
         self._pattern = self._vp.scene.new('VectorPattern', {
            name='div_pattern', x=0, y=0, pageWidth=GAP, pageHeight=GAP*3, width=GAP, height=GAP*3, units=VUNIT_USERSPACE, spreadMethod=VSPREAD_REPEAT
         })
         local pt = string.format('0,0, %d,%d, %d,%d 0,%d', GAP, GAP, GAP, GAP*2, GAP)
         self._pattern.viewport.new('VectorPolygon', { points=pt, fill='rgb(0,0,0,20)' })

         local pt = string.format('0,%d, %d,%d, %d,%d 0,%d', GAP, GAP, GAP+GAP, GAP, GAP*2+GAP, GAP+GAP)
         self._pattern.viewport.new('VectorPolygon', { points=pt, fill='rgb(0,0,0,40)' })
      else
         self._pattern = self._vp.scene.new('VectorPattern', {
            name='div_pattern', x=0, y=0, pageWidth=GAP*3, pageHeight=GAP, width=GAP*3, height=GAP, units=VUNIT_USERSPACE, spreadMethod=VSPREAD_REPEAT
         })
         local pt = string.format('0,0, %d,0, %d,%d %d,%d', GAP, GAP*2, GAP, GAP, GAP)
         self._pattern.viewport.new('VectorPolygon', { points=pt, fill='rgb(0,0,0,20)' })

         local pt = string.format('%d,0, %d,0, %d,%d %d,%d', GAP, GAP+GAP, GAP*2+GAP, GAP, GAP+GAP, GAP)
         self._pattern.viewport.new('VectorPolygon', { points=pt, fill='rgb(0,0,0,40)' })
      end

      check(self._vp.scene.mtAddDef(div_name, self._pattern))
   end

   self._vp.subscribe('free', function(Viewport)
      if self._anchored then mGfx.unlockCursor(self._vp) end
   end)

   if (self._orientation == 'h') then
      self._dividerVP = self._vp.new('VectorViewport', {
         name='div_vp', x=0, y=0, width=GAP, height='100%', cursor=PTC_SPLIT_HORIZONTAL
      })
   else
      self._dividerVP = self._vp.new('VectorViewport', {
         name='div_vp', x=0, y=0, width='100%', height=GAP, cursor=PTC_SPLIT_VERTICAL
      })
   end

   if (Options.style != 'none') then
      self._dividerVP.new('VectorRectangle', {
         name='div_fill', x=0, y=0, width='100%', height='100%', fill='url(#' .. div_name .. ')'
      })
   end

   arrangeAll(self)

   self._pct = (self._div[self._anchor] + HALF_GAP) / self._vp[self._length]

   self._vp.mtSubscribeFeedback(FM_PATH_CHANGED, function(Viewport, Event)
      if self._proportional then
         if (self._orientation == 'h') then
            arrangeAll(self, self._pct * Viewport.width)
         else
            arrangeAll(self, self._pct * Viewport.height)
         end
      else
         arrangeAll(self)
      end

      Viewport.acDraw()
   end)

   check(self._dividerVP.mtSubscribeInput(bit.bor(JTYPE_MOVEMENT, JTYPE_BUTTON), function(Viewport, Events)
      local ev = Events
      while ev do
         if (ev.type == JET_ABS_XY) then
            if self._buttonHeld then
               if (self._orientation == 'h') then
                  arrangeAll(self, ev.absX - self._vp.absX)
               else
                  arrangeAll(self, ev.absY - self._vp.absY)
               end
               self._pct = (self._div[self._anchor] + HALF_GAP) / self._vp[self._length]
            end
         elseif (ev.type == JET_BUTTON_1) then -- LMB
            if (ev.value > 0) then
               if mGfx.lockCursor(self._vp) == ERR_Okay then
                  self._anchored = true
                  self._anchorX  = input.x
                  self._anchorY  = input.y
               end
               self._buttonHeld = true
            elseif self._buttonHeld then
               if self._anchored then
                  self._anchored = false
                  mGfx.unlockCursor(self._vp)
               end

               self._buttonHeld = false
            end
         end
         ev = ev.next
      end
   end))

   return self
end
