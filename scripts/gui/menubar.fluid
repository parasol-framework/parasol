--[[
The MenuBar interface creates and manages the use of items and groups of items in the UI, typically using icons, text
or both for item representation.  Each item performs a specific application function that is activated via a callback
mechanism.

The following example illustrates basic usage:

   gui.menubar(viewport, {
      x=0, y=0, xOffset=0,
      createItems = function(Bar)
         Bar.addItem(10, 'Rename', 'layout/interface_textbox', function()
            print('rename')
         end)
         Bar.addItem(11, 'Delete', 'tools/eraser', function()
            print('delete')
         end)
      end
   })

The first parameter is the target viewport for the MenuBar graphic.  Valid options to use when creating the menubar are
as follows:

  createItems: Required.  A function that will define the items to display in the menubar.
  x, y:        The x and y coordinates of the menubar.
  xOffset:     Optional x offset (defaults to 0).
--]]

   require 'common'
   require 'gui'
   require 'gui/menu'
   include 'vector'

   if (not mFont) then mFont = mod.load('font') end

local lColours = {
   textFill      = 'rgb(255,255,255)',
   textHighlight = 'rgb(160,160,220)',
   iconGradient  = { first={ r=250,g=249,b=248 }, last={ r=190,g=191,b=192 } }
}

local VMARGIN   = 6
local GAP       = 26
local ICON_SIZE = 12
local FONT_SIZE = 16
local count = 0

local function counter()
   count = count + 1
   return count
end

local function activateItem(self) -- Activate the current menu item.
   if not self._currentItem then return end

   if self._currentItem.callback then
      self._currentItem.callback(self._currentItem.id, self._currentItem.name)
   end

   local menu = self._currentItem.menu
   if not menu then
      menu = gui.menu({
         relative     = self.viewport.scene.surface,
         x            = self._currentItem.x,
         y            = self.viewport.height - 2,
         keyMonitor   = self.viewport,
         config       = self._currentItem.menuConfig
      })
      self._currentItem.menu = menu
   end

   menu.x = self._currentItem.x

   if self._lastMenu and self._lastMenu != menu then
      self._lastMenu.hide()
   end

   if menu.toggle() == 1 then
      self._lastMenu = menu
   end
end

local function firstItem(self) -- Return the first item
   return self._first
end

local function lastItem(self) -- Return the last item
   return self._last
end

local function newItem(self, Name, ID) -- Append an item to the menu bar
   if ID and self._lookup[ID] then error('An item with identifier ' .. ID .. ' already exists.') end

   local item = { id=ID, name=Name }
   if nz(Name) then
      item.displayName = mSys.StrTranslateText(Name)
   end

   if self._last then self._last.next = item end
   item.prev = self._last
   item.next = nil
   self._last = item
   if (not self._first) then self._first = item end

   if ID then self._lookup[ID] = item end
   return item
end

local function getCursorItem(self, X, Y)
   local item = self._first
   while item do
      if (X >= item.x) and (X <  item.x + item.width) and (Y >= item.y) and (Y <  item.y + item.height) then
         return item
      end
      item = item.next
   end
end

-- Highlight selected item (for keyboard item selection)

local function highlightItem(self, Item)
   self._currentItem = Item
   self._hIcon.x          = Item.x + 1
   self._hIcon.y          = 1
   self._hIcon.width      = Item.width - 2
   self._hIcon.height     = self.viewport.height - 2
   self._hIcon.visibility = 'visible'

   self.viewport.acDraw()
end

local function arrangeItems(self)
   if self._vg then self._vg.acFree() end

   self._vg = self.viewport.new('VectorGroup', { name='ItemGroup' })

   local item = self._first
   local x = 0
   local y = 0
   local spanCount = 0
   while item do
      item.x        = x
      item.y        = y
      item.width    = ICON_SIZE + (VMARGIN * 2)
      item.height   = ICON_SIZE + (VMARGIN * 2)
      item.gfxWidth = item.width

      local iconWidth = 0
      if item.svg then
         iconWidth = ICON_SIZE + VMARGIN
         item.svgGroup.x = x + VMARGIN
         item.svgGroup.y = y + VMARGIN
         if self._disabled or item.disabled then
            item.vectorIcon.opacity = 0.5
         end
      end

      if nz(item.displayName) then
         item.vectorText = self._vg.new('VectorText', {
            x        = x + iconWidth + VMARGIN,
            face     = 'Source Sans Pro',
            fontSize = FONT_SIZE,
            fill     = lColours.textFill,
            string   = item.displayName
         })

         item.gfxWidth = iconWidth + mFont.StringWidth(item.vectorText.font, item.displayName, -1) + (VMARGIN * 2)
         item.width = item.gfxWidth + GAP
         item.vectorText.y = (self.viewport.height * 0.5) + (item.vectorText.font.height * 0.5)

         if self._disabled or item.disabled then
            item.vectorText.opacity = 0.5
         end
      end

      x = x + item.width
      spanCount = spanCount + 1

      item = item.next
   end

   self._arranged = true
end

gui.menubar = function(HostVP, Options)
   local self = { -- Public variables
      host = nil,
      viewport = nil,
      _lookup = { },
      _disabled = false,
      _arranged = false
   }

   local function applyFill(Vector, Fill)
      while (Vector != nil) do
         if (Vector.fill != 'none') then
            Vector.fill = Fill
         end
         if (Vector.stroke != nil) then Vector.stroke = Fill end
         local child = Vector.child
         if (child != nil) then applyFill(child, Fill) end
         Vector = Vector.next
      end
   end

   -- Add a clickable item to the menubar.  The Name acts as the item text that is displayed in the menubar if no
   -- icon can be displayed.  The icon string must be in the standard format of 'category/icon'.

   self.addItem = function(ID, Name, Icon, Function, Menu)
      local item = newItem(self, Name, ID)
      item.callback = Function
      item.menuConfig = Menu

      if Icon then
         catch(function()
            local gname = 'menu_grd' .. counter()
            item.svgGroup = self.viewport.new('VectorViewport', { x=0, y=0, width=ICON_SIZE, height=ICON_SIZE })
            item.svgGradient = gui.simpleGradient(self.viewport.scene, gname, { lColours.iconGradient.first, lColours.iconGradient.last }, 0, 0, 0, ICON_SIZE, 'userspace', true)
            item.svg = obj.new('svg', { target=item.svgGroup, path='icons:' .. Icon .. '.svg' })
            applyFill(item.svgGroup, 'url(#' .. gname .. ')')

            local viewport = item.svgGroup.child
            if (viewport != nil) then
               while (child != nil) do
                  if (child.class.id == ID_VECTORVIEWPORT) then
                     viewport = child
                     break
                  end
               end

               if (viewport.viewHeight < viewport.viewWidth) then
                  item.svgGradient.y1 = viewport.viewY - ((viewport.viewWidth - viewport.viewHeight) * 0.5)
                  item.svgGradient.y2 = item.svgGradient.y1 + viewport.viewWidth
               else
                  item.svgGradient.y1 = viewport.viewY
                  item.svgGradient.y2 = viewport.viewY + viewport.viewHeight
               end
            end
         end)
      end

      self._arranged = false
   end

   -- Individual menubar items can be disabled with this method.  Reverse this action with enableItem().

   self.disableItem = function(ID)
      local item = self._lookup[ID]
      if item and (not item.disabled) then
         item.disabled = true
         self.viewport.acDraw()
      end
   end

   -- Items that have been disabled can be re-enabled by calling this method.

   self.enableItem = function(ID)
      local item = self._lookup[ID]
      if item and item.disabled then
         item.disabled = false
         self.viewport.acDraw()
      end
   end

   -- Remove an item from the menubar.

   self.removeItem = function(ID)
      local item = self._lookup[ID]
      self._lookup[ID] = nil
      if item.prev then item.prev.next = item.next end
      if item.next then item.next.prev = item.prev end
      if (item == self._first) then self._first = item.next end
      if (item == self._last) then self._last = item.prev end
      if (item == self._currentItem) then self._currentItem = nil end
   end

   local function hoverUpdate(Item, StateChanged) -- Highlight items that the user hovers over.
      if (self._currentItem == Item) and (StateChanged != true) then return end

      self._hIcon.visibility = 'hidden' -- Turn off keyboard highlighting
      self._currentItem = Item

      if self._prevItem and (self._prevItem != self._currentItem) then
         self._prevItem.vectorText.fill = lColours.textFill
      end

      if self._currentItem and (not self._currentItem.disabled) and (not self._disabled) then
         self._currentItem.vectorText.fill = lColours.textHighlight
         self._prevItem = self._currentItem
      end

      self.viewport.acDraw()
   end

   -- Main entry point

   catch(function()
      if (not HostVP) then error('A target viewport is required.') end

      self.viewport = HostVP.new('vectorviewport')
      self.viewport.x      = nz(Options.x, 0)
      self.viewport.y      = nz(Options.y, 0)
      self.viewport.height = 1
      self.viewport.xOffset = nz(Options.xOffset, 0)

      if (self.viewport.acInit() != ERR_Okay) then error('Failed to initialise viewport.') end

      self.viewport.subscribe('free', function(Viewport, Args)
         self = { }
      end)

      self.viewport.mtSubscribeFeedback(bit.bor(FM_HAS_FOCUS, FM_CHILD_HAS_FOCUS, FM_LOST_FOCUS), function(Viewport, Event)
         if (Event == FM_LOST_FOCUS) then
            self._hasFocus = false
            if self._currentItem then
               self._hIcon.visibility = 'hidden' -- Turn off keyboard highlighting
            end
         else
            self._hasFocus = true
         end

         self.viewport.acDraw()
      end)

      self.enable = function()
         self._disabled = false
         self.viewport.acDraw()
      end

      self.disable = function()
         self._disabled = true
         self.viewport.acDraw()
      end

      self.viewport.mtSubscribeInput(bit.bor(JTYPE_BUTTON, JTYPE_MOVEMENT, JTYPE_FEEDBACK), function(Viewport, Events)
         local ev = Events
         while ev do
            if (ev.type == JET_ENTERED_SURFACE) then

            elseif (ev.type == JET_LEFT_SURFACE) then
               if self._currentItem then
                  hoverUpdate(nil)
               end
            elseif (bit.band(ev.flags, JTYPE_MOVEMENT) != 0) then
               if self._clicked then return end

               local item = getCursorItem(self, ev.x, ev.y)

               hoverUpdate(item)
            elseif (bit.band(ev.flags, JTYPE_BUTTON) != 0) then
               if (ev.type != JET_BUTTON_1) then return end

               if (ev.value > 0) then
                  if self._currentItem then
                     if self._currentItem.disabled or self._disabled then return end

                     self._clicked = self._currentItem
                     hoverUpdate(self._currentItem, true)
                     activateItem(self)
                  end
               elseif self._clicked then
                  self._clicked = nil

                  hoverUpdate(self._currentItem, true)
               end
            end

            ev = ev.next
         end
      end)

      self.viewport.mtSubscribeKeyboard(function(Viewport, Qualifiers, Code, Unicode)
         if (bit.band(Qualifiers, KQ_PRESSED) != 0) then
            if (Code == K_ENTER) or (Code == K_NP_ENTER) or (Code == K_SPACE) then
               activateItem(self)
            elseif (Code == K_UP) or (Code == K_LEFT) then
               if (self._currentItem) then
                  local scan = self._currentItem.prev
                  if (not scan) then scan = lastItem(self) end
                  highlightItem(self, scan)
               else
                  highlightItem(self, firstItem(self))
               end
            elseif (Code == K_DOWN) or (Code == K_RIGHT) or (Code == K_TAB) then
               if self._currentItem then
                  local scan = self._currentItem.next
                  if (not scan) then scan = firstItem(self) end
                  highlightItem(self, scan)
               else
                  highlightItem(self, firstItem(self))
               end
            end
         end
      end)

      self._bkgd = self.viewport.new('VectorGroup', { name='ItemBackground' })

      self._hIcon = self.viewport.new('VectorRectangle', { -- Keyboard-based selection
         stroke    = 'rgb(0,0,0,128)',
         dashArray = '1, 1',
         roundX    = 3,
         roundY    = 3,
         x         = 0,
         y         = 0,
         width     = 16,
         height    = 16,
         visibility = 'hidden'
      })

      Options.createItems(self)

      self.viewport.height = ICON_SIZE + (VMARGIN * 2)

      self._bkgd.new('VectorRectangle', { -- Main background
         fill   = 'rgb(0,0,0,200)',
         x      = 0,
         y      = 0,
         width  = '100%',
         height = self.viewport.height - 1
      })

      self._bkgd.new('VectorRectangle', { -- Bottom stroke
         fill        = 'rgb(0,0,0,64)',
         stroke      = 'rgb(255,255,255,64)',
         strokeWidth = 1,
         x           = 0,
         y           = self.viewport.height - 1,
         width       = '100%',
         height      = 1
      })

      arrangeItems(self)
   end,
   function(Exception)
      error('Failed to initialise Menubar: ' .. Exception.message)
   end)

   return self
end
