--[[
The MenuBar interface creates and manages the use of items and groups of items in the UI, typically using icons, text
or both for item representation.  Each item performs a specific application function that is activated via a callback
mechanism.

The following example illustrates basic usage:

   gui.menubar(viewport, {
      x=0, y=0, xOffset=0,
      createItems = function(Bar)
         Bar.addItem(10, 'Rename', 'layout/interface_textbox', function()
            print('rename')
         end)
         Bar.addItem(11, 'Delete', 'tools/eraser', function()
            print('delete')
         end)
      end
   })

The first parameter is the target viewport for the MenuBar graphic.  Valid options to use when creating the menubar are
as follows:

  createItems: Required.  A function that will define the items to display in the menubar.
  x, y:        The x and y coordinates of the menubar.
  xOffset:     Optional x offset (defaults to 0).
  tabFocus:    Optional reference to a TabFocus object for the MenuBar to connect to.
--]]

   require 'common'
   require 'gui'
   require 'gui/menu'
   include 'vector'

   if (not mFont) then mFont = mod.load('font') end

local lColours = {
   textFill = 'rgb(255,255,255)',
   textHighlight = 'rgb(160,160,220)',
   iconGradient = { first={ r=250,g=249,b=248 }, last={ r=190,g=191,b=192 } }
}

local VMARGIN   = 6
local GAP       = 26
local ICON_SIZE = 12
local FONT_SIZE = 16
local count = 0

local function counter()
   count = count + 1
   return count
end

gui.menubar = function(HostVP, Options)
   local self = { -- Public variables
      host = nil,
      vp = nil,
      _lookup = { },
      _disabled = false,
      _arranged = false
   }

   local function activateItem() -- Activate the current menu item.
      if not self._currentItem then return end

      if self._currentItem.callback then
         self._currentItem.callback(self._currentItem.id, self._currentItem.name)
      end

      local menu = self._currentItem.menu
      if not menu then
         menu = gui.menu({
            relative     = self.vp.scene.surface,
            x            = self._currentItem.x,
            y            = self.vp.height - 2,
            keyMonitor   = self.vp,
            config       = self._currentItem.menuConfig
         })
         self._currentItem.menu = menu
      end

      menu.x = self._currentItem.x

      if menu.switch() == 1 then
         if self._lastMenu and self._lastMenu != menu then
            self._lastMenu.hide()
         end
         self._lastMenu = menu
      end
   end

   local function firstItem() -- Return the first item
      return self._first
   end

   local function lastItem() -- Return the last item
      return self._last
   end

   local function newItem(Name, ID) -- Append an item to the menu bar
      if ID and (self._lookup[ID]) then error('An item with identifier ' .. ID .. ' already exists.') end

      local item = { id=ID, name=Name }
      if nz(Name) then
         item.displayName = mSys.StrTranslateText(Name)
      end

      if self._last then self._last.next = item end
      item.prev = self._last
      item.next = nil
      self._last = item
      if (not self._first) then self._first = item end

      if ID then self._lookup[ID] = item end
      return item
   end

   local function getCursorItem(X, Y)
      local item = self._first
      while (item) do
         if (X >= item.x) and (X <  item.x + item.width) and (Y >= item.y) and (Y <  item.y + item.height) then
            return item
         end
         item = item.next
      end
   end

   -- Highlight selected item (for keyboard item selection)

   local function highlightItem(Item)
      self._currentItem = Item
      self._hIcon.x          = Item.x + 1
      self._hIcon.y          = 1
      self._hIcon.width      = Item.width - 2
      self._hIcon.height     = self.vp.height - 2
      self._hIcon.visibility = 'visible'

      self.vp.acDraw()
   end

   local function keyFeedback(Input, Surface, Flags, Code, Unicode)
      if (bit.band(Flags, KQ_PRESSED) != 0) then
         if (Code == K_ENTER) or (Code == K_NP_ENTER) or (Code == K_SPACE) then
            activateItem()
         elseif (Code == K_UP) or (Code == K_LEFT) then
            if (self._currentItem) then
               local scan = self._currentItem.prev
               if (not scan) then scan = lastItem() end
               highlightItem(scan)
            else
               highlightItem(firstItem())
            end
         elseif (Code == K_DOWN) or (Code == K_RIGHT) or (Code == K_TAB) then
            if self._currentItem then
               local scan = self._currentItem.next
               if (not scan) then scan = firstItem() end
               highlightItem(scan)
            else
               highlightItem(firstItem())
            end
         end
      end
   end

   local function arrangeItems()
      if self._vg then self._vg.acFree() end

      self._vg = self.vp.new('VectorGroup', { name='ItemGroup' })

      local item = self._first
      local x = 0
      local y = 0
      local spanCount = 0
      while item do
         item.x        = x
         item.y        = y
         item.width    = ICON_SIZE + (VMARGIN * 2)
         item.height   = ICON_SIZE + (VMARGIN * 2)
         item.gfxWidth = item.width

         local iconWidth = 0
         if item.svg then
            iconWidth = ICON_SIZE + VMARGIN
            item.svgGroup.x = x + VMARGIN
            item.svgGroup.y = y + VMARGIN
            if self._disabled or item.disabled then
               item.vectorIcon.opacity = 0.5
            end
         end

         if nz(item.displayName) then
            item.vectorText = self._vg.new('VectorText', {
               x        = x + iconWidth + VMARGIN,
               face     = 'Source Sans Pro',
               fontSize = FONT_SIZE,
               fill     = lColours.textFill,
               string   = item.displayName
            })

            item.gfxWidth = iconWidth + mFont.StringWidth(item.vectorText.font, item.displayName, -1) + (VMARGIN * 2)
            item.width = item.gfxWidth + GAP
            item.vectorText.y = (self.vp.height * 0.5) + (item.vectorText.font.height * 0.5)

            if self._disabled or item.disabled then
               item.vectorText.opacity = 0.5
            end
         end

         x = x + item.width
         spanCount = spanCount + 1

         item = item.next
      end

      self._arranged = true
   end

   local function applyFill(Vector, Fill)
      while (Vector != nil) do
         if (Vector.fill != 'none') then
            Vector.fill = Fill
         end
         if (Vector.stroke != nil) then Vector.stroke = Fill end
         local child = Vector.child
         if (child != nil) then applyFill(child, Fill) end
         Vector = Vector.next
      end
   end

   -- Add a clickable item to the menubar.  The Name acts as the item text that is displayed in the menubar if no
   -- icon can be displayed.  The icon string must be in the standard format of 'category/icon'.

   self.addItem = function(ID, Name, Icon, Function, Menu)
      local item = newItem(Name, ID)
      item.callback = Function
      item.menuConfig = Menu

      if Icon then
         catch(function()
            local gname = 'menu_grd' .. counter()
            item.svgGroup = self.vp.new('VectorViewport', { x=0, y=0, width=ICON_SIZE, height=ICON_SIZE })
            item.svgGradient = gui.simpleGradient(self.vp.scene, gname, { lColours.iconGradient.first, lColours.iconGradient.last }, 0, 0, 0, ICON_SIZE, 'userspace', true)
            item.svg = obj.new('svg', { target=item.svgGroup, path='icons:' .. Icon .. '.svg' })
            applyFill(item.svgGroup, 'url(#' .. gname .. ')')

            local viewport = item.svgGroup.child
            if (viewport != nil) then
               while (child != nil) do
                  if (child.class.id == ID_VECTORVIEWPORT) then
                     viewport = child
                     break
                  end
               end

               if (viewport.viewHeight < viewport.viewWidth) then
                  item.svgGradient.y1 = viewport.viewY - ((viewport.viewWidth - viewport.viewHeight) * 0.5)
                  item.svgGradient.y2 = item.svgGradient.y1 + viewport.viewWidth
               else
                  item.svgGradient.y1 = viewport.viewY
                  item.svgGradient.y2 = viewport.viewY + viewport.viewHeight
               end
            end
         end)
      end

      self._arranged = false
   end

   -- Individual menubar items can be disabled with this method.  Reverse this action with enableItem().

   self.disableItem = function(ID)
      local item = self._lookup[ID]
      if item and (not item.disabled) then
         item.disabled = true
         self.vp.acDraw()
      end
   end

   -- Items that have been disabled can be re-enabled by calling this method.

   self.enableItem = function(ID)
      local item = self._lookup[ID]
      if item and item.disabled then
         item.disabled = false
         self.vp.acDraw()
      end
   end

   -- Remove an item from the menubar.

   self.removeItem = function(ID)
      local item = self._lookup[ID]
      self._lookup[ID] = nil
      if item.prev then item.prev.next = item.next end
      if item.next then item.next.prev = item.prev end
      if (item == self._first) then self._first = item.next end
      if (item == self._last) then self._last = item.prev end
      if (item == self._currentItem) then self._currentItem = nil end
   end

   local function hoverUpdate(Item, StateChanged) -- Highlight items that the user hovers over.
      if (self._currentItem == Item) and (StateChanged != true) then return end

      self._hIcon.visibility = 'hidden' -- Turn off keyboard highlighting
      self._currentItem = Item

      if self._prevItem and self._prevItem != self._currentItem then
         self._prevItem.vectorText.fill = lColours.textFill
      end

      if self._currentItem and (not self._currentItem.disabled) and (not self._disabled) then
         self._currentItem.vectorText.fill = lColours.textHighlight
         self._prevItem = self._currentItem
      end

      self.vp.acDraw()
   end

   local function inputFeedback(Viewport, Events) -- Internal input handler
      local ev = Events
      while ev do
         if (ev.type == JET_ENTERED_SURFACE) then

         elseif (ev.type == JET_LEFT_SURFACE) then
            if self._currentItem then
               hoverUpdate(nil)
            end
         elseif (bit.band(ev.flags, JTYPE_MOVEMENT) != 0) then
            if self._clicked then return end

            local item = getCursorItem(ev.x, ev.y)

            hoverUpdate(item)
         elseif (bit.band(ev.flags, JTYPE_BUTTON) != 0) then
            if (ev.value > 0) then
               if self._disabled then return end

               if self._currentItem then
                  if self._currentItem.disabled then return end

                  if (ev.type == JET_BUTTON_1) then
                     self._clicked = self._currentItem
                     lClickX  = ev.x
                     lClickY  = ev.y
                     hoverUpdate(self._currentItem, true)
                     activateItem()
                  end
               end
            elseif (ev.type == JET_BUTTON_1) then
               if self._clicked then
                  self._clicked = nil

                  hoverUpdate(self._currentItem, true)
               end
            end
         end

         ev = ev.next
      end
   end

   -- Main entry point

   catch(function()
      if (not HostVP) then error('A target viewport is required.') end

      self.vp = HostVP.new('vectorviewport')
      self.vp.x      = nz(Options.x, 0)
      self.vp.y      = nz(Options.y, 0)
      self.vp.height = 1
      self.vp.xOffset = nz(Options.xOffset, 0)

      if (self.vp.acInit() != ERR_Okay) then error('Failed to initialise viewport.') end

      self.vp.subscribe('free', function(Viewport, Args)
         self = { }
      end)

      self.vp.subscribe('focus', function(Viewport, Args)
         self.vp.acDraw()
      end)

      self.vp.subscribe('lostfocus', function(Viewport, Args)
         if self._currentItem then
            self._hIcon.visibility = 'hidden' -- Turn off keyboard highlighting
            self.vp.acDraw()
         end
      end)

      self.enable = function()
         self._disabled = false
         self.vp.acDraw()
      end

      self.disable = function()
         self._disabled = true
         self.vp.acDraw()
      end

      self.vp.mtSubscribeInput(bit.bor(JTYPE_BUTTON, JTYPE_MOVEMENT, JTYPE_FEEDBACK), inputFeedback)
      input.keyboard(self.vp.scene.surface, keyFeedback)

      self._bkgd = self.vp.new('VectorGroup', { name='ItemBackground' })

      self._hIcon = self.vp.new('VectorRectangle', { -- Keyboard-based selection
         stroke    = 'rgb(0,0,0,128)',
         dashArray = '1, 1',
         roundX    = 3,
         roundY    = 3,
         x         = 0,
         y         = 0,
         width     = 16,
         height    = 16,
         visibility = 'hidden'
      })

      Options.createItems(self)

      self.vp.height = ICON_SIZE + (VMARGIN * 2)

      self._bkgd.new('VectorRectangle', { -- Main background
         fill   = 'rgb(0,0,0,200)',
         x      = 0,
         width  = '100%',
         height = self.vp.height - 1,
         y      = 0
      })

      self._bkgd.new('VectorRectangle', { -- Bottom stroke
         fill        = 'rgb(0,0,0,64)',
         stroke      = 'rgb(255,255,255,64)',
         strokeWidth = 1,
         x           = 0,
         width       = '100%',
         height      = 1,
         y           = self.vp.height - 1
      })

      arrangeItems()

      if Options.tabFocus then
         Options.tabFocus.mtAddObject(self.vp)
      end
   end,
   function(Exception)
      error('Failed to initialise Menubar: ' .. Exception.message)
   end)

   return self
end
