--[[
The colour dialog provides a standard interface for user colour selection.  On activation, it presents the user
with a small window containing common colours, personal colours and a rainbow palette.  The dialog will close once the
user selects a colour, or cancels the dialog window.

To create a dialog box:

   require 'gui/colourdialog'
   gui.dialog.colour({ Options... })

If the dialog box is modal, the call will not return until the user has responded to the dialog.

To receive feedback from the dialog box, set the feedback option with a function that follows this prototype:

   function feedback(Colour)

The Colour will refer to the user's selected colour in RGB string format, e.g. '128,255,64'.  In the event that the
dialog is cancelled, the Colour is set to nil.

Note that the dialog box is designed for execution as a temporary resource that is deallocated once the user has
responded.  Retaining dialog boxes consumes resources with no descernible speed improvement to the user.

Valid options to use when creating the dialog are as follows:

   popover:    Place the dialog window over the referenced surface.
   target:     Open the dialog window within the referenced surface.
   modal:      Set to true if the dialog box needs to be modal (prevents interaction with other windows).
   okText:     Text to display in the OK button.
   cancelText: Text to display in the Cancel button.
   path:       The initial selection path.
   feedback:   Refers to a Fluid function that will receive the user's response to the dialog.
   colour:     The default colour in 'R,G,B' format.

--]]

   require 'common'
   require 'json'
   require 'gui'

   if (gui == nil) then gui = { } end
   if (gui.dialog == nil) then gui.dialog = { } end

gui.dialog.colour = function(Options)
   local mFont   = mod.load('font')
   local mGfx    = mod.load('display')
   local mVector = mod.load('vector')
   local mWidget = mod.load('widget')

   local self = { -- Public variables and global resources that need to be retained
      windowID = nil,
      colour = { r=0, g=0, b=0, a=255 }
   }

   local lOptions = Options
   local lWindow, lFont, lPaletteChanged
   local lRGB = { r=200, g=200, b=200, a=255 }
   local lColBorder = { r=0, g=0, b=0,  a=128 }
   local lPicker
   local lAbsX = -1
   local lAbsY = -1
   local lRainbowX = -1
   local lRainbowY = -1
   local lRainbow = { winX = 0, winY = 0, winWidth = 0, winHeight = 0 }
   local lLinks = { }
   local lCustom = { }
   local lWidgetGap = 3
   local lRainbowBmp -- Rainbow palette bitmap
   local BTNSIZE = 20
   local BTNGAP = 3
   local WIDGET_GAP = 6
   local lAddIcon
   local updateRGB -- Forward declarations of functions
   local lThemeColour

   local lCommon = {
     '0,64,64', '0,128,128', '0,192,192', '0,255,255', '64,255,255',  '128,255,255', '192,255,255', '224,255,255', -- Aqua
     '0,64,0',  '0,128,0',   '0,192,0',   '0,255,0',   '64,255,64',   '128,255,128', '192,255,192', '224,255,224', -- Green
     '64,64,0', '128,128,0', '192,192,0', '255,255,0', '255,255,64',  '255,255,128', '255,255,192', '255,255,224', -- Yellow
     '64,0,0',  '128,0,0',   '192,0,0',   '255,0,0',   '255,64,64',   '255,128,128', '255,192,192', '255,224,224', -- Red
     '64,0,64', '128,0,128', '192,0,192', '255,0,255', '255,64,255',  '255,128,255', '255,192,255', '255,224,255', -- Purple
     '0,0,64',  '0,0,128',   '0,0,192',   '0,0,255',   '64,64,255',   '128,128,255', '192,192,255', '224,224,255', -- Blue
     '0,0,0',   '32,32,32',  '64,64,64',  '96,96,96',  '128,128,128', '160,160,160', '192,192,192', '255,255,255'  -- Grey
   }

   local buildLayout = function()
      if not self.scene then return end

      lLinks = { }

      local dx = WIDGET_GAP
      local dy = WIDGET_GAP

      self.txtBasicColours = self.viewport.new('VectorText', {
         x        = dx,
         y        = dy + gui.getFontHeight(gui.fonts.widget),
         string   = 'Basic colours',
         fill     = 'rgb(0,0,0,255)',
         face     = gui.fonts.widget.face,
         fontSize = string.format('%.2fpt', gui.fonts.widget.size),
         align    = 'left'
      })

      dy = dy + gui.getFontHeight(gui.fonts.widget) + WIDGET_GAP

      -- Configure an array of 8x6 buttons representing a pre-selected colour palette

      local y = dy
      local colour = 1
      for row=1, 7 do
         local x = WIDGET_GAP - 1
         for col=1, 8 do
            local rgb = gui.strToRGB(lCommon[colour])

            local vec = self.viewport.new('VectorRectangle', {
               fill   = gui.rgbToSVG(rgb),
               stroke = gui.rgbToSVG(lColBorder),
               strokeWidth = 1,
               x      = x,
               y      = y,
               width  = BTNSIZE,
               height = BTNSIZE,
               roundX = 2,
               roundY = 2
            })

            table.insert(lLinks, {
               vector=vec, x=x, y=y, width=BTNSIZE, height=BTNSIZE, colour=rgb,
               routine = function(Link)
                  updateRGB(Link.colour)
               end
            })

            x = x + BTNSIZE + BTNGAP
            colour = colour + 1
         end
         y = y + BTNSIZE + BTNGAP
      end

      dy = y + BTNGAP

      -- Configure an array of 8x2 user customised colours

      self.txtPersonalColours = self.viewport.new('VectorText', {
         x        = dx,
         y        = dy + gui.getFontHeight(gui.fonts.widget),
         string   = 'Personal colours',
         fill     = 'rgb(0,0,0,255)',
         face     = gui.fonts.widget.face,
         fontSize = string.format('%.2fpt', gui.fonts.widget.size),
         align    = 'left'
      })

      dy = dy + gui.getFontHeight(gui.fonts.widget) + WIDGET_GAP
      y = dy
      local ci = 1
      for row=1, 2 do
         local x = dx
         for column=1, 7 do
            local rgb = nz(lCustom[ci], { r=255, g=255, b=255, a=255 })
            if not rgb.r then rgb.r = 255 end
            if not rgb.g then rgb.g = 255 end
            if not rgb.b then rgb.b = 255 end
            if not rgb.a then rgb.a = 255 end

            local vec = self.viewport.new('VectorRectangle', {
               fill   = gui.rgbToSVG(rgb),
               stroke = gui.rgbToSVG(lColBorder),
               strokeWidth = 1,
               x      = x,
               y      = y,
               width  = BTNSIZE,
               height = BTNSIZE,
               roundX = 2,
               roundY = 2
            })

            table.insert(lLinks, { vector=vec, x=x, y=y, width=BTNSIZE, height=BTNSIZE, colour=rgb,
               routine = function(Link)
                  updateRGB(Link.colour)
               end
            })

            x = x + BTNSIZE + BTNGAP
            ci = ci + 1
         end

         -- Add buttons for the adding and removing of personal colours

         if (row == 1) then
            lAddIcon = self.viewport.new('VectorViewport', { x=x+2, y=y, width=BTNSIZE, height=BTNSIZE })
            gui.simpleGradient(self.scene, 'grdAddIcon', { lThemeColour.first, lThemeColour.last }, 0, 0, 0, 1)
            obj.new('svg', { target=lAddIcon, path='icons:items/add.svg' })
            gui.applyFill(lAddIcon, 'url(#grdAddIcon)')

            table.insert(lLinks, {
               vec=lAddIcon, x=x, y=y, width=BTNSIZE, height=BTNSIZE,
               routine = function(Link)
                  for k, v in pairs(lCustom) do
                     if (v.r == lRGB.r) and (v.g == lRGB.g) and (v.b == lRGB.b) then return end
                  end

                  if (#lCustom < 7 * 2) then
                     lPaletteChanged = true
                     table.insert(lCustom, lRGB)
                     lWindow.surface.acDraw()
                  else
                     local dlg = obj.new('dialog', {
                        image   = 'icons:items/error(48)',
                        buttons = 'okay',
                        title   = 'Out of Palette Space',
                        popover = lWindow,
                        string  = 'You have run out of space for adding new colours to your personal palette.  Please delete some of your existing colours before adding new ones.',
                     })
                     dlg.acShow()
                  end
               end
            })
         elseif (row == 2) then
            lDeleteIcon = self.viewport.new('VectorViewport', { x=x+2, y=y, width=BTNSIZE, height=BTNSIZE })
            obj.new('svg', { target=lDeleteIcon, path='icons:items/trash.svg' })
            gui.applyFill(lDeleteIcon, 'url(#grdAddIcon)')

            table.insert(lLinks, { vec=lDeleteIcon, x=x, y=y, width=BTNSIZE, height=BTNSIZE,
               routine = function(Link)
                  for k, v in pairs(lCustom) do
                     if (v.r == lRGB.r) and (v.g == lRGB.g) and (v.b == lRGB.b) then
                        lPaletteChanged = true
                        table.remove(lCustom, k)
                        lWindow.surface.acDraw()
                        break
                     end
                  end
               end
            })
         end

         y = y + BTNSIZE + BTNGAP
      end

      local bottom = y + WIDGET_GAP

      -- Configure the palette selection area

      dx = dx + ((BTNSIZE + BTNGAP) * 8) + 10
      dy = WIDGET_GAP

      self.txtRainbowPalette = self.viewport.new('VectorText', {
         x        = dx,
         y        = dy + gui.getFontHeight(gui.fonts.widget),
         string   = 'Rainbow palette',
         fill     = 'rgb(0,0,0,255)',
         face     = gui.fonts.widget.face,
         fontSize = string.format('%.2fpt', gui.fonts.widget.size),
         align    = 'left'
      })

      dy = dy + gui.getFontHeight(gui.fonts.widget) + WIDGET_GAP

      self.vecRainbowPalette = self.viewport.new('VectorRectangle', {
         x      = dx,
         y      = dy,
         width  = lRainbowBmp.width,
         height = lRainbowBmp.height,
         roundX = 4,
         roundY = 4,
         stroke = gui.rgbToSVG(lColBorder),
         fill   = 'url(#Rainbow)'
      })

      lRainbowX = dx
      lRainbowY = dy

      dy = dy + self.vecRainbowPalette.height + WIDGET_GAP

      -- The picker selects colours in the rainbow palette and is only visible if the user activates it.

      self.vecPicker = self.viewport.new('VectorEllipse', {
         cx      = lRainbowX,
         cy      = lRainbowY,
         radiusX = 4,
         radiusY = 4,
         visibility = VIS_HIDDEN
      })

      self.vecChosenColour = self.viewport.new('VectorRectangle', {
         x      = dx,
         y      = dy,
         roundX = 4,
         roundY = 4,
         width  = lRainbowBmp.width,
         height = 32,
         fill   = gui.rgbToSVG(lRGB),
         stroke = gui.rgbToSVG(lColBorder)
      })

      dy = dy + self.vecChosenColour.height + WIDGET_GAP

      self.inputRGB = self.viewport.new('input', {
         x = dx,
         y = dy,
         width = lRainbowBmp.width,
         label = 'RGB:',
         inputMask = '%d,%d,%d'
      })

      dy = dy + self.inputRGB.height + WIDGET_GAP

      -- Okay and cancel buttons

      lCancelButton = self.viewport.new('button', {
         text    = nz(lOptions.cancelText, 'Cancel'),
         xOffset = WIDGET_GAP,
         y       = dy,
         icon    = 'items/cancel'
      })

      lOkayButton = self.viewport.new('button', {
         text    = nz(lOptions.okText, 'OK'),
         xOffset = lCancelButton.width + (WIDGET_GAP * 2),
         y       = dy,
         icon    = 'items/checkmark'
      })

      lOkayButton.subscribe('activate', function()
         saveColours()
         if (lOptions.feedback != nil) then
            lOptions.feedback(lRGB.r .. ',' .. lRGB.g .. ',' .. lRGB.b)
         end
         lWindow = nil
      end)

      lCancelButton.subscribe('activate', function()
         if (lOptions.feedback != nil) then
            lOptions.feedback(nil)
         end
         lWindow = nil
      end)

      dy = dy + lOkayButton.height + WIDGET_GAP
      if (dy > bottom) then bottom = dy end

      collectgarbage()

      return (lRainbowX + lRainbowBmp.width + WIDGET_GAP), bottom
   end

   local function arrangeLayout()
      -- Recalculate clickable links

      for _, link in ipairs(lLinks) do
         if link.vector then
            _, link.x, link.y, link.width, link.height = link.vector.mtGetBoundary()
         end
      end

      if self.vecRainbowPalette then
         _, lRainbow.winX, lRainbow.winY, lRainbow.winWidth, lRainbow.winHeight = self.vecRainbowPalette.mtGetBoundary()
      end

      -- Draw the picker within the rainbow palette, if active

      if not self.vecPicker then return end

      if (lPicker) then
         local val = (lPicker.y * 255) / (lRainbowBmp.height * 0.75)
         if (val > 255) then val = 255 end

         self.vecPicker.cx = lRainbowX + lPicker.x
         self.vecPicker.cy = lRainbowY + lPicker.y

         self.vecPicker.stroke   = 'rgb(' .. val .. ',' .. val .. ',' .. val .. ',255)'
         self.vecPicker.visibility = VIS_VISIBLE
      else
         self.vecPicker.visibility = VIS_HIDDEN
      end
   end

   updateRGB = function(RGB)
      if not RGB then return end
      lRGB = RGB
      if self.vecChosenColour then
         self.vecChosenColour.fill = gui.rgbToSVG(lRGB)
      end
      self.inputRGB.string = nz(lRGB.r,0) .. ',' .. nz(lRGB.g,0) .. ',' .. nz(lRGB.b,0)
      lWindow.surface.acDraw()
   end

   -- Executed when the user clicks the rainbow palette area.  Some coordinate translation
   -- occurs in order to manage viewport scaling within the display window.

   local function selectPalette(X, Y)
      if (X < 0) then X = 0 end
      if (Y < 0) then Y = 0 end
      if (X >= lRainbow.winWidth) then X = lRainbow.winWidth - 1 end
      if (Y >= lRainbow.winHeight) then Y = lRainbow.winHeight - 1 end

      local descaleX, descaleY = (lRainbowBmp.width / lRainbow.winWidth), (lRainbowBmp.height / lRainbow.winHeight)
      local dX, dY = X * descaleX, Y * descaleY

      local rgb = mGfx.ReadRGBPixel(lRainbowBmp, descaleX * X, descaleY * Y)

      if (not lPicker) then lPicker = { x=dX, y=dY } end

      local left, top, right, bottom = lPicker.x - 4, lPicker.y - 4, lPicker.x + 4, lPicker.y + 4

      if (dX < lPicker.x) then
         left = dX - 4
      else
         right = dX + 4
      end

      if (dY < lPicker.y) then
         top = dY - 4
      else
         bottom = dY + 4
      end

      lPicker = { x=dX, y=dY }

      arrangeLayout() -- Will set the picker to the correct location

      lWindow.surface.acDraw(lRainbow.winX + left, lRainbow.winY + top, right - left, bottom - top)

      updateRGB({ r=rgb.red, g=rgb.green, b=rgb.blue })
   end

   local function inputFeedback(SurfaceID, Msg)
      if (Msg.type == JET_BUTTON_1) then
         if (Msg.value > 0) then -- Button down
            if (Msg.x >= lRainbow.winX) and
               (Msg.y >= lRainbow.winY) and
               (Msg.x < lRainbow.winX + lRainbow.winWidth) and
               (Msg.y < lRainbow.winY + lRainbow.winHeight) then
               selectPalette(Msg.x - lRainbow.winX, Msg.y - lRainbow.winY)
               lRainbowClick = true
            end
            lAbsX = Msg.absX
            lAbsY = Msg.absY
         else -- Button released
            lRainbowClick = false

            if (math.abs(Msg.absX - lAbsX) <= 2) and (math.abs(Msg.absY - lAbsY) <= 2) then
               for _, link in ipairs(lLinks) do
                  if (Msg.x >= link.x) and (Msg.x < link.x + link.width) and
                     (Msg.y >= link.y) and (Msg.y < link.y + link.height) then
                     link.routine(link)
                     break
                  end
               end
            end
         end
      elseif (Msg.type == JET_ABS_X) or (Msg.type == JET_ABS_Y) then
         if (lRainbowClick) then selectPalette(Msg.x - lRainbow.winX, Msg.y - lRainbow.winY) end
      end
   end

   local function loadColours()
      catch(function()
         local js = file.readAll('user:config/colours.json')
         if nz(js) then
            lCustom = json.decode(js)
         end
      end)
   end

   local function saveColours()
      if (not lPaletteChanged) then return end

      catch(function()
         local output = json.encode(lCustom)
         if nz(output) then
            local saveFile = obj.new('file', { path='user:config/colours.json', flags='!NEW|WRITE' })
            saveFile.acWrite(output)
         end
      end,
      function(Exception)
         msg('Failed to save custom colour table: ' .. Exception.message)
      end)
   end

   local function createRainbowBitmap()
      local size = ((BTNSIZE + BTNGAP) * 7) - BTNGAP
      lRainbowBmp = obj.new('bitmap', { width=size, height=size, bitsPerPixel=32 })

      local val = lRainbowBmp.height / 2
      for y=0, (lRainbowBmp.height / 2) - 1 do
         local s = 1 - (val / (lRainbowBmp.height / 2))
         local v = 1
         for x=0, lRainbowBmp.width-1 do
            local h = x * 6 / lRainbowBmp.width
            local i = math.floor(h)
            local f = h - i
            if bit.band(i, 1) == 0 then
               f = 1 - f
            end
            local m = v * (1 - s)
            local n = v * (1 - s * f)

            local err, rgb
            if (i == 1) then err, rgb = lRainbowBmp.mtGetColour(n * 255, v * 255, m * 255, 255)
            elseif (i == 2) then err, rgb = lRainbowBmp.mtGetColour(m * 255, v * 255, n * 255, 255)
            elseif (i == 3) then err, rgb = lRainbowBmp.mtGetColour(m * 255, n * 255, v * 255, 255)
            elseif (i == 4) then err, rgb = lRainbowBmp.mtGetColour(n * 255, m * 255, v * 255, 255)
            elseif (i == 5) then err, rgb = lRainbowBmp.mtGetColour(v * 255, m * 255, n * 255, 255)
            else err, rgb = lRainbowBmp.mtGetColour(v * 255, n * 255, m * 255, 255)
            end

            mGfx.DrawPixel(lRainbowBmp, x, y, rgb)
         end
         val = val - 1
      end

      local val = lRainbowBmp.height / 2
      for y=lRainbowBmp.height/2, lRainbowBmp.height-1 do
         local s = val / (lRainbowBmp.height / 2)
         local v = val / (lRainbowBmp.height / 2)
         for x=0, lRainbowBmp.width-1 do
            local h = x * 6.0 / lRainbowBmp.width
            local i = math.floor(h)
            local f = h - i
            if bit.band(i, 1) == 0 then
               f = 1 - f
            end
            local m = v * (1 - s)
            local n = v * (1 - s * f)

            local err, rgb
            if (i == 1) then err, rgb = lRainbowBmp.mtGetColour(n * 255, v * 255, m * 255, 255)
            elseif (i == 2) then err, rgb = lRainbowBmp.mtGetColour(m * 255, v * 255, n * 255, 255)
            elseif (i == 3) then err, rgb = lRainbowBmp.mtGetColour(m * 255, n * 255, v * 255, 255)
            elseif (i == 4) then err, rgb = lRainbowBmp.mtGetColour(n * 255, m * 255, v * 255, 255)
            elseif (i == 5) then err, rgb = lRainbowBmp.mtGetColour(v * 255, m * 255, n * 255, 255)
            else err, rgb = lRainbowBmp.mtGetColour(v * 255, n * 255, m * 255, 255)
            end

            mGfx.DrawPixel(lRainbowBmp, x, y, rgb)
         end
         val = val - 1
      end
   end

   catch(function()
      lFont = obj.new('font', { face='Open Sans:10' })

      lCustom = { }

      if (Options.theme == 'dark') then
         lThemeColour = { first={ r=250,g=249,b=248 }, last={ r=210,g=211,b=212 } }
      else
         lThemeColour = { first={ r=90,g=90,b=90 }, last={ r=70,g=70,b=110 } }
      end

      loadColours()
      createRainbowBitmap()

      lWindow = obj.new('window', {
         insideWidth  = 600,
         insideHeight = 400,
         minWidth     = 200,
         minHeight    = 50,
         quit         = false,
         center       = true,
         stickToFront = true,
         aspectRatio  = true,
         popover      = lOptions.popover,
         parent       = lOptions.target,
         icon         = 'tools/palette',
         title        = nz(lOptions.title, 'Select a colour'),
         modal        = nz(lOptions.modal, false)
      })

      lWindow.subscribe('close', function(WindowID, Args, Reference)
         saveColours()
         if (lOptions.feedback != nil) then
            lOptions.feedback(nil)
         end
         lWindow = nil
      end)

      self.windowID = lWindow.id

      -- Initialise the layout that will contain the vector graphics

      self.layout = obj.new('layout')
      self.layout.surface = lWindow.surface
      self.layout.topMargin    = 4
      self.layout.bottomMargin = 4
      self.layout.rightMargin  = 4
      self.layout.leftMargin   = 4

      self.layout.subscribe('free', function()
         self.layout = nil
      end)

      self.layout.resizeCallback = function(Owner)
         arrangeLayout()
      end

      if self.layout.acInit() != ERR_Okay then error('Failed to initialise surface.') end

      lTab = lWindow.new('tabfocus', { })

      input.subscribe(bit.bor(JTYPE_MOVEMENT, JTYPE_BUTTON), lWindow.surface, 0, inputFeedback)

      self.scene = obj.new('VectorScene', { surface = lWindow.surface })

      self.viewport = self.scene.new('VectorViewport', { })

      self.scene.mtAddDef('Rainbow', self.scene.new('VectorImage', { bitmap = lRainbowBmp }))

      self.viewport.viewWidth, self.viewport.viewHeight = buildLayout()

      -- Manage the aspect ratio.  The current width will determine the height
      scale = self.viewport.viewHeight / self.viewport.viewWidth
      lWindow.insideHeight = lWindow.insideWidth * scale
      lWindow.minWidth     = lWindow.insideWidth * 0.25
      lWindow.minHeight    = lWindow.insideHeight * 0.25

      self.inputRGB.subscribe('activate', function(Input)
         updateRGB(gui.strToRGB(Input.string))
      end)

      updateRGB(gui.strToRGB(nz(lOptions.colour, '200,200,200')))

      lTab.mtAddObject(lOkayButton)
      lTab.mtAddObject(lCancelButton)

      lWindow.acMoveToFront()
      lWindow.acShow()

      arrangeLayout()
   end,
   function(Exception)
      error('Failed to initialise colour dialog: ' .. Exception.message)
   end)

   return self
end

--=====================================================================================================================

   -- This sub-routine is provided for languages other than Fluid to utilise the module.

   do
      local state = getExecutionState()
      if (state.inRequire != true) then
         local dlg = colour.dialog({
            popover    = arg('popover'),
            target     = arg('target'),
            modal      = arg('modal'),
            okText     = arg('okText'),
            cancelText = arg('cancelText'),
            icon       = arg('icon')
         })

         return dlg.windowID
      end
   end
