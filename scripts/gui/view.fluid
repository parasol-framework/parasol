--[[

The View class is used to display data to the user in the form of tree structures, lists or groups.

Items are created and stored as structured tables.

Here is an example of a list of valid item structures.  Each attribute can potentially be a column in the display when
using column mode.

   { { id=1, group='file', path='parasol:system/', name='document.txt', size=1232, dateCreated='2018-08-02T17:14' },
     { id=2, group='folder', path='parasol:system/', name='config', icon='category/name' }
   }

To build tree structures, arrange the items as seen in this example:

  { { id='1', group='folder',
      { id='1.1', group='folder',
        { id=1.1.1', group='file' },
        { ... }
      }
    },
    { ... }
  }

Initialisation options:

   columns:        Active columns for 'column mode' may be set via this field.
   contextMenu:    Reference to a menu that will be displayed for contextual actions.
   dateFormat:     Sets the format to use when displaying date types.
   document:       If document mode is enabled, this field must refer to a Document object for data processing and display.
   focus:          References the surface that must be used for user focus monitoring.
   maxItemWidth:   Limits item width when using the 'list' or 'longList' style.
   multiSelect:    If true, more than one item can be selected at a time by the user.
   sensitive:      If true, activation will occur whenever a new item is selected (double click no longer necessary).
   style:          Preset the view style (refer to view styles in this document)
   target:         The surface or vector viewport that will host the view.
   textAttrib:     Declares the attribute to use as the main text when drawing the item.  Defaults to 'text'.

Callbacks:

   itemSelected:     An item has been selected by the user.
   itemActivated:    An item has been activated by the user, e.g. by double clicking or pressing enter.
   itemDeselected:   An item has been deselected by the user.
   activeChange:     The active item has changed (includes reporting of deselection events)
   branchExpanded:   TODO - A callback for receiving notifications when tree branches are expanded.
   cellClick:        TODO - A callback for receiving notifications of clicks in column cells.

Readable fields:

   highlightTag:   Refers to the current item that the user has highlighted.
   selectedItem:   TODO - Refers to the most recently selected item.

Methods:

   loadItems()     Load a new set of items and display them for the user.  Any existing items will be cleared.
   selectedItems() TODO - Returns a table of all currently selected items.

Graphics and UI options:

   noIcons:       Do not display icons alongside the item text.
   dragDrop:      Enable support for drag and drop.
   autoDeselect:  Deselects a highlighted item when it is activated by user clicking or the enter key.

View styles:

   Column:     A vertical list of items accompanied with attributes arranged into columns.  A column control banner with named headers is provided for the user.
   ColumnTree: Not implemented
   Document:   Not implemented
   GroupTree:  Not implemented
   List:       Not implemented
   Icon:       Not implemented
   LongList:   A vertical list of items.
   Tree:       Not implemented

--]]

   require 'common'
   require 'gui'
   require 'gui/scrollbar'

   if (mFont == nil) then mFont = mod.load('font') end
   if (mGfx == nil) then mGfx = mod.load('display') end
   if (mVector == nil) then mVector = mod.load('vector') end
   if (mWidget == nil) then mWidget = mod.load('widget') end

gui.view = function(Options)
   local self = { -- Resources that require tracking
      icons = { },
      zones = { },
      items = { },
      viewport = nil
   }

   local rebuild, cursorActivity -- Forward declared functions
   local lScene, lViewport, lPage, lView
   local lActiveTag, lHighlightedItem, lSelectedItem
   local lThemeColour, lActiveZone, lItemFont, lPageFeedback
   local lDate         = struct.new('DateTime')
   local lColumns      = { }
   local lLookupCol    = { } -- Lookup columns by integer ID
   local lNamedCol     = { } -- Lookup columns by attribute name
   local lLookup       = { } -- Lookup items by ID
   local lOrder        = { } -- Item references
   local lTextAttrib   = nz(Options.textAttrib, 'text')
   local lIconSize     = 16
   local lRowEnd       = 0
   local lRowIndex     = 0
   local lVSpacing     = nz(Options.vSpacing, 2)
   local lImageCache   = { } -- Replaces 'glCache' for storing images
   local lColumnHeight = 12 + 6
   local lStyle        = nz(Options.style, 'LONGLIST'):upper()
   local lGroupFace    = 'open sans:12:bold'
   local lItemCounter  = 1
   local lCounter      = 1
   local lEdgeMargin   = 4
   local lDisabled     = false
   local lLineHeight   = gui.getFontHeight(gui.fonts.default) * 1.3
   local MARGIN        = math.round(lLineHeight * 0.3)

   local lColBackground     = { r=255, g=255, b=255,  a=255 }
   local lColBkgdHighlight  = { r=0,   g=0,   b=0,    a=10 }
   local lColSelect         = { r=0,   g=0,   b=60,   a=140 }
   local lFillTitleFont     = 'rgb(0,0,0)'
   local lFillTitleSortFont = 'rgb(0,0,0)'
   local lColHighlight      = { r=0,   g=0,   b=0,    a=0 }
   local lColSelectFont     = { r=255, g=255, b=255,  a=255 }
   local lColItem           = { r=0,   g=0,   b=0,    a=255 }
   local lColItemSelectHigh = { r=255, g=255, b=255,  a=255 }
   local lColBorder         = { r=160, g=160, b=160,  a=255 }
   local lButtonHighlight   = { r=0xf0, g=0xf0, b=0xf0, a=255 }
   local lButtonShadow      = { r=0xd0, g=0xd0, b=0xd0, a=255 }
   local lButtonBackground  = { r=0xf0, g=0xf0, b=0xf0, a=255 }

   local lFillItem, lFillItemSelectHigh, lFillBkgdSelectHighlight, lFillSelect, lFillBkgdHighlight, lFillHighlight
   local lStrokeButton, lFillSelectFont

   local function counter()
      lCounter = lCounter + 1
      return lCounter
   end

   local function loadItems(Items)
      if not Items then error('No Items provided') end

      msg('Processing ' .. #Items .. ' items')

      if self.items then -- Clear existing items
         for _, item in pairs(self.items) do
            if item then
               item:_free()
            end
         end
      end

      self.items = { }
      lLookup = { }
      for _, item in pairs(Items) do
         local new_item = {
            _id = lItemCounter,
            _x = 0, _y = 0, _width = 0, _height = 0,
            _free = function(Item)
               if Item._vectors and Item._vectors.viewport then
                  -- Presume that freeing the root viewport removes all vectors.
                  Item._vectors.viewport.acFree()
               end
            end
         }

         for k, v in pairs(item) do -- Copy all item key-values supplied by the user
            new_item[k] = v
         end

         table.insert(self.items, new_item)
         lLookup[lItemCounter] = new_item
         lItemCounter = lItemCounter + 1
      end
   end

   -- Reasons for a reported change:
   --
   --   clear:     All items in the view were removed.
   --   inverted:  Item automatically deselected due to an invert operation.
   --   moved:     The item has been deselected due to moving position.
   --   user:      Selected by user interaction (click or keypress)
   --   manual:    Item was manually selected (by the application, not the user).

   local function reportItemSelected(Reason, Item)
      if Options.itemSelected then
         Options.itemSelected(self, Reason, Item)
      end
   end

   local function reportItemDeselected(Reason, Item)
      if Options.itemSelected then
         Options.itemDeselected(self, Reason, Item)
      end
   end

   local function reportItemActivated(Reason, Item)
      if Item.activity then Item.activity(Item) end
      if Options.itemActivated then Options.itemActivated(self, Reason, Item) end
   end

   local function reportActiveChange(Reason, Item)
      if Options.activeChange then
         Options.activeChange(self, Reason, Item)
      end
   end

   local function getCursorItem(X, Y)
      for _, item in pairs(self.items) do
         if item._x then
            if (X >= item._x) and (X < item._x + item._width) and (Y >= item._y) and (Y < item._y + item._height) then
               return item
            end
         end
      end
   end

   local function checkCursorImage()
      if self.pointerLocked and not lActiveZone then
         mGfx.restoreCursor(PTR_DEFAULT, lScene.surface)
         self.pointerLocked = nil
      end
   end

   local function highlightItem(Item)  -- Simplifies the process of highlighting an item.  Item can be nil for deselection.
      if (Item == lHighlightedItem) then return end
      if lHighlightedItem and lHighlightedItem._highlightEvent and (Item != lHighlightedItem) then
         lHighlightedItem._highlightEvent(lHighlightedItem, false)
      end

      lHighlightedItem = Item

      if Item and Item._highlightEvent then
         Item._highlightEvent(Item, true)
      end
   end

   -- Simplifies the process of selecting an item.  For deselection use deselectItem()

   local function selectItem(Item)
      if (Item == lSelectedItem) then return end

      lSelectedItem = Item

      if (Item) then
         Item._selected = true
         if (Item._selectEvent) then
            Item._selectEvent(Item)
         end
      end
   end

   local function deselectItem(Item)
      if (lSelectedItem == Item) then lSelectedItem = nil end

      if (Item) then
         Item._selected = false
         if (Item._selectEvent) then
            Item._selectEvent(Item)
         end
      else -- Deselect everything
         for _, i in ipairs(self.items) do
            if (i._selected) then
               i._selected = false
               if (i._selectEvent) then
                  i._selectEvent(i)
               end
            end
         end
      end
   end

   -- Generic callback for the user hovering and interacting with listed items

   local function itemHoverCallback(Zone, CursorX, CursorY)
      highlightItem(Zone.item)

      self.hoveredItem = {
         click = function(Input)
            if Input.value == 0 and bit.band(Input.flags, JTYPE_DBL_CLICK) != 0 then
               reportItemActivated('user', Zone.item)
            end
         end
      }
   end

   local function loadIcon(Name)
      local icon = { }
      if not self.icons[Name] then
         local err
         err, icon.bmp = mWidget.createIcon(Name, nil, nil, nil, lIconSize)
         icon.img = lScene.new('VectorImage', { bitmap = icon.bmp })
         lScene.mtAddDef(Name, icon.img)
         self.icons[Name] = icon
      end
      return self.icons[Name]
   end

   local function initListStyle()
      lFillItem           = gui.rgbToSVG(lColItem)
      lFillItemSelectHigh = gui.rgbToSVG(lColItemSelectHigh)
      lFillSelect         = gui.rgbToSVG(lColSelect)
      lFillSelectFont     = gui.rgbToSVG(lColSelectFont)
      lFillHighlight      = gui.rgbToSVG(lColHighlight)
      lFillBkgdHighlight  = gui.rgbToSVG(lColBkgdHighlight)
      lFillBkgdSelectHighlight = gui.rgbToSVG(gui.interpolateRGB(lColBkgdHighlight, lColSelect))
   end

   local function initColumnStyle()
      initListStyle()
      lStrokeButton = gui.rgbToSVG(lColBorder)

      for _, col in pairs(lColumns) do
         if not col.vecGradient then
            local defName = 'colGradient' .. counter()
            local selName = 'colSelect' .. counter()

            if nz(col.align, 'left') == 'right' then
               col.vecGradient = gui.simpleGradient(lScene, defName,
                  { {r=0,g=0,b=0,a=0,offset=0.1 }, {r=0,g=0,b=0,a=255,offset=0.2}, {r=0,g=0,b=0,a=255,offset=1.0} },
                  0, 0, col.width, 0, 'userspace')

               col.vecGradientSelect = gui.simpleGradient(lScene, selName,
                  { {r=255,g=255,b=255,a=0,offset=0.1 }, {r=255,g=255,b=255,a=255,offset=0.2}, {r=255,g=255,b=255,a=255,offset=1.0} },
                  0, 0, col.width, 0, 'userspace')
            else
               col.vecGradient = gui.simpleGradient(lScene, defName,
                  { {r=0,g=0,b=0,a=255,offset=0 }, {r=0,g=0,b=0,a=255,offset=0.9}, {r=0,g=0,b=0,a=0,offset=0.98} },
                  0, 0, col.width, 0, 'userspace')

               col.vecGradientSelect = gui.simpleGradient(lScene, selName,
                  { {r=255,g=255,b=255,a=255,offset=0 }, {r=255,g=255,b=255,a=255,offset=0.9}, {r=255,g=255,b=255,a=0,offset=0.98} },
                  0, 0, col.width, 0, 'userspace')
            end

            col.fillItem = 'url(#' .. defName .. ')'
            col.fillItemSelect = 'url(#' .. selName .. ')'
         else
            col.vecGradient.x2 = col.width
         end
      end
   end

   local function columnText(Value, Type)
      if type(Value) == 'table' then
         Value = Value.value
      end

      if Type == 'bytesize' then
         Value = tonumber(Value)
         if not Value then
            return ''
         elseif Value < 1024 then
            return string.format('%.0f', Value)
         elseif Value < 1024 * 1024 then
            return string.format('%.0f KB', Value / 1024)
         elseif Value < 1024 * 1024 * 1024 then
            Value = Value / (1024 * 1024)
            if Value >= 10 then
               return string.format('%.0f MB', Value)
            else
               return string.format('%.1f MB', Value)
            end
         elseif Value < 1024 * 1024 * 1024 * 1024 then
            return string.format('%.1f GB', Value / (1024 * 1024 * 1024))
         else
            return string.format('%.1f TB', Value / (1024 * 1024 * 1024 * 1024))
         end
      elseif Type == 'date' then
         local err = mSys.StrReadDate(Value, lDate)
         if err == ERR_Okay then
            return string.format('%4d-%02d-%02d %02d:%02d', lDate.year, lDate.month, lDate.day, lDate.hour, lDate.minute)
         end
      elseif Type == 'numeric' then
         return string.format('%d', nz(tonumber(Value), 0))
      elseif Type == 'seconds' then
         Value = nz(tonumber(Value), 0)
         local min = Value / 60
         local sec = Value % 60
         return string.format('%d:%.2d', min, sec)
      elseif Type == 'float' then
         return string.format('%.3f', nz(tonumber(Value), 0))
      end

      return Value
   end

   local function setListTextFill(Item, Fill)
      if Item._vectors.text then
         Item._vectors.text.fill = Fill
      end
   end

   -- When an item is hovered, create a highlight for it.  ColBkgdHighlight defines the background colour to use
   -- when an item is highlighted.  If an item is also marked as selected, then the final colour is interpolated
   -- with ColSelect.

   local function highlightItemGeneric(Item, Highlighted)
      if not Item._vectors.highlight then
         Item._vectors.highlight = Item._vectors.viewport.new('VectorRectangle', {
            roundX = 4, roundY = 4, width = '100%', height = '100%', visibility = VIS_HIDDEN
         })
         Item._vectors.highlight.acMoveToBack()
      end

      if (Highlighted) then
         if Item._selected then -- Both selected AND highlighted
            Item._vectors.highlight.fill = lFillBkgdSelectHighlight
            setListTextFill(Item, lFillItemSelectHigh)
         else
            Item._vectors.highlight.fill = lFillBkgdHighlight
            setListTextFill(Item, lFillItem)
         end

         Item._vectors.highlight.visibility = VIS_VISIBLE
      elseif (Item._selected) then
         setListTextFill(Item, lFillItemSelectHigh)
         Item._vectors.highlight.fill = lFillSelect
         Item._vectors.highlight.visibility = VIS_VISIBLE
      else
         setListTextFill(Item, lFillItem)
         Item._vectors.highlight.visibility = VIS_HIDDEN
      end
      lScene.surface.mtScheduleRedraw()
   end

   local function cvItemHighlight(Item, Highlighted)
      if not Item._vectors.highlight and (Highlighted or Item._selected) then
         Item._vectors.highlight = Item._vectors.viewport.new('VectorRectangle', {
            roundX = 4, roundY = 4, x = 0, y = 0, width = '100%', height = '100%'
         })
         Item._vectors.highlight.acMoveToBack()
      end

      if (Highlighted) then
         if Item._selected then -- Both selected AND highlighted
            for k, col in pairs(Item._col) do
               if col.text then col.text.fill = lNamedCol[k].fillItemSelect end
            end
            Item._vectors.highlight.fill = lFillBkgdSelectHighlight
         else
            for k, col in pairs(Item._col) do
               if col.text then col.text.fill = lNamedCol[k].fillItem end
            end
            Item._vectors.highlight.fill = lFillBkgdHighlight
         end
      elseif (Item._selected) then
         for k, col in pairs(Item._col) do
            if col.text then col.text.fill = lNamedCol[k].fillItemSelect end
         end

         Item._vectors.highlight.fill = lFillSelect
      else
         if Item.fill then
            for k, col in pairs(Item._col) do
               if col.text then col.text.fill = Item.fill end
            end
         else
            for k, col in pairs(Item._col) do
               if col.text then col.text.fill = lNamedCol[k].fillItem end
            end
         end

         if Item._vectors.highlight then
            Item._vectors.highlight.acFree()
            Item._vectors.highlight = nil
         end
      end
      lScene.surface.mtScheduleRedraw()
   end

   local function arrangeColumns()
      self.banner.lines.acClear()

      local pc = struct.new('PathCommand')
      for _, col in pairs(lColumns) do
         if (col.align == 'right') then
            col.vecTitle.x = col.width - MARGIN
         else
            col.vecTitle.x = MARGIN
         end

         pc.type = PE_Move
         pc.x = col.x + col.width
         pc.y = 0
         self.banner.lines.mtAddCommand(pc)

         pc.type = PE_Line
         pc.x = col.x + col.width
         pc.y = self.bannerHeight
         self.banner.lines.mtAddCommand(pc)

         col.bannerVP.x = col.x
         col.bannerVP.width = col.width

         if col.vecGradient then
            col.vecGradient.x2 = col.width
            col.vecGradientSelect.x2 = col.width
         end
      end

      if self.currentSort then
         local col = self.currentSort.col
         if col.align == 'right' then
            self.currentSort.icon.x = MARGIN
         else
            self.currentSort.icon.x = col.width - MARGIN - lIconSize
         end
      end
   end

   local function constructColumnBanner()
      -- The banner is placed outside of the view so that it cannot be scrolled vertically.

      self.bannerHeight = lLineHeight * 1.3
      lView.y = self.bannerHeight

      if not self.banner then self.banner = { } end

      -- Background graphics

      if not self.banner.viewport then
         self.banner.viewport = lViewport.new('VectorViewport', {
            x = 0, y = 0,
            width = '100%', height = self.bannerHeight
         })

         self.banner.bkgd = self.banner.viewport.new('VectorRectangle', {
            fill   = gui.rgbToSVG(lButtonBackground),
            stroke = lStrokeButton,
            strokeWidth = 2,
            x      = 0,
            y      = 0,
            width  = '100%',
            height = '100%'
         })

         self.banner.lines = self.banner.viewport.new('VectorPath', {
            stroke = lStrokeButton,
            strokeWidth = 1
         })

         self.banner.viewport.mtSubscribeInput(bit.bor(JTYPE_MOVEMENT, JTYPE_BUTTON), function(Viewport, Events)
            local ev = Events
            while (ev) do
               if (ev.type == JET_BUTTON_1) then
                  if (bit.band(ev.flags, JTYPE_REPEATED) != 0) then
                     return
                  end

                  for _, zone in pairs(self.bannerZones) do
                     if ev.x >= zone.x and ev.x < zone.x + zone.width then
                        zone.click(zone, ev.x, ev.y, ev.value)
                        break
                     end
                  end
               end
               ev = ev.next
            end
         end)
      end

      -- Draw column text and separators

      local x = 0
      local prev = nil
      for _, col in pairs(lColumns) do
         if prev then
            prev.next = col
            col.prev = prev
         end

         col.x = x
         col.minWidth = x + MARGIN

         if not col.bannerVP then
            -- Each banner viewport hosts the title and sorting icon
            col.bannerVP = self.banner.viewport.new('VectorViewport', {
               x = x, y = 0, width = col.width, height = '100%', overflow = VOF_HIDDEN
            })

            col.vecViewport = lPage.new('VectorViewport', {  -- The column VP hosts all page text for the column
               x = x, y = 0, width = col.width, height = '100%', overflow = VOF_HIDDEN
            })

            -- Column title

            col.vecTitle = col.bannerVP.new('VectorText', {
               face     = gui.fonts.widget.face,
               fontSize = string.format('%.2fpt', gui.fonts.widget.size),
               align    = nz(col.align, 'left'),
               y        = lLineHeight
            })

            -- Support for resize management

            col.resizeVP = self.banner.viewport.new('VectorViewport', {
               x = x + col.width - (MARGIN * 0.5), y = 0,
               width = MARGIN, height = '100%', cursor = PTR_SPLIT_HORIZONTAL
            })

            col.resizeVP.dragCallback = function(SizeVP, X, Y)
               -- Rearrange layout
               local delta_x = X - SizeVP.x
               col.width = col.width + delta_x
               if (col.width < MARGIN) then col.width = MARGIN end
               col.vecViewport.width = col.width

               local scan = col.next
               local new_x = col.x + col.width
               while scan do
                  scan.x = new_x
                  scan.resizeVP.x = new_x + scan.width - (MARGIN * 0.5)
                  scan.vecViewport.x = new_x
                  new_x = new_x + scan.width
                  scan = scan.next
               end

               arrangeColumns()

               if self.scrollbar then
                  local page_width = new_x + lEdgeMargin + lEdgeMargin
                  self.scrollbar.setDynamicPageSize(page_width, page_width, lPage.height)
               end

               if (col.align == 'right') then -- Realign all text in this column
                  local align_x = col.width - MARGIN
                  for _, item in pairs(self.items) do
                     if item._col and item._col[col.attrib].text then
                        item._col[col.attrib].text.x = align_x
                     end
                  end
               end

               SizeVP.x = col.x + col.width - (MARGIN * 0.5)
               SizeVP.acDraw()
            end
         else
            col.bannerVP.x = x
            col.bannerVP.width = col.width

            col.vecViewport.x = x
            col.vecViewport.width = col.width
         end

         col.vecTitle.string = nz(col['title'], 'Untitled')
         if self.currentSort and (col == self.currentSort.col) then
            col.vecTitle.fill = lFillTitleSortFont
         else
            col.vecTitle.fill = lFillTitleFont
         end

         -- Create a zone for sorting the column when clicked

         table.insert(self.bannerZones, {
            x      = x + 2,
            y      = 0,
            width  = col.width - 4,
            height = self.bannerHeight,
            col    = col,
            click = function(Zone, X, Y, Value)
               if Value == 1 then return end

               if self.currentSort and self.currentSort.icon then
                  self.currentSort.icon.acFree()
                  self.currentSort.icon = nil
               end

               if self.currentSort and (self.currentSort.col == col) and (self.currentSort.ascending == true) then
                  self.currentSort = { col=col, ascending=false }
                  if not self.iconDescending then
                     loadIcon('layout/sort_alpha_desc')
                     self.currentSort.icon = col.bannerVP.new('VectorRectangle', {
                        fill   = 'url(#layout/sort_alpha_desc)',
                        y      = math.round(lEdgeMargin + ((lLineHeight - lIconSize) * 0.5)),
                        width  = lIconSize,
                        height = lIconSize
                     })
                  end
               else
                  self.currentSort = { col=col, ascending=true }
                  if not self.iconAscending then
                     loadIcon('layout/sort_alpha_asc')
                     self.currentSort.icon = col.bannerVP.new('VectorRectangle', {
                        fill   = 'url(#layout/sort_alpha_asc)',
                        y      = math.round(lEdgeMargin + ((lLineHeight - lIconSize) * 0.5)),
                        width  = lIconSize,
                        height = lIconSize
                     })
                  end
               end

               if col.align == 'right' then
                  self.currentSort.icon.x = MARGIN
               else
                  self.currentSort.icon.x = col.width - MARGIN - lIconSize
               end

               self.sortColumn(col, self.currentSort.ascending)
            end
         })

         x = x + col.width
         prev = col
      end

      arrangeColumns()

      -- Ensure that the column banner is always aligned with the page.

      lPageFeedback = function()
         self.banner.viewport.x     = lPage.x
         self.banner.viewport.width = lPage.width
      end
   end

   -- Generate graphics for items in a columnar view.  This function is called recursively if the style
   -- is a ColumnTree with open branches.

   local function constructColumnView(Items)
      local width  = lViewport.width - lEdgeMargin - lEdgeMargin
      local height = lViewport.height
      local x      = lEdgeMargin
      local y      = 0

      local index = 0
      for _, item in pairs(self.items) do
         index = index + 1

         if not item._vectors then item._vectors = { } end
         if not item._col then item._col = { } end

         item._x = x
         item._y = y
         item._width  = width
         item._height = lLineHeight
         if not item.lineOffset then
            item._lineOffset = lLineHeight - ((lLineHeight - gui.getFontHeight(gui.fonts.widget)) * 0.5)
         end

         -- Each item gets a viewport within the page

         if not item._vectors.viewport then
            item._vectors.viewport = lPage.new('VectorViewport', {
               x = x, y = y + lEdgeMargin, xOffset = lEdgeMargin, height = lLineHeight
            })
         else
            item._vectors.viewport.x      = x
            item._vectors.viewport.y      = y + lEdgeMargin
            item._vectors.viewport.width  = width
            item._vectors.viewport.height = lLineHeight
         end

         item._highlightEvent = cvItemHighlight

         -- Respond to positive item selection by the user (e.g. button click)

         item._selectEvent = function(Item)
            if (Item == lHighlightedItem) then
               Item._highlightEvent(Item, true)
            else
               Item._highlightEvent(Item, false)
            end
         end

         local cx = 0
         for _, col in pairs(lColumns) do
            local iconMargin = 0
            local attrib = col.attrib

            if not item._col[attrib] then item._col[attrib] = { } end

            if col.showIcons and item.icon then
               catch(function()
                  local icon = { }

                  if not self.icons[item.icon] then
                     local err
                     err, icon.bmp = mWidget.createIcon(item.icon, nil, nil, nil, lIconSize)
                     icon.img = lScene.new('VectorImage', { bitmap = icon.bmp })
                     lScene.mtAddDef(item.icon, icon.img)
                     self.icons[item.icon] = icon
                  end

                  if not item._vectors.iconImage then
                     item._vectors.iconImage = col.vecViewport.new('VectorRectangle', {
                        fill   = 'url(#' .. item.icon .. ')',
                        x      = x + MARGIN,
                        y      = lEdgeMargin + y + ((lLineHeight - lIconSize) * 0.5),
                        width  = lIconSize,
                        height = lIconSize
                     })
                  else
                     item._vectors.iconImage.x = x + MARGIN
                     item._vectors.iconImage.y = lEdgeMargin + y + ((lLineHeight - lIconSize) * 0.5)
                  end
               end,
               function(Exception)
                  msg('Failed to process icon ' .. item.icon .. ', error ' .. Exception.message)
               end)
               iconMargin = MARGIN + lIconSize + MARGIN
            end

            if nz(item[attrib]) then
               if not item._col[attrib].text then
                  item._col[attrib].text = col.vecViewport.new('VectorText', {
                     face     = gui.fonts.widget.face,
                     fontSize = string.format('%.2fpt', gui.fonts.widget.size),
                     align    = nz(col.align, 'left')
                  })
                  item._vectors['_a_' .. attrib] = item._col[attrib].text -- Referenced for future termination
               end

               if col.align == 'right' then
                  item._col[attrib].text.x = col.width - MARGIN
               else
                  item._col[attrib].text.x = x + iconMargin
               end
               item._col[attrib].text.y = y + item._lineOffset
               item._col[attrib].text.string = columnText(item[attrib], col.type)

               item._highlightEvent(item, false)
            end

            -- Item click and hover management

            table.insert(self.zones, {
               x      = 0,
               y      = item._y,
               width  = 1000000,
               height = item._height,
               item   = item,
               hoverCallback = itemHoverCallback
            })

            cx = cx + col.width
         end

         y = y + lLineHeight + lVSpacing
      end

      local page_width = 0
      for _, col in pairs(lColumns) do
         col.vecViewport.acMoveToFront()
         page_width = col.x + col.width + lEdgeMargin
      end

      if self.scrollbar then
         self.scrollbar.setDynamicPageSize(page_width, page_width, y + lEdgeMargin)
      end
   end

   -- In group-tree mode, all the items at the root of the tree get their own title-bar and their children are displayed as trees.
--[[
   local function initVectorGroupTree()
      local iconbmp
      local ny, ix, ey
      local alt

      if lColBackground.a > 0 then
         gfxDrawRectangle(ax, ay, awidth, aheight, PackPixelRGBA(Bitmap, &lColBackground), BAF_BLEND|BAF_FILL)
      end

      if #self.items < 1 then return end

      --if (!(expand = get_expand_bitmap())) goto exit
      --if (!(collapse = get_collapse_bitmap())) goto exit

      local ny = ay
      local ey = ay
      local alt = 0
      for _, tag in pairs(self.items) do
         ny = ay + tag.Y
         ey = tag.Y + tag.Height

         if tag._open then
            drawTree(Surface, Bitmap, tag.child, &ey)
            if tag._open and lGroupShadow then
               drawShadow(Bitmap, ny+tag.Height)
            end
         end

         local groupbmp
         if lAltGroup then -- Group graphic - button style background
            alt = not alt
            if alt then
               groupbmp = lGroupBitmap
            else
               groupbmp = lSelectBitmap
            end
         else
            if tag._open then
                groupbmp = lSelectBitmap ? lSelectBitmap : lGroupBitmap
            else
               groupbmp = lGroupBitmap ? lGroupBitmap : lSelectBitmap
            end
         end

         if groupbmp then -- Tiled background
            for ix=ax, ix < ax+awidth, ix += groupbmp.Width do
               gfxCopyArea(groupbmp, Bitmap, 0, 0, 0, groupbmp.Width, tag.Height, ix, ny)
            end
         elseif tag._open then
            gfxDrawRectangle(ax, ny, awidth, tag.Height, PackPixel(Bitmap,180,180,200), BAF_FILL)
            gfxDrawRectangle(ax, ny, awidth, 1, PackPixel(Bitmap,200,200,220), BAF_FILL)
            gfxDrawRectangle(ax, ny+tag.Height-1, awidth, 1, PackPixel(Bitmap,120,120,140), BAF_FILL)
         else
            gfxDrawRectangle(ax, ny, awidth, tag.Height, PackPixel(Bitmap,160,160,180), BAF_FILL)
            gfxDrawRectangle(ax, ny, awidth, 1, PackPixel(Bitmap,180,180,200), BAF_FILL)
            gfxDrawRectangle(ax, ny+tag.Height-1, awidth, 1, PackPixel(Bitmap,140,140,150), BAF_FILL)
         end

         -- Draw group icon and title

         ix = ax + 3
         if tag.icon then

            if (tag._open or tag._selected) and tag._iconOpen then
               iconbmp = tag._iconOpen
            else
               iconbmp = tag._icon
            end

            if lDisabled then
               iconbmp.opacity = 128
            end

            gfxCopyArea(iconbmp, Bitmap, BAF_BLEND, 0, 0, iconbmp.Width, iconbmp.Height,
               ix + ((tag.height - iconbmp.Width)/2),
               ny + ((tag.height - iconbmp.Height)/2))

            ix = ix + tag.height + 4
         else
            ix = ix + 4
         end

         if tag.title then
            lPage.new('VectorText', {
               x      = ix,
               y      = ny,
               face   = lGroupFace,
               fill   = lColTitleFont,
               string = tag.title
            })
         end
      end

      -- Darken any unused area at the bottom of the group view

      if lColGroupShade.a then
         ey = ey + ay
         gfxDrawRectangle(Bitmap, ax, ey, awidth, ay + aheight - ey, PackPixelRGBA(Bitmap, &lColGroupShade), BAF_BLEND|BAF_FILL)
      end
   end
--]]

   local function constructListView()
      if not lItemFont then
         lItemFont = obj.new('font', {
            face = gui.fonts.widget.face,
            point = string.format('%.2fpt', gui.fonts.widget.size)
         })
      end

      local width  = lViewport.width - lEdgeMargin - lEdgeMargin
      local height = lViewport.height
      local x      = lEdgeMargin
      local y      = 0
      local index  = 0
      local widest_item = 0
      for _, item in pairs(self.items) do
         index = index + 1

         if not item._vectors then item._vectors = { } end

         item._x = x
         item._y = y
         item._width  = width
         item._height = lLineHeight

         -- If the item is hovered, create a highlight for it.  ColBkgdHighlight defines the background colour to use
         -- when an item is highlighted.  If an item is also marked as selected, then the final colour is interpolated
         -- with ColSelect.

         item._highlightEvent = highlightItemGeneric

         -- Respond to positive item selection by the user (e.g. button click)

         item._selectEvent = function(Item)
            if (Item == lHighlightedItem) then
               Item._highlightEvent(Item, true)
            else
               Item._highlightEvent(Item, false)
            end
         end

         -- Each item gets its own viewport in the page

         if not item._vectors.viewport then
            item._vectors.viewport = lPage.new('VectorViewport', {
               x       = lEdgeMargin,
               y       = y + lEdgeMargin,
               xOffset = lEdgeMargin,
               height  = lLineHeight
            })
         end

         local internalMargin = (lLineHeight * 0.2)
         local iconMargin = 0

         if not Options.noIcons then
            iconMargin = lIconSize + internalMargin
         end

         local vp = item._vectors.viewport

         if item.icon then
            catch(function()
               local icon = { }

               if not self.icons[item.icon] then
                  local err
                  err, icon.bmp = mWidget.createIcon(item.icon, nil, nil, nil, lIconSize)
                  icon.img = lScene.new('VectorImage', { bitmap = icon.bmp })
                  lScene.mtAddDef(item.icon, icon.img)
                  self.icons[item.icon] = icon
               end

               if not item._vectors.iconImage then
                  item._vectors.iconImage = vp.new('VectorRectangle', {
                     fill   = 'url(#' .. item.icon .. ')',
                     x      = lLineHeight * 0.2,
                     y      = ((lLineHeight - lIconSize) * 0.5),
                     width  = lIconSize,
                     height = lIconSize
                  })
               end
            end,
            function(Exception)
               msg('Failed to process icon ' .. item.icon .. ', error ' .. Exception.message)
            end)
         end

         if nz(item[lTextAttrib]) then
            if not item._vectors.text then
               item._vectors.text = vp.new('VectorText', {
                  face     = gui.fonts.widget.face,
                  fontSize = string.format('%.2fpt', gui.fonts.widget.size),
                  align    = 'left'
               })
            end

            item._vectors.text.x = internalMargin + iconMargin
            item._vectors.text.y = lLineHeight - ((lLineHeight - gui.getFontHeight(gui.fonts.widget)))
            item._vectors.text.string = item[lTextAttrib]
            --font.wrapEdge = x + item.Width

            width = internalMargin + iconMargin + mFont.stringWidth(lItemFont, item[lTextAttrib], -1) + internalMargin

            local base = nz(item.colour, lColItem)
            if item._selected then
               if lColSelectFont.a > 0 then
                  base = lColSelectFont
               end
            elseif (item.index == lHighlightedItem) and (lColHighlight.a > 0) then
               base = lColHighlight
            end

            item._vectors.text.fill = gui.rgbToSVG({ r=base.r, g=base.g, b=base.b, a=base.a })
         end

         y = y + lLineHeight + lVSpacing
         if (width > widest_item) then widest_item = width end
      end

      -- Item click and hover management

      for _, item in pairs(self.items) do
         table.insert(self.zones, {
            x      = item._x,
            y      = item._y,
            width  = widest_item,
            height = item._height,
            item   = item,
            hoverCallback = itemHoverCallback
         })
      end

      -- Adjust the page dimensions and report to the scrollbar

      if self.scrollbar then
         widest_item = widest_item + lEdgeMargin + lEdgeMargin
         self.scrollbar.setDynamicPageSize(widest_item, widest_item, y + lEdgeMargin + lVSpacing)
      end
   end

   rebuild = function() -- Forward declared function
      if not lScene then return end

      self.zones = { }
      self.bannerZones = { }
      self.hoveredItem = { }
      lPage.x = 0
      lPage.y = 0
      lPageFeedback = nil

      if lStyle == 'GROUPTREE' then
         constructGroupTreeView()
      elseif lStyle == 'TREE' then
      elseif lStyle == 'LIST' or lStyle == 'LONGLIST' then
         initListStyle()
         constructListView()
      elseif lStyle == 'ICON' then
         constructIconView()
      elseif lStyle == 'COLUMNTREE' then
         initColumnStyle()
         constructColumnBanner()
--[[
         if #self.items < 1 then return end

         drawTree()
         constructColumnView()
--]]
      elseif lStyle == 'COLUMN' then
         initColumnStyle()
         constructColumnBanner()
         constructColumnView()
      end

      cursorActivity()
      lScene.surface.mtScheduleRedraw()
   end

   cursorActivity = function() -- Forward declared function
      local cursor

      if not lActiveZone then
         if self.cursorX then
            if (lStyle == 'LONGLIST') then
               for _, zone in pairs(self.zones) do
                  if self.cursorY >= zone.y and self.cursorY < zone.y + zone.height then
                     cursor = zone.hoverCallback(zone, self.cursorX, self.cursorY)
                     break
                  end
               end
            else
               for _, zone in pairs(self.zones) do
                  if self.cursorX >= zone.x and self.cursorX < zone.x + zone.width and
                     self.cursorY >= zone.y and self.cursorY < zone.y + zone.height then
                     cursor = zone.hoverCallback(zone, self.cursorX, self.cursorY)
                     break
                  end
               end
            end
         end

         if not cursor then checkCursorImage() end
      end
   end

   self.disable = function()
      lDisabled = true
   end

   self.enable = function()
      lDisabled = false
   end

   -- Clears a view of all internal content and updates the display.

   self.clear = function()
      local activate = false
      if lSelectedItem then
         reportItemDeselected('clear', lSelectedItem)
         activate = true
      end

      if lActiveTag then
         reportActiveChange('clear', lActiveTag)
      end

      highlightItem(nil)
      deselectItem(nil)
      lActiveTag = nil

      loadItems({ })
      rebuild()

      --if activate and Options.notifyOnClear or Options.sensitive then
         --reportItemActivated('clear', nil)
      --end
   end

   -- Closes open tree branches.

   self.closeBranch = function(ID)
      local item = lLookup[ID]
      if item._openBranch then
         item._openBranch = false
         arrangeItems()
      end
   end

   -- Inserts new items into the view's tree structure.

   self.insertItem = function(Item, PrevItem)
      print('insertItem() not supported yet')
   end

   -- Inverts all currently selected items in the view.

   self.invertSelection = function()
      if lSensitive then return end

      highlightItem(nil)

      for _, item in ipairs(self.items) do
         if (item._selected) then
            deselectItem(item)
         else
            selectItem(item)
         end
      end

      lActiveTag = nil

      if lSelectedItem then
         reportItemSelected('inverted', lSelectedItem)
      else
         reportItemDeselected('inverted', nil)
      end

      lScene.surface.mtScheduleRedraw()
   end

   -- Returns the graphical dimensions of an item in the view.

   self.itemDimensions = function(Item)
      return { x=0, y=0, width=0, height=0 }
   end

   -- Moves an item towards the bottom of the view.

   self.lowerItem = function(XPath, Item)

   end

   -- Automate the expansion of closed tree branches

   self.openBranch = function(XPath, Item, Parents)

   end

   -- Moves an item towards the top of the view.

   self.raiseItem = function(XPath, Item)

   end

   -- Removes an item from the view.

   self.removeItem = function(XPath, Item, InvisibleRemoval)

   end

   -- Checks the visibility of an item, scrolling it into view if it is partially or fully hidden.

   self.revealItem = function(Item)

   end

   -- Selects all items in the view for the user.

   self.selectAll = function()
      for _, item in ipairs(self.items) do
         selectItem(item)
      end

      highlightItem(nil)
      lActiveTag    = self.items[1]
      lSelectedItem = self.items[1]
      reportItemSelected('selected', self.items[1])
      reportActiveChange('selected', self.items[1])

      lScene.surface.mtScheduleRedraw()
   end

   -- Manually select an item(s).  The client must provide the function 'TestItem', which will receive
   -- a reference to each known item.  It must return 'true' for any item that needs to be selected.

   self.selectItems = function(TestItem)
      for _, item in ipairs(self.items) do
         if TestItem(item) == true then
            selectItem(item)
            lActiveTag = item
            reportItemSelected('selected', item)
            reportActiveChange('selected', item)
         end
      end
      lScene.surface.mtScheduleRedraw()
   end

   -- Deselects all currently selected items.

   self.selectNone = function()
      for _, item in ipairs(self.items) do
         if (item._selected) then
            deselectItem(item)
         end
      end

      lActiveTag = nil
      reportItemDeselected('deselected', self.items[1])
      reportActiveChange('deselected', self.items[1])

      lScene.surface.mtScheduleRedraw()
   end

   self.setColumns = function(Columns)
      msg('Loading ' .. #Columns .. ' columns')

      for _, col in pairs(lColumns) do
         if col.vecViewport then col.vecViewport.acFree() end
         if col.vecGradient then col.vecGradient.acFree() end
         if col.vecTitle then col.vecTitle.acFree() end
      end

      local c = 1
      lColumns   = { }
      lLookupCol = { }
      lNamedCol  = { }
      for _, item in pairs(Columns) do
         if not item['attrib'] then error('No attrib defined for column ' .. c) end

         local new_col = { _index=c, width=100, title='Untitled' }
         for k, v in pairs(item) do
            new_col[k] = v
         end
         table.insert(lColumns, new_col)
         lLookupCol[c] = new_col
         lNamedCol[item['attrib']] = new_col
         c = c + 1
      end

      rebuild()
   end

   -- Changes the underlying attributes of any item in the view.

   self.setItem = function(XPath, TagIndex, Key, Value)

   end

   -- Load a new set of items and display them for the user.  Any existing items will be cleared.

   self.loadItems = function(Items)
      loadItems(Items)
      rebuild()
   end

   -- Sorts the view by column (name or index).

   self.sortColumn = function(Column, Ascending)
      if type(Column) == 'string' then
         for _, col in pairs(lColumns) do
            if col['attrib'] == Column then
               Column = col
               break
            end
         end
      elseif type(Column) == 'number' then
         Column = lColumns[Column]
      end

      if type(Column) == 'table' then
         -- NB: Attrib values that evaluate to nil are not permitted/supported.

         if #self.items > 0 then
            local attrib = Column['attrib']
            if type(self.items[1][attrib]) == 'table' then
               if self.items[1][attrib]['sort'] then
                  table.sort(self.items, function(a,b)
                     if Ascending then
                        return a[attrib].sort < b[attrib].sort
                     else
                        return a[attrib].sort > b[attrib].sort
                     end
                  end)
               else
                  table.sort(self.items, function(a,b)
                     if Ascending then
                        return a[attrib].value < b[attrib].value
                     else
                        return a[attrib].value > b[attrib].value
                     end
                  end)
               end
            elseif type(self.items[1][attrib]) == 'string' then
               table.sort(self.items, function(a,b)
                  if Ascending then
                     return a[attrib]:lower() < b[attrib]:lower()
                  else
                     return a[attrib]:lower() > b[attrib]:lower()
                  end
               end)
            else
               table.sort(self.items, function(a,b)
                  if Ascending then
                     return a[attrib] < b[attrib]
                  else
                     return a[attrib] > b[attrib]
                  end
               end)
            end
         end

         rebuild()
      end
   end

   self.sort = function()
   end

   catch(function()
      if Options.theme == 'light' then
         lThemeColour = { first={ r=250,g=249,b=248 }, last={ r=210,g=211,b=212 } }
      else
         lThemeColour = { first={ r=90,g=90,b=90 }, last={ r=70,g=70,b=110 } }
      end

      self.parentViewport = Options.target

      lScene    = self.parentViewport.scene
      lViewport = self.parentViewport.new('VectorViewport', { name='view_main' }) -- Main viewport for vector graphics.

      self.bkgd = lViewport.new('VectorRectangle', {
         name   = 'view_bkgd',
         fill   = gui.rgbToSVG(lColBackground),
         width  = '100%',
         height = '100%'
      })

      lView = lViewport.new('VectorViewport', { name='view_view', x=0, xOffset=0, y=0, yOffset=0, overflow=VOF_HIDDEN })
      lPage = lView.new('VectorViewport', { name='view_page', width='100%', height='100%' })

      self.border = lViewport.new('VectorRectangle', {
         name   = 'view_border',
         stroke = gui.rgbToSVG(lColBorder),
         strokeWidth = 1,
         width  = '100%',
         height = '100%'
      })

      self.viewport = lViewport -- For the benefit of client access

      if Options.x then lViewport.x = Options.x end
      if Options.y then lViewport.y = Options.y end
      if Options.xOffset then lViewport.xOffset = Options.xOffset end
      if Options.yOffset then lViewport.yOffset = Options.yOffset end
      if Options.width then lViewport.width = Options.width end
      if Options.height then lViewport.height = Options.height end

      self.parentViewport.subscribe('free', function(Surface, Args)
         self.parentViewport = nil
      end)
--[[
      self.parentViewport.surface.subscribe('focus', function(Surface, Args)

      end)

      self.parentViewport.surface.subscribe('lostfocus', function(Surface, Args)

      end)
--]]

      self.scrollbar = gui.scrollbar({
         target = lViewport,
         view   = lView,
         page   = lPage,
         direction = 'all'
      })

      if self.focus and bit.band(self.focus.flags, RNF_HAS_FOCUS) != 0 then
         input.keyboard(lScene.surface, function(Input, Surface, Flags, Code, Unicode)
            if bit.band(Flags, KQ_PRESSED) != 0 then
               if (Code == K_ENTER) or (Code == K_NP_ENTER) or (Code == K_SPACE) then
                  sendFeedback()
               elseif (Code == K_UP) or (Code == K_LEFT) then
                  if lHighlightedItem then
                     local scan = lHighlightedItem.prev
                     while scan and scan.type != TI_ICON do
                        scan = scan.prev
                     end
                     if (not scan) then scan = lastIcon() end
                     highlightItem(scan)
                  else
                     highlightItem(self.items)
                  end
               elseif (Code == K_DOWN) or (Code == K_RIGHT) then
                  if lHighlightedItem then
                     local scan = lHighlightedItem.next
                     while scan and scan.type != TI_ICON do
                        scan = scan.next
                     end
                     if not scan then scan = self.items end
                     highlightItem(scan)
                  else
                     highlightItem(self.items)
                  end
               end
            end
         end)
      end

      lPage.mtSubscribeInput(bit.bor(JTYPE_MOVEMENT, JTYPE_BUTTON, JTYPE_FEEDBACK, JTYPE_EXT_MOVEMENT), function(Viewport, Events)
         local ev = Events
         while (ev) do
            if (ev.type == JET_ENTERED_SURFACE) then
               self.cursorX = ev.x
               self.cursorY = ev.y
               checkCursorImage()
            elseif (ev.type == JET_LEFT_SURFACE) then
               self.cursorX = nil
               self.cursorY = nil
               checkCursorImage()
               if lHighlightedItem then
                  highlightItem(nil)
               end
            elseif (ev.type == JET_WHEEL) then
               local length = lPage.height - lView.height
               if (length > 0) then
                  if (length > lView.height) then length = lView.height end
                  self.scrollbar.scrollPage(0, -ev.value * length * 0.06)
               end
            elseif (ev.type == JET_BUTTON_1) then
               if (bit.band(ev.flags, JTYPE_REPEATED) != 0) then
                  return
               end

               if (ev.value == 1) then
                  self.clickAbsX = ev.absX
                  self.clickAbsY = ev.absY
                  self.clickX = ev.x
                  self.clickY = ev.y
               end

               if lActiveZone then
                  if lActiveZone.clickRelease then
                     lActiveZone.clickRelease(ev.x, ev.y, ev.absX, ev.absY)
                  end
                  lActiveZone = nil
                  cursorActivity()
                  return
               end

               if self.hoveredItem and self.hoveredItem.click then
                  if self.hoveredItem.click(ev) then
                     return
                  end
               end

               if (ev.value == 1) and lHighlightedItem then
                  if not Options.multiSelect and lSelectedItem then
                     deselectItem(lSelectedItem)
                  end

                  if lHighlightedItem._selected then
                     deselectItem(lHighlightedItem)
                     reportItemDeselected('user', lHighlightedItem)
                  else
                     selectItem(lHighlightedItem)
                     reportItemSelected('user', lHighlightedItem)
                  end
               end
            elseif (ev.type == JET_ABS_X) or (ev.type == JET_ABS_Y) then
               if lActiveZone and lActiveZone.clickMove then
                  lActiveZone.clickMove(ev)
               end

               self.cursorX = ev.x
               self.cursorY = ev.y
               self.cursorAbsX = ev.absX
               self.cursorAbsY = ev.absY
               cursorActivity()
            end
            ev = ev.next
         end
      end)

      if Options.items then
         loadItems(Options.items)
      end

      if Options.columns then
         self.setColumns(Options.columns)
      end

      rebuild()

      lPage.mtSubscribeFeedback(FM_PATH_CHANGED, function(Viewport, Event)
         if lPageFeedback then lPageFeedback() end
      end)
   end,
   function(Exception)
      error('Failed to initialise View: ' .. Exception.message)
   end)

   return self
end
