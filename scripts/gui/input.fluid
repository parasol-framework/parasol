--[[
Documentation is available in the Parasol Wiki.
--]]

   import 'common'
   import 'gui'

function reportActivate(self, State)
   self.events.activate ?? return
   text = self.text.string
   hash = string.hash(text)
   if hash != self.hash then
      self.hash = hash
      self.events.activate(self, { text=text, state=State })
   end
end

function validateInput(self)
   if self.inputMask then
      userInput = self.text.string ?? ''
      if string.len(userInput) > 0 then
         if not string.find(userInput, self.inputMask) then
            self.text.string = self._lastGoodInput
            self.viewport.acDraw()
            return false
         end
      end
      self._lastGoodInput = userInput
   end
   return true
end

gui.input = function(Options)
   self = { -- Public variables
      events         = Options.events ?? { },
      label          = Options.label,
      parentViewport = Options.target,
      inputMask      = Options.inputMask,
      text           = nil, -- A VectorText that represents the string
      viewport       = nil, -- The input box's primary viewport
      _lastGoodInput = ''
   }

   -- Change the active state of the input box to disabled or enabled

   self.disable = function(self)
      self.disabled = true
      self.viewport.acDisable()
      self.text.opacity = 0.5
      self.bkgd.fill = gui.style.page.bkgd
      self.events?.disable(self)
      self.viewport.acDraw()
   end

   self.enable = function(self)
      self.disabled = false
      self.viewport.acDisable()
      self.text.opacity = 1.0
      self.bkgd.fill = gui.style.page.bkgd
      self.events?.enable(self)
      self.viewport.acDraw()
   end

   -- Main entry point --

   assert(Options.target, 'A target viewport is required.')

   font_max_height, font_height = gui.getFontHeight(gui.fonts.widget)
   box_height = math.floor(font_max_height * 1.35) + 1

   vps = { -- Viewport settings
      name    = 'vp_input',
      x       = Options.x,
      y       = Options.y,
      width   = Options.width,
      height  = box_height,
      xOffset = Options.xOffset,
      yOffset = Options.yOffset
   }

   if not vps.x and not vps.xOffset then vps.x = 0 end
   if not vps.y and not vps.yOffset then vps.y = 0 end
   if not vps.width and not vps.xOffset then vps.width = gui.style.widget.width end

   self.viewport = self.parentViewport.new('VectorViewport', vps)

   self.inputViewport = self.viewport.new('VectorViewport', {
      name    = 'vp_input_box',
      cursor  = 'text',
      x       = 0,
      y       = 0,
      width   = self.viewport.width,
      yOffset = 0,
      resizeEvent = function(Viewport, Vector, X, Y, Width, Height)
         new_width = Width - self.labelWidth
         if Vector.width != new_width then
            Vector.width = new_width
         end

         if Vector.height != Height then
            Vector.height = Height
         end
      end
   })

   if self.label then
      self.labelText = self.viewport.new('VectorText', {
         name      = 'vt_input_label',
         x         = 0,
         y         = math.round(font_height + math.floor((box_height - font_height) * 0.5)),
         face      = Options.textFace ?? gui.fonts.label.face,
         fontSize  = string.format('%.2fpt', gui.fonts.label.size),
         fontStyle = gui.fonts.label.style,
         fill      = Options.labelFill ?? gui.style.window.text,
         string    = self.label,
         lineLimit = 1
      })

      self.labelWidth          = self.labelText.textWidth + gui.style.widget.margin
      self.inputViewport.x     = self.labelText.x + self.labelWidth
      self.inputViewport.width = self.viewport.width - self.labelWidth
   else
      self.labelWidth = 0
   end

   self.bkgd = self.inputViewport.new('VectorRectangle', {
      fill = Options.bkgd ?? gui.style.page.bkgd, x = 0, y = 0, width = '100%', height = '100%',
   })

   if not Options.flushEdges then
      self.bkgd.stroke      = gui.style.page.stroke
      self.bkgd.strokeWidth = gui.style.page.strokeWidth
      self.bkgd.roundX      = gui.style.page.strokeWidth * 2
      self.bkgd.roundY      = gui.style.page.strokeWidth * 2
   end

   self._textClip = self.inputViewport.new('VectorViewport', {
      name = 'vp_input_clip',
      x = gui.style.page.strokeWidth, y = gui.style.page.strokeWidth,
      xOffset = gui.style.page.strokeWidth, yOffset = gui.style.page.strokeWidth,
      overflow = VOF_HIDDEN
   })

   self.text = self._textClip.new('VectorText', {
      name      = 'vt_input',
      x         = 4,
      y         = math.round(font_height + math.floor((box_height - font_height - (gui.style.page.strokeWidth * 2)) * 0.5)),
      face      = Options.textFace ?? gui.fonts.widget.face,
      fontSize  = string.format('%.2fpt', gui.fonts.widget.size),
      fontStyle = Options.textStyle ?? gui.fonts.widget.style,
      fill      = Options.textFill ?? gui.style.page.text,
      string    = Options.text,
      lineLimit = 1,
      textFlags = (function()
         flags = VTXF_EDITABLE
         if Options.secret then flags = (flags | VTXF_SECRET) end
         return flags
      end)()
   })

   if Options.selected then self.text.mtSelectArea(0, 20000) end

   self.viewport.mtSubscribeFeedback(FM_HAS_FOCUS | FM_CHILD_HAS_FOCUS | FM_LOST_FOCUS, function(Viewport, Event)
      if Event is FM_LOST_FOCUS then
         self.bkgd.stroke = gui.style.page.stroke
         self.events?.lostFocus(self)
         if validateInput(self) then
            reportActivate(self, 'lost-focus')
         end
      else
         self._lastGoodInput = self.text.string
         if self.disabled then
            self.bkgd.stroke = gui.style.page.stroke
         else
            self.bkgd.stroke = gui.style.page.strokeFocus
            self.events?.focus(self)
         end
      end

      Viewport.acDraw()
   end)

   self._textClip.mtSubscribeKeyboard(function(Viewport, Qualifiers, Value, Unicode)
      if (Qualifiers & KQ_PRESSED) is 0 then return end

      if (Value is KEY_ENTER) or (Value is KEY_NP_ENTER) then
         validateInput(self)
         reportActivate(self, 'activated')
      end

      self.events?.keypress(self, { qualifiers=Qualifiers, value=Value, unicode=Unicode })
   end)

   if self.events.cursorEntry or self.events.cursorExit then
      self.inputViewport.mtSubscribeInput(JTYPE_CROSSING, function(Viewport, Msg)
         repeat
            if Msg.type is JET_CROSSED_IN then
               if self.events.cursorEntry then self.events.cursorEntry(self) end
            elseif Msg.type is JET_CROSSED_OUT then
               if self.events.cursorExit then self.events.cursorExit(self) end
            end
            Msg = Msg.next
         until not Msg
      end)
   end


   self.events?.show(self)

   return self
end
