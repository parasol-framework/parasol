-- Internal support functions for listview, columnview etc

   require 'common'
   require 'gui'
   require 'gui/scrollbar'

   if (not mFont) then mFont = mod.load('font') end
   if (not mGfx) then mGfx = mod.load('display') end
   if (not mVec) then mVec = mod.load('vector') end

   local lColBackground = 'rgb(255,255,255)'
   local lColBorder     = 'rgb(160,160,160)'
   local lItemCounter   = 1

----------------------------------------------------------------------------------------------------------------------

local function checkCursorImage(View)
   if View.pointerLocked and not View.activeZone then
      mGfx.restoreCursor(PTR_DEFAULT, View.scene.surface)
      View.pointerLocked = nil
   end
end

local function highlightItem(View, Item)  -- Simplifies the process of highlighting an item.  Item can be nil for deselection.
   if (Item == View.hItem) then return end

   if View.hItem and View.hItem._highlightEvent and (Item != View.hItem) then
      View.hItem._highlightEvent(View, View.hItem, false)
   end

   View.hItem = Item

   if Item and Item._highlightEvent then
      Item._highlightEvent(View, Item, true)
   end

   View.scene.surface.mtScheduleRedraw()
end

local function clearItems(View)
   if View.items then
      for _, item in pairs(View.items) do
         if item then
            item:_free()
         end
      end
   end

   View.items = { }
   View.lookup = { }
end

----------------------------------------------------------------------------------------------------------------------

local function deselectAll(View)
   for _, i in ipairs(View.items) do
      if i._selected then
         i._selected = false
         if i._selectEvent then
            i._selectEvent(View, i)
         end
      end
   end
end

local function deselectItem(View, Item)
   if (View.sItem == Item) then View.sItem = nil end

   Item._selected = false
   if Item._selectEvent then
      Item._selectEvent(View, Item)
   end
end

local function selectItem(View, Item)
   if (Item == View.sItem) then return end

   View.sItem = Item

   if Item then
      Item._selected = true
      if Item._selectEvent then
         Item._selectEvent(View, Item)
      end
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Reasons for a reported change:
--
--   clear:     All items in the view were removed.
--   inverted:  Item automatically deselected due to an invert operation.
--   moved:     The item has been deselected due to moving position.
--   user:      Selected by user interaction (click or keypress)
--   manual:    Item was manually selected (by the application, not the user).

local function reportItemSelected(View, Reason, Item)
   if View.itemSelected then
      View.itemSelected(View, Reason, Item)
   end
end

local function reportItemDeselected(View, Reason, Item)
   if View.itemDeselected then
      View.itemDeselected(View, Reason, Item)
   end
end

local function reportItemActivated(View, Reason, Item)
   if Item.activity then Item.activity(Item) end
   if View.itemActivated then View.itemActivated(View, Reason, Item) end
end

local function reportActiveChange(View, Reason, Item)
   if View.activeChange then
      View.activeChange(View, Reason, Item)
   end
end

----------------------------------------------------------------------------------------------------------------------

gui.initView = function(Options, BuildUI, NewItems)
   local vw = {
      lookup     = { }, -- Lookup items by ID
      activeZone = nil,
      zones      = { },
      items      = { },
      activeTag  = nil,
      disabled   = false,
      sensitive  = nz(Options.sensitive, false),
      hItem      = nil, -- Highlighted item
      sItem      = nil, -- Selected item
      activeItem = nil,
      scene      = nil,
      viewport   = nil,
      page       = nil,
      window     = nil,
      noIcons    = Options.noIcons,
      itemSelected   = Options.itemSelected,
      itemDeselected = Options.itemDeselected,
      itemActivated  = Options.itemActivated,
      activeChange   = Options.activeChange
   }

   vw.addItem = function(Item)
      if not Item then error('No Item provided') end
      vw.addItems({ Item })
   end

   vw.addItems = function(Items)
      if not Items then error('No Items provided') end

      local new_items = { }
      for k, item in pairs(Items) do
         local new_item = {
            _id = lItemCounter,
            _vectors = { },
            _free = function(Item) -- This hook can be overridden by the client
               local vp = Item._vectors.viewport
               Item._vectors.viewport = nil

               for k, v in pairs(Item._vectors) do
                  v.acFree()
               end

               if vp then vp.acFree() end

               Item._vectors = { }
            end
         }

         for k, v in pairs(item) do -- Copy all item key-values supplied by the user
            new_item[k] = v
         end

         table.insert(vw.items, new_item)
         table.insert(new_items, new_item)
         vw.lookup[lItemCounter] = new_item
         lItemCounter = lItemCounter + 1
      end

      if NewItems then NewItems(vw, new_items) end -- Report new items to view manager
   end

   -- Generic callback for the user hovering and interacting with listed items

   local function itemHoverCallback(Zone, CursorX, CursorY)
      highlightItem(vw, Zone.item)

      vw.hoveredItem = {
         click = function(Input)
            if (Input.value == 0) and (bit.band(Input.flags, JTYPE_DBL_CLICK) != 0) then
               reportItemActivated(vw, 'user', Zone.item)
            end
         end
      }
   end

   local function cursorActivity()
      if not vw.activeZone and vw.cursorX then
         for _, zone in pairs(vw.zones) do
            if (vw.cursorY >= zone.y) and (vw.cursorY < zone.y + zone.height) then
               if ((not zone.width) or ((vw.cursorX >= zone.x) and (vw.cursorX < zone.x + zone.width))) then
                  local cursor = zone.hoverCallback(zone, vw.cursorX, vw.cursorY)
                  if not cursor then checkCursorImage(vw) end
                  break
               end
            end
         end
      end
   end

   vw.disable = function()
      vw.disabled = true
   end

   vw.enable = function()
      vw.disabled = false
   end

   -- Add a monitored click zone.
   -- If Width is nil then the click zone will span the entire width of the page and X is ignored.

   vw.addZone = function(X, Y, Width, Height, Item, HoverCallback)
      if not HoverCallback then HoverCallback = itemHoverCallback end

      table.insert(vw.zones, {
         x      = X,
         y      = Y,
         width  = Width,
         height = Height,
         item   = Item,
         hoverCallback = HoverCallback
      })

      return vw.zones[#vw.zones]
   end

   -- Clears a view of all internal content and updates the display.

   vw.clear = function()
      local activate = false
      if vw.sItem then
         reportItemDeselected(vw, 'clear', vw.sItem)
         activate = true
      end

      if vw.activeItem then
         reportActiveChange(vw, 'clear', vw.activeItem)
      end

      highlightItem(vw, nil)
      deselectAll(vw, nil)
      vw.activeItem = nil

      clearItems(vw)
      vw.rebuild()

      --if activate and Options.notifyOnClear or vw.sensitive then
         --reportItemActivated(vw, 'clear', nil)
      --end
   end

   -- Inverts all currently selected items in the view.

   vw.invertSelection = function()
      if vw.sensitive then return end

      highlightItem(vw, nil)

      for _, item in ipairs(vw.items) do
         if item._selected then
            deselectItem(vw, item)
         else
            selectItem(vw, item)
         end
      end

      vw.activeItem = nil

      if vw.sItem then
         reportItemSelected(vw, 'inverted', vw.sItem)
      else
         reportItemDeselected(vw, 'inverted', nil)
      end

      vw.scene.surface.mtScheduleRedraw()
   end

   -- Returns the graphical dimensions of an item in the view.

   vw.itemDimensions = function(Item)
      return { x=0, y=0, width=0, height=0 }
   end

   -- Moves an item towards the bottom of the view.

   vw.lowerItem = function(XPath, Item)

   end

   -- Moves an item towards the top of the view.

   vw.raiseItem = function(XPath, Item)

   end

   -- Removes an item from the view.

   vw.removeItem = function(XPath, Item, InvisibleRemoval)

   end

   -- Checks the visibility of an item, scrolling it into view if it is partially or fully hidden.

   vw.revealItem = function(Item)

   end

   -- Selects all items in the view for the user.

   vw.selectAll = function()
      for _, item in ipairs(vw.items) do
         selectItem(vw, item)
      end

      highlightItem(vw, nil)
      vw.activeItem = vw.items[1]
      vw.sItem = vw.items[1]
      reportItemSelected(vw, 'selected', vw.items[1])
      reportActiveChange(vw, 'selected', vw.items[1])

      vw.scene.surface.mtScheduleRedraw()
   end

   -- Manually select an item(s).  The client must provide the Conditional function that will receive
   -- a reference to each known item.  It must return 'true' for any item that needs to be selected.

   vw.selectItems = function(Conditional)
      for _, item in ipairs(vw.items) do
         if Conditional(item) == true then
            selectItem(vw, item)
            vw.activeItem = item
            reportItemSelected(vw, 'selected', item)
            reportActiveChange(vw, 'selected', item)
         end
      end
      vw.scene.surface.mtScheduleRedraw()
   end

   -- Return a table of all selected items

   vw.selectedItems = function()
      local list = { }
      for _, item in ipairs(vw.items) do
         if item._selected then
            table.insert(list, item)
         end
      end
      return list
   end

   -- Deselects all currently selected items.

   vw.deselectAll = function()
      deselectAll(vw)

      vw.activeItem = nil
      reportItemDeselected(vw, 'deselected', vw.items[1])
      reportActiveChange(vw, 'deselected', vw.items[1])

      vw.scene.surface.mtScheduleRedraw()
   end

   -- Changes the underlying attributes of any item in the view.

   vw.setItem = function(XPath, TagIndex, Key, Value)

   end

   -- Load a new set of items and display them for the user.  Any existing items will be cleared.

   vw.loadItems = function(Items)
      clearItems(vw)
      vw.addItems(Items)
      vw.rebuild()
   end

   -- Internal function for sorting items by any named attribute.  Clients must call sort() instead.

   vw.sortItems = function(Attrib, Ascending)
      if not Attrib then
         Attrib = 'name'
      end

      if Ascending == nil then
         Ascending = true
      end

      if (#vw.items <= 1) then return end

      if (type(vw.items[1][Attrib]) == 'table') then
         if vw.items[1][Attrib]['sort'] then
            table.sort(vw.items, function(a,b)
               if Ascending then
                  return a[Attrib].sort < b[Attrib].sort
               else
                  return a[Attrib].sort > b[Attrib].sort
               end
            end)
         else
            table.sort(vw.items, function(a,b)
               if Ascending then
                  return a[Attrib].value < b[Attrib].value
               else
                  return a[Attrib].value > b[Attrib].value
               end
            end)
         end
      elseif type(vw.items[1][Attrib]) == 'string' then
         table.sort(vw.items, function(a,b)
            if Ascending then
               return a[Attrib]:lower() < b[Attrib]:lower()
            else
               return a[Attrib]:lower() > b[Attrib]:lower()
            end
         end)
      else
         table.sort(vw.items, function(a,b)
            if Ascending then
               return a[Attrib] < b[Attrib]
            else
               return a[Attrib] > b[Attrib]
            end
         end)
      end

      vw.scene.surface.mtScheduleRedraw()
   end

   -- Sort items by any named attribute (Attrib must appear in all items)
   -- Functionality must be defined by the host.

   vw.sort = function(Attrib, Ascending)
      msg('The view implementation must override the sort() method.')
   end

   -- Internal function for building the view's UI

   vw.rebuild = function()
      vw.zones = { }
      vw.hoveredItem = { }

      vw.page.x = 0 -- Reset the page position
      vw.page.y = 0

      BuildUI(vw, vw.scene, vw.window, vw.page)
      cursorActivity() -- Reset the cursor
      vw.border.acMoveToFront()
      vw.scene.surface.mtScheduleRedraw()
   end

   -- Initialisation --

   vw.parentViewport = Options.target

   vw.scene    = vw.parentViewport.scene
   vw.viewport = vw.parentViewport.new('VectorViewport', { name='view_main' }) -- Main viewport for vector graphics.

   vw.bkgd = vw.viewport.new('VectorRectangle', {
      name   = 'view_bkgd',
      fill   = lColBackground,
      width  = '100%',
      height = '100%'
   })

   vw.window = vw.viewport.new('VectorViewport', { name='view_view', x=0, xOffset=0, y=0, yOffset=0, overflow=VOF_HIDDEN })
   vw.page = vw.window.new('VectorViewport', { name='view_page', width='100%', height='100%' })

   vw.border = vw.viewport.new('VectorRectangle', {
      name   = 'view_border',
      width  = '100%',
      height = '100%',
      stroke = lColBorder,
      strokeWidth = 1.5
   })

   for k, v in pairs({ 'x', 'y', 'xOffset', 'yOffset', 'width', 'height'}) do
      if Options[v] then vw.viewport[v] = Options[v] end
   end

   vw.parentViewport.subscribe('free', function(Surface, Args)
      vw.parentViewport = nil
   end)
--[[
   vw.parentViewport.surface.subscribe('focus', function(Surface, Args)

   end)

   vw.parentViewport.surface.subscribe('lostfocus', function(Surface, Args)

   end)
--]]

   vw.scrollbar = gui.scrollbar({
      target = vw.viewport,
      view   = vw.window,
      page   = vw.page,
      direction = 'all'
   })

   if vw.focus and bit.band(vw.focus.flags, RNF_HAS_FOCUS) != 0 then
      input.keyboard(vw.scene.surface, function(Input, Surface, Flags, Code, Unicode)
         if bit.band(Flags, KQ_PRESSED) != 0 then
            if (Code == K_ENTER) or (Code == K_NP_ENTER) or (Code == K_SPACE) then

            elseif (Code == K_UP) or (Code == K_LEFT) then
               if vw.hItem then
                  local scan = vw.hItem.prev
                  while scan and scan.type != TI_ICON do
                     scan = scan.prev
                  end
                  if (not scan) then scan = lastIcon() end
                  highlightItem(vw, scan)
               else
                  highlightItem(vw, vw.items)
               end
            elseif (Code == K_DOWN) or (Code == K_RIGHT) then
               if vw.hItem then
                  local scan = vw.hItem.next
                  while scan and scan.type != TI_ICON do
                     scan = scan.next
                  end
                  if not scan then scan = vw.items end
                  highlightItem(vw, scan)
               else
                  highlightItem(vw, vw.items)
               end
            end
         end
      end)
   end

   vw.page.mtSubscribeInput(bit.bor(JTYPE_MOVEMENT, JTYPE_BUTTON, JTYPE_FEEDBACK, JTYPE_EXT_MOVEMENT), function(Viewport, Events)
      local ev = Events
      while (ev) do
         if (ev.type == JET_ENTERED_SURFACE) then
            vw.cursorX = ev.x
            vw.cursorY = ev.y
            checkCursorImage(vw)
         elseif (ev.type == JET_LEFT_SURFACE) then
            vw.cursorX = nil
            vw.cursorY = nil
            checkCursorImage(vw)
            if vw.hItem then
               highlightItem(vw, nil)
            end
         elseif (ev.type == JET_WHEEL) then
            local length = vw.page.height - vw.window.height
            if (length > 0) then
               if (length > vw.window.height) then length = vw.window.height end
               vw.scrollbar.scrollPage(0, -ev.value * length * 0.06)
            end
         elseif (ev.type == JET_BUTTON_1) then
            if (bit.band(ev.flags, JTYPE_REPEATED) != 0) then
               return
            end

            if (ev.value == 1) then
               vw.clickAbsX = ev.absX
               vw.clickAbsY = ev.absY
               vw.clickX = ev.x
               vw.clickY = ev.y
            end

            if vw.activeZone then -- Custom zone for click activity
               if vw.activeZone.clickRelease then
                  vw.activeZone.clickRelease(ev.x, ev.y, ev.absX, ev.absY)
               end
               vw.activeZone = nil
               cursorActivity()
               return
            end

            if vw.hoveredItem and vw.hoveredItem.click then -- Feedback for all click types.  Refer to hoveredItem()
               if vw.hoveredItem.click(ev) then
                  return
               end
            end

            if (ev.value == 1) and vw.hItem then
               if not Options.multiSelect and vw.sItem then
                  deselectItem(vw, vw.sItem)
               end

               if vw.hItem._selected then
                  deselectItem(vw, vw.hItem)
                  reportItemDeselected(vw, 'user', vw.hItem)
               else
                  selectItem(vw, vw.hItem)
                  reportItemSelected(vw, 'user', vw.hItem)
               end

               vw.scene.surface.mtScheduleRedraw()
            end
         elseif (ev.type == JET_ABS_X) or (ev.type == JET_ABS_Y) then
            if vw.activeZone and vw.activeZone.clickMove then
               vw.activeZone.clickMove(ev)
            end

            vw.cursorX = ev.x
            vw.cursorY = ev.y
            vw.cursorAbsX = ev.absX
            vw.cursorAbsY = ev.absY
            cursorActivity()
         end
         ev = ev.next
      end
   end)

   if Options.items then
      vw.addItems(Options.items)
   end

   vw.rebuild()

   return vw
end
