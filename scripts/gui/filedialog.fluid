--[[
To display a file dialog box:

   gui.dialog.file({ Options... })

If the dialog box is modal, the call will not return until the user has responded to the dialog.

To receive feedback from the dialog box, set the feedback option with a function that follows this prototype:

   function feedback(Dialog, Files)

Whereby Dialog refers to the dialog object and Files refers to an array of the selected file names (full path not
included, read currentPath for the folder).  In the event that the dialog is cancelled, the Files array will be set to
nil.

Note that the dialog box should be managed as a dynamic resource, i.e. created as necessary and deallocated once the
user has responded (i.e. set all references to nil).  Retaining dialog boxes in memory will provide no descernible
speed improvement to the user.

Valid options to use when creating the dialog are as follows:

   popover:      Place the dialog window over the referenced surface.
   target:       Open the dialog window within the referenced surface.
   modal:        Set to true if the dialog box needs to be modal (prevents interaction with other windows).
   okText:       Override the text to display in the OK button.
   cancelText:   Override the text to display in the Cancel button.
   filter:       Name of the default filter to apply from the filterList.
   filterList:   List of items for the combobox filter, e.g. { { name='All Files', pattern='*' } }
   icon:         Window icon
   path:         The initial selection path.
   selectFolder: Set to true if folders can be selected.
   multiSelect:  Set to true if more than one item can be selected.
   userInput:    Set to true if the user can enter custom text.
   warnExists:   If true, confirm with the user if the selected file should be overwritten.
   feedback:     Refers to a Fluid function that will receive the user's response to the dialog.
--]]

   require 'common'
   require 'gui/fileview'
   require 'gui/columnview'
   require 'gui/toolbar'
   require 'gui/button'
   require 'gui/combobox'
   include 'widget'

   if (gui == nil) then gui = { } end
   if (gui.dialog == nil) then gui.dialog = { } end

gui.dialog.file = function(Options)
   local self = { -- Public variables
      windowID = nil,
      currentPath = file.splitPath(Options.path)
   }

   local lOptions = Options
   local lWindow, lFileView, lFilter, lFilters, lFileBox, lToolbar, lPathBox, lView
   local glWidgetGap = 8

   local function processFeedback()
      local list = { }
      if nz(lOptions.multiSelect) then
         for k,v in ipairs(nz(lView.selectedTags, {})) do
            local error, name = lView.xml.mtGetAttrib(v, 'name')
            table.insert(list, name)
         end
      end

      if (#list == 0) then
         local filename = lFileBox.text.string
         if nz(filename) then
            table.insert(list, filename)
         end
      end

      if (lOptions.warnExists == true) and (#list > 0) then
         local error, type = mSys.AnalysePath(nz(lFileView.path,'') .. list[1])
         if type == LOC_FILE then
            local msg

            if #list == 1 then
               msg = "You are about to overwrite the file '" .. list[1] .. "'.  Do you want to continue?"
            else
               msg = 'You are about to overwrite ' .. #list .. ' files.  Do you want to continue?'
            end

            local confirm = gui.dialog.message({
               target  = lOptions.target,
               modal   = true,
               options = { { id=-1, text='No', icon='items/cancel' },
                           { id=1, text='Yes', icon='items/checkmark' } },
               title   = 'Confirmation Required',
               image   = 'items/warning',
               message = msg,
               popover = windowID,
               feedback = function(Dialog, Response, State)
                  if (Response) and (Response.id == 1) then
                     if lOptions.feedback then
                        lOptions.feedback(self, lFileView.path, list)
                     end
                     lWindow = nil
                  end
               end
            })

            return true
         end
      end

      if lOptions.feedback then
         if (#list == 0) then list = nil end
         lOptions.feedback(self, lFileView.path, list)
      end

      lWindow = nil
      return true
   end

   lWindow = obj.new('window', {
      insideWidth  = 500,
      insideHeight = 550,
      minWidth     = 250,
      minHeight    = 150,
      quit         = false,
      center       = true,
      popover      = lOptions.popover,
      parent       = lOptions.target,
      icon         = nz(lOptions.icon, 'icons:folders/folder'),
      title        = nz(lOptions.title, 'Select a file'),
      modal        = nz(lOptions.modal, false),
      closeFeedback = function(Window)
         if (lOptions.feedback != nil) then
            lOptions.feedback(self, nil)
         end

         lWindow = nil
      end
   })

   self.windowID = lWindow.id

   self.scene = obj.new('VectorScene', { surface = lWindow.surface })

   self.viewport = self.scene.new('VectorViewport', { })

   lToolbar = gui.toolbar(self.viewport, {
      x       = 0,
      y       = 0,
      xOffset = 0,
      createItems = function(Bar)
         Bar.addGroup(1, 'Navigation', 2)

         Bar.addItem(2, 'Root', 'Root Folder', 'devices/harddisk', function()
            lFileView.browse(nil)
         end)

         Bar.addItem(3, 'Parent', 'Parent Folder', 'arrows/arrow_nw', function()
            lFileView.parentFolder()
         end)

         Bar.addGroup(4, 'Clipboard', 3)

         Bar.addItem(5, 'Cut', 'Cut', 'tools/cut', function()
            lFileView.cutFiles()
         end)

         Bar.addItem(6, 'Copy', 'Copy', 'tools/copy', function()
            lFileView.copyFiles()
         end)

         Bar.addItem(7, 'Paste', 'Paste', 'tools/paste', function()
            lFileView.pasteFiles()
         end)

         Bar.addGroup(8, 'Actions', 3)

         Bar.addItem(9, 'Create Folder', 'Create Folder', 'folders/folder_new', function()
            lFileView.createFolder()
         end)

         Bar.addItem(10, 'Rename', 'Rename', 'layout/interface_textbox', function()
            lFileView.renameFile()
         end)

         Bar.addItem(11, 'Delete', 'Delete', 'tools/eraser', function()
            lFileView.deleteFiles()
         end)

         Bar.addGroup(12, 'View', 2)

         Bar.addItem(13, 'Column View', 'Column View', 'layout/column_three', function()
            lFileView.view.style = 'column'
         end)

         Bar.addItem(14, 'List View', 'List View', 'layout/list', function()
            lFileView.view.style = 'list'
         end)
      end
   })

   lPathBox = gui.input({
      target    = self.viewport,
      x         = 0,
      y         = lToolbar.viewport.height,
      xOffset   = 0,
      text      = lOptions.path,
      flushEdges = true,
      feedback  = function(Input, Value, State)
         lFileView.browse(nz(Value, ''))
      end
   })

   -- Okay and cancel buttons

   local footer = lWindow.bottomMargin

   lCancelButton = gui.button({
      target  = self.viewport,
      text    = nz(lOptions.cancelText, 'Cancel'),
      xOffset = glWidgetGap,
      yOffset = footer,
      icon    = 'items/cancel',
      feedback = function(Button)
         if lOptions.feedback != nil then
            lOptions.feedback(self, nil)
         end
         lWindow = nil
      end
   })

   lOkayButton = gui.button({
      target     = self.viewport,
      text       = nz(lOptions.okText, 'Okay'),
      xOffset    = lCancelButton.viewport.width + (glWidgetGap * 2),
      yOffset    = footer,
      icon       = 'items/checkmark',
      feedback   = processFeedback
   })

   footer = footer + lOkayButton.viewport.height + glWidgetGap

   -- Filter selection

   if lOptions.filterList and (#lOptions.filterList > 0) then
      local items = { }
      lFilters = { }
      for _, item in pairs(lOptions.filterList) do
         table.insert(items, { item=item.name })
         lFilters[item.name] = item.pattern
      end

      lFilter = gui.combobox({
         target      = self.viewport,
         label       = 'Filter:',
         x           = lWindow.leftMargin,
         xOffset     = lWindow.rightMargin,
         yOffset     = footer,
         allowCustom = userInput,
         items       = items,
         feedback = function(Combo, Text)
            lFileView.filter = nz(lFilters[Text], Text)
         end
      })

      footer = footer + lFilter.viewport.height + glWidgetGap
   end

   -- Create the file and filter input boxes

   local label_width = 0
   if lFilter then label_width = lFilter.labelWidth end
   lFileBox = gui.input({
      target     = self.viewport,
      labelWidth = label_width,
      label   = 'File:',
      x       = lWindow.leftMargin,
      xOffset = lWindow.rightMargin,
      yOffset = footer,
      feedback = function(Input, Value, State)
         lView.selectionIndex = -1
         if (State == 1) then
            processFeedback()
         end
      end
   })

   footer = footer + lFileBox.viewport.height + glWidgetGap

   -- File view area

   local viewRegion = self.viewport.new('VectorViewport', {
      x        = 0,
      y        = lPathBox.viewport.y + lPathBox.viewport.height,
      width    = '100%',
      yOffset  = footer,
      overflow = VOF_HIDDEN
   })

   lView = gui.columnView({
      target      = viewRegion,
      dragDrop    = true,
      multiSelect = lOptions.multiSelect,
      selectCallback = function(View, Flags, Tag)
         -- Display the selected item in the file text box.

         if lFileView == nil then return end

         local selection = lFileView.selectionPath()
         if not nz(selection) then
            --lFileBox.text.string = ''
            return
         end

         local err, fileType = mSys.AnalysePath(selection)
         if err != ERR_Okay then
            lFileBox.text.string = ''
            return
         end

         if fileType == LOC_FILE then
            lFileBox.text.string = lFileView.selection()
            return
         end

         if nz(lOptions.selectFolder) then
            if fileType == LOC_FOLDER then
               lFileBox.text.string = ''
            elseif fileType == LOC_VOLUME then
               lFileBox.text.string = ''
            end
         end
      end
   })

   lFileView = gui.fileview(lView, {
      path     = lOptions.path,
      filter   = '*',
      sysKeys  = true,
      fileSelected = processFeedback,
      pathChanged = function(FlieView, Path)
         self.currentPath = Path
         lPathBox.text.string = self.currentPath
      end
   })

   self.currentPath = lFileView.path

   lWindow.acMoveToFront()
   lWindow.acShow()

   return self
end

   -- This sub-routine is provided for languages other than Fluid to utilise the module.

   do
      local state = getExecutionState()
      if (state.inRequire != true) then
         local dlg = gui.dialog.file({
            popover      = arg('popover'),
            target       = arg('target'),
            modal        = arg('modal'),
            okText       = arg('okText'),
            cancelText   = arg('cancelText'),
            filterList   = arg('filterList'),
            icon         = arg('icon'),
            path         = arg('path'),
            selectFolder = arg('selectFolder', nil),
            multiSelect  = arg('multiSelect', nil),
            userInput    = arg('userInput', nil)
         })

         return dlg.windowID
      end
   end
