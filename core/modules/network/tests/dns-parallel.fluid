--[[
Tests for resolving server names in parallel.
--]]

   local mNet = mod.load('network')

function netAddressToString(IP)
   return bit.rshift(bit.band(IP.data[1], 0xff000000), 24) .. '.' ..
      bit.rshift(bit.band(IP.data[1], 0xff0000), 16) .. '.' ..
      bit.rshift(bit.band(IP.data[1], 0xff00), 8) .. '.' ..
      bit.band(IP.data[1], 0xff)
end

function name_resolved(ClientData, Error, HostName, Addresses)
   if (Error == ERR_Okay) then
      if (not HostName) then error('HostName not specified in results.') end

      local total_ips = 0

      print('Resolved host name ' .. HostName)

      local ip_list = nil
      if (Addresses != nil) then
         total_ips = #Addresses
         for index, ip in pairs(Addresses) do
            if (ip.type == IPADDR_V4) or (ip.type == IPADDR_V6) then
               if (ip_list == nil) then
                  ip_list = netAddressToString(ip)
               else
                  ip_list = ip_list .. ', ' .. netAddressToString(ip)
               end
            else
               error('Unrecognised TCP/IP address type ' .. ip.type)
            end
         end
      end

      local msg = 'Resolved ' .. nz(HostName,'NIL') .. ' with ' .. total_ips .. ' IP addresses.'
      if (ip_list) then msg = msg .. '  IPs: ' .. ip_list end
      print(msg)
   else
      error('Failed to resolve ' .. nz(HostName,'NIL') .. ', error ' ..mSys.GetErrorMsg(Error))
   end

   glTotalResolved = glTotalResolved + 1

   if (glTotalResolved == #glDomains) then
      mSys.SendMessage(nil, MSGID_QUIT)
   end
end

//=====================================================================================================================

function address_resolved(ClientData, Error, HostName, Addresses)
   if (Error == ERR_Okay) then
      print('IP resolved to address "' .. HostName .. '"')
      if (HostName != 'dns.google') then error('IP resolved to ' .. HostName) end

      mSys.SendMessage(nil, MSGID_QUIT)
   else
      error('Failed to resolve ' .. nz(HostName,'NIL') .. ', error ' ..mSys.GetErrorMsg(Error))
   end
end

//=====================================================================================================================
// This test resolves each name more than once.  The expected response is for the callback to be called multiple times
// for the same host.  In the log output you may see a thread being created for the first resolve, then the second call
// will hit the local DNS cache and return immediately.

function testDuplication()
   glTotalResolved = 0

   local domains = { 'google.com', 'news.bbc.co.uk' }
   function duplicate_resolved(ClientData, Error, HostName, Addresses)
      if (Error == ERR_Okay) then
         print('Resolved: ' .. nz(HostName,'NIL'))
      else
         print('Failed to resolve ' .. nz(HostName,'NIL') .. ', error ' ..mSys.GetErrorMsg(Error))
      end

      glTotalResolved = glTotalResolved + 1

      if (glTotalResolved == #domains * 2) then
         mSys.SendMessage(nil, MSGID_QUIT)
      end
   end

   for k,v in pairs(domains) do
      print('Resolving x2 ' .. v)
      mNet.ResolveName(v, 0, duplicate_resolved, 0)
      mSys.WaitTime(1, 0)
      mNet.ResolveName(v, 0, duplicate_resolved, 0)
   end

   local elapsed, err = processMessages(5000)
   if (err == ERR_TimeOut) then error('Name resolution timed-out.') end
end

//=====================================================================================================================
// Non-blocking name resolution (default)

function testNameResolutionAsync()
   glTotalResolved = 0

   for k,v in pairs(glDomains) do
      print('Resolving ' .. v)
      mNet.ResolveName(v, 0, name_resolved, 0)
   end

   local elapsed, err = processMessages(5000)
   if (err == ERR_TimeOut) then error('Name resolution timed-out.') end
end

//=====================================================================================================================
// Blocking name resolution

function testNameResolution()
   if (NSF_SYNCHRONOUS == nil) then error('NSF_SYNCHRONOUS not defined.') end

   glTotalResolved = 0

   for k,v in pairs(glDomains) do
      print('Resolving ' .. v)
      local current_total = glTotalResolved
      mNet.ResolveName(v, NSF_SYNCHRONOUS, name_resolved, 0)
      if (current_total == glTotalResolved) then error('Name was not resolved when ResolveName() had returned') end
   end

   local elapsed, err = processMessages(5000)
   if (err == ERR_TimeOut) then error('Name resolution timed-out.') end
end

//=====================================================================================================================

function testAddressResolution()
   mNet.ResolveAddress('8.8.8.8', 0, address_resolved, 0)

   local elapsed, err = processMessages(5000)
   if (err == ERR_TimeOut) then error('Address resolution timed-out.') end
   if (glTotalResolved < 1) then error('Failed to resolve the IP address.') end
end

//=====================================================================================================================

   return {
      tests = { 'testDuplication', 'testNameResolution', 'testNameResolutionAsync', 'testAddressResolution' },
      init = function()
         //glDomains = { 'amazon.co.uk' }
         glDomains = { 'google.com', 'parasol.ws', 'amazon.co.uk', 'stackoverflow.com', 'theguardian.com', 'www.bbc.co.uk' }
      end,
      cleanup = function()
         glDomains = nil
         glTotalResolved = nil
      end
   }
