/*****************************************************************************
-CATEGORY-
Name: Objects
-END-
*****************************************************************************/

#include "defs.h"
#include <parasol/main.h>

extern ERROR CLASS_Free(struct rkMetaClass *, APTR);
extern ERROR CLASS_Init(struct rkMetaClass *, APTR);

static LONG add_shared_object(OBJECTPTR, OBJECTID, WORD);

/*****************************************************************************

-FUNCTION-
CreateObject: Provides a simplified means of creating and initialising new objects.

CreateObject() combines the ~NewObject() and ~SetFields() functions into a stream-lined creation process and
initialises the resulting object.  This is a convenience function and is not an integral part of the object management
services.

Please refer to the ~NewObject() function for information on the allocation of new objects.  Also see the ~SetFields()
function for an outline of the formatting details of the tag arguments.

-INPUT-
large ClassID: Set to a class ID obtained from the "system/register.h" file or from ~ResolveClassName().
int(NF) Flags: Optional flags to directly pass to ~NewObject().
&obj Object: Pointer to an address variable that will store a reference to the new object.
vtags Tags: Field tags are specified here.  See the ~SetFields() function for information on the structure of the tags.  Remember to terminate the tag-list with TAGEND.

-ERRORS-
Okay
Args
NewObject
SetField

*****************************************************************************/

ERROR CreateObject(LARGE ClassID, LONG Flags, OBJECTPTR *argObject, ...)
{
   va_list list;
   va_start(list, argObject);
   ERROR error = CreateObjectF(ClassID, Flags, argObject, list);
   va_end(list);
   return error;
}

ERROR CreateObjectF(LARGE ClassID, LONG Flags, OBJECTPTR *argObject, va_list List)
{
   if (glLogLevel > 2) {
      struct rkMetaClass **ptr;
      if (!KeyGet(glClassMap, ClassID, (APTR *)&ptr, NULL)) {
         LogF("~CreateObject()","Class: %s", ptr[0]->ClassName);
      }
      else LogF("~CreateObject()","Class: $%.8x", (ULONG)ClassID);
   }
   else LogF("~CreateObject()","Class: $%.8x", (ULONG)ClassID);

   OBJECTPTR object;
   ERROR error;

   if (!NewObject(ClassID, Flags|NF_CREATE_OBJECT, &object)) {
      if (!SetFieldsF(object, List)) {
         if (!(error = acInit(object))) {
            if (argObject) *argObject = object;
            else if (object->UniqueID < 0) ReleaseObject(object);
            LogBack();
            return ERR_Okay;
         }
      }
      else error = LogError(ERH_CreateObject, ERR_SetField);

      if (object->UniqueID < 0) {
         acFree(object);
         ReleaseObject(object);
      }
      else acFree(object);
   }
   else error = ERR_NewObject;

   if (argObject) *argObject = NULL;
   LogBack();
   return error;
}

/*****************************************************************************

-FUNCTION-
NewObject: Creates new objects.

The NewObject() function is used to create new objects and register them for use within the Core.  After creating
a new object, the client can proceed to set the object's field values and initialise it with #Init() so that it
can be used as intended.

The new object will be modeled according to the class blueprint indicated by ClassID.  Pre-defined class ID's are
defined in the `parasol/system/register.h` include file and a complete list of known classes is available in the Class
Index Guide.  ID's for unregistered classes can be found dynamically by using the ~ResolveClassName() function.

A pointer to the new object will be returned in the Object parameter.  By default, new objects are always owned by the
object that holds the current context.  It is possible to track a new object to a different owner by using the
~SetOwner() function after calling NewObject().

To destroy an object, use the #Free() action.

-INPUT-
large ClassID: A class ID from "system/register.h" or generated by ~ResolveClassName().
int(NF) Flags:  Optional flags.
&obj Object: Pointer to an address variable that will store a reference to the new object.

-ERRORS-
Okay
NullArgs
MissingClass: The ClassID is invalid or refers to a class that is not installed.
Failed
ObjectExists: An object with the provided Name already exists in the system (applies only when the NF_UNIQUE flag has been used).
-END-

*****************************************************************************/

ERROR NewObject(LARGE ClassID, LONG Flags, OBJECTPTR *Object)
{
   static BYTE master_sorted = FALSE;

   ULONG class_id = (ULONG)(ClassID & 0xffffffff);
   if ((!class_id) OR (!Object)) return LogError(ERH_NewObject, ERR_NullArgs);

   struct rkMetaClass *class;
   if (class_id IS ID_METACLASS) {
      class = &glMetaClass;
      glMetaClass.ActionTable[AC_Free].PerformAction = (APTR)CLASS_Free;
      glMetaClass.ActionTable[AC_Init].PerformAction = (APTR)CLASS_Init;
      // Initialise the glMetaClass fields if this has not already been done.

      if (!master_sorted) {
         sort_class_fields(&glMetaClass, glMetaClass.prvFields);
         master_sorted = TRUE;
      }
   }
   else if (!(class = (struct rkMetaClass *)FindClass(class_id))) {
      LogF("NewObject()","Class $%.8x was not found in the system.", class_id);
      return ERR_MissingClass;
   }

   if (Object) *Object = NULL;

   Flags &= (NF_UNTRACKED|NF_INTEGRAL|NF_UNIQUE|NF_NAME|NF_PUBLIC|NF_CREATE_OBJECT); // Very important to eliminate any internal flags.

   // If the object is to be a child of a larger object, turn off use of the UNTRACKED flag (otherwise the child will
   // end up being tracked to its task rather than its parent object).

   if (Flags & NF_INTEGRAL) Flags &= ~NF_UNTRACKED;

   // Force certain flags on the class' behalf

   if (class->Flags & CLF_PUBLIC_OBJECTS) Flags |= NF_PUBLIC;
   if (class->Flags & CLF_NO_OWNERSHIP)   Flags |= NF_UNTRACKED;

   if (Flags & NF_PUBLIC) {
      LogF("@NewObject","Request to allocate public object denied, use NewLockedObject().");
      return LogError(ERH_NewObject, ERR_Args);
   }

   if (!(Flags & NF_CREATE_OBJECT)) {
      LogF("~NewObject()","%s #%d, Flags: $%x", class->ClassName, glSharedControl->PrivateIDCounter, Flags);
   }

   OBJECTPTR context = NULL;
   OBJECTPTR head = NULL;
   MEMORYID head_id = 0;
   ERROR error = ERR_Failed;

   if (!AllocMemory(class->Size + sizeof(struct Stats), MEM_OBJECT|MEM_NO_LOCK, (APTR *)&head, &head_id)) {
      head->Stats = ResolveAddress(head, class->Size);
      head->UniqueID = head_id;
      head->MemFlags |= MEM_NO_LOCK; // Prevents private memory allocations made by this class from being automatically locked.
      head->ClassID = class->BaseClassID;
      if (class->BaseClassID IS class->SubClassID) { // Object derived from a base class
         head->SubID   = 0;
      }
      else { // Object derived from a sub-class
         head->SubID   = class->SubClassID;
      }

      head->Class = (struct rkMetaClass *)class;
      if ((glCurrentTaskID != SystemTaskID) AND (!(class->Flags & CLF_NO_OWNERSHIP))) {
         head->TaskID = glCurrentTaskID;
      }

      if (!(Flags & NF_UNTRACKED)) { // Don't track untracked objects to specific threads.
         head->ThreadMsg = tlThreadWriteMsg; // If the object needs to belong to a thread, this will record it.
      }

      // Note that the untracked flag is turned off because if it is left on, objects will allocate their children as
      // being untracked (due to use of ObjectFlags as a reference for child allocation).   We don't want our tracking to
      // be screwed up do we...

      set_object_flags(head, (WORD)Flags);
      head->Flags |= NF_NEW_OBJECT;
   }
   else { error = ERR_AllocMemory; goto failed; }

   // Tracking for our new object is configured here.

   OBJECTPTR task;
   if (class->Flags & CLF_NO_OWNERSHIP) {
   }
   else if (Flags & NF_UNTRACKED) {
      if (class_id IS ID_MODULE); // Untracked modules have no owner, due to the expunge process.
      else {
         // If the object is private and untracked, set its owner to the current task.  This will ensure that the object
         // is deallocated correctly when the Core is closed.

         if (glCurrentTaskID) {
            if (!AccessObject(glCurrentTaskID, 5000, &task)) {
               SetOwner(head, task);
               ReleaseObject(task);
            }
            else LogF("NewObject","Unable to access local task (ID: %d).", glCurrentTaskID);
         }
      }
   }
   else if (tlContext != &glTopContext) { // Track the object to the current context
      SetOwner(head, tlContext->Object);
   }
   else if (glCurrentTaskID) { // If no current context is available then track the object to the local task
      if (!AccessObject(glCurrentTaskID, 3000, &task)) {
         SetOwner(head, task);
         ReleaseObject(task);
      }
      else LogF("NewObject","Unable to access the local task #%d", glCurrentTaskID);
   }
   else if (SystemTaskID) { // If no current task is available then track the object to the system task
      if (!AccessObject(SystemTaskID, 3000, &task)) {
         SetOwner(head, task);
         ReleaseObject(task);
      }
      else LogF("NewObject","Unable to access the system task #%d", SystemTaskID);
   }

   // After the header has been created we can set the context, then call the base class's NewObject() support.  If the
   // class is a child, we will also call its supporting NewObject() action if it has specified one.
   //
   // Note: The NewObject support caller has a special feature where it passes the expected object context in the args pointer.

   context = SetContext(head);

      if (class->Base) {
         if (class->Base->ActionTable[AC_NewObject].PerformAction) {
            if ((error = class->Base->ActionTable[AC_NewObject].PerformAction(head, NULL)) != ERR_Okay) {
               LogError(ERH_NewObject, error);
               goto failed;
            }
         }
         else {
            error = LogError(ERH_NewObject, ERR_NoAction);
            goto failed;
         }
      }

      if (class->ActionTable[AC_NewObject].PerformAction) {
         if ((error = class->ActionTable[AC_NewObject].PerformAction(head, NULL)) != ERR_Okay) {
            LogError(ERH_NewObject, error);
            goto failed;
         }
      }

   SetContext(context);
   context = NULL;

   ((struct rkMetaClass *)head->Class)->OpenCount++;
   if (class->Base) class->Base->OpenCount++;

   head->Flags &= ~NF_NEW_OBJECT;
   *Object = head;
   if (!(Flags & NF_CREATE_OBJECT)) LogBack();
   return ERR_Okay;

failed:
   if (context) SetContext(context);

   if (head) {
      head->Flags &= ~NF_NEW_OBJECT;
      FreeResource(head);
   }

   if (!(Flags & NF_CREATE_OBJECT)) LogBack();
   return error;
}

/*****************************************************************************

-FUNCTION-
NewLockedObject: Creates a new object with a lock immediately applied.

The NewLockedObject() function extends ~NewObject() with the addition of applying a lock to the new object at the time
of its allocation.  Its use is also required in cases where the client needs to allocate a public object that can be
shared between processes.

References to the created object are available as a pointer and unique object ID.  Once the lock is no longer required,
a call to ~ReleaseObject() is necessary to release it.  If the lock is not released, any attempt to free the
object will fail and this can eventually lead to program closure problems.  Problems such as this can be debugged
quickly by checking the application log for unreleased lock errors.

-INPUT-
large ClassID: A class ID from "system/register.h" or generated by ~ResolveClassName().
int(NF) Flags: Optional flags.
&obj Object: Optional.  Pointer to an address variable that will store a reference to the new object.  If set to NULL, the acquired lock is released before returning to the client.
&oid ID: Compulsory.  The unique ID of the new object will be returned in this parameter.
cstr Name: Enabled only if NF_NAME or NF_UNIQUE are specified as Flags.  The Name refers to the name that you want to give the object.

-ERRORS-
Okay
NullArgs
MissingClass: The ClassID is invalid or refers to a class that is not installed.
Failed
ObjectExists: An object with the provided Name already exists in the system (applies only when the NF_UNIQUE flag has been used).
-END-

*****************************************************************************/

ERROR NewLockedObject(LARGE ClassID, LONG Flags, OBJECTPTR *Object, OBJECTID *ObjectID, CSTRING Name)
{
   static BYTE master_sorted = FALSE;
   static BYTE private_lock = FALSE;

   ULONG class_id = (ULONG)(ClassID & 0xffffffff);
   if ((!class_id) OR (!ObjectID)) return LogError(ERH_NewObject, ERR_NullArgs);

   struct rkMetaClass *class;
   if (class_id IS ID_METACLASS) {
      class = &glMetaClass;
      glMetaClass.ActionTable[AC_Free].PerformAction = (APTR)CLASS_Free;
      glMetaClass.ActionTable[AC_Init].PerformAction = (APTR)CLASS_Init;
      // Initialise the glMetaClass fields if this has not already been done.

      if (!master_sorted) {
         sort_class_fields(&glMetaClass, glMetaClass.prvFields);
         master_sorted = TRUE;
      }
   }
   else if (!(class = (struct rkMetaClass *)FindClass(class_id))) {
      LogF("NewLockedObject()","Class $%.8x was not found in the system.", class_id);
      return ERR_MissingClass;
   }

   if (Object)   *Object   = NULL;
   *ObjectID = 0;

   Flags &= (NF_UNTRACKED|NF_INTEGRAL|NF_UNIQUE|NF_NAME|NF_PUBLIC|NF_CREATE_OBJECT); // Very important to eliminate any internal flags.

   // If the object is to be a child of a larger object, turn off use of the UNTRACKED flag (otherwise the child will
   // end up being tracked to its task rather than its parent object).

   if (Flags & NF_INTEGRAL) Flags &= ~NF_UNTRACKED;

   // Force certain flags on the class' behalf

   if (class->Flags & CLF_PUBLIC_OBJECTS) Flags |= NF_PUBLIC;
   if (class->Flags & CLF_NO_OWNERSHIP)   Flags |= NF_UNTRACKED;

   if (Flags & NF_PUBLIC) LogF("~NewLockedObject()","%s #%d, Flags: $%x", class->ClassName, glSharedControl->IDCounter, Flags);
   else LogF("~NewLockedObject()","%s #%d, Flags: $%x", class->ClassName, glSharedControl->PrivateIDCounter, Flags);

   OBJECTPTR context = NULL;
   OBJECTPTR head = NULL;
   MEMORYID head_id = 0;
   APTR sharelock = NULL;
   BYTE resourced = FALSE;
   ERROR error = ERR_Failed;

   if (((Flags & NF_UNIQUE) AND (Name)) OR (Flags & NF_PUBLIC)) {
      // Locking RPM_SharedObjects for the duration of this function will ensure that other tasks do not create shared
      // objects with the same name when NF_UNIQUE is in use.

      if (!AccessMemory(RPM_SharedObjects, MEM_READ_WRITE, 2000, &sharelock)) {
         if (Flags & NF_UNIQUE) {
            OBJECTID search_id;
            if ((!FastFindObject(Name, class_id, &search_id, 1, NULL)) AND (search_id)) {
               *ObjectID = search_id;
               ReleaseMemoryID(RPM_SharedObjects);
               LogBack();
               return ERR_ObjectExists; // Return ERR_ObjectExists so that the caller knows that the failure was not caused by an object creation error.
            }
         }
      }
      else {
         LogError(ERH_NewObject, ERR_AccessMemory);
         LogBack();
         return ERR_AccessMemory;
      }
   }

   if ((Flags & NF_PUBLIC) AND (class->Flags & CLF_PRIVATE_ONLY)) {
      LogF("@NewLockedObject","Public objects cannot be allocated from class $%.8x.", class_id);
      Flags &= ~NF_PUBLIC;
   }

   if (Flags & NF_PUBLIC) {
      if (!AllocMemory(class->Size + sizeof(struct Stats), MEM_PUBLIC|MEM_OBJECT, (void **)&head, &head_id)) {
         head->Stats = ResolveAddress(head, class->Size);
         head->MemFlags |= MEM_PUBLIC;
         head->UniqueID = head_id;
      }
      else { error = ERR_AllocMemory; goto failed; }
   }
   else if (!AllocMemory(class->Size + sizeof(struct Stats), MEM_OBJECT|MEM_NO_LOCK, (APTR *)&head, &head_id)) {
      head->Stats = ResolveAddress(head, class->Size);
      head->UniqueID = head_id;
      head->MemFlags |= MEM_NO_LOCK; // Prevents private memory allocations made by this class from being automatically locked.
   }
   else { error = ERR_AllocMemory; goto failed; }

   head->ClassID = class->BaseClassID;
   if (class->BaseClassID IS class->SubClassID) { // Object derived from a base class
      head->SubID = 0;
   }
   else head->SubID = class->SubClassID; // Object derived from a sub-class

   head->Class = (struct rkMetaClass *)class;
   if ((glCurrentTaskID != SystemTaskID) AND (!(class->Flags & CLF_NO_OWNERSHIP))) {
      head->TaskID = glCurrentTaskID;
   }

   if (!(Flags & (NF_PUBLIC|NF_UNTRACKED))) { // Don't track public and untracked objects to specific threads.
      head->ThreadMsg = tlThreadWriteMsg; // If the object needs to belong to a thread, this will record it.
   }

   // Add the object to our lists.  This must be done before calling the NewObject action because we will otherwise
   // risk stuffing up the list order.

   if (Flags & NF_PUBLIC) {
      if (add_shared_object(head, head_id, (WORD)Flags) != ERR_Okay) goto failed;
      resourced = TRUE;
   }

   // Note that the untracked flag is turned off because if it is left on, objects will allocate their children as
   // being untracked (due to use of ObjectFlags as a reference for child allocation).

   set_object_flags(head, (WORD)Flags);
   head->Flags |= NF_NEW_OBJECT;

   // Tracking for our newly created object is setup here.

   OBJECTPTR task;
   if (class->Flags & CLF_NO_OWNERSHIP); // The class mandates that objects have no owner.
   else if (Flags & NF_UNTRACKED) {
      if (class_id IS ID_MODULE); // Untracked modules have no owner, due to the expunge process.
      else if (!(Flags & NF_PUBLIC)) {
         // If the object is private and untracked, set its owner to the current task.  This will ensure that the object
         // is deallocated correctly when the Core is closed.

         if (glCurrentTaskID) {
            if (!AccessObject(glCurrentTaskID, 5000, &task)) {
               SetOwner(head, task);
               ReleaseObject(task);
            }
            else LogF("NewLockedObject","Unable to access local task (ID: %d).", glCurrentTaskID);
         }
      }
   }
   else if (tlContext != &glTopContext) { // Track the object to the current context
      SetOwner(head, tlContext->Object);
   }
   else if (glCurrentTaskID) { // If no current context is available then track the object to the local task
      if (!AccessObject(glCurrentTaskID, 3000, &task)) {
         SetOwner(head, task);
         ReleaseObject(task);
      }
      else LogF("NewLockedObject","Unable to access the local task #%d", glCurrentTaskID);
   }
   else if (SystemTaskID) { // If no current task is available then track the object to the system task
      if (!AccessObject(SystemTaskID, 3000, &task)) {
         SetOwner(head, task);
         ReleaseObject(task);
      }
      else LogF("NewLockedObject","Unable to access the system task #%d", SystemTaskID);
   }

   if ((Object) AND (!(Flags & NF_PUBLIC))) {
      if (AccessPrivateObject(head, 0x7fffffff) != ERR_Okay) goto failed;
      private_lock = TRUE;
   }

   // After the header has been created we can set the context, then call the base class's NewObject() support.  If the
   // class is a child, we will also call its supporting NewObject() action if it has specified one.
   //
   // Note: The NewObject support caller has a special feature where it passes the expected object context in the args pointer.

   context = SetContext(head);

      if (class->Base) {
         if (class->Base->ActionTable[AC_NewObject].PerformAction) {
            if ((error = class->Base->ActionTable[AC_NewObject].PerformAction(head, NULL)) != ERR_Okay) {
               LogError(ERH_NewObject, error);
               goto failed;
            }
         }
         else {
            error = LogError(ERH_NewObject, ERR_NoAction);
            goto failed;
         }
      }

      if (class->ActionTable[AC_NewObject].PerformAction) {
         if ((error = class->ActionTable[AC_NewObject].PerformAction(head, NULL)) != ERR_Okay) {
            LogError(ERH_NewObject, error);
            goto failed;
         }
      }

   SetContext(context);
   context = NULL;

   // Increment the class' open count if the object is private.  We do not increment the count for public objects,
   // because this prevents the Core from expunging modules correctly during shutdown.

   if (!(Flags & NF_PUBLIC)) {
      ((struct rkMetaClass *)head->Class)->OpenCount++;
      if (class->Base) class->Base->OpenCount++;
   }

   *ObjectID = head_id;

   if ((Flags & (NF_UNIQUE|NF_NAME)) AND (Name)) SetName(head, Name); // Set the object's name if it was specified

   head->Flags &= ~NF_NEW_OBJECT;
   if (Flags & NF_PUBLIC) {
      if (Object) { // All we need to do is set the Locked flag rather than making a call to AccessObject()
         head->Locked = TRUE;
         *Object = head;
      }
      else ReleaseMemoryID(head_id);
   }
   else {
      if (Object) *Object = head;
   }

   if (sharelock) ReleaseMemoryID(RPM_SharedObjects);
   LogBack();
   return ERR_Okay;

failed:
   if (context) SetContext(context);

   if (head) {
      head->Flags &= ~NF_NEW_OBJECT;

      if (Flags & NF_PUBLIC) {
         if (resourced) remove_shared_object(head_id);
         ReleaseMemoryID(head_id);
         FreeResourceID(head_id);
      }
      else {
         if (private_lock) ReleasePrivateObject(head);
         FreeResource(head);
      }
   }

   if (sharelock) ReleaseMemoryID(RPM_SharedObjects);
   *ObjectID = 0;
   LogBack();
   return error;
}

/*****************************************************************************

-FUNCTION-
ResolveClassName: Resolves any class name to a unique identification ID.

This function will resolve a class name to its unique ID.

Class ID's are used by functions such as ~NewObject() for fast processing.

-INPUT-
cstr Name: The name of the class that you want to resolve.

-RESULT-
cid: Returns the class ID identified from the class name, or NULL if the class could not be found.
-END-

*****************************************************************************/

CLASSID ResolveClassName(CSTRING ClassName)
{
   struct ClassItem *item;

   if ((!ClassName) OR (!*ClassName)) {
      LogError(ERH_ResolveClassName, ERR_NullArgs);
      return NULL;
   }

   if ((item = find_class(StrHash(ClassName, FALSE)))) {
      return item->ClassID;
   }
   else return 0;
}

/*****************************************************************************

-FUNCTION-
ResolveClassID: Converts a valid class ID to its equivalent name.

This function is able to resolve a valid class identifier to its equivalent name.  The name is resolved by scanning the
class database, so the class must be registered in the database for this function to return successfully.

-INPUT-
cid ID: The ID of the class that needs to be resolved.

-RESULT-
cstr: Returns the name of the class, or NULL if the ID is not recognised.  Standard naming conventions apply, so it can be expected that the string is capitalised and without spaces, e.g. "NetSocket".
-END-

*****************************************************************************/

CSTRING ResolveClassID(ULONG ID)
{
   struct ClassItem *item;
   if ((item = find_class(ID))) return item->Name;
   else {
      LogF("@ResolveClassID()","Failed to resolve ID $%.8x", ID);
      return NULL;
   }
}

//****************************************************************************

ERROR find_public_object_entry(struct SharedObjectHeader *Header, OBJECTID ObjectID, LONG *Position)
{
   struct SharedObject *array = ResolveAddress(Header, Header->Offset);

   LONG j;
   LONG floor   = 0;
   LONG ceiling = Header->NextEntry;
   LONG i       = ceiling>>1;
   for (j=0; j < 2; j++) {
      while ((!array[i].ObjectID) AND (i > 0)) i--;

      if (ObjectID < array[i].ObjectID)      floor = i + 1;
      else if (ObjectID > array[i].ObjectID) ceiling = i;
      else {
         *Position = i;
         return ERR_Okay;
      }
      i = floor + ((ceiling - floor)>>1);
  }

   while ((!array[i].ObjectID) AND (i > 0)) i--;

   if (ObjectID < array[i].ObjectID) {
      while (i < ceiling) {
         if (array[i].ObjectID IS ObjectID) {
            *Position = i;
            return ERR_Okay;
         }
         i++;
      }
   }
   else {
      while (i >= 0) {
         if (array[i].ObjectID IS ObjectID) {
            *Position = i;
            return ERR_Okay;
         }
         i--;
      }
   }

   return ERR_Search;
}

/*****************************************************************************
** These functions are responsible for maintaining the public object list table.
*/

static ERROR add_shared_object(OBJECTPTR Object, OBJECTID ObjectID, WORD Flags)
{
   // This routine guarantees that the public_objects table will be sorted in the order of object creation (ObjectID)
   // so long as the ObjectID is incremented correctly.

   if (ObjectID >= 0) return LogError(ERH_AddSharedObject, ERR_Args);

   struct SharedObjectHeader *public_hdr;
   if (!AccessMemory(RPM_SharedObjects, MEM_READ_WRITE, 2000, (void **)&public_hdr)) {
      struct SharedObject *public_objects;
      LONG i, j, k;

      public_objects = ResolveAddress(public_hdr, public_hdr->Offset);

      // If the table is at its limit, compact it first by eliminating entries that no longer contain any data.

      if (public_hdr->NextEntry >= public_hdr->ArraySize) {
         LONG last_entry = 0;
         LONG entry_size = sizeof(struct SharedObject)>>1;
         for (i=0; i < public_hdr->ArraySize; i++) {
            if (!public_objects[i].ObjectID) {
               for (j=i+1; (j < public_hdr->ArraySize) AND (public_objects[j].ObjectID IS NULL); j++);
               if (j < public_hdr->ArraySize) {
                  // Move the record at position j to position i
                  for (k=0; k < entry_size; k++) {
                     ((WORD *)(public_objects+i))[k] = ((WORD *)(public_objects+j))[k];
                  }
                  // Kill the moved record at its previous position
                  public_objects[j].ObjectID = 0;
                  public_objects[j].OwnerID  = 0;
                  last_entry = i;
               }
               else break;
            }
            else last_entry = i;
         }
         if (last_entry < public_hdr->ArraySize-1) public_hdr->NextEntry = last_entry + 1;
         else public_hdr->NextEntry = public_hdr->ArraySize;
         LogF("4AddObject","Public object array compressed from %d entries to %d entries.", public_hdr->ArraySize, public_hdr->NextEntry);
      }

      // If the table is at capacity, we must allocate more space for new records

      if (public_hdr->NextEntry >= public_hdr->ArraySize) {
         LogF("@AddObject","The public object array is at capacity (%d blocks)", public_hdr->ArraySize);
         ReleaseMemoryID(RPM_SharedObjects);
         return ERR_ArrayFull;
      }

      // "Pull-back" the NextPublicObject position if there are null entries present at the tail-end of the array (occurs if objects are allocated then quickly freed).

      while ((public_hdr->NextEntry > 0) AND (public_objects[public_hdr->NextEntry-1].ObjectID IS NULL)) {
         public_hdr->NextEntry--;
      }

      // Add the entry to the next available space

      public_objects[public_hdr->NextEntry].ObjectID = ObjectID;
      public_objects[public_hdr->NextEntry].OwnerID  = Object->OwnerID;

      if (((struct rkMetaClass *)(Object->Class))->Flags & CLF_NO_OWNERSHIP) {
         public_objects[public_hdr->NextEntry].MessageMID = 0;
      }
      else public_objects[public_hdr->NextEntry].MessageMID = glTaskMessageMID;

/* We should use this routine to set the message id, in case the object is going to be a child of another that is
   public and belongs to a different task.

      if (Object->TaskID IS glCurrentTaskID) {
         public_objects[public_hdr->NextEntry].MessageMID = glTaskMessageMID;
      }
      else if (LOCK_TASKS() IS ERR_Okay) {
         for (i=0; i < MAX_TASKS; i++) {
            if (shTasks[i].TaskID IS Object->TaskID) {
               public_objects[public_hdr->NextEntry].MessageMID = shTasks[i].MessageID;
               break;
            }
         }
         if (i IS MAX_TASKS) public_objects[public_hdr->NextEntry].MessageMID = glTaskMessageMID;
         UNLOCK_TASKS();
      }
*/
      if (Flags & NF_PUBLIC) public_objects[public_hdr->NextEntry].Address  = NULL;
      else public_objects[public_hdr->NextEntry].Address  = Object;

      public_objects[public_hdr->NextEntry].ClassID     = Object->ClassID;
      public_objects[public_hdr->NextEntry].Name[0]     = 0;
      public_objects[public_hdr->NextEntry].Flags       = Flags;
      public_objects[public_hdr->NextEntry].InstanceID  = glInstanceID;
      public_hdr->NextEntry++;

      ReleaseMemoryID(RPM_SharedObjects);
      return ERR_Okay;
   }
   else return LogError(ERH_AddSharedObject, ERR_AccessMemory);
}

//****************************************************************************

void remove_shared_object(OBJECTID ObjectID)
{
   struct SharedObjectHeader *publichdr;

   if (!AccessMemory(RPM_SharedObjects, MEM_READ_WRITE, 2000, (void **)&publichdr)) {
      LONG pos;
      if (find_public_object_entry(publichdr, ObjectID, &pos) IS ERR_Okay) {
         struct SharedObject *obj = ResolveAddress(publichdr, publichdr->Offset);
         obj[pos].ObjectID   = 0;
         obj[pos].ClassID    = 0;
         obj[pos].OwnerID    = 0;
         obj[pos].Name[0]    = 0;
         obj[pos].Flags      = 0;
         obj[pos].InstanceID = 0;
      }
      else LogF("@remove_shared_object","Object #%d is not registered in the public object list.", ObjectID);
      ReleaseMemoryID(RPM_SharedObjects);
   }
   else LogError(ERH_RemoveObject, ERR_AccessMemory);
}

