<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN">
<html xml:lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-8254DG7MT6"> </script><script>
	   window.dataLayer = window.dataLayer || [];
	   function gtag(){dataLayer.push(arguments);}
	   gtag('js', new Date());
      gtag('config', 'G-8254DG7MT6');</script><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="Parasol Framework documentation, machine generated from source"><meta name="author" content="Paul Manias"><link rel="icon" href="/favicon.ico"><title>Parasol Framework Manual</title><link href="../css/bootstrap.min.css" rel="stylesheet"><link href="../css/module-template.css" rel="stylesheet"></head><body><nav class="navbar navbar-inverse navbar-fixed-top"><div class="container"><div class="navbar-header"><button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="../index.html">Parasol Framework</a></div><div id="navbar" class="collapse navbar-collapse"><ul class="nav navbar-nav"><li class="active"><a href="core.html">Modules</a></li><li><a href="classes/module.html">Classes</a></li><li><a href="fluid.html">Fluid</a></li></ul></div></div></nav><div class="container"><div class="row"><div class="col-sm-9"><div class="docs-content" style="display:none;" id="default-page"><h1>Base Modules</h1><p>The following modules are included in the standard distribution and can be loaded at run-time with <samp>mod.load()</samp> in Fluid or <samp>LoadModule()</samp> in C/C++.</p><p>Use the navigation bar on the right to peruse the available functionality of the selected module.</p><p>Beginners should start with the Core module, which includes the bulk of Parasol's functionality.</p><ul><li><a href="audio.html">Audio</a></li><li><a href="core.html">Core</a></li><li><a href="display.html">Display</a></li><li><a href="document.html">Document</a></li><li><a href="fluid.html">Fluid</a></li><li><a href="font.html">Font</a></li><li><a href="network.html">Network</a></li><li><a href="vector.html">Vector</a></li></ul></div><div class="docs-content" style="display:none;" id="AccessPointer"><h1>AccessPointer()</h1><p class="lead">Returns a lock on the default pointer object.</p><div class="panel panel-info"><div class="panel-heading"><samp>objPointer * gfxAccessPointer()</samp></div></div><h3>Description</h3>
<p>Use AccessPointer() to grab a lock on the default pointer object that is active in the system.  This is typically the first object created from the Pointer class with a name of <code>SystemPointer</code>.</p>
<p>Call ReleaseObject to free the lock once it is no longer required.</p>
    <h3>Result</h3><p>Returns the address of the default pointer object.</p><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="CheckIfChild"><h1>CheckIfChild()</h1><p class="lead">Checks if a surface is a child of another particular surface.</p><div class="panel panel-info"><div class="panel-heading"><samp>ERROR gfxCheckIfChild(OBJECTID Parent, OBJECTID Child)</samp></div><div class="panel-body"><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Parent</td><td>The surface that is assumed to be the parent.</td></tr><tr><td>Child</td><td>The child surface to check.</td></tr></tbody></table></div></div><h3>Description</h3>
<p>This function checks if a surface identified by the Child value is the child of the surface identified by the Parent value.  <code>ERR_True</code> is returned if the surface is confirmed as being a child of the parent, or if the Child and Parent values are equal.  All other return codes indicate false or failure.</p>
    <h3>Error Codes</h3><table class="table table-sm borderless"><tbody><tr><th class="col-md-1">True</th><td>Operation successful.</td></tr><tr><th class="col-md-1">False</th><td>The result is false.</td></tr><tr><th class="col-md-1">Args</th><td>Invalid arguments passed to function.</td></tr><tr><th class="col-md-1">AccessMemory</th><td>Access to a shared memory block was denied.</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="CopyArea"><h1>CopyArea()</h1><p class="lead">Copies a rectangular area from one bitmap to another.</p><div class="panel panel-info"><div class="panel-heading"><samp>ERROR gfxCopyArea(objBitmap * Bitmap, objBitmap * Dest, BAF Flags, LONG X, LONG Y, LONG Width, LONG Height, LONG XDest, LONG YDest)</samp></div><div class="panel-body"><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Bitmap</td><td>The source bitmap.</td></tr><tr><td>Dest</td><td>Pointer to the destination bitmap.</td></tr><tr><td><a onclick="showPage('BAF');">Flags</a></td><td>Optional flags.</td></tr><tr><td>X</td><td>The horizontal position of the area to be copied.</td></tr><tr><td>Y</td><td>The vertical position of the area to be copied.</td></tr><tr><td>Width</td><td>The width of the area.</td></tr><tr><td>Height</td><td>The height of the area.</td></tr><tr><td>XDest</td><td>The horizontal position to copy the area to.</td></tr><tr><td>YDest</td><td>The vertical position to copy the area to.</td></tr></tbody></table></div></div><h3>Description</h3>
<p>This function copies rectangular areas from one bitmap to another.  It performs a straight region-copy only, using the fastest method available.  Bitmaps may be of a different type (e.g. bit depth), however this will result in performance penalties.  The copy process will respect the clipping region defined in both the source and destination bitmap objects.</p>
<p>If the <code>TRANSPARENT</code> flag is set in the source object, all colours that match the ColourIndex field will be ignored in the copy operation.</p>
<p>To enable dithering, pass <code>BAF::DITHER</code> in the Flags argument.  The drawing algorithm will use dithering if the source needs to be down-sampled to the target bitmap's bit depth.  To enable alpha blending, set <code>BAF::BLEND</code> (the source bitmap will also need to have the <code>BMF::ALPHA_CHANNEL</code> flag set to indicate that an alpha channel is available).</p>
<p>The quality of 32-bit alpha blending can be improved by selecting the <code>BAF::LINEAR</code> flag.  This enables an additional computation whereby each RGB value is converted to linear sRGB colour space before performing the blend.  The discernible value of using this option largely depends on the level of opaqueness of either bitmap.  Note that this option is not usable if either bitmap is already in a linear colourspace (<code>ERR_InvalidState</code> will be returned if that is the case).</p>
    <h3>Error Codes</h3><table class="table table-sm borderless"><tbody><tr><th class="col-md-1">Okay</th><td>Operation successful.</td></tr><tr><th class="col-md-1">Mismatch</th><td>A mis-match has been detected that prevents further processing.</td></tr><tr><th class="col-md-1">InvalidState</th><td>Object was in an incorrect state for the operation.</td></tr><tr><th class="col-md-1">NullArgs</th><td>Function call missing argument value(s)</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="CopyRawBitmap"><h1>CopyRawBitmap()</h1><p class="lead">Copies graphics data from an arbitrary surface to a bitmap.</p><div class="panel panel-info"><div class="panel-heading"><samp>ERROR gfxCopyRawBitmap(struct BitmapSurfaceV2 * Surface, objBitmap * Bitmap, CSRF Flags, LONG X, LONG Y, LONG Width, LONG Height, LONG XDest, LONG YDest)</samp></div><div class="panel-body"><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Surface</td><td>Description of the surface source.</td></tr><tr><td>Bitmap</td><td>Destination bitmap.</td></tr><tr><td><a onclick="showPage('CSRF');">Flags</a></td><td>Optional flags.</td></tr><tr><td>X</td><td>Horizontal source coordinate.</td></tr><tr><td>Y</td><td>Vertical source coordinate.</td></tr><tr><td>Width</td><td>Source width.</td></tr><tr><td>Height</td><td>Source height.</td></tr><tr><td>XDest</td><td>Horizontal destination coordinate.</td></tr><tr><td>YDest</td><td>Vertical destination coordinate.</td></tr></tbody></table></div></div><h3>Description</h3>
<p>This function will copy data from a described surface to a destination bitmap object.  You are required to provide the function with a full description of the source in a <code>BitmapSurface</code> structure.</p>
<p>The X, Y, Width and Height parameters define the area from the source that you wish to copy.  The XDest and YDest parameters define the top left corner that you will blit the graphics to in the destination.</p>
    <h3>Error Codes</h3><table class="table table-sm borderless"><tbody><tr><th class="col-md-1">Okay</th><td>Operation successful.</td></tr><tr><th class="col-md-1">Args</th><td>Invalid arguments passed to function.</td></tr><tr><th class="col-md-1">NullArgs</th><td>Function call missing argument value(s)</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="CopySurface"><h1>CopySurface()</h1><p class="lead">Copies surface graphics data into any bitmap object</p><div class="panel panel-info"><div class="panel-heading"><samp>ERROR gfxCopySurface(OBJECTID Surface, objBitmap * Bitmap, BDF Flags, LONG X, LONG Y, LONG Width, LONG Height, LONG XDest, LONG YDest)</samp></div><div class="panel-body"><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Surface</td><td>The ID of the surface object to copy from.</td></tr><tr><td>Bitmap</td><td>Must reference a target Bitmap object.</td></tr><tr><td><a onclick="showPage('BDF');">Flags</a></td><td>Optional flags.</td></tr><tr><td>X</td><td>The horizontal source coordinate.</td></tr><tr><td>Y</td><td>The vertical source coordinate.</td></tr><tr><td>Width</td><td>The width of the graphic that will be copied.</td></tr><tr><td>Height</td><td>The height of the graphic that will be copied.</td></tr><tr><td>XDest</td><td>The horizontal target coordinate.</td></tr><tr><td>YDest</td><td>The vertical target coordinate.</td></tr></tbody></table></div></div><h3>Description</h3>
<p>This function will copy the graphics data from any surface object to a target Bitmap.  This is the fastest and most convenient way to get graphics information out of any surface.  As surfaces are buffered, it is guaranteed that the result will not be obscured by any overlapping surfaces that are on the display.</p>
    <h3>Error Codes</h3><table class="table table-sm borderless"><tbody><tr><th class="col-md-1">Okay</th><td>Operation successful.</td></tr><tr><th class="col-md-1">Search</th><td>A search routine in this function failed.</td></tr><tr><th class="col-md-1">AccessMemory</th><td>Access to a shared memory block was denied.</td></tr><tr><th class="col-md-1">NullArgs</th><td>Function call missing argument value(s)</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="DrawPixel"><h1>DrawPixel()</h1><p class="lead">Draws a single pixel to a bitmap.</p><div class="panel panel-info"><div class="panel-heading"><samp>void gfxDrawPixel(objBitmap * Bitmap, LONG X, LONG Y, ULONG Colour)</samp></div><div class="panel-body"><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Bitmap</td><td>The target bitmap object.</td></tr><tr><td>X</td><td>The horizontal coordinate of the pixel.</td></tr><tr><td>Y</td><td>The vertical coordinate of the pixel.</td></tr><tr><td>Colour</td><td>The colour value to use for the pixel.</td></tr></tbody></table></div></div><h3>Description</h3>
<p>This function draws a pixel to the coordinates X, Y on a bitmap with a colour determined by the Colour index. This function will check the given coordinates to make sure that the pixel is inside the bitmap's clipping area.</p>
    <div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="DrawRGBPixel"><h1>DrawRGBPixel()</h1><p class="lead">Draws a 24 bit pixel to a bitmap.</p><div class="panel panel-info"><div class="panel-heading"><samp>void gfxDrawRGBPixel(objBitmap * Bitmap, LONG X, LONG Y, struct RGB8 * RGB)</samp></div><div class="panel-body"><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Bitmap</td><td>The target bitmap object.</td></tr><tr><td>X</td><td>Horizontal coordinate of the pixel.</td></tr><tr><td>Y</td><td>Vertical coordinate of the pixel.</td></tr><tr><td>RGB</td><td>The colour to be drawn, in RGB format.</td></tr></tbody></table></div></div><h3>Description</h3>
<p>This function draws an RGB colour to the (X, Y) position of a target bitmap.  The function will check the given coordinates to ensure that the pixel is inside the bitmap's clipping area.</p>
    <div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="DrawRectangle"><h1>DrawRectangle()</h1><p class="lead">Draws rectangles, both filled and unfilled.</p><div class="panel panel-info"><div class="panel-heading"><samp>void gfxDrawRectangle(objBitmap * Bitmap, LONG X, LONG Y, LONG Width, LONG Height, ULONG Colour, BAF Flags)</samp></div><div class="panel-body"><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Bitmap</td><td>Pointer to the target Bitmap.</td></tr><tr><td>X</td><td>The left-most coordinate of the rectangle.</td></tr><tr><td>Y</td><td>The top-most coordinate of the rectangle.</td></tr><tr><td>Width</td><td>The width of the rectangle.</td></tr><tr><td>Height</td><td>The height of the rectangle.</td></tr><tr><td>Colour</td><td>The colour value to use for the rectangle.</td></tr><tr><td><a onclick="showPage('BAF');">Flags</a></td><td>Use FILL to fill the rectangle.  Use of BLEND will enable blending.</td></tr></tbody></table></div></div><h3>Description</h3>
<p>This function draws both filled and unfilled rectangles.  The rectangle is drawn to the target bitmap at position (X, Y) with dimensions determined by the specified Width and Height.  If the Flags parameter defines <code>BAF::FILL</code> then the rectangle will be filled, otherwise only the outline will be drawn.  The colour of the rectangle is determined by the pixel value in the Colour argument.  Blending is not enabled unless the <code>BAF::BLEND</code> flag is defined and an alpha value is present in the Colour.</p>
    <div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="ExposeSurface"><h1>ExposeSurface()</h1><p class="lead">Exposes the content of a surface to the display.</p><div class="panel panel-info"><div class="panel-heading"><samp>ERROR gfxExposeSurface(OBJECTID Surface, LONG X, LONG Y, LONG Width, LONG Height, EXF Flags)</samp></div><div class="panel-body"><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Surface</td><td>The ID of the surface object that will be exposed.</td></tr><tr><td>X</td><td>The horizontal coordinate of the area to expose.</td></tr><tr><td>Y</td><td>The vertical coordinate of the area to expose.</td></tr><tr><td>Width</td><td>The width of the expose area.</td></tr><tr><td>Height</td><td>The height of the expose area.</td></tr><tr><td><a onclick="showPage('EXF');">Flags</a></td><td>Optional flags - using CHILDREN will expose all intersecting child regions.</td></tr></tbody></table></div></div><h3>Description</h3>
<p>This expose routine will expose all content within a defined surface area, copying it to the display.  This will include all child surfaces that intersect with the region being exposed if you set the <code>EXF::CHILDREN</code> flag.</p>
    <h3>Error Codes</h3><table class="table table-sm borderless"><tbody><tr><th class="col-md-1">Okay</th><td>Operation successful.</td></tr><tr><th class="col-md-1">Search</th><td>A search routine in this function failed.</td></tr><tr><th class="col-md-1">AccessMemory</th><td>Access to a shared memory block was denied.</td></tr><tr><th class="col-md-1">NullArgs</th><td>Function call missing argument value(s)</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="FlipBitmap"><h1>FlipBitmap()</h1><p class="lead">Flips a bitmap around its horizontal or vertical axis.</p><div class="panel panel-info"><div class="panel-heading"><samp>void gfxFlipBitmap(objBitmap * Bitmap, FLIP Orientation)</samp></div><div class="panel-body"><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Bitmap</td><td>Pointer to a bitmap object.</td></tr><tr><td><a onclick="showPage('FLIP');">Orientation</a></td><td>Set to either FLIP_HORIZONTAL or FLIP_VERTICAL.  If set to neither, the function does nothing.</td></tr></tbody></table></div></div><h3>Description</h3>
<p>The FlipBitmap() function is used to flip bitmap images on their horizontal or vertical axis.  The amount of time required to flip a bitmap is dependent on the area of the bitmap you are trying to flip over and its total number of colours.</p>
    <div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="GetColourFormat"><h1>GetColourFormat()</h1><p class="lead">Generates the values for a ColourFormat structure for a given bit depth.</p><div class="panel panel-info"><div class="panel-heading"><samp>void gfxGetColourFormat(struct ColourFormat * Format, LONG BitsPerPixel, LONG RedMask, LONG GreenMask, LONG BlueMask, LONG AlphaMask)</samp></div><div class="panel-body"><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Format</td><td>Pointer to an empty ColourFormat structure.</td></tr><tr><td>BitsPerPixel</td><td>The depth that you would like to generate colour values for.  Ignored if mask values are set.</td></tr><tr><td>RedMask</td><td>Red component bit mask value.  Set this value to zero if the BitsPerPixel argument is used.</td></tr><tr><td>GreenMask</td><td>Green component bit mask value.</td></tr><tr><td>BlueMask</td><td>Blue component bit mask value.</td></tr><tr><td>AlphaMask</td><td>Alpha component bit mask value.</td></tr></tbody></table></div></div><h3>Description</h3>
<p>This function will generate the values for a <code>ColourFormat</code> structure, for either a given bit depth or customised colour bit values.  The <code>ColourFormat</code> structure is used by internal bitmap routines to pack and unpack bit values to and from bitmap memory.</p>
<pre>struct ColourFormat {
   UBYTE  RedShift;    // Right shift value (applies only to 15/16 bit formats for eliminating redundant bits)
   UBYTE  BlueShift;
   UBYTE  GreenShift;
   UBYTE  AlphaShift;
   UBYTE  RedMask;     // The unshifted mask value (ranges from 0x00 to 0xff)
   UBYTE  GreenMask;
   UBYTE  BlueMask;
   UBYTE  AlphaMask;
   UBYTE  RedPos;      // Left shift/positional value
   UBYTE  GreenPos;
   UBYTE  BluePos;
   UBYTE  AlphaPos;
};
</pre>
<p>The <code>ColourFormat</code> structure is supported by the following macros for packing and unpacking colour bit values:</p>
<pre>Colour = CFPackPixel(Format,Red,Green,Blue)
Colour = CFPackPixelA(Format,Red,Green,Blue,Alpha)
Colour = CFPackAlpha(Format,Alpha)
Red    = CFUnpackRed(Format,Colour)
Green  = CFUnpackGreen(Format,Colour)
Blue   = CFUnpackBlue(Format,Colour)
Alpha  = CFUnpackAlpha(Format,Colour)
</pre>
    <div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="GetCursorInfo"><h1>GetCursorInfo()</h1><p class="lead">Retrieves graphics information from the active mouse cursor.</p><div class="panel panel-info"><div class="panel-heading"><samp>ERROR gfxGetCursorInfo(struct CursorInfo * Info, LONG Size)</samp></div><div class="panel-body"><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Info</td><td>Pointer to a CursorInfo structure.</td></tr><tr><td>Size</td><td>The byte-size of the Info structure.</td></tr></tbody></table></div></div><h3>Description</h3>
<p>The GetCursorInfo() function is used to retrieve useful information on the graphics structure of the mouse cursor.  It will return the maximum possible dimensions for custom cursor graphics and indicates the optimal bits-per-pixel setting for the hardware cursor.</p>
<p>If there is no cursor (e.g. this is likely on touch-screen devices) then all field values will be set to zero.</p>
<p>Note: If the hardware cursor is monochrome, the bits-per-pixel setting will be set to 2 on return.  This does not indicate a 4 colour cursor image; rather colour 0 is the mask, 1 is the foreground colour (black), 2 is the background colour (white) and 3 is an XOR pixel.  When creating the bitmap, always set the palette to the RGB values that are wanted.  The mask colour for the bitmap must refer to colour index 0.</p>
    <h3>Error Codes</h3><table class="table table-sm borderless"><tbody><tr><th class="col-md-1">Okay</th><td>Operation successful.</td></tr><tr><th class="col-md-1">NoSupport</th><td>This request is not supported.</td></tr><tr><th class="col-md-1">NullArgs</th><td>Function call missing argument value(s)</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="GetCursorPos"><h1>GetCursorPos()</h1><p class="lead">Returns the coordinates of the UI pointer.</p><div class="panel panel-info"><div class="panel-heading"><samp>ERROR gfxGetCursorPos(DOUBLE * X, DOUBLE * Y)</samp></div><div class="panel-body"><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>X</td><td>32-bit variable that will store the pointer's horizontal coordinate.</td></tr><tr><td>Y</td><td>32-bit variable that will store the pointer's vertical coordinate.</td></tr></tbody></table></div></div><h3>Description</h3>
<p>This function is used to retrieve the current coordinates of the user interface pointer.  If the device is touch-screen based then the coordinates will reflect the last position that a touch event occurred.</p>
    <h3>Error Codes</h3><table class="table table-sm borderless"><tbody><tr><th class="col-md-1">Okay</th><td>Operation successful.</td></tr><tr><th class="col-md-1">AccessObject</th><td>An attempt to gain exclusive access to a shared object failed.</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="GetDisplayInfo"><h1>GetDisplayInfo()</h1><p class="lead">Retrieves display information.</p><div class="panel panel-info"><div class="panel-heading"><samp>ERROR gfxGetDisplayInfo(OBJECTID Display, struct DisplayInfoV3 ** Info)</samp></div><div class="panel-body"><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Display</td><td>Object ID of the display to be analysed.</td></tr><tr><td>Info</td><td>This reference will receive a pointer to a DISPLAYINFO structure.</td></tr></tbody></table></div></div><h3>Description</h3>
<p>The GetDisplayInfo() function returns information about a display, which includes information such as its size and bit depth.  If the system is running on a hosted display (e.g. Windows or X11) then GetDisplayInfo() can also be used to retrieve information about the default monitor by using a Display of zero.</p>
<p>The resulting <code>DISPLAYINFO</code> structure values remain good until the next call to this function, at which point they will be overwritten.</p>
    <h3>Error Codes</h3><table class="table table-sm borderless"><tbody><tr><th class="col-md-1">Okay</th><td>Operation successful.</td></tr><tr><th class="col-md-1">AllocMemory</th><td>A call to AllocMemory() failed to create a new memory block.</td></tr><tr><th class="col-md-1">NullArgs</th><td>Function call missing argument value(s)</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="GetDisplayType"><h1>GetDisplayType()</h1><p class="lead">Returns the type of display supported.</p><div class="panel panel-info"><div class="panel-heading"><samp>DT gfxGetDisplayType()</samp></div></div><h3>Description</h3>
<p>This function returns the type of display supported by the loaded Display module.  Current return values are:</p>
<table class="table"><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><th>DT_GLES</th><td>The display is driven by OpenGLES.</td></tr><tr><th>DT_NATIVE</th><td>The display is native (supported by internal drivers).</td></tr><tr><th>DT_WINGDI</th><td>The display is driven by Microsoft Windows drivers.</td></tr><tr><th>DT_X11</th><td>The display is driven by the X Window System (X11, X.Org, XFree86)</td></tr></tbody></table>
    <h3>Result</h3><p>Returns an integer indicating the display type.</p><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="GetInputTypeName"><h1>GetInputTypeName()</h1><p class="lead">Returns the string name for an input type.</p><div class="panel panel-info"><div class="panel-heading"><samp>CSTRING gfxGetInputTypeName(JET Type)</samp></div><div class="panel-body"><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td><a onclick="showPage('JET');">Type</a></td><td>JET type integer.</td></tr></tbody></table></div></div><h3>Description</h3>
<p>This function converts JET integer constants to their string equivalent.</p>
    <h3>Result</h3><p>A string describing the input type is returned or NULL if the Type is invalid.</p><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="GetModalSurface"><h1>GetModalSurface()</h1><p class="lead">Returns the current modal surface (if defined).</p><div class="panel panel-info"><div class="panel-heading"><samp>OBJECTID gfxGetModalSurface()</samp></div></div><h3>Description</h3>
<p>This function returns the modal surface for the running process.  Returns zero if no modal surface is active.</p>
    <h3>Result</h3><p>The UID of the modal surface, or zero.</p><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="GetRelativeCursorPos"><h1>GetRelativeCursorPos()</h1><p class="lead">Returns the coordinates of the pointer cursor, relative to a surface object.</p><div class="panel panel-info"><div class="panel-heading"><samp>ERROR gfxGetRelativeCursorPos(OBJECTID Surface, DOUBLE * X, DOUBLE * Y)</samp></div><div class="panel-body"><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Surface</td><td>Unique ID of the surface that the coordinates need to be relative to.</td></tr><tr><td>X</td><td>32-bit variable that will store the pointer's horizontal coordinate.</td></tr><tr><td>Y</td><td>32-bit variable that will store the pointer's vertical coordinate.</td></tr></tbody></table></div></div><h3>Description</h3>
<p>This function is used to retrieve the current coordinates of the pointer cursor. The coordinates are relative to the surface object that is specified in the Surface argument.</p>
<p>The X and Y parameters will not be set if a failure occurs.</p>
    <h3>Error Codes</h3><table class="table table-sm borderless"><tbody><tr><th class="col-md-1">Okay</th><td>Operation successful.</td></tr><tr><th class="col-md-1">AccessObject</th><td>An attempt to gain exclusive access to a shared object failed.</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="GetSurfaceCoords"><h1>GetSurfaceCoords()</h1><p class="lead">Returns the dimensions of a surface.</p><div class="panel panel-info"><div class="panel-heading"><samp>ERROR gfxGetSurfaceCoords(OBJECTID Surface, LONG * X, LONG * Y, LONG * AbsX, LONG * AbsY, LONG * Width, LONG * Height)</samp></div><div class="panel-body"><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Surface</td><td>The surface to query.  If zero, the top-level display is queried.</td></tr><tr><td>X</td><td>The X coordinate of the surface is returned here.</td></tr><tr><td>Y</td><td>The Y coordinate of the surface is returned here.</td></tr><tr><td>AbsX</td><td>The absolute X coordinate of the surface is returned here.</td></tr><tr><td>AbsY</td><td>The absolute Y coordinate of the surface is returned here.</td></tr><tr><td>Width</td><td>The width of the surface is returned here.</td></tr><tr><td>Height</td><td>The height of the surface is returned here.</td></tr></tbody></table></div></div><h3>Description</h3>
<p>GetSurfaceCoords() retrieves the dimensions that describe a surface object's area as X, Y, Width and Height.  This is the fastest way to retrieve surface dimensions when access to the object structure is not already available.</p>
    <h3>Error Codes</h3><table class="table table-sm borderless"><tbody><tr><th class="col-md-1">Okay</th><td>Operation successful.</td></tr><tr><th class="col-md-1">Search</th><td>A search routine in this function failed.</td></tr><tr><th class="col-md-1">AccessMemory</th><td>Access to a shared memory block was denied.</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="GetSurfaceFlags"><h1>GetSurfaceFlags()</h1><p class="lead">Retrieves the Flags field from a surface.</p><div class="panel panel-info"><div class="panel-heading"><samp>ERROR gfxGetSurfaceFlags(OBJECTID Surface, RNF * Flags)</samp></div><div class="panel-body"><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Surface</td><td>The surface to query.  If zero, the top-level surface is queried.</td></tr><tr><td><a onclick="showPage('RNF');">Flags</a></td><td>The flags value is returned here.</td></tr></tbody></table></div></div><h3>Description</h3>
<p>This function returns the current Flags field from a surface.  It provides the same result as reading the field directly, however it is considered advantageous in circumstances where the overhead of locking a surface object for a read operation is undesirable.</p>
<p>For information on the available flags, please refer to the Flags field of the Surface class.</p>
    <h3>Error Codes</h3><table class="table table-sm borderless"><tbody><tr><th class="col-md-1">Okay</th><td>Operation successful.</td></tr><tr><th class="col-md-1">AccessMemory</th><td>Access to a shared memory block was denied.</td></tr><tr><th class="col-md-1">NullArgs</th><td>Function call missing argument value(s)</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="GetSurfaceInfo"><h1>GetSurfaceInfo()</h1><p class="lead">Retrieves display information for any surface object without having to access it directly.</p><div class="panel panel-info"><div class="panel-heading"><samp>ERROR gfxGetSurfaceInfo(OBJECTID Surface, struct SurfaceInfoV2 ** Info)</samp></div><div class="panel-body"><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Surface</td><td>The unique ID of a surface to query.  If zero, the root surface is returned.</td></tr><tr><td>Info</td><td>This parameter will receive a SurfaceInfo pointer that describes the Surface object.</td></tr></tbody></table></div></div><h3>Description</h3>
<p>GetSurfaceInfo() is used for quickly retrieving basic information from surfaces, allowing the client to bypass the AccessObject() function.  The resulting structure values are good only up until the next call to this function, at which point those values will be overwritten.</p>
    <h3>Error Codes</h3><table class="table table-sm borderless"><tbody><tr><th class="col-md-1">Okay</th><td>Operation successful.</td></tr><tr><th class="col-md-1">Search</th><td>A search routine in this function failed.</td></tr><tr><th class="col-md-1">Args</th><td>Invalid arguments passed to function.</td></tr><tr><th class="col-md-1">AccessMemory</th><td>Access to a shared memory block was denied.</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="GetUserFocus"><h1>GetUserFocus()</h1><p class="lead">Returns the ID of the surface that currently has the user's focus.</p><div class="panel panel-info"><div class="panel-heading"><samp>OBJECTID gfxGetUserFocus()</samp></div></div><h3>Description</h3>
<p>This function returns the unique ID of the surface that has the user's focus.</p>
    <h3>Result</h3><p>Returns the ID of the surface object that has the user focus, or zero on failure.</p><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="GetVisibleArea"><h1>GetVisibleArea()</h1><p class="lead">Returns the visible region of a surface.</p><div class="panel panel-info"><div class="panel-heading"><samp>ERROR gfxGetVisibleArea(OBJECTID Surface, LONG * X, LONG * Y, LONG * AbsX, LONG * AbsY, LONG * Width, LONG * Height)</samp></div><div class="panel-body"><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Surface</td><td>The surface to query.  If zero, the top-level display will be queried.</td></tr><tr><td>X</td><td>The X coordinate of the visible area.</td></tr><tr><td>Y</td><td>The Y coordinate of the visible area.</td></tr><tr><td>AbsX</td><td>The absolute X coordinate of the visible area.</td></tr><tr><td>AbsY</td><td>The absolute Y coordinate of the visible area.</td></tr><tr><td>Width</td><td>The visible width of the surface.</td></tr><tr><td>Height</td><td>The visible height of the surface.</td></tr></tbody></table></div></div><h3>Description</h3>
<p>The GetVisibleArea() function returns the visible area of a surface, which is based on its position within its parent surfaces. The resulting coordinates are relative to point <code>0,0</code> of the queried surface. If the surface is not obscured, then the resulting coordinates will be <code>(0,0),(Width,Height)</code>.</p>
    <h3>Error Codes</h3><table class="table table-sm borderless"><tbody><tr><th class="col-md-1">Okay</th><td>Operation successful.</td></tr><tr><th class="col-md-1">Search</th><td>A search routine in this function failed.</td></tr><tr><th class="col-md-1">AccessMemory</th><td>Access to a shared memory block was denied.</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="LockBitmap"><h1>LockBitmap()</h1><p class="lead">Returns a bitmap that represents the video area covered by the surface object.</p><div class="panel panel-info"><div class="panel-heading"><samp>ERROR gfxLockBitmap(OBJECTID Surface, objBitmap ** Bitmap, LVF * Info)</samp></div><div class="panel-body"><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Surface</td><td>Object ID of the surface object that you want to lock.</td></tr><tr><td>Bitmap</td><td>The resulting bitmap will be returned in this parameter.</td></tr><tr><td><a onclick="showPage('LVF');">Info</a></td><td>Special flags may be returned in this parameter.  If EXPOSE_CHANGES is returned, any changes must be exposed in order for them to be displayed to the user.</td></tr></tbody></table></div></div><h3>Description</h3>
<p>Use the LockBitmap() function to gain direct access to the bitmap information of a surface object. Because the layering buffer will be inaccessible to the UI whilst you retain the lock, you must keep your access time to an absolute minimum or desktop performance may suffer.</p>
<p>Repeated calls to this function will nest.  To release a surface bitmap, call the UnlockBitmap function.</p>
    <h3>Error Codes</h3><table class="table table-sm borderless"><tbody><tr><th class="col-md-1">Okay</th><td>Operation successful.</td></tr><tr><th class="col-md-1">Args</th><td>Invalid arguments passed to function.</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="LockCursor"><h1>LockCursor()</h1><p class="lead">Anchors the cursor so that it cannot move without explicit movement signals.</p><div class="panel panel-info"><div class="panel-heading"><samp>ERROR gfxLockCursor(OBJECTID Surface)</samp></div><div class="panel-body"><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Surface</td><td>Refers to the surface object that the pointer should send movement signals to.</td></tr></tbody></table></div></div><h3>Description</h3>
<p>The LockCursor() function will lock the current pointer position and pass UserMovement signals to the surface referenced in the Surface parameter.  The pointer will not move unless the SetCursorPos function is called. The anchor is granted on a time-limited basis.  It is necessary to reissue the anchor every time that a UserMovement signal is intercepted.  Failure to reissue the anchor will return the pointer to its normal state, typically within 200 microseconds.</p>
<p>The anchor can be released at any time by calling the UnlockCursor function.</p>
    <h3>Error Codes</h3><table class="table table-sm borderless"><tbody><tr><th class="col-md-1">Okay</th><td>Operation successful.</td></tr><tr><th class="col-md-1">NoSupport</th><td>This request is not supported.</td></tr><tr><th class="col-md-1">AccessObject</th><td>An attempt to gain exclusive access to a shared object failed.</td></tr><tr><th class="col-md-1">NullArgs</th><td>Function call missing argument value(s)</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="ReadPixel"><h1>ReadPixel()</h1><p class="lead">Reads a pixel's colour from the target bitmap.</p><div class="panel panel-info"><div class="panel-heading"><samp>ULONG gfxReadPixel(objBitmap * Bitmap, LONG X, LONG Y)</samp></div><div class="panel-body"><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Bitmap</td><td>Pointer to a bitmap object.</td></tr><tr><td>X</td><td>The horizontal coordinate of the pixel.</td></tr><tr><td>Y</td><td>The vertical coordinate of the pixel.</td></tr></tbody></table></div></div><h3>Description</h3>
<p>This function reads a pixel from a bitmap area and returns its colour index (if the Bitmap is indexed with a palette) or its packed pixel value.  Zero is returned if the pixel is out of bounds.</p>
    <h3>Result</h3><p>The colour value of the pixel will be returned.  Zero is returned if the pixel is out of bounds.</p><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="ReadRGBPixel"><h1>ReadRGBPixel()</h1><p class="lead">Reads a pixel's colour from the target bitmap.</p><div class="panel panel-info"><div class="panel-heading"><samp>void gfxReadRGBPixel(objBitmap * Bitmap, LONG X, LONG Y, struct RGB8 ** RGB)</samp></div><div class="panel-body"><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Bitmap</td><td>Pointer to a bitmap object.</td></tr><tr><td>X</td><td>The horizontal coordinate of the pixel.</td></tr><tr><td>Y</td><td>The vertical coordinate of the pixel.</td></tr><tr><td>RGB</td><td>The colour values will be stored in this RGB structure.</td></tr></tbody></table></div></div><h3>Description</h3>
<p>This function reads a pixel from a bitmap surface and returns the value in an RGB structure that remains good up until the next call to this function.  Zero is returned in the alpha component if the pixel is out of bounds.</p>
<p>This function is thread-safe if the target Bitmap is locked.</p>
    <div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="Resample"><h1>Resample()</h1><p class="lead">Resamples a bitmap by dithering it to a new set of colour masks.</p><div class="panel panel-info"><div class="panel-heading"><samp>ERROR gfxResample(objBitmap * Bitmap, struct ColourFormat * ColourFormat)</samp></div><div class="panel-body"><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Bitmap</td><td>The bitmap object to be resampled.</td></tr><tr><td>ColourFormat</td><td>The new colour format to be applied to the bitmap.</td></tr></tbody></table></div></div><h3>Description</h3>
<p>The Resample() function provides a means for resampling a bitmap to a new colour format without changing the actual bit depth of the image. It uses dithering so as to retain the quality of the image when down-sampling.  This function is generally used to 'pre-dither' true colour bitmaps in preparation for copying to bitmaps with lower colour quality.</p>
<p>You are required to supply a ColourFormat structure that describes the colour format that you would like to apply to the bitmap's image data.</p>
    <h3>Error Codes</h3><table class="table table-sm borderless"><tbody><tr><th class="col-md-1">Okay</th><td>Operation successful.</td></tr><tr><th class="col-md-1">NullArgs</th><td>Function call missing argument value(s)</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="RestoreCursor"><h1>RestoreCursor()</h1><p class="lead">Returns the pointer image to its original state.</p><div class="panel panel-info"><div class="panel-heading"><samp>ERROR gfxRestoreCursor(PTC Cursor, OBJECTID Owner)</samp></div><div class="panel-body"><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td><a onclick="showPage('PTC');">Cursor</a></td><td>The cursor image that the pointer will be restored to (0 for the default).</td></tr><tr><td>Owner</td><td>The ownership ID that was given in the initial call to SetCursor().</td></tr></tbody></table></div></div><h3>Description</h3>
<p>Use the RestoreCursor() function to undo an earlier call to SetCursor.  It is necessary to provide the same OwnerID that was used in the original call to SetCursor.</p>
<p>To release ownership of the cursor without changing the current cursor image, use a Cursor setting of <code>PTC::NOCHANGE</code>.</p>
    <h3>Error Codes</h3><table class="table table-sm borderless"><tbody><tr><th class="col-md-1">Okay</th><td>Operation successful.</td></tr><tr><th class="col-md-1">Args</th><td>Invalid arguments passed to function.</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="ScaleToDPI"><h1>ScaleToDPI()</h1><p class="lead">Scales a value to the active display's DPI.</p><div class="panel panel-info"><div class="panel-heading"><samp>DOUBLE gfxScaleToDPI(DOUBLE Value)</samp></div><div class="panel-body"><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Value</td><td>The number to be scaled.</td></tr></tbody></table></div></div><h3>Description</h3>
<p>ScaleToDPI() is a convenience function for scaling any value to the active display's current DPI setting.  The value that you provide must be fixed in relation to the system wide default of 96 DPI.  If the display's DPI varies differs to that, your value will be scaled to match.  For instance, an 8 point font at 96 DPI would be scaled to 20 points if the display was 240 DPI.</p>
<p>If the DPI of the display is unknown, your value will be returned unscaled.</p>
    <h3>Result</h3><p>The scaled value is returned.</p><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="SetClipRegion"><h1>SetClipRegion()</h1><p class="lead">Sets a clipping region for a bitmap object.</p><div class="panel panel-info"><div class="panel-heading"><samp>void gfxSetClipRegion(objBitmap * Bitmap, LONG Number, LONG Left, LONG Top, LONG Right, LONG Bottom, LONG Terminate)</samp></div><div class="panel-body"><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Bitmap</td><td>The target bitmap.</td></tr><tr><td>Number</td><td>The number of the clip region to set.</td></tr><tr><td>Left</td><td>The horizontal start of the clip region.</td></tr><tr><td>Top</td><td>The vertical start of the clip region.</td></tr><tr><td>Right</td><td>The right-most edge of the clip region.</td></tr><tr><td>Bottom</td><td>The bottom-most edge of the clip region.</td></tr><tr><td>Terminate</td><td>Set to TRUE if this is the last clip region in the list, otherwise FALSE.</td></tr></tbody></table></div></div><h3>Description</h3>
<p>The SetClipRegion() method is used to manage the clipping regions assigned to a bitmap object.  Each new bitmap that is created has at least one clip region assigned to it, but by using SetClipRegion() you can also define multiple clipping areas, which is useful for complex graphics management.</p>
<p>Each clipping region that you set is assigned a Number, starting from zero which is the default.  Each time that you set a new clip region you must specify the number of the region that you wish to set.  If you attempt to 'skip' regions - for instance, if you set regions 0, 1, 2 and 3, then skip 4 and set 5, the routine will set region 4 instead. If you have specified multiple clip regions and want to lower the count or reset the list, set the number of the last region that you want in your list and set the Terminate argument to TRUE to kill the regions specified beyond it.</p>
<p>The <code>ClipLeft</code>, <code>ClipTop</code>, <code>ClipRight</code> and <code>ClipBottom</code> fields in the target Bitmap will be updated to reflect the overall area that is covered by the clipping regions that have been set.</p>
    <div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="SetCursor"><h1>SetCursor()</h1><p class="lead">Sets the cursor image and can anchor the pointer to any surface.</p><div class="panel panel-info"><div class="panel-heading"><samp>ERROR gfxSetCursor(OBJECTID Surface, CRF Flags, PTC Cursor, CSTRING Name, OBJECTID Owner)</samp></div><div class="panel-body"><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Surface</td><td>Refers to the surface object that the pointer should anchor itself to, if the RESTRICT flag is used.  Otherwise, this parameter can be set to a surface that the new cursor image should be limited to.  The object referred to here must be publicly accessible to all tasks.</td></tr><tr><td><a onclick="showPage('CRF');">Flags</a></td><td>Optional flags that affect the cursor.</td></tr><tr><td><a onclick="showPage('PTC');">Cursor</a></td><td>The ID of the cursor image that is to be set.</td></tr><tr><td>Name</td><td>The name of the cursor image that is to be set (if Cursor is zero).</td></tr><tr><td>Owner</td><td>The object nominated as the owner of the anchor, and/or owner of the cursor image setting.</td></tr></tbody></table></div></div><h3>Description</h3>
<p>Use the SetCursor() function to change the pointer image and/or restrict the movement of the pointer to a surface area.</p>
<p>To change the cursor image, set the Cursor or Name parameters to define the new image.  Valid cursor ID's and their equivalent names are listed in the documentation for the Cursor field.  If the ObjectID field is set to a valid surface, then the cursor image will switch back to the default setting once the pointer moves outside of its region.  If both the Cursor and Name parameters are NULL, the cursor image will remain unchanged from its current image.</p>
<p>The SetCursor() function accepts the following flags in the Flags parameter:</p>
<table class="table"><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><th>CRF_BUFFER</th><td>Use of the BUFFER option allows the cursor request to be buffered in the event that the cursor is locked at the time of calling the SetCursor() function.  Use of this flag is highly recommended in most circumstances, but may not be used in conjunction with the ANCHOR option.</td></tr><tr><th>CRF_LMB</th><td>Release the cursor after the left mouse button is held and released.</td></tr><tr><th>CRF_MMB</th><td>Release the cursor after the middle mouse button is held and released.</td></tr><tr><th>CRF_NO_BUTTONS</th><td>Set the cursor only on the condition that the user is not holding down any buttons.  ERR_NothingDone is returned if the user has a button held down.</td></tr><tr><th>CRF_RESTRICT</th><td>Similar to the anchor option, but allows the pointer to move within the surface referred to by ObjectID.</td></tr><tr><th>CRF_RMB</th><td>Release the cursor after the right mouse button is held and released.</td></tr></tbody></table>
<p>The Owner parameter is used as a locking mechanism to prevent the cursor from being changed whilst it is locked.  We recommend that it is set to an object ID such as the program's task ID.  As the owner, the cursor remains under your program's control until RestoreCursor is called.</p>
    <h3>Error Codes</h3><table class="table table-sm borderless"><tbody><tr><th class="col-md-1">Okay</th><td>Operation successful.</td></tr><tr><th class="col-md-1">Args</th><td>Invalid arguments passed to function.</td></tr><tr><th class="col-md-1">NoSupport</th><td>This request is not supported.</td></tr><tr><th class="col-md-1">OutOfRange</th><td>A specified number is outside of the valid range.</td></tr><tr><th class="col-md-1">AccessObject</th><td>An attempt to gain exclusive access to a shared object failed.</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="SetCursorPos"><h1>SetCursorPos()</h1><p class="lead">Changes the position of the pointer cursor.</p><div class="panel panel-info"><div class="panel-heading"><samp>ERROR gfxSetCursorPos(DOUBLE X, DOUBLE Y)</samp></div><div class="panel-body"><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>X</td><td>The new horizontal coordinate for the pointer.</td></tr><tr><td>Y</td><td>The new vertical coordinate for the pointer.</td></tr></tbody></table></div></div><h3>Description</h3>
<p>Changes the position of the pointer cursor using coordinates relative to the entire display.</p>
    <h3>Error Codes</h3><table class="table table-sm borderless"><tbody><tr><th class="col-md-1">Okay</th><td>Operation successful.</td></tr><tr><th class="col-md-1">AccessObject</th><td>An attempt to gain exclusive access to a shared object failed.</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="SetCustomCursor"><h1>SetCustomCursor()</h1><p class="lead">Sets the cursor to a customised bitmap image.</p><div class="panel panel-info"><div class="panel-heading"><samp>ERROR gfxSetCustomCursor(OBJECTID Surface, CRF Flags, objBitmap * Bitmap, LONG HotX, LONG HotY, OBJECTID Owner)</samp></div><div class="panel-body"><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Surface</td><td>Refers to the surface object that the pointer should restrict itself to, if the RESTRICT flag is used.  Otherwise, this parameter can be set to a surface that the new cursor image should be limited to.  The object referred to here must be publicly accessible to all tasks.</td></tr><tr><td><a onclick="showPage('CRF');">Flags</a></td><td>Optional flags affecting the cursor are set here.</td></tr><tr><td>Bitmap</td><td>The bitmap to set for the mouse cursor.</td></tr><tr><td>HotX</td><td>The horizontal position of the cursor hot-spot.</td></tr><tr><td>HotY</td><td>The vertical position of the cursor hot-spot.</td></tr><tr><td>Owner</td><td>The object nominated as the owner of the anchor.</td></tr></tbody></table></div></div><h3>Description</h3>
<p>Use the SetCustomCursor() function to change the pointer image and/or anchor the position of the pointer so that it cannot move without permission.  The functionality provided is identical to that of the SetCursor() function with some minor adjustments to allow custom images to be set.</p>
<p>The Bitmap that is provided should be within the width, height and bits-per-pixel settings that are returned by the GetCursorInfo() function.  If the basic settings are outside the allowable parameters, the Bitmap will be trimmed or resampled appropriately when the cursor is downloaded to the video card.</p>
<p>It may be possible to speed up the creation of custom cursors by drawing directly to the pointer's internal bitmap buffer rather than supplying a fresh bitmap.  To do this, the Bitmap parameter must be NULL and it is necessary to draw to the pointer's bitmap before calling SetCustomCursor().  Note that the bitmap is always returned as a 32-bit, alpha-enabled graphics area.  The following code illustrates this process:</p>
<pre>if (auto pointer = gfxAccessPointer()) {
   objBitmap *bitmap;
   if (!AccessObject(pointer-&gt;BitmapID, 3000, &amp;bitmap)) {
      // Adjust clipping to match the cursor size.
      buffer-&gt;Clip.Right  = CursorWidth;
      buffer-&gt;Clip.Bottom = CursorHeight;
      if (buffer-&gt;Clip.Right &gt; buffer-&gt;Width) buffer-&gt;Clip.Right = buffer-&gt;Width;
      if (buffer-&gt;Clip.Bottom &gt; buffer-&gt;Height) buffer-&gt;Clip.Bottom = buffer-&gt;Height;

      // Draw to the bitmap here.
      ...

      gfxSetCustomCursor(ObjectID, NULL, NULL, 1, 1, glTaskID, NULL);
      ReleaseObject(bitmap);
   }
   gfxReleasePointer(pointer);
}
</pre>
    <h3>Error Codes</h3><table class="table table-sm borderless"><tbody><tr><th class="col-md-1">Okay</th><td>Operation successful.</td></tr><tr><th class="col-md-1">Args</th><td>Invalid arguments passed to function.</td></tr><tr><th class="col-md-1">NoSupport</th><td>This request is not supported.</td></tr><tr><th class="col-md-1">AccessObject</th><td>An attempt to gain exclusive access to a shared object failed.</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="SetHostOption"><h1>SetHostOption()</h1><p class="lead">Alter options associated with the host display system.</p><div class="panel panel-info"><div class="panel-heading"><samp>ERROR gfxSetHostOption(HOST Option, LARGE Value)</samp></div><div class="panel-body"><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td><a onclick="showPage('HOST');">Option</a></td><td>One of TRAY_ICON, TASKBAR or STICK_TO_FRONT.</td></tr><tr><td>Value</td><td>The value to be applied to the option.</td></tr></tbody></table></div></div><h3>Description</h3>
<p>For internal usage only.</p>
    <h3>Error Codes</h3><table class="table table-sm borderless"><tbody><tr><th class="col-md-1">Okay</th><td>Operation successful.</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="SetModalSurface"><h1>SetModalSurface()</h1><p class="lead">Enables a modal surface for the current task.</p><div class="panel panel-info"><div class="panel-heading"><samp>OBJECTID gfxSetModalSurface(OBJECTID Surface)</samp></div><div class="panel-body"><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Surface</td><td>The surface to enable as modal.</td></tr></tbody></table></div></div><h3>Description</h3>
<p>Any surface that is created by a task can be enabled as a modal surface.  A surface that has been enabled as modal becomes the central point for all GUI interaction with the task.  All other I/O between the user and surfaces maintained by the task will be ignored for as long as the target surface remains modal.</p>
<p>A task can switch off the current modal surface by calling this function with a Surface parameter of zero.</p>
<p>If a surface is modal at the time that this function is called, it is not possible to switch to a new modal surface until the current modal state is dropped.</p>
    <h3>Result</h3><p>The object ID of the previous modal surface is returned (zero if there was no currently modal surface).</p><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="StartCursorDrag"><h1>StartCursorDrag()</h1><p class="lead">Attaches an item to the cursor for the purpose of drag and drop.</p><div class="panel panel-info"><div class="panel-heading"><samp>ERROR gfxStartCursorDrag(OBJECTID Source, LONG Item, CSTRING Datatypes, OBJECTID Surface)</samp></div><div class="panel-body"><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Source</td><td>Refers to an object that is managing the source data.</td></tr><tr><td>Item</td><td>A custom number that represents the item being dragged from the source.</td></tr><tr><td>Datatypes</td><td>A null terminated byte array that lists the datatypes supported by the source item, in order of conversion preference.</td></tr><tr><td>Surface</td><td>A 32-bit composite surface that represents the item being dragged.</td></tr></tbody></table></div></div><h3>Description</h3>
<p>This function starts a drag and drop operation with the mouse cursor.  The user must be holding the primary mouse button to initiate the drag and drop operation.</p>
<p>A Source object ID is required that indicates the origin of the item being dragged and will be used to retrieve the data on completion of the drag and drop operation. An Item number, which is optional, identifies the item being dragged from the Source object.</p>
<p>The type of data represented by the source item and all other supportable data types are specified in the Datatypes parameter as a null terminated array.  The array is arranged in order of preference, starting with the item's native data type.  Acceptable data type values are listed in the documentation for the DataFeed action.</p>
<p>The Surface argument allows for a composite surface to be dragged by the mouse cursor as a graphical representation of the source item.  It is recommended that the graphic be 32x32 pixels in size and no bigger than 64x64 pixels.  The Surface will be hidden on completion of the drag and drop operation.</p>
<p>If the call to StartCursorDrag() is successful, the mouse cursor will operate in drag and drop mode.  The UserMovement and UserClickRelease actions normally reported from the SystemPointer will now include the <code>JD_DRAGITEM</code> flag in the ButtonFlags parameter.  When the user releases the primary mouse button, the drag and drop operation will stop and the DragDrop action will be passed to the surface immediately underneath the mouse cursor.  Objects that are monitoring for the DragDrop action on that surface can then contact the Source object with a DataFeed DragDropRequest.  The resulting data is then passed to the requesting object with a DragDropResult on the DataFeed.</p>
    <h3>Error Codes</h3><table class="table table-sm borderless"><tbody><tr><th class="col-md-1">Okay</th><td>Operation successful.</td></tr><tr><th class="col-md-1">InUse</th><td>Resource is in use.</td></tr><tr><th class="col-md-1">Failed</th><td>General failure.</td></tr><tr><th class="col-md-1">AccessObject</th><td>An attempt to gain exclusive access to a shared object failed.</td></tr><tr><th class="col-md-1">NullArgs</th><td>Function call missing argument value(s)</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="SubscribeInput"><h1>SubscribeInput()</h1><p class="lead">Subscribe to incoming input messages for any active surface object.</p><div class="panel panel-info"><div class="panel-heading"><samp>ERROR gfxSubscribeInput(FUNCTION * Callback, OBJECTID SurfaceFilter, JTYPE Mask, OBJECTID DeviceFilter, LONG * Handle)</samp></div><div class="panel-body"><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Callback</td><td>Reference to a callback function that will receive input messages.</td></tr><tr><td>SurfaceFilter</td><td>Optional.  Only the input messages that match the given surface ID will be received.</td></tr><tr><td><a onclick="showPage('JTYPE');">Mask</a></td><td>Combine JTYPE flags to define the input messages required by the client.  Set to 0xffffffff if all messages are desirable.</td></tr><tr><td>DeviceFilter</td><td>Optional.  Only the input messages that match the given device ID will be received.  NOTE - Support not yet implemented, set to zero.</td></tr><tr><td>Handle</td><td>A handle for the subscription is returned here.</td></tr></tbody></table></div></div><h3>Description</h3>
<p>The SubscribeInput() function provides a systematic way of receiving input events as they occur.  Coverage is limited to device events that are linked to the display (i.e. events from track pads, mouse pointers, graphics tablets and touch screens).  Keyboard devices are not included.</p>
<p>The client is required to remove the subscription with UnsubscribeInput once tracking is no longer required.</p>
<p>Input events can be filtered so that they are received in relation to surfaces and devices.  An input mask can also be applied so that only certain types of events are received.</p>
<p>A callback is required for receiving the input events.  The following C++ code illustrates a method for processing events in the callback:</p>
<pre>ERROR consume_input_events(const InputEvent *Events, LONG Handle)
{
   for (auto e=Events; e; e=e-&gt;Next) {
      if (((e-&gt;Flags &amp; JTYPE::BUTTON) != JTYPE::NIL) and (e-&gt;Value &gt; 0)) {
         process_click(Self, e-&gt;RecipientID, e-&gt;X, e-&gt;Y);
      }
   }

   return ERR_Okay;
}
</pre>
<p>All processable events are referenced in the InputEvent structure in the Events parameter.</p>
<p>JET constants are as follows and take note of <code>ENTERED_SURFACE</code> and <code>LEFT_SURFACE</code> which are software generated and not a device event:</p>
<table class="table"><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody></tbody></table>
<p>The JTYPE values for the Flags field are as follows.  Note that these flags also serve as input masks for the SubscribeInput() function, so to receive a message of the given type the appropriate JTYPE flag must have been set in the original subscription call.</p>
<table class="table"><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody></tbody></table>
    <h3>Error Codes</h3><table class="table table-sm borderless"><tbody><tr><th class="col-md-1">Okay</th><td>Operation successful.</td></tr><tr><th class="col-md-1">NullArgs</th><td>Function call missing argument value(s)</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="Sync"><h1>Sync()</h1><p class="lead">Waits for the completion of all active bitmap operations.</p><div class="panel panel-info"><div class="panel-heading"><samp>void gfxSync(objBitmap * Bitmap)</samp></div><div class="panel-body"><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Bitmap</td><td>Pointer to the bitmap that you want to synchronise or NULL to sleep on the graphics accelerator.</td></tr></tbody></table></div></div><h3>Description</h3>
<p>The Sync() function will wait for all current video operations to complete before it returns.  This ensures that it is safe to write to video memory with the CPU, preventing any possibility of clashes with the onboard graphics chip.</p>
    <div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="UnlockBitmap"><h1>UnlockBitmap()</h1><p class="lead">Unlocks any earlier call to gfxLockBitmap().</p><div class="panel panel-info"><div class="panel-heading"><samp>ERROR gfxUnlockBitmap(OBJECTID Surface, objBitmap * Bitmap)</samp></div><div class="panel-body"><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Surface</td><td>The ID of the surface object that you are releasing.</td></tr><tr><td>Bitmap</td><td>Pointer to the bitmap structure returned earlier by LockBitmap().</td></tr></tbody></table></div></div><h3>Description</h3>
<p>Call the UnlockBitmap() function to release a surface object from earlier calls to LockBitmap.</p>
    <h3>Error Codes</h3><table class="table table-sm borderless"><tbody><tr><th class="col-md-1">Okay</th><td>Operation successful.</td></tr><tr><th class="col-md-1">NullArgs</th><td>Function call missing argument value(s)</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="UnlockCursor"><h1>UnlockCursor()</h1><p class="lead">Undoes an earlier call to LockCursor()</p><div class="panel panel-info"><div class="panel-heading"><samp>ERROR gfxUnlockCursor(OBJECTID Surface)</samp></div><div class="panel-body"><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Surface</td><td>Refers to the surface object used for calling LockCursor().</td></tr></tbody></table></div></div><h3>Description</h3>
<p>Call this function to undo any earlier calls to LockCursor() and return the mouse pointer to its regular state.</p>
    <h3>Error Codes</h3><table class="table table-sm borderless"><tbody><tr><th class="col-md-1">Okay</th><td>Operation successful.</td></tr><tr><th class="col-md-1">NotLocked</th><td>There is no exclusive lock on this object.</td></tr><tr><th class="col-md-1">AccessObject</th><td>An attempt to gain exclusive access to a shared object failed.</td></tr><tr><th class="col-md-1">NullArgs</th><td>Function call missing argument value(s)</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="UnsubscribeInput"><h1>UnsubscribeInput()</h1><p class="lead">Removes an input subscription.</p><div class="panel panel-info"><div class="panel-heading"><samp>ERROR gfxUnsubscribeInput(LONG Handle)</samp></div><div class="panel-body"><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Handle</td><td>Reference to a handle returned by SubscribeInput().</td></tr></tbody></table></div></div><h3>Description</h3>
<p>This function removes an input subscription that has been created with SubscribeInput.</p>
    <h3>Error Codes</h3><table class="table table-sm borderless"><tbody><tr><th class="col-md-1">Okay</th><td>Operation successful.</td></tr><tr><th class="col-md-1">NotFound</th><td>A search routine in this function failed.</td></tr><tr><th class="col-md-1">NullArgs</th><td>Function call missing argument value(s)</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="WindowHook"><h1>WindowHook()</h1><p class="lead">Adds a function hook for receiving window messages from a host desktop.</p><div class="panel panel-info"><div class="panel-heading"><samp>ERROR gfxWindowHook(OBJECTID SurfaceID, WH Event, FUNCTION * Callback)</samp></div><div class="panel-body"><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>SurfaceID</td><td>A hosted surface to be monitored.</td></tr><tr><td><a onclick="showPage('WH');">Event</a></td><td>A window hook event.</td></tr><tr><td>Callback</td><td>A function to callback when the event is triggered.</td></tr></tbody></table></div></div><h3>Description</h3>
<p>Adds a function hook for receiving window events from a host desktop.</p>
    <h3>Error Codes</h3><table class="table table-sm borderless"><tbody><tr><th class="col-md-1">Okay</th><td>Operation successful.</td></tr><tr><th class="col-md-1">NullArgs</th><td>Function call missing argument value(s)</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="ACF"><h1>ACF Type</h1><p class="lead">Acceleration flags for GetDisplayInfo().</p><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Name</th><th>Description</th></tr></thead><tbody><tr><td>ACF_SOFTWARE_BLIT</td><td>Software blitting is used (or forced) for this display.</td></tr><tr><td>ACF_VIDEO_BLIT</td><td>Video blitting is supported for this display.</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="BAF"><h1>BAF Type</h1><p class="lead">Instructions for basic graphics operations.</p><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Name</th><th>Description</th></tr></thead><tbody><tr><td>BAF_BLEND</td><td>Enable alpha blending to the destination if the source supports an alpha channel.</td></tr><tr><td>BAF_COPY</td><td>Special CopyArea() option that avoids blending when the destination pixel is empty.</td></tr><tr><td>BAF_DITHER</td><td>Perform dithering if the colour formats differ between the source and destination.</td></tr><tr><td>BAF_FILL</td><td>For primitive operations such as DrawRectangle(), this will fill the shape with a solid colour or texture.</td></tr><tr><td>BAF_LINEAR</td><td>Use linear interpolation to improve the quality of alpha blending.</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="BDF"><h1>BDF Type</h1><p class="lead">CopySurface() flags</p><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Name</th><th>Description</th></tr></thead><tbody><tr><td>BDF_DITHER</td><td>Allow the use of dithering to improve image quality at a cost of speed.</td></tr><tr><td>BDF_REDRAW</td><td>Redraw the surface before performing the copy operation.</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="BMF"><h1>BMF Type</h1><p class="lead">Bitmap flags</p><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Name</th><th>Description</th></tr></thead><tbody><tr><td>BMF_ACCELERATED_2D</td><td>2D video acceleration is available.</td></tr><tr><td>BMF_ACCELERATED_3D</td><td>3D video acceleration is available.</td></tr><tr><td>BMF_ALPHA_CHANNEL</td><td>For 32-bit images, indicates that an alpha channel is present.</td></tr><tr><td>BMF_BLANK_PALETTE</td><td>Forces a blank/black palette on initialisation.</td></tr><tr><td>BMF_CLEAR</td><td>Clear graphics on initialisation and when resizing.</td></tr><tr><td>BMF_COMPRESSED</td><td>The bitmap data is compressed.</td></tr><tr><td>BMF_FIXED_DEPTH</td><td>Prevent changing of bitmap depth after initialisation (e.g. via acResize()).</td></tr><tr><td>BMF_INVERSE_ALPHA</td><td>Indicates reverse alpha blending, higher values are transparent.</td></tr><tr><td>BMF_MASK</td><td>Declare the Bitmap as a 1 or 8 bit mask.  Must be set in conjunction with the BitsPerPixel field on initialisation.</td></tr><tr><td>BMF_NEVER_SHRINK</td><td>Ignore resize requests that would shrink the size of the bitmap.</td></tr><tr><td>BMF_NO_BLEND</td><td>Drawing routines that support this flag will not blend pixels.</td></tr><tr><td>BMF_NO_DATA</td><td>Do not allocate memory in the Data field on initialisation.</td></tr><tr><td>BMF_PREMUL</td><td>The RGB values are premultiplied (32-bit only).</td></tr><tr><td>BMF_QUERIED</td><td>Automatically set after a Query on the bitmap.</td></tr><tr><td>BMF_TRANSPARENT</td><td>Indicates that the bitmap utilises a transparent colour.  This is automatically set if the ColourRGB field is set and support exists in functions such as CopyArea().</td></tr><tr><td>BMF_USER</td><td>This user flag can be used to tag bitmaps with special meaning.  Not used internally.</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="BMP"><h1>BMP Type</h1><p class="lead">Bitmap types</p><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Name</th><th>Description</th></tr></thead><tbody><tr><td>BMP_CHUNKY</td><td>Chunky pixel mode (default).</td></tr><tr><td>BMP_PLANAR</td><td>Planar pixel mode separates pixel bits across multiple planes.  Commonly used for single bit bitmap masks.</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="CEF"><h1>CEF Type</h1><p class="lead"></p><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Name</th><th>Description</th></tr></thead><tbody><tr><td>CEF_DELETE</td><td>Requests that the original file source is deleted if a successful paste operation takes place.</td></tr><tr><td>CEF_EXTEND</td><td>Instead of replacing existing clipboard data, add the new data to the group.</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="CLIPTYPE"><h1>CLIPTYPE Type</h1><p class="lead">Clipboard types</p><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Name</th><th>Description</th></tr></thead><tbody><tr><td>CLIPTYPE_AUDIO</td><td>An audio clip that is recognised by the Sound class (such as wav's and mp3's).</td></tr><tr><td>CLIPTYPE_DATA</td><td>Raw information that is uncategorised can be defined as a data clip.</td></tr><tr><td>CLIPTYPE_FILE</td><td>Pure file references are stored as file clips.  This type is typically used by file managers for moving and copying files.</td></tr><tr><td>CLIPTYPE_IMAGE</td><td>Images that are recognised by the Picture class may be stored as this type (such as jpeg's and png files).</td></tr><tr><td>CLIPTYPE_OBJECT</td><td>An object that has been deserialised into binary form.</td></tr><tr><td>CLIPTYPE_TEXT</td><td>Plain text files such as ASCII and UTF-8 must be identified through this clip type.</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="CPF"><h1>CPF Type</h1><p class="lead">Clipboard flags</p><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Name</th><th>Description</th></tr></thead><tbody><tr><td>CPF_DRAG_DROP</td><td>Enables drag and drop mode.  The clipboard content will be private and not share data with the host system in this mode.</td></tr><tr><td>CPF_HISTORY_BUFFER</td><td>Enables the history buffer.  Note that this results in active clipboard monitoring and the program will make copies of all potential clipboard content - whether it is used or not.</td></tr><tr><td>CPF_HOST</td><td>This indicator is automatically set when a clipboard was created due to incoming content from the host system.</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="CRF"><h1>CRF Type</h1><p class="lead">Flags for the SetCursor() function.</p><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Name</th><th>Description</th></tr></thead><tbody><tr><td>CRF_BUFFER</td><td>Use of the BUFFER option allows the cursor request to be buffered in the event that the cursor is locked at the time of calling the SetCursor() function.  Use of this flag is highly recommended in most circumstances, but may not be used in conjunction with the ANCHOR option.</td></tr><tr><td>CRF_LMB</td><td>Release the cursor after the left mouse button is held and released.</td></tr><tr><td>CRF_MMB</td><td>Release the cursor after the middle mouse button is held and released.</td></tr><tr><td>CRF_NO_BUTTONS</td><td>Set the cursor only on the condition that the user is not holding down any buttons.  ERR_NothingDone is returned if the user has a button held down.</td></tr><tr><td>CRF_RESTRICT</td><td>Similar to the anchor option, but allows the pointer to move within the surface referred to by ObjectID.</td></tr><tr><td>CRF_RMB</td><td>Release the cursor after the right mouse button is held and released.</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="CS"><h1>CS Type</h1><p class="lead">Colour space options.</p><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Name</th><th>Description</th></tr></thead><tbody><tr><td>CS_CIE_LAB</td><td>Cartesian L*a*b* colour space defined by CIE 15.</td></tr><tr><td>CS_CIE_LCH</td><td>Polar L*CHab colour space defined by CIE 15.</td></tr><tr><td>CS_LINEAR_RGB</td><td>Linear RGB is used to improve colour balance in blending operations.</td></tr><tr><td>CS_SRGB</td><td>The default colour-space is sRGB.</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="CSRF"><h1>CSRF Type</h1><p class="lead">Flags for CopySurface().</p><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Name</th><th>Description</th></tr></thead><tbody><tr><td>CSRF_ALPHA</td><td>Enable alpha blending if the source is in 32-bit colour format with an alpha channel.</td></tr><tr><td>CSRF_CLIP</td><td>Enable clipping of the source coordinates.</td></tr><tr><td>CSRF_DEFAULT_FORMAT</td><td>Ignore the colour format defined in the source surface (if any) and generate a default format based on the BitsPerPixel value.</td></tr><tr><td>CSRF_OFFSET</td><td>Adjust X and Y coordinates by the offset values defined in the Surface' XOffset and YOffset fields.</td></tr><tr><td>CSRF_TRANSLUCENT</td><td>Perform a translucent copy operation, using the strength value specified in the Surface Opacity field.</td></tr><tr><td>CSRF_TRANSPARENT</td><td>Enable transparent copying, whereby colours matching the source's Colour field will be ignored.</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="CT"><h1>CT Type</h1><p class="lead"></p><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Name</th><th>Description</th></tr></thead><tbody><tr><td>CT_AUDIO</td><td></td></tr><tr><td>CT_DATA</td><td></td></tr><tr><td>CT_END</td><td></td></tr><tr><td>CT_FILE</td><td></td></tr><tr><td>CT_IMAGE</td><td></td></tr><tr><td>CT_OBJECT</td><td></td></tr><tr><td>CT_TEXT</td><td></td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="DPMS"><h1>DPMS Type</h1><p class="lead">Possible modes for the Display class' PowerMode field.</p><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Name</th><th>Description</th></tr></thead><tbody><tr><td>DPMS_DEFAULT</td><td>Use the default DPMS mode as defined by the display driver.</td></tr><tr><td>DPMS_OFF</td><td>Stop sending power to the display in order to turn it off (it may not be possible to restart the display without the user's intervention).</td></tr><tr><td>DPMS_STANDBY</td><td>Puts the display into standby (reduced power) mode.</td></tr><tr><td>DPMS_SUSPEND</td><td>Puts the display into suspend mode (blanks the display output while maintaining normal power levels).</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="DRAG"><h1>DRAG Type</h1><p class="lead"></p><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Name</th><th>Description</th></tr></thead><tbody><tr><td>DRAG_ANCHOR</td><td>The surface is being dragged and the mouse pointer is anchored to the surface.</td></tr><tr><td>DRAG_NONE</td><td>The surface is not being dragged.</td></tr><tr><td>DRAG_NORMAL</td><td>The surface is being dragged.</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="DSF"><h1>DSF Type</h1><p class="lead"></p><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Name</th><th>Description</th></tr></thead><tbody><tr><td>DSF_NO_DRAW</td><td>Drawing and exposures are disabled</td></tr><tr><td>DSF_NO_EXPOSE</td><td>Drawing is enabled, exposures are disabled</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="DT"><h1>DT Type</h1><p class="lead">Flags for GetDisplayType().</p><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Name</th><th>Description</th></tr></thead><tbody><tr><td>DT_GLES</td><td>The display is driven by OpenGLES.</td></tr><tr><td>DT_NATIVE</td><td>The display is native (supported by internal drivers).</td></tr><tr><td>DT_WINGDI</td><td>The display is driven by Microsoft Windows drivers.</td></tr><tr><td>DT_X11</td><td>The display is driven by the X Window System (X11, X.Org, XFree86)</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="EXF"><h1>EXF Type</h1><p class="lead">Optional flags for the ExposeSurface() function.</p><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Name</th><th>Description</th></tr></thead><tbody><tr><td>EXF_ABSOLUTE</td><td>The supplied coordinates for exposure are absolute (relative to the display).</td></tr><tr><td>EXF_ABSOLUTE_COORDS</td><td>The supplied coordinates for exposure are absolute (relative to the display).</td></tr><tr><td>EXF_CHILDREN</td><td>If set, all child surfaces that intersect with exposed region will be included in the expose operation.</td></tr><tr><td>EXF_REDRAW_VOLATILE</td><td>Redraw every volatile object that intersects with the expose region, including internal volatile children.</td></tr><tr><td>EXF_REDRAW_VOLATILE_OVERLAP</td><td>Only redraw volatile objects that obscure the expose region from a position outside of the target surface and its children.  Useful if no redrawing has occurred in the surface, but the surface has moved to a new position and the parents need to be redrawn.</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="FLIP"><h1>FLIP Type</h1><p class="lead">Flags for the bitmap Flip method.</p><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Name</th><th>Description</th></tr></thead><tbody><tr><td>FLIP_HORIZONTAL</td><td>Flip the bitmap from top to bottom.</td></tr><tr><td>FLIP_VERTICAL</td><td>Flip the bitmap from left to right.</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="GMF"><h1>GMF Type</h1><p class="lead">Flags for gamma operations.</p><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Name</th><th>Description</th></tr></thead><tbody><tr><td>GMF_SAVE</td><td>Save the provided settings permanently.</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="HOST"><h1>HOST Type</h1><p class="lead"></p><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Name</th><th>Description</th></tr></thead><tbody><tr><td>HOST_STICK_TO_FRONT</td><td>The hosted display sticks to the front.</td></tr><tr><td>HOST_TASKBAR</td><td>The hosted display is given a taskbar button.</td></tr><tr><td>HOST_TRANSLUCENCE</td><td>Change the alpha channel level for the entire window.</td></tr><tr><td>HOST_TRANSPARENT</td><td>Defines an RGB colour that is to be used as transparent.</td></tr><tr><td>HOST_TRAY_ICON</td><td>All new displays are represented in the system tray when this option is active.</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="IRF"><h1>IRF Type</h1><p class="lead">Flags for RedrawSurface().</p><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Name</th><th>Description</th></tr></thead><tbody><tr><td>IRF_FORCE_DRAW</td><td>Forces redrawing to the surface buffer (overrides visibility checks).</td></tr><tr><td>IRF_IGNORE_CHILDREN</td><td>Do not draw child surfaces (this includes volatile children).</td></tr><tr><td>IRF_IGNORE_NV_CHILDREN</td><td>Do not draw child surfaces unless they are volatile.</td></tr><tr><td>IRF_RELATIVE</td><td>Coordinate arguments are expressed in relative format.  Right and Bottom reflect Width and Height respectively.</td></tr><tr><td>IRF_SINGLE_BITMAP</td><td>Only draw children and/or siblings when they share our bitmap space.</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="LVF"><h1>LVF Type</h1><p class="lead">drwLockBitmap() result flags</p><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Name</th><th>Description</th></tr></thead><tbody><tr><td>LVF_EXPOSE_CHANGES</td><td></td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="MON"><h1>MON Type</h1><p class="lead">Flags for the Display class SetMonitor() method.</p><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Name</th><th>Description</th></tr></thead><tbody><tr><td>MON_AUTO_DETECT</td><td>Monitor settings to be auto-detected on startup.</td></tr><tr><td>MON_BIT_6</td><td>The device is limited to 6-bit colour production in real terms.</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="PF"><h1>PF Type</h1><p class="lead">Flags for the Pointer class.</p><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Name</th><th>Description</th></tr></thead><tbody><tr><td>PF_ANCHOR</td><td>Allow the pointer to be anchored.</td></tr><tr><td>PF_UNUSED</td><td></td></tr><tr><td>PF_VISIBLE</td><td>Indicates that the pointer is currently visible.  Read-only.</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="RNF"><h1>RNF Type</h1><p class="lead">Switches for the Surface class' Flags field.</p><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Name</th><th>Description</th></tr></thead><tbody><tr><td>RNF_AFTER_COPY</td><td>Read-only.  Indicates that after-copy mode has been enabled.</td></tr><tr><td>RNF_ASPECT_RATIO</td><td>When resizing, enforce the aspect ratio as defined by MinWidth and MinHeight.</td></tr><tr><td>RNF_AUTO_QUIT</td><td>The surface object will send a quit message to its supporting process when and if the Close method is called.  This flag is typically used when a surface object represents a core window for an application.</td></tr><tr><td>RNF_COMPOSITE</td><td>Do not copy background information into the surface buffer - composite on the fly instead</td></tr><tr><td>RNF_DISABLED</td><td>This flag is set if the Disable action has been called on a surface object.  Calling the Enable action will turn off the flag setting.</td></tr><tr><td>RNF_FIXED_BUFFER</td><td>Passes the NEVER_SHRINK option to the surface bitmap</td></tr><tr><td>RNF_FIXED_DEPTH</td><td>The target buffer always remains at the same depth</td></tr><tr><td>RNF_FULL_SCREEN</td><td>Allow the surface to open as a new screen display</td></tr><tr><td>RNF_GRAB_FOCUS</td><td>Helps application windows manage the user's focus within the window</td></tr><tr><td>RNF_HAS_FOCUS</td><td>Read-only.  If set, this flag indicates that the surface object currently has the focus.</td></tr><tr><td>RNF_HOST</td><td>Define host on initialisation to create a container that can host surfaces from other processes.</td></tr><tr><td>RNF_IGNORE_FOCUS</td><td>Focus is diverted directly to the parent</td></tr><tr><td>RNF_INIT_ONLY</td><td>Synonym for HOST | TRANSPARENT | DISABLED | PRECOPY | VIDEO | FIXED_BUFFER | PERVASIVE_COPY | FIXED_DEPTH | FULL_SCREEN | IGNORE_FOCUS</td></tr><tr><td>RNF_NO_FOCUS</td><td>Prevents any kind of focussing on this object; no circumvention is possible</td></tr><tr><td>RNF_NO_HORIZONTAL</td><td>Turns off all horizontal movement (applies to the Move action only).</td></tr><tr><td>RNF_NO_PRECOMPOSITE</td><td>Do not copy background information into the surface buffer - composite on the fly instead</td></tr><tr><td>RNF_NO_VERTICAL</td><td>Turns off all vertical movement (applies to the Move action only).</td></tr><tr><td>RNF_PERVASIVE_COPY</td><td>This flag can be set in conjunction with after-copy mode.  It forces the after-copy support routine to copy graphics over the entire surface area, rather than avoiding the graphics of child surfaces.</td></tr><tr><td>RNF_POST_COMPOSITE</td><td>Do not copy background information into the surface buffer - composite on the fly instead</td></tr><tr><td>RNF_PRECOPY</td><td>Enables pre-copy mode, which means that all graphics behind the surface object are copied into the bitmap buffer prior to any redraw.  This mode can have a noticable impact on CPU time when drawing.</td></tr><tr><td>RNF_READ_ONLY</td><td>Synonym for HAS_FOCUS | CURSOR | AFTER_COPY</td></tr><tr><td>RNF_SCROLL_CONTENT</td><td>If set, the surface object will send Move and MoveToPoint messages if the Scroll and ScrollToPoint actions are ever called on the object.</td></tr><tr><td>RNF_STICKY</td><td>Prevents any response to the Move action.  It can be circumvented by writing to coordinate fields directly.</td></tr><tr><td>RNF_STICK_TO_BACK</td><td>Enable if the surface object must stick to the back of its container.</td></tr><tr><td>RNF_STICK_TO_FRONT</td><td>Enable if the surface object must stick to the front of its container.</td></tr><tr><td>RNF_TOTAL_REDRAW</td><td>Perform a total redraw of the entire surface when drawing - no partial draws</td></tr><tr><td>RNF_TRANSPARENT</td><td>Enables transparency, which means that the internal graphics routines will ignore this surface during redraws.  It is typically used when creating containers that will host other surfaces.</td></tr><tr><td>RNF_VIDEO</td><td>Set this flag if you would like the surface object's data to be managed in video memory only.  While this can give some speed advantages, be warned that video based surfaces are limited to write-only operations.</td></tr><tr><td>RNF_VISIBLE</td><td>If a surface object is visible to the user, the VISIBLE flag will be set.  If the flag is not set, the surface object is hidden.</td></tr><tr><td>RNF_VOLATILE</td><td>Synonym for PRECOPY | AFTER_COPY | CURSOR</td></tr><tr><td>RNF_WRITE_ONLY</td><td>Set this flag if you would like the surface object's data to be managed in video memory only.  While this can give some speed advantages, be warned that video based surfaces are limited to write-only operations.</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="RT"><h1>RT Type</h1><p class="lead"></p><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Name</th><th>Description</th></tr></thead><tbody><tr><td>RT_ROOT</td><td>Can be used by window surfaces to identify themselves as a root layer.</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="SCR"><h1>SCR Type</h1><p class="lead">Display flags.</p><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Name</th><th>Description</th></tr></thead><tbody><tr><td>SCR_ALPHA_BLEND</td><td>Enables alpha channel blending (if display is hosted and 32-bit).</td></tr><tr><td>SCR_AUTO_SAVE</td><td>Saves settings to the global display state when the object is freed.</td></tr><tr><td>SCR_BIT_6</td><td>Display is limited to 6-bit output per colour gun.</td></tr><tr><td>SCR_BORDERLESS</td><td>If display is hosted, create it as a popup / borderless window.</td></tr><tr><td>SCR_BUFFER</td><td>Set if you would like a complementing buffer in video RAM.</td></tr><tr><td>SCR_COMPOSITE</td><td>Enables alpha channel blending (if display is hosted and 32-bit).</td></tr><tr><td>SCR_CUSTOM_WINDOW</td><td>The display has been created with a custom window reference.</td></tr><tr><td>SCR_DPMS_ENABLED</td><td>Power saving through DPMS is supported.</td></tr><tr><td>SCR_FLIPPABLE</td><td>If SCR::BUFFER is used, this flag may be set by the display manager if it is possible to flip the buffer.</td></tr><tr><td>SCR_GTF_ENABLED</td><td>GTF frequency timings are supported.</td></tr><tr><td>SCR_HOSTED</td><td>The display is a desktop hosted window.</td></tr><tr><td>SCR_MAXIMISE</td><td>Special win32 flag.</td></tr><tr><td>SCR_MAXSIZE</td><td>For GetDisplayInfo() only, indicates that the width and height values indicate the display's maximum size.</td></tr><tr><td>SCR_NO_ACCELERATION</td><td>2D graphics card acceleration is not available.</td></tr><tr><td>SCR_POWERSAVE</td><td>Power saving is active (read-only).</td></tr><tr><td>SCR_READ_ONLY</td><td>Synonym for MAXIMISE | CUSTOM_WINDOW | FLIPPABLE | GTF_ENABLED | DPMS_ENABLED | POWERSAVE | HOSTED | MAXSIZE | REFRESH | BIT_6 | VISIBLE | NO_ACCELERATION</td></tr><tr><td>SCR_REFRESH</td><td>For GetDisplayInfo() only, used to indicate that a display change has recently occurred and cache refresh is required.</td></tr><tr><td>SCR_VISIBLE</td><td>Set if the screen is on display.</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="SWIN"><h1>SWIN Type</h1><p class="lead">Options for the Surface WindowType field.</p><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Name</th><th>Description</th></tr></thead><tbody><tr><td>SWIN_HOST</td><td>Default to the standard hosted window mode with full titlebar, borders and taskbar representation.</td></tr><tr><td>SWIN_ICON_TRAY</td><td>Create a borderless (custom) window with icon tray representation.</td></tr><tr><td>SWIN_NONE</td><td>Create a borderless (custom) window with no UI representation.</td></tr><tr><td>SWIN_TASKBAR</td><td>Create a borderless (custom) window with taskbar representation.</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="WH"><h1>WH Type</h1><p class="lead">Events for WindowHook()</p><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Name</th><th>Description</th></tr></thead><tbody><tr><td>WH_CLOSE</td><td></td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="struct-BitmapSurface"><h1>BitmapSurface Structure</h1><p class="lead"></p><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Field</th><th class="col-md-1">Type</th><th>Description</th></tr></thead><tbody><tr><td>Data</td><td><span class="text-nowrap">APTR</span></td><td>Pointer to the bitmap graphics data.</td></tr><tr><td>Width</td><td><span class="text-nowrap">WORD</span></td><td>Pixel width of the bitmap.</td></tr><tr><td>Height</td><td><span class="text-nowrap">WORD</span></td><td>Pixel height of the bitmap.</td></tr><tr><td>LineWidth</td><td><span class="text-nowrap">LONG</span></td><td>The distance between bitmap lines, measured in bytes.</td></tr><tr><td>BitsPerPixel</td><td><span class="text-nowrap">UBYTE</span></td><td>The number of bits per pixel (8, 15, 16, 24, 32).</td></tr><tr><td>BytesPerPixel</td><td><span class="text-nowrap">UBYTE</span></td><td>The number of bytes per pixel (1, 2, 3, 4).</td></tr><tr><td>Opacity</td><td><span class="text-nowrap">UBYTE</span></td><td>Opacity level of the source if CSRF::TRANSLUCENT is used.</td></tr><tr><td>Version</td><td><span class="text-nowrap">UBYTE</span></td><td>Version of this structure.</td></tr><tr><td>Colour</td><td><span class="text-nowrap">LONG</span></td><td>Colour index to use if CSRF::TRANSPARENT is used.</td></tr><tr><td>Clip</td><td><span class="text-nowrap">struct ClipRectangle</span></td><td>A clipping rectangle will restrict drawing operations to this region if CSRF::CLIP is used.</td></tr><tr><td>XOffset</td><td><span class="text-nowrap">WORD</span></td><td>Offset all X coordinate references by the given value.</td></tr><tr><td>YOffset</td><td><span class="text-nowrap">WORD</span></td><td>Offset all Y coordinate references by the given value.</td></tr><tr><td>Format</td><td><span class="text-nowrap">struct ColourFormat</span></td><td>The colour format of this bitmap's pixels, or alternatively use CSRF::DEFAULT_FORMAT.</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="struct-CursorInfo"><h1>CursorInfo Structure</h1><p class="lead"></p><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Field</th><th class="col-md-1">Type</th><th>Description</th></tr></thead><tbody><tr><td>Width</td><td><span class="text-nowrap">LONG</span></td><td>Maximum cursor width for custom cursors</td></tr><tr><td>Height</td><td><span class="text-nowrap">LONG</span></td><td>Maximum cursor height for custom cursors</td></tr><tr><td>Flags</td><td><span class="text-nowrap">LONG</span></td><td>Currently unused</td></tr><tr><td>BitsPerPixel</td><td><span class="text-nowrap">WORD</span></td><td>Preferred bits-per-pixel setting for custom cursors</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="struct-DisplayInfo"><h1>DisplayInfo Structure</h1><p class="lead"></p><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Field</th><th class="col-md-1">Type</th><th>Description</th></tr></thead><tbody><tr><td>Display</td><td><span class="text-nowrap">OBJECTID</span></td><td>Object ID related to the display</td></tr><tr><td>Flags</td><td><span class="text-nowrap">SCR</span></td><td>Display flags</td></tr><tr><td>Width</td><td><span class="text-nowrap">WORD</span></td><td>Pixel width of the display</td></tr><tr><td>Height</td><td><span class="text-nowrap">WORD</span></td><td>Pixel height of the display</td></tr><tr><td>BitsPerPixel</td><td><span class="text-nowrap">WORD</span></td><td>Bits per pixel</td></tr><tr><td>BytesPerPixel</td><td><span class="text-nowrap">WORD</span></td><td>Bytes per pixel</td></tr><tr><td>AccelFlags</td><td><span class="text-nowrap">ACF</span></td><td>Flags describing supported hardware features.</td></tr><tr><td>AmtColours</td><td><span class="text-nowrap">LONG</span></td><td>Total number of supported colours.</td></tr><tr><td>PixelFormat</td><td><span class="text-nowrap">struct PixelFormat</span></td><td>The colour format to use for each pixel.</td></tr><tr><td>MinRefresh</td><td><span class="text-nowrap">FLOAT</span></td><td>Minimum refresh rate</td></tr><tr><td>MaxRefresh</td><td><span class="text-nowrap">FLOAT</span></td><td>Maximum refresh rate</td></tr><tr><td>RefreshRate</td><td><span class="text-nowrap">FLOAT</span></td><td>Recommended refresh rate</td></tr><tr><td>Index</td><td><span class="text-nowrap">LONG</span></td><td>Display mode ID (internal)</td></tr><tr><td>HDensity</td><td><span class="text-nowrap">LONG</span></td><td>Horizontal pixel density per inch.</td></tr><tr><td>VDensity</td><td><span class="text-nowrap">LONG</span></td><td>Vertical pixel density per inch.</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="struct-PixelFormat"><h1>PixelFormat Structure</h1><p class="lead">Carries instructions to pack or unpack RGBA colours.</p><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Field</th><th class="col-md-1">Type</th><th>Description</th></tr></thead><tbody><tr><td>RedShift</td><td><span class="text-nowrap">UBYTE</span></td><td>Right shift value</td></tr><tr><td>GreenShift</td><td><span class="text-nowrap">UBYTE</span></td><td>Green shift value</td></tr><tr><td>BlueShift</td><td><span class="text-nowrap">UBYTE</span></td><td>Blue shift value</td></tr><tr><td>AlphaShift</td><td><span class="text-nowrap">UBYTE</span></td><td>Alpha shift value</td></tr><tr><td>RedMask</td><td><span class="text-nowrap">UBYTE</span></td><td>The unshifted red mask value (ranges from 0x00 to 0xff)</td></tr><tr><td>GreenMask</td><td><span class="text-nowrap">UBYTE</span></td><td>The unshifted green mask value (ranges from 0x00 to 0xff)</td></tr><tr><td>BlueMask</td><td><span class="text-nowrap">UBYTE</span></td><td>The unshifted blue mask value (ranges from 0x00 to 0xff)</td></tr><tr><td>AlphaMask</td><td><span class="text-nowrap">UBYTE</span></td><td>The unshifted alpha mask value (ranges from 0x00 to 0xff)</td></tr><tr><td>RedPos</td><td><span class="text-nowrap">UBYTE</span></td><td>Left shift/positional value for red</td></tr><tr><td>GreenPos</td><td><span class="text-nowrap">UBYTE</span></td><td>Left shift/positional value for green</td></tr><tr><td>BluePos</td><td><span class="text-nowrap">UBYTE</span></td><td>Left shift/positional value for blue</td></tr><tr><td>AlphaPos</td><td><span class="text-nowrap">UBYTE</span></td><td>Left shift/positional value for alpha</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="struct-SurfaceCoords"><h1>SurfaceCoords Structure</h1><p class="lead"></p><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Field</th><th class="col-md-1">Type</th><th>Description</th></tr></thead><tbody><tr><td>X</td><td><span class="text-nowrap">LONG</span></td><td>Horizontal coordinate</td></tr><tr><td>Y</td><td><span class="text-nowrap">LONG</span></td><td>Vertical coordinate</td></tr><tr><td>Width</td><td><span class="text-nowrap">LONG</span></td><td>Width</td></tr><tr><td>Height</td><td><span class="text-nowrap">LONG</span></td><td>Height</td></tr><tr><td>AbsX</td><td><span class="text-nowrap">LONG</span></td><td>Absolute X</td></tr><tr><td>AbsY</td><td><span class="text-nowrap">LONG</span></td><td>Absolute Y</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div><div class="docs-content" style="display:none;" id="struct-SurfaceInfo"><h1>SurfaceInfo Structure</h1><p class="lead"></p><table class="table" style="border: 4px; margin-bottom: 0px; border: 0px; border-bottom: 0px;"><thead><tr><th class="col-md-1">Field</th><th class="col-md-1">Type</th><th>Description</th></tr></thead><tbody><tr><td>Data</td><td><span class="text-nowrap">APTR</span></td><td>Bitmap data memory ID</td></tr><tr><td>ParentID</td><td><span class="text-nowrap">OBJECTID</span></td><td>Object that contains the surface area</td></tr><tr><td>BitmapID</td><td><span class="text-nowrap">OBJECTID</span></td><td>Surface bitmap buffer</td></tr><tr><td>DisplayID</td><td><span class="text-nowrap">OBJECTID</span></td><td>Refers to the display if this object is at root level</td></tr><tr><td>Flags</td><td><span class="text-nowrap">RNF</span></td><td>Surface flags</td></tr><tr><td>X</td><td><span class="text-nowrap">LONG</span></td><td>Horizontal coordinate</td></tr><tr><td>Y</td><td><span class="text-nowrap">LONG</span></td><td>Vertical coordinate</td></tr><tr><td>Width</td><td><span class="text-nowrap">LONG</span></td><td>Width of the surface area</td></tr><tr><td>Height</td><td><span class="text-nowrap">LONG</span></td><td>Height of the surface area</td></tr><tr><td>AbsX</td><td><span class="text-nowrap">LONG</span></td><td>Absolute X coordinate</td></tr><tr><td>AbsY</td><td><span class="text-nowrap">LONG</span></td><td>Absolute Y coordinate</td></tr><tr><td>Level</td><td><span class="text-nowrap">WORD</span></td><td>Branch level within the tree</td></tr><tr><td>BitsPerPixel</td><td><span class="text-nowrap">BYTE</span></td><td>Bits per pixel of the bitmap</td></tr><tr><td>BytesPerPixel</td><td><span class="text-nowrap">BYTE</span></td><td>Bytes per pixel of the bitmap</td></tr><tr><td>LineWidth</td><td><span class="text-nowrap">LONG</span></td><td>Line width of the bitmap, in bytes</td></tr></tbody></table><div class="footer copyright">Display module documentation © Paul Manias 2003-2023</div></div></div><div class="col-sm-3"><div id="nav-tree"><h3>Display Module</h3><div class="panel-group" id="accordion"><div class="panel panel-info"><div class="panel-heading"><h4 class="panel-title"><span class="badge" style="display:inline-block; width:30px; background-color:#fff; color:#666">5</span>  <a data-toggle="collapse" data-parent="#accordion" href="#classes">Classes</a></h4></div><div id="classes" class="panel-collapse collapse"><div class="panel-body"><ul class="list-unstyled"><li><a href="classes/bitmap.html">Bitmap</a></li><li><a href="classes/clipboard.html">Clipboard</a></li><li><a href="classes/display.html">Display</a></li><li><a href="classes/pointer.html">Pointer</a></li><li><a href="classes/surface.html">Surface</a></li></ul></div></div></div><div class="panel panel-primary"><div class="panel-heading"><h4 class="panel-title"><span class="badge" style="display:inline-block; width:30px">12</span>  <a data-toggle="collapse" data-parent="#accordion" href="#Bitmap">Bitmap</a></h4></div><div id="Bitmap" class="panel-collapse collapse"><div class="panel-body"><ul class="list-unstyled"><li><a onclick="showPage('CopyArea');">CopyArea</a></li><li><a onclick="showPage('CopyRawBitmap');">CopyRawBitmap</a></li><li><a onclick="showPage('DrawPixel');">DrawPixel</a></li><li><a onclick="showPage('DrawRGBPixel');">DrawRGBPixel</a></li><li><a onclick="showPage('DrawRectangle');">DrawRectangle</a></li><li><a onclick="showPage('FlipBitmap');">FlipBitmap</a></li><li><a onclick="showPage('GetColourFormat');">GetColourFormat</a></li><li><a onclick="showPage('ReadPixel');">ReadPixel</a></li><li><a onclick="showPage('ReadRGBPixel');">ReadRGBPixel</a></li><li><a onclick="showPage('Resample');">Resample</a></li><li><a onclick="showPage('SetClipRegion');">SetClipRegion</a></li><li><a onclick="showPage('Sync');">Sync</a></li></ul></div></div></div><div class="panel panel-primary"><div class="panel-heading"><h4 class="panel-title"><span class="badge" style="display:inline-block; width:30px">11</span>  <a data-toggle="collapse" data-parent="#accordion" href="#Cursor">Cursor</a></h4></div><div id="Cursor" class="panel-collapse collapse"><div class="panel-body"><ul class="list-unstyled"><li><a onclick="showPage('AccessPointer');">AccessPointer</a></li><li><a onclick="showPage('GetCursorInfo');">GetCursorInfo</a></li><li><a onclick="showPage('GetCursorPos');">GetCursorPos</a></li><li><a onclick="showPage('GetRelativeCursorPos');">GetRelativeCursorPos</a></li><li><a onclick="showPage('LockCursor');">LockCursor</a></li><li><a onclick="showPage('RestoreCursor');">RestoreCursor</a></li><li><a onclick="showPage('SetCursor');">SetCursor</a></li><li><a onclick="showPage('SetCursorPos');">SetCursorPos</a></li><li><a onclick="showPage('SetCustomCursor');">SetCustomCursor</a></li><li><a onclick="showPage('StartCursorDrag');">StartCursorDrag</a></li><li><a onclick="showPage('UnlockCursor');">UnlockCursor</a></li></ul></div></div></div><div class="panel panel-primary"><div class="panel-heading"><h4 class="panel-title"><span class="badge" style="display:inline-block; width:30px">4</span>  <a data-toggle="collapse" data-parent="#accordion" href="#Display">Display</a></h4></div><div id="Display" class="panel-collapse collapse"><div class="panel-body"><ul class="list-unstyled"><li><a onclick="showPage('GetDisplayInfo');">GetDisplayInfo</a></li><li><a onclick="showPage('GetDisplayType');">GetDisplayType</a></li><li><a onclick="showPage('ScaleToDPI');">ScaleToDPI</a></li><li><a onclick="showPage('SetHostOption');">SetHostOption</a></li></ul></div></div></div><div class="panel panel-primary"><div class="panel-heading"><h4 class="panel-title"><span class="badge" style="display:inline-block; width:30px">3</span>  <a data-toggle="collapse" data-parent="#accordion" href="#Input">Input</a></h4></div><div id="Input" class="panel-collapse collapse"><div class="panel-body"><ul class="list-unstyled"><li><a onclick="showPage('GetInputTypeName');">GetInputTypeName</a></li><li><a onclick="showPage('SubscribeInput');">SubscribeInput</a></li><li><a onclick="showPage('UnsubscribeInput');">UnsubscribeInput</a></li></ul></div></div></div><div class="panel panel-primary"><div class="panel-heading"><h4 class="panel-title"><span class="badge" style="display:inline-block; width:30px">13</span>  <a data-toggle="collapse" data-parent="#accordion" href="#Surfaces">Surfaces</a></h4></div><div id="Surfaces" class="panel-collapse collapse"><div class="panel-body"><ul class="list-unstyled"><li><a onclick="showPage('CheckIfChild');">CheckIfChild</a></li><li><a onclick="showPage('CopySurface');">CopySurface</a></li><li><a onclick="showPage('ExposeSurface');">ExposeSurface</a></li><li><a onclick="showPage('GetModalSurface');">GetModalSurface</a></li><li><a onclick="showPage('GetSurfaceCoords');">GetSurfaceCoords</a></li><li><a onclick="showPage('GetSurfaceFlags');">GetSurfaceFlags</a></li><li><a onclick="showPage('GetSurfaceInfo');">GetSurfaceInfo</a></li><li><a onclick="showPage('GetUserFocus');">GetUserFocus</a></li><li><a onclick="showPage('GetVisibleArea');">GetVisibleArea</a></li><li><a onclick="showPage('LockBitmap');">LockBitmap</a></li><li><a onclick="showPage('SetModalSurface');">SetModalSurface</a></li><li><a onclick="showPage('UnlockBitmap');">UnlockBitmap</a></li><li><a onclick="showPage('WindowHook');">WindowHook</a></li></ul></div></div></div><div class="panel panel-success"><div class="panel-heading"><h4 class="panel-title"><a data-toggle="collapse" data-parent="#accordion" href="#structures">Structures</a></h4></div><div id="structures" class="panel-collapse collapse"><div class="panel-body"><ul class="list-unstyled"><li><a onclick="showPage('struct-BitmapSurface');">BitmapSurface</a></li><li><a onclick="showPage('struct-CursorInfo');">CursorInfo</a></li><li><a onclick="showPage('struct-DisplayInfo');">DisplayInfo</a></li><li><a onclick="showPage('struct-PixelFormat');">PixelFormat</a></li><li><a onclick="showPage('struct-SurfaceCoords');">SurfaceCoords</a></li><li><a onclick="showPage('struct-SurfaceInfo');">SurfaceInfo</a></li></ul></div></div></div></div></div></div></div></div><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script><script src="../js/bootstrap.min.js"></script><script src="../js/base.js"></script><script type="text/javascript">
var glCurrentMethod;

$(document).ready(function() {
   glCurrentMethod = document.getElementById("Introduction");

   var page = glParameters["page"];
   if (isEmpty(page)) page = glParameters["function"];

   if (isEmpty(page)) showPage("default-page", true);
   else showPage(page, true);

   window.onpopstate = popState;
});

function popState(event) {
   console.log("popState() to " + JSON.stringify(event.state));

   state = event.state
   if (!state) state = { page: 'default-page' }

   var div
   if (state.page) div = document.getElementById(state.page);
   else div =  document.getElementById('default-page');

   if (div) {
      if (glCurrentMethod) glCurrentMethod.style.display = "none"; // Hide previous method.
      div.style.display = "block"; // Show selected method.
      glCurrentMethod = div;
   }
   else console.log("Div for '" + state.page + "' not found.");
}

function showPage(Name, NoHistory)
{
   console.log('showPage() ' + Name);

   var div = document.getElementById(Name);
   if (div) {
      if (glCurrentMethod) glCurrentMethod.style.display = "none"; // Hide previous method.
      div.style.display = "block"; // Show selected method.
      glCurrentMethod = div;

      if (!NoHistory) {
         history.pushState({ page: Name }, null, "?page=" + Name);
      }
   }
   else console.log("Div for '" + Name + "' not found.");
}
         </script></body></html>
