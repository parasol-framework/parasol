<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="-//W3C//DTD XHTML 1.1//EN" xml:lang="en" xsi:schemaLocation="http://www.w3.org/MarkUp/SCHEMA/xhtml11.xsd"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta><script type="text/javascript" async="async" src="https://www.googletagmanager.com/gtag/js?id=G-8254DG7MT6"> </script><script type="text/javascript">
	   window.dataLayer = window.dataLayer || [];
	   function gtag(){dataLayer.push(arguments);}
	   gtag('js', new Date());
      gtag('config', 'G-8254DG7MT6');</script><meta name="viewport" content="width=device-width, initial-scale=1"></meta><meta name="description" content="Parasol Framework documentation, machine generated from source"></meta><meta name="author" content="Paul Manias"></meta><link rel="icon" href="/favicon.ico"></link><title>Parasol Framework Manual</title><link href="../../css/bootstrap.min.css" rel="stylesheet"></link><link href="../../css/module-template.css" rel="stylesheet"></link><script type="text/javascript">
          var shiftWindow = function() { scrollBy(0, -100) };
          window.addEventListener("hashchange", shiftWindow);
          function load() { if (window.location.hash) shiftWindow(); }
        </script></head><body><nav class="navbar navbar-expand-sm navbar-dark bg-dark"><div class="container-fluid"><div class="navbar-header"><a class="navbar-brand" href="../../index.html">Parasol Framework</a></div><button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div id="navbar" class="collapse navbar-collapse"><ul class="nav navbar-nav"><li class="nav-item"><a class="nav-link" href="../../gallery.html">Gallery</a></li><li class="nav-item"><a class="nav-link" href="../api.html">API</a></li><li class="nav-item"><a class="nav-link" href="../../wiki/Home.html">Wiki</a></li><li class="nav-item"><a class="nav-link" href="https://github.com/parasol-framework/parasol">GitHub</a></li></ul></div></div></nav>
<div class="container-fluid"><div class="row"><div class="d-sm-block d-none col-3 sidebar" style="max-width: 230px;"><div class="flex-shrink-1 pt-2 pe-2 sticky-top overflow-auto vh-100 b-shadow">
<ul class="list-unstyled"><li><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle="collapse" data-bs-target="#mod-collapse" aria-expanded="false">Modules</button><div class="collapse" id="mod-collapse"><ul class="btn-toggle-nav list-unstyled fw-normal"><li class="api-ref"><a class="rounded" href="../audio.html">Audio</a></li><li class="api-ref"><a class="rounded" href="../core.html">Core</a></li><li class="api-ref"><a class="rounded" href="../display.html">Display</a></li><li class="api-ref"><a class="rounded" href="../fluid.html">Fluid</a></li><li class="api-ref"><a class="rounded" href="../font.html">Font</a></li><li class="api-ref"><a class="rounded" href="../network.html">Network</a></li><li class="api-ref"><a class="rounded" href="../vector.html">Vector</a></li></ul></div></li></ul>
<ul class="list-unstyled"><li class="border-top my-3"></li><li><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle="collapse" data-bs-target="#audio-collapse" aria-expanded="false">Audio</button><div class="collapse" id="audio-collapse"><ul class="btn-toggle-nav list-unstyled fw-normal pb-1"><li class="api-ref"><a class="rounded" href="audio.html">Audio</a></li><li class="api-ref"><a class="rounded" href="sound.html">Sound</a></li></ul></div></li>
<li><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle="collapse" data-bs-target="#core-collapse" aria-expanded="false">Core</button><div class="collapse" id="core-collapse"><ul class="btn-toggle-nav list-unstyled pb-1"><li class="api-ref"><a class="rounded" href="file.html">File</a></li><li class="api-ref"><a class="rounded" href="metaclass.html">MetaClass</a></li><li class="api-ref"><a class="rounded" href="module.html">Module</a></li><li class="api-ref"><a class="rounded" href="storagedevice.html">StorageDevice</a></li><li class="api-ref"><a class="rounded" href="task.html">Task</a></li><li class="api-ref"><a class="rounded" href="thread.html">Thread</a></li><li class="api-ref"><a class="rounded" href="time.html">Time</a></li></ul></div></li>
<li><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle="collapse" data-bs-target="#data-collapse" aria-expanded="false">Data</button><div class="collapse" id="data-collapse"><ul class="btn-toggle-nav list-unstyled pb-1"><li class="api-ref"><a class="rounded" href="compression.html">Compression</a></li><li class="api-ref"><a class="rounded" href="config.html">Config</a></li><li class="api-ref"><a class="rounded" href="script.html">Script</a></li><li class="api-ref"><a class="rounded" href="xml.html">XML</a></li></ul></div></li>
<li><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle="collapse" data-bs-target="#devices-collapse" aria-expanded="false">Devices</button><div class="collapse" id="devices-collapse"><ul class="btn-toggle-nav list-unstyled pb-1"><li class="api-ref"><a class="rounded" href="controller.html">Controller</a></li></ul></div></li>
<li><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle="collapse" data-bs-target="#effects-collapse" aria-expanded="false">Effects</button><div class="collapse" id="effects-collapse"><ul class="btn-toggle-nav list-unstyled pb-1"><li class="api-ref"><a class="rounded" href="blurfx.html">BlurFX</a></li><li class="api-ref"><a class="rounded" href="colourfx.html">ColourFX</a></li><li class="api-ref"><a class="rounded" href="compositefx.html">CompositeFX</a></li><li class="api-ref"><a class="rounded" href="convolvefx.html">ConvolveFX</a></li><li class="api-ref"><a class="rounded" href="displacementfx.html">DisplacementFX</a></li><li class="api-ref"><a class="rounded" href="filtereffect.html">FilterEffect</a></li><li class="api-ref"><a class="rounded" href="floodfx.html">FloodFX</a></li><li class="api-ref"><a class="rounded" href="imagefx.html">ImageFX</a></li><li class="api-ref"><a class="rounded" href="lightingfx.html">LightingFX</a></li><li class="api-ref"><a class="rounded" href="mergefx.html">MergeFX</a></li><li class="api-ref"><a class="rounded" href="morphologyfx.html">MorphologyFX</a></li><li class="api-ref"><a class="rounded" href="offsetfx.html">OffsetFX</a></li><li class="api-ref"><a class="rounded" href="remapfx.html">RemapFX</a></li><li class="api-ref"><a class="rounded" href="sourcefx.html">SourceFX</a></li><li class="api-ref"><a class="rounded" href="turbulencefx.html">TurbulenceFX</a></li><li class="api-ref"><a class="rounded" href="wavefunctionfx.html">WaveFunctionFX</a></li></ul></div></li>
<li><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle="collapse" data-bs-target="#ext-collapse" aria-expanded="false">Extensions</button><div class="collapse" id="ext-collapse"><ul class="btn-toggle-nav list-unstyled pb-1"><li class="api-ref"><a class="rounded" href="scintilla.html">Scintilla</a></li><li class="api-ref"><a class="rounded" href="scintillasearch.html">ScintillaSearch</a></li></ul></div></li>
<li><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle="collapse" data-bs-target="#gfx-collapse" aria-expanded="false">Graphics</button><div class="collapse" id="gfx-collapse"><ul class="btn-toggle-nav list-unstyled pb-1"><li class="api-ref"><a class="rounded" href="bitmap.html">Bitmap</a></li><li class="api-ref"><a class="rounded" href="clipboard.html">Clipboard</a></li><li class="api-ref"><a class="rounded" href="display.html">Display</a></li><li class="api-ref"><a class="rounded" href="document.html">Document</a></li><li class="api-ref"><a class="rounded" href="font.html">Font</a></li><li class="api-ref"><a class="rounded" href="picture.html">Picture</a></li><li class="api-ref"><a class="rounded" href="pointer.html">Pointer</a></li><li class="api-ref"><a class="rounded" href="surface.html">Surface</a></li><li class="api-ref"><a class="rounded" href="svg.html">SVG</a></li></ul></div></li>
<li><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle="collapse" data-bs-target="#net-collapse" aria-expanded="false">Network</button><div class="collapse" id="net-collapse"><ul class="btn-toggle-nav list-unstyled pb-1"><li class="api-ref"><a class="rounded" href="clientsocket.html">ClientSocket</a></li><li class="api-ref"><a class="rounded" href="http.html">HTTP</a></li><li class="api-ref"><a class="rounded" href="netclient.html">NetClient</a></li><li class="api-ref"><a class="rounded" href="netsocket.html">NetSocket</a></li><li class="api-ref"><a class="rounded" href="proxy.html">Proxy</a></li></ul></div></li>
<li><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle="collapse" data-bs-target="#vectors-collapse" aria-expanded="false">Vectors</button><div class="collapse" id="vectors-collapse"><ul class="btn-toggle-nav list-unstyled pb-1"><li class="api-ref"><a class="rounded" href="vector.html">Vector</a></li><li class="api-ref"><a class="rounded" href="vectorclip.html">VectorClip</a></li><li class="api-ref"><a class="rounded" href="vectorcolour.html">VectorColour</a></li><li class="api-ref"><a class="rounded" href="vectorellipse.html">VectorEllipse</a></li><li class="api-ref"><a class="rounded" href="vectorfilter.html">VectorFilter</a></li><li class="api-ref"><a class="rounded" href="vectorgradient.html">VectorGradient</a></li><li class="api-ref"><a class="rounded" href="vectorgroup.html">VectorGroup</a></li><li class="api-ref"><a class="rounded" href="vectorimage.html">VectorImage</a></li><li class="api-ref"><a class="rounded" href="vectorpath.html">VectorPath</a></li><li class="api-ref"><a class="rounded" href="vectorpattern.html">VectorPattern</a></li><li class="api-ref"><a class="rounded" href="vectorpolygon.html">VectorPolygon</a></li><li class="api-ref"><a class="rounded" href="vectorrectangle.html">VectorRectangle</a></li><li class="api-ref"><a class="rounded" href="vectorscene.html">VectorScene</a></li><li class="api-ref"><a class="rounded" href="vectorshape.html">VectorShape</a></li><li class="api-ref"><a class="rounded" href="vectorspiral.html">VectorSpiral</a></li><li class="api-ref"><a class="rounded" href="vectortext.html">VectorText</a></li><li class="api-ref"><a class="rounded" href="vectortransition.html">VectorTransition</a></li><li class="api-ref"><a class="rounded" href="vectorviewport.html">VectorViewport</a></li><li class="api-ref"><a class="rounded" href="vectorwave.html">VectorWave</a></li></ul></div></li></ul></div></div>
<div class="col-sm-9" style="max-width: 1200px;"><div class="docs-content" style="display:none;" id="default-page"><div class="page-header"><h1>NetSocket Class</h1></div><p class="lead">Manages network connections via TCP/IP sockets.</p>
<p>The NetSocket class provides a simple way of managing TCP/IP socket communications.  Connections from a single client to the server and from the server to multiple clients are supported.  SSL functionality is also integrated.</p>
<p>The design of the NetSocket class caters to asynchronous (non-blocking) communication.  This is achieved primarily through callback fields - connection alerts are managed by <a data-bs-toggle="tooltip" title="A callback trigger for when the state of the NetSocket is changed." href="#tf-Feedback">Feedback</a>, incoming data is received through <a data-bs-toggle="tooltip" title="Callback that is triggered when the socket receives data." href="#tf-Incoming">Incoming</a> and readiness for outgoing data is supported by <a data-bs-toggle="tooltip" title="Callback that is triggered when a socket is ready to send data." href="#tf-Outgoing">Outgoing</a>.</p>
<h4>Client-Server Connections</h4>
<p>After a connection has been established, data may be written using any of the following methods:</p>
<ul>
<li>Write directly to the socket with the <a data-bs-toggle="tooltip" title="Writes data to the socket." href="#ta-Write">Write()</a> action.</li>
<li>Subscribe to the socket by referring to a routine in the <a data-bs-toggle="tooltip" title="Callback that is triggered when a socket is ready to send data." href="#tf-Outgoing">Outgoing</a> field.  The routine will be called to
initially fill the internal write buffer, thereafter it will be called whenever the buffer is empty.</li>
</ul>
<p>It is possible to write to a NetSocket object before the connection to a server is established.  Doing so will buffer the data in the socket until the connection with the server has been initiated, at which point the data will be immediately sent.</p>
<h4>Server-Client Connections</h4>
<p>To accept incoming client connections, create a NetSocket object with the <code>SERVER</code> flag set and define the <a data-bs-toggle="tooltip" title="The port number to use for connections." href="#tf-Port">Port</a> value on which to listen for new clients.  If multiple connections from a single client IP address are allowed, set the <code>MULTI_CONNECT</code> flag.</p>
<p>When a new connection is detected, the <a data-bs-toggle="tooltip" title="A callback trigger for when the state of the NetSocket is changed." href="#tf-Feedback">Feedback</a> function will be called as <code>Feedback(*NetSocket, *ClientSocket, NTC State)</code></p>
<p>The NetSocket parameter refers to the original NetSocket object, <a href="clientsocket.html">ClientSocket</a> applies if a client connection is involved and the State value will be set to <code>NTC::CONNECTED</code>.  If a client disconnects, the <a data-bs-toggle="tooltip" title="A callback trigger for when the state of the NetSocket is changed." href="#tf-Feedback">Feedback</a> function will be called in the same manner but with a State value of <code>NTC::DISCONNECTED</code>.</p>
<p>Information on all active connections can be read from the <a data-bs-toggle="tooltip" title="For server sockets, lists all clients connected to the server." href="#tf-Clients">Clients</a> field.  This contains a linked list of IP addresses and their connections to the server port.</p>
<p>To send data to a client, write it to the target <a href="clientsocket.html">ClientSocket</a>.</p>
<p>All data that is received from client sockets will be passed to the <a data-bs-toggle="tooltip" title="Callback that is triggered when the socket receives data." href="#tf-Incoming">Incoming</a> feedback routine with a reference to a <a href="clientsocket.html">ClientSocket</a>.</p>
<h4>SSL Server Certificates</h4>
<p>For SSL server sockets, custom certificates can be specified using the <a data-bs-toggle="tooltip" title="SSL certificate file to use if in server mode." href="#tf-SSLCertificate">SSLCertificate</a> field. Both PEM and PKCS#12 formats are supported across all platforms.</p>
<p>Example with PKCS#12 certificate:</p>
<p>
<code></code><code> netsocket = obj.new('netsocket', { flags = 'SERVER|SSL', port = 8443, sslCertificate = 'config:ssl/server.p12', sslKeyPassword = 'password123' }) </code><code></code></p>
<p>Example with PEM certificate and separate private key:</p>
<p>
<code></code><code> netsocket = obj.new('netsocket', { flags = 'SERVER|SSL', port = 8443, sslCertificate = 'config:ssl/server.crt', sslPrivateKey = 'config:ssl/server.key' }) </code><code></code></p>
<p>If no custom certificate is specified, the framework will automatically use a localhost self-signed certificate for development purposes.  For production use, always specify a proper certificate signed by a trusted CA.</p>
<h3>Structure</h3><p>The NetSocket class consists of the following fields:</p><table class="table"><thead><th class="col-md-1"><div data-bs-toggle="tooltip" title="Read/Write access indicators are listed below">Access</div></th><th class="col-md-1">Name</th><th class="col-md-1">Type</th><th>Comment</th></thead><tbody><tr data-bs-toggle="collapse" data-bs-target="#fl-Address" style="scroll-margin:3em;" role="button"><td class="col-md-1" id="tf-Address"><i class="bi bi-check-circle-fill text-success" data-bs-toggle="tooltip" title="Direct read access"></i>
                           
                          <i class="bi bi-check-circle text-success" data-bs-toggle="tooltip" title="Functional write access"></i></td><th class="col-md-1">Address</th><td class="col-md-1"><span class="text-nowrap">STRING</span></td><td>An IP address or domain name to connect to.</td></tr><tr><td colspan="4" class="hiddenRow"><div id="fl-Address" class="accordion-body collapse"><div class="doc-content" style="margin:20px">
<p>If this field is set with an IP address or domain name prior to initialisation, an attempt to connect to that location will be made when the NetSocket is initialised.  Post-initialisation this field cannot be set by the client, however calls to <a data-bs-toggle="tooltip" title="Connects a NetSocket to an address." href="#tm-Connect">Connect()</a> will result in it being updated so that it always reflects the named address of the current connection.</p>
      
</div></div></td></tr>
<tr data-bs-toggle="collapse" data-bs-target="#fl-Backlog" style="scroll-margin:3em;" role="button"><td class="col-md-1" id="tf-Backlog"><i class="bi bi-check-circle-fill text-success" data-bs-toggle="tooltip" title="Direct read access"></i>
                           
                          <i class="bi bi-check-lg text-success" data-bs-toggle="tooltip" title="Immutable"></i></td><th class="col-md-1">Backlog</th><td class="col-md-1"><span class="text-nowrap">INT</span></td><td>The maximum number of connections that can be queued against the socket.</td></tr><tr><td colspan="4" class="hiddenRow"><div id="fl-Backlog" class="accordion-body collapse"><div class="doc-content" style="margin:20px">
<p>Incoming connections to NetSocket objects are queued until they are answered by the object.  Setting the Backlog adjusts the maximum number of connections on the queue, which otherwise defaults to 10.</p>
<p>If the backlog is exceeded, subsequent connections to the socket should expect a connection refused error.</p>
      
</div></div></td></tr>
<tr data-bs-toggle="collapse" data-bs-target="#fl-ClientData" style="scroll-margin:3em;" role="button"><td class="col-md-1" id="tf-ClientData"><i class="bi bi-check-circle-fill text-success" data-bs-toggle="tooltip" title="Direct read access"></i>
                           
                          <i class="bi bi-check-circle-fill text-success" data-bs-toggle="tooltip" title="Direct write access"></i></td><th class="col-md-1">ClientData</th><td class="col-md-1"><span class="text-nowrap">APTR</span></td><td>A client-defined value that can be useful in action notify events.</td></tr><tr><td colspan="4" class="hiddenRow"><div id="fl-ClientData" class="accordion-body collapse"><div class="doc-content" style="margin:20px">
<p>This is a free-entry field value that can store client data for future reference.</p>
      
</div></div></td></tr>
<tr data-bs-toggle="collapse" data-bs-target="#fl-ClientLimit" style="scroll-margin:3em;" role="button"><td class="col-md-1" id="tf-ClientLimit"><i class="bi bi-check-circle-fill text-success" data-bs-toggle="tooltip" title="Direct read access"></i>
                           
                          <i class="bi bi-check-circle-fill text-success" data-bs-toggle="tooltip" title="Direct write access"></i></td><th class="col-md-1">ClientLimit</th><td class="col-md-1"><span class="text-nowrap">INT</span></td><td>The maximum number of clients (unique IP addresses) that can be connected to a server socket.</td></tr><tr><td colspan="4" class="hiddenRow"><div id="fl-ClientLimit" class="accordion-body collapse"><div class="doc-content" style="margin:20px">
<p>The ClientLimit value limits the maximum number of IP addresses that can be connected to the socket at any one time. For socket limits per client, see the <a data-bs-toggle="tooltip" title="Limits the number of connected sockets per client IP address." href="#tf-SocketLimit">SocketLimit</a> field.</p>
      
</div></div></td></tr>
<tr data-bs-toggle="collapse" data-bs-target="#fl-Clients" style="scroll-margin:3em;"><td class="col-md-1" id="tf-Clients"><i class="bi bi-check-circle-fill text-success" data-bs-toggle="tooltip" title="Direct read access"></i>
                           
                          <i class="bi bi-dash-circle-fill text-secondary" data-bs-toggle="tooltip" title="Not writeable"></i></td><th class="col-md-1">Clients</th><td class="col-md-1"><span class="text-nowrap"><a href="netclient.html">*NetClient</a></span></td><td>For server sockets, lists all clients connected to the server.</td></tr>
<tr data-bs-toggle="collapse" data-bs-target="#fl-Error" style="scroll-margin:3em;" role="button"><td class="col-md-1" id="tf-Error"><i class="bi bi-check-circle-fill text-success" data-bs-toggle="tooltip" title="Direct read access"></i>
                           
                          <i class="bi bi-dash-circle-fill text-secondary" data-bs-toggle="tooltip" title="Not writeable"></i></td><th class="col-md-1">Error</th><td class="col-md-1"><span class="text-nowrap">ERR</span></td><td>Information about the last error that occurred during a NetSocket operation</td></tr><tr><td colspan="4" class="hiddenRow"><div id="fl-Error" class="accordion-body collapse"><div class="doc-content" style="margin:20px">
<p>This field describes the last error that occurred during a NetSocket operation:</p>
<p>In the case where a NetSocket object enters the <code>NTC::DISCONNECTED</code> state from the <code>NTC::CONNECTED</code> state, this field can be used to determine how a TCP connection was closed.</p>
<table class="table"><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><th class="col-md-1">ERR::Okay</th><td>The connection was closed gracefully.  All data sent by the peer has been received.</td></tr>
<tr><th class="col-md-1">ERR::Disconnected</th><td>The connection was broken in a non-graceful fashion. Data may be lost.</td></tr>
<tr><th class="col-md-1">ERR::TimeOut</th><td>The connect operation timed out.</td></tr>
<tr><th class="col-md-1">ERR::ConnectionRefused</th><td>The connection was refused by the remote host.  Note: This error will not occur on Windows, and instead the Error field will be set to <code>ERR::Failed</code>.</td></tr>
<tr><th class="col-md-1">ERR::NetworkUnreachable</th><td>The network was unreachable.  Note: This error will not occur on Windows, and instead the Error field will be set to <code>ERR::Failed</code>.</td></tr>
<tr><th class="col-md-1">ERR::HostUnreachable</th><td>No path to host was found.  Note: This error will not occur on Windows, and instead the Error field will be set to <code>ERR::Failed</code>.</td></tr>
<tr><th class="col-md-1">ERR::Failed</th><td>An unspecified error occurred.</td></tr>
</tbody></table>
      
</div></div></td></tr>
<tr data-bs-toggle="collapse" data-bs-target="#fl-Feedback" style="scroll-margin:3em;" role="button"><td class="col-md-1" id="tf-Feedback"><i class="bi bi-check-circle text-success" data-bs-toggle="tooltip" title="Functional read access"></i>
                           
                          <i class="bi bi-check-circle text-success" data-bs-toggle="tooltip" title="Functional write access"></i></td><th class="col-md-1">Feedback</th><td class="col-md-1"><span class="text-nowrap">FUNCTION</span></td><td>A callback trigger for when the state of the NetSocket is changed.</td></tr><tr><td colspan="4" class="hiddenRow"><div id="fl-Feedback" class="accordion-body collapse"><div class="doc-content" style="margin:20px">
<p>The client can define a function in this field to receive notifications whenever the state of the socket changes - typically connection messages.</p>
<p>In server mode, the function must follow the prototype <code>Function(*NetSocket, *ClientSocket, NTC State)</code>.  Otherwise <code>Function(*NetSocket, NTC State)</code>.</p>
<p>The <code>NetSocket</code> parameter refers to the NetSocket object to which the function is subscribed.  In server mode, <code>ClientSocket</code> refers to the <a href="clientsocket.html">ClientSocket</a> on which the state has changed.</p>
      
</div></div></td></tr>
<tr data-bs-toggle="collapse" data-bs-target="#fl-Flags" style="scroll-margin:3em;" role="button"><td class="col-md-1" id="tf-Flags"><i class="bi bi-check-circle-fill text-success" data-bs-toggle="tooltip" title="Direct read access"></i>
                           
                          <i class="bi bi-check-circle-fill text-success" data-bs-toggle="tooltip" title="Direct write access"></i></td><th class="col-md-1">Flags</th><td class="col-md-1"><span class="text-nowrap">NSF</span></td><td>Optional flags.</td></tr><tr><td colspan="4" class="hiddenRow"><div id="fl-Flags" class="accordion-body collapse"><div class="doc-content" style="margin:20px">
<table class="table"><thead><tr><th class="col-md-1">Name</th><th>Description</th></tr></thead><tbody><tr><th class="col-md-1">NSF::BROADCAST</th><td>Enable broadcast (UDP only).</td></tr>
<tr><th class="col-md-1">NSF::DISABLE_SERVER_VERIFY</th><td>Disable SSL certificate verification (for testing only).</td></tr>
<tr><th class="col-md-1">NSF::LOG_ALL</th><td>Print extra log messages.</td></tr>
<tr><th class="col-md-1">NSF::MULTI_CONNECT</th><td>Allow multiple connections from the same IP when in server mode.</td></tr>
<tr><th class="col-md-1">NSF::SERVER</th><td>Puts the socket into server mode.  In this state the netsocket object will wait for incoming connections from clients.</td></tr>
<tr><th class="col-md-1">NSF::SSL</th><td>Use Secure Sockets Layer for all communication.</td></tr>
<tr><th class="col-md-1">NSF::SYNCHRONOUS</th><td>Use synchronous (blocking) network calls.</td></tr>
<tr><th class="col-md-1">NSF::UDP</th><td>Use UDP (connectionless datagram protocol) instead of TCP.</td></tr>
</tbody></table>
      
</div></div></td></tr>
<tr data-bs-toggle="collapse" data-bs-target="#fl-Handle" style="scroll-margin:3em;"><td class="col-md-1" id="tf-Handle"><i class="bi bi-check-circle text-success" data-bs-toggle="tooltip" title="Functional read access"></i>
                           
                          <i class="bi bi-check-circle text-success" data-bs-toggle="tooltip" title="Functional write access"></i></td><th class="col-md-1">Handle</th><td class="col-md-1"><span class="text-nowrap">APTR</span></td><td>Platform specific reference to the network socket handle.</td></tr>
<tr data-bs-toggle="collapse" data-bs-target="#fl-Incoming" style="scroll-margin:3em;" role="button"><td class="col-md-1" id="tf-Incoming"><i class="bi bi-check-circle text-success" data-bs-toggle="tooltip" title="Functional read access"></i>
                           
                          <i class="bi bi-check-circle text-success" data-bs-toggle="tooltip" title="Functional write access"></i></td><th class="col-md-1">Incoming</th><td class="col-md-1"><span class="text-nowrap">FUNCTION</span></td><td>Callback that is triggered when the socket receives data.</td></tr><tr><td colspan="4" class="hiddenRow"><div id="fl-Incoming" class="accordion-body collapse"><div class="doc-content" style="margin:20px">
<p>The Incoming field can be set with a custom function that will be called whenever the socket receives data.  The function prototype for C++ is <code>ERR Incoming(*NetSocket, APTR Meta)</code>.  For Fluid use <code>function Incoming(NetSocket)</code>.</p>
<p>The <code>NetSocket</code> parameter refers to the NetSocket object.  <code>Meta</code> is optional userdata from the <code>FUNCTION</code>.</p>
<p>Retrieve data from the socket with the <a data-bs-toggle="tooltip" title="Read information from the socket." href="#ta-Read">Read()</a> action. Reading at least some of the data from the socket is compulsory - if the function does not do this then the data will be cleared from the socket when the function returns. If the callback function returns/raises <code>ERR::Terminate</code> then the Incoming field will be cleared and the function will no longer be called.  All other error codes are ignored.</p>
      
</div></div></td></tr>
<tr data-bs-toggle="collapse" data-bs-target="#fl-MaxPacketSize" style="scroll-margin:3em;" role="button"><td class="col-md-1" id="tf-MaxPacketSize"><i class="bi bi-check-circle-fill text-success" data-bs-toggle="tooltip" title="Direct read access"></i>
                           
                          <i class="bi bi-check-lg text-success" data-bs-toggle="tooltip" title="Immutable"></i></td><th class="col-md-1">MaxPacketSize</th><td class="col-md-1"><span class="text-nowrap">INT</span></td><td>Maximum UDP packet size for sending and receiving data.</td></tr><tr><td colspan="4" class="hiddenRow"><div id="fl-MaxPacketSize" class="accordion-body collapse"><div class="doc-content" style="margin:20px">
<p>This field sets the maximum size in bytes for UDP packets when sending or receiving data.  It only applies to UDP sockets and is ignored for TCP connections.  The default value is 65507 bytes, which is the maximum payload size for UDP packets (65535 - 8 bytes UDP header - 20 bytes IP header).</p>
<p>If you attempt to send a packet larger than MaxPacketSize, a warning will be logged and the operation may fail. When receiving data, packets larger than this size will be truncated.</p>
      
</div></div></td></tr>
<tr data-bs-toggle="collapse" data-bs-target="#fl-MsgLimit" style="scroll-margin:3em;" role="button"><td class="col-md-1" id="tf-MsgLimit"><i class="bi bi-check-circle-fill text-success" data-bs-toggle="tooltip" title="Direct read access"></i>
                           
                          <i class="bi bi-check-lg text-success" data-bs-toggle="tooltip" title="Immutable"></i></td><th class="col-md-1">MsgLimit</th><td class="col-md-1"><span class="text-nowrap">INT</span></td><td>Limits the size of incoming and outgoing data packets.</td></tr><tr><td colspan="4" class="hiddenRow"><div id="fl-MsgLimit" class="accordion-body collapse"><div class="doc-content" style="margin:20px">
<p>This field limits the size of incoming and outgoing message queues (each socket connection receives two queues assigned to both incoming and outgoing messages).  The size is defined in bytes.  Sending or receiving messages that overflow the queue results in the connection being terminated with an error.</p>
<p>The default setting is 1 megabyte.</p>
      
</div></div></td></tr>
<tr data-bs-toggle="collapse" data-bs-target="#fl-MulticastTTL" style="scroll-margin:3em;" role="button"><td class="col-md-1" id="tf-MulticastTTL"><i class="bi bi-check-circle-fill text-success" data-bs-toggle="tooltip" title="Direct read access"></i>
                           
                          <i class="bi bi-check-lg text-success" data-bs-toggle="tooltip" title="Immutable"></i></td><th class="col-md-1">MulticastTTL</th><td class="col-md-1"><span class="text-nowrap">INT</span></td><td>Time-to-live (hop limit) for multicast packets.</td></tr><tr><td colspan="4" class="hiddenRow"><div id="fl-MulticastTTL" class="accordion-body collapse"><div class="doc-content" style="margin:20px">
<p>This field sets the time-to-live (TTL) value for multicast packets sent from UDP sockets.  The TTL determines how many network hops (routers) a multicast packet can traverse before being discarded.  This helps prevent multicast traffic from flooding the network indefinitely.</p>
<p>The default TTL is 1, which restricts multicast to the local network segment.  Higher values allow multicast packets to traverse more network boundaries:</p>
<ul>
<li>1: Local network segment only</li>
<li>32: Within the local site</li>
<li>64: Within the local region</li>
<li>128: Within the local continent</li>
<li>255: Unrestricted (global)</li>
</ul>
      
</div></div></td></tr>
<tr data-bs-toggle="collapse" data-bs-target="#fl-OutQueueSize" style="scroll-margin:3em;"><td class="col-md-1" id="tf-OutQueueSize"><i class="bi bi-check-circle text-success" data-bs-toggle="tooltip" title="Functional read access"></i>
                           
                          <i class="bi bi-dash-circle-fill text-secondary" data-bs-toggle="tooltip" title="Not writeable"></i></td><th class="col-md-1">OutQueueSize</th><td class="col-md-1"><span class="text-nowrap">INT</span></td><td>The number of bytes on the socket's outgoing queue.</td></tr>
<tr data-bs-toggle="collapse" data-bs-target="#fl-Outgoing" style="scroll-margin:3em;" role="button"><td class="col-md-1" id="tf-Outgoing"><i class="bi bi-check-circle text-success" data-bs-toggle="tooltip" title="Functional read access"></i>
                           
                          <i class="bi bi-check-circle text-success" data-bs-toggle="tooltip" title="Functional write access"></i></td><th class="col-md-1">Outgoing</th><td class="col-md-1"><span class="text-nowrap">FUNCTION</span></td><td>Callback that is triggered when a socket is ready to send data.</td></tr><tr><td colspan="4" class="hiddenRow"><div id="fl-Outgoing" class="accordion-body collapse"><div class="doc-content" style="margin:20px">
<p>The Outgoing field can be set with a custom function that will be called whenever the socket is ready to send data. In client mode the function must be in the format <code>ERR Outgoing(*NetSocket, APTR Meta)</code>.  In server mode the function format is <code>ERR Outgoing(*NetSocket, *ClientSocket, APTR Meta)</code>.</p>
<p>To send data to the NetSocket object, call the <a data-bs-toggle="tooltip" title="Writes data to the socket." href="#ta-Write">Write()</a> action.  If the callback function returns an error other than <code>ERR::Okay</code> then the Outgoing field will be cleared and the function will no longer be called.</p>
      
</div></div></td></tr>
<tr data-bs-toggle="collapse" data-bs-target="#fl-Port" style="scroll-margin:3em;"><td class="col-md-1" id="tf-Port"><i class="bi bi-check-circle-fill text-success" data-bs-toggle="tooltip" title="Direct read access"></i>
                           
                          <i class="bi bi-check-lg text-success" data-bs-toggle="tooltip" title="Immutable"></i></td><th class="col-md-1">Port</th><td class="col-md-1"><span class="text-nowrap">INT</span></td><td>The port number to use for connections.</td></tr>
<tr data-bs-toggle="collapse" data-bs-target="#fl-SSLCertificate" style="scroll-margin:3em;" role="button"><td class="col-md-1" id="tf-SSLCertificate"><i class="bi bi-check-circle-fill text-success" data-bs-toggle="tooltip" title="Direct read access"></i>
                           
                          <i class="bi bi-check-circle text-success" data-bs-toggle="tooltip" title="Functional write access"></i></td><th class="col-md-1">SSLCertificate</th><td class="col-md-1"><span class="text-nowrap">STRING</span></td><td>SSL certificate file to use if in server mode.</td></tr><tr><td colspan="4" class="hiddenRow"><div id="fl-SSLCertificate" class="accordion-body collapse"><div class="doc-content" style="margin:20px">
<p>Set SSLCertificate to the path of an SSL certificate file to use when the NetSocket is in server mode.  The certificate file must be in a supported format such as PEM, CRT, or P12.  If no certificate is defined, the NetSocket will either self-sign or use a localhost certificate, if available.</p>
      
</div></div></td></tr>
<tr data-bs-toggle="collapse" data-bs-target="#fl-SSLKeyPassword" style="scroll-margin:3em;" role="button"><td class="col-md-1" id="tf-SSLKeyPassword"><i class="bi bi-check-circle-fill text-success" data-bs-toggle="tooltip" title="Direct read access"></i>
                           
                          <i class="bi bi-check-circle text-success" data-bs-toggle="tooltip" title="Functional write access"></i></td><th class="col-md-1">SSLKeyPassword</th><td class="col-md-1"><span class="text-nowrap">STRING</span></td><td>SSL private key password.</td></tr><tr><td colspan="4" class="hiddenRow"><div id="fl-SSLKeyPassword" class="accordion-body collapse"><div class="doc-content" style="margin:20px">
<p>If the SSL private key is encrypted, set this field to the password required to decrypt it.  If the private key is not encrypted, this field can be left empty.</p>
      
</div></div></td></tr>
<tr data-bs-toggle="collapse" data-bs-target="#fl-SocketLimit" style="scroll-margin:3em;"><td class="col-md-1" id="tf-SocketLimit"><i class="bi bi-check-circle-fill text-success" data-bs-toggle="tooltip" title="Direct read access"></i>
                           
                          <i class="bi bi-check-circle-fill text-success" data-bs-toggle="tooltip" title="Direct write access"></i></td><th class="col-md-1">SocketLimit</th><td class="col-md-1"><span class="text-nowrap">INT</span></td><td>Limits the number of connected sockets per client IP address.</td></tr>
<tr data-bs-toggle="collapse" data-bs-target="#fl-State" style="scroll-margin:3em;" role="button"><td class="col-md-1" id="tf-State"><i class="bi bi-check-circle text-success" data-bs-toggle="tooltip" title="Functional read access"></i>
                           
                          <i class="bi bi-check-circle text-success" data-bs-toggle="tooltip" title="Functional write access"></i></td><th class="col-md-1">State</th><td class="col-md-1"><span class="text-nowrap">NTC</span></td><td>The current connection state of the NetSocket object.</td></tr><tr><td colspan="4" class="hiddenRow"><div id="fl-State" class="accordion-body collapse"><div class="doc-content" style="margin:20px">
<p>The State reflects the connection state of the NetSocket.  If the <a data-bs-toggle="tooltip" title="A callback trigger for when the state of the NetSocket is changed." href="#tf-Feedback">Feedback</a> field is defined with a function, it will be called automatically whenever the state is changed.  Note that the ClientSocket parameter will be NULL when the Feedback function is called.</p>
<p>Note that in server mode this State value should not be used as it cannot reflect the state of all connected client sockets.  Each <a href="clientsocket.html">ClientSocket</a> carries its own independent State value for use instead.</p>
<table class="table"><thead><tr><th class="col-md-1">Name</th><th>Description</th></tr></thead><tbody><tr><th class="col-md-1">NTC::CONNECTED</th><td>There is an active connection at present.</td></tr>
<tr><th class="col-md-1">NTC::CONNECTING</th><td>A connection is being established.</td></tr>
<tr><th class="col-md-1">NTC::DISCONNECTED</th><td>There is no connection.</td></tr>
<tr><th class="col-md-1">NTC::HANDSHAKING</th><td>An SSL connection is being established.</td></tr>
<tr><th class="col-md-1">NTC::MULTISTATE</th><td>In server mode the NetSocket will be set to MULTISTATE to indicate one or more client connections.</td></tr>
<tr><th class="col-md-1">NTC::RESOLVING</th><td>The host name is being resolved.</td></tr>
</tbody></table>
      
</div></div></td></tr>
<tr data-bs-toggle="collapse" data-bs-target="#fl-TotalClients" style="scroll-margin:3em;" role="button"><td class="col-md-1" id="tf-TotalClients"><i class="bi bi-check-circle-fill text-success" data-bs-toggle="tooltip" title="Direct read access"></i>
                           
                          <i class="bi bi-dash-circle-fill text-secondary" data-bs-toggle="tooltip" title="Not writeable"></i></td><th class="col-md-1">TotalClients</th><td class="col-md-1"><span class="text-nowrap">INT</span></td><td>Indicates the total number of clients currently connected to the socket (if in server mode).</td></tr><tr><td colspan="4" class="hiddenRow"><div id="fl-TotalClients" class="accordion-body collapse"><div class="doc-content" style="margin:20px">
<p>In server mode, the NetSocket will maintain a count of the total number of clients currently connected to the socket. You can read the total number of connections from this field.</p>
<p>In client mode, this field is always set to zero.</p>
      
</div></div></td></tr>
</tbody></table><h3>Actions</h3><p>The following actions are currently supported:</p><table class="table"><tbody><tr data-bs-toggle="collapse" data-bs-target="#tac-Disable" style="scroll-margin:3em;" id="ta-Disable" role="button"><td style="width:1%; border-top-style: none; border-bottom-style: none;"><i class="bi bi-chevron-double-right text-secondary"></i></td><th class="col-md-1 text-primary">Disable</th><td>Disables sending and receiving on the socket.</td></tr><tr><td class="hiddenRow" style="width:1%; border-top-style: none; border-bottom-style: none;"></td><td colspan="2" class="hiddenRow"><div id="tac-Disable" class="collapse"><div class="card" style="border-radius: 0;"><div class="card-header action-header" style="border-radius: 0;"><samp>ERR acDisable(*Object)</samp></div></div><div class="docs-content" style="margin:1em .5em 1em .5em;">
<p>This method will stop all sending and receiving of data over the socket.  This is irreversible.</p>
      
<div class="sub-header">Error Codes</div><table class="table table-sm borderless"><tbody><tr><th class="col-md-1">Okay</th><td>Operation successful.</td></tr>
<tr><th class="col-md-1">Failed</th><td>Shutdown operation failed.</td></tr>
</tbody></table></div></div></td></tr>
<tr data-bs-toggle="collapse" data-bs-target="#tac-Read" style="scroll-margin:3em;" id="ta-Read" role="button"><td style="width:1%; border-top-style: none; border-bottom-style: none;"><i class="bi bi-chevron-double-right text-secondary"></i></td><th class="col-md-1 text-primary">Read</th><td>Read information from the socket.</td></tr><tr><td class="hiddenRow" style="width:1%; border-top-style: none; border-bottom-style: none;"></td><td colspan="2" class="hiddenRow"><div id="tac-Read" class="collapse"><div class="card" style="border-radius: 0;"><div class="card-header action-header" style="border-radius: 0;"><samp>ERR acRead(*Object, APTR Buffer, INT Length, INT *Result)</samp></div><div class="card-body" style="padding:0px"><table class="table"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Buffer</td><td>Points a buffer that will receive the data.</td></tr>
<tr><td>Length</td><td>The total number of bytes to read from the object.  This value cannot exceed the size of the Buffer.</td></tr>
<tr><td>Result</td><td>The Read action will write this parameter with the total number of bytes read into the Buffer.</td></tr>
</tbody></table></div></div><div class="docs-content" style="margin:1em .5em 1em .5em;">
<p>The Read() action will read incoming data from the socket and write it to the provided buffer.  If the socket connection is safe, success will always be returned by this action regardless of whether or not data was available.  Almost all other return codes indicate permanent failure and the socket connection will be closed when the action returns.</p>
<p>Because NetSocket objects are non-blocking, reading from the socket is normally performed in the <a data-bs-toggle="tooltip" title="Callback that is triggered when the socket receives data." href="#tf-Incoming">Incoming</a> callback.  Reading from the socket when no data is available will result in an immediate return with no output.</p>
      
<div class="sub-header">Error Codes</div><table class="table table-sm borderless"><tbody><tr><th class="col-md-1">Okay</th><td>Read successful (if no data was on the socket, success is still indicated).</td></tr>
<tr><th class="col-md-1">Failed</th><td>A permanent failure has occurred and socket has been closed.</td></tr>
<tr><th class="col-md-1">InvalidState</th><td>The socket is not in a state that allows reading (e.g. during SSL handshake).</td></tr>
<tr><th class="col-md-1">Disconnected</th><td>The socket connection is closed.</td></tr>
<tr><th class="col-md-1">NullArgs</th><td>Function call missing argument value(s)</td></tr>
</tbody></table></div></div></td></tr>
<tr data-bs-toggle="collapse" data-bs-target="#tac-Write" style="scroll-margin:3em;" id="ta-Write" role="button"><td style="width:1%; border-top-style: none; border-bottom-style: none;"><i class="bi bi-chevron-double-right text-secondary"></i></td><th class="col-md-1 text-primary">Write</th><td>Writes data to the socket.</td></tr><tr><td class="hiddenRow" style="width:1%; border-top-style: none; border-bottom-style: none;"></td><td colspan="2" class="hiddenRow"><div id="tac-Write" class="collapse"><div class="card" style="border-radius: 0;"><div class="card-header action-header" style="border-radius: 0;"><samp>ERR acWrite(*Object, APTR Buffer, INT Length, INT Result)</samp></div><div class="card-body" style="padding:0px"><table class="table"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Buffer</td><td>A buffer containing the data that will be written to the object.</td></tr>
<tr><td>Length</td><td>The total number of bytes to write to the object.</td></tr>
<tr><td>Result</td><td>This parameter with be updated with the total number of bytes written from the Buffer.</td></tr>
</tbody></table></div></div><div class="docs-content" style="margin:1em .5em 1em .5em;">
<p>Writing data to a socket will send raw data to the remote client or server.  Write connections are buffered, so any data overflow generated in a call to this action will be buffered into a software queue.  Resource limits placed on the software queue are governed by the <a data-bs-toggle="tooltip" title="Limits the size of incoming and outgoing data packets." href="#tf-MsgLimit">MsgLimit</a> field setting.</p>
<p>Do not use this action if in server mode.  Instead, write to the <a href="clientsocket.html">ClientSocket</a> object that will receive the data.</p>
<p>It is possible to write to a socket in advance of any connection being made. The netsocket will queue the data and automatically send it once the first connection has been made.</p>
      
</div></div></td></tr>
</tbody></table><h3>Methods</h3><p>The following methods are currently supported:</p><table class="table"><tbody><tr data-bs-toggle="collapse" data-bs-target="#tmx-Connect" role="button" style="scroll-margin:3em;"><th class="col-md-1 text-primary">Connect</th><td id="tm-Connect">Connects a NetSocket to an address.</td></tr><tr><td colspan="2" class="hiddenRow"><div id="tmx-Connect" class="accordion-body collapse"><div class="card" style="border-radius: 0;"><div class="card-header action-header" style="border-radius: 0;"><samp>ERR ns::Connect(OBJECTPTR Object, CSTRING Address, INT Port, DOUBLE Timeout)</samp></div><div class="card-body" style="padding:0px"><table class="table"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Address</td><td>String containing either a domain name (e.g. <code>www.google.com</code>) or an IP address (e.g. <code>123.123.123.123</code>)</td></tr>
<tr><td>Port</td><td>Remote port to connect to.</td></tr>
<tr><td>Timeout</td><td>Connection timeout in seconds (0 = no timeout).</td></tr>
</tbody></table></div></div><div class="docs-content" style="margin:1em .5em 1em .5em;">
<p>This method initiates the connection process with a target IP address.  The address to connect to can be specified either as a domain name, in which case the domain name is first resolved to an IP address, or the address can be specified in standard IP notation.</p>
<p>This method is non-blocking.  It will return immediately and the connection will be resolved once the server responds to the connection request or an error occurs.  Client code should subscribe to the <a data-bs-toggle="tooltip" title="The current connection state of the NetSocket object." href="#tf-State">State</a> field to respond to changes to the connection state.</p>
<p>Pre-Condition: Must be in a connection state of <code>NTC::DISCONNECTED</code></p>
<p>Post-Condition: If this method returns <code>ERR::Okay</code>, will be in state <code>NTC::CONNECTING</code>.</p>
      
<div class="sub-header">Error Codes</div><table class="table table-sm borderless"><tbody><tr><th class="col-md-1">Okay</th><td>The NetSocket connecting process was successfully started.</td></tr>
<tr><th class="col-md-1">Failed</th><td>The connect failed for some other reason.</td></tr>
<tr><th class="col-md-1">Args</th><td>Address was NULL, or Port was not in the required range.</td></tr>
<tr><th class="col-md-1">TimeOut</th><td>Connection attempt timed out.</td></tr>
<tr><th class="col-md-1">InvalidState</th><td>The NetSocket was not in the state <code>NTC::DISCONNECTED</code> or the object is in server mode.</td></tr>
<tr><th class="col-md-1">HostNotFound</th><td>Host name resolution failed.</td></tr>
</tbody></table></div></div></td></tr>
<tr data-bs-toggle="collapse" data-bs-target="#tmx-DisconnectClient" role="button" style="scroll-margin:3em;"><th class="col-md-1 text-primary">DisconnectClient</th><td id="tm-DisconnectClient">Disconnects all sockets connected to a specific client IP.</td></tr><tr><td colspan="2" class="hiddenRow"><div id="tmx-DisconnectClient" class="accordion-body collapse"><div class="card" style="border-radius: 0;"><div class="card-header action-header" style="border-radius: 0;"><samp>ERR ns::DisconnectClient(OBJECTPTR Object, objNetClient * Client)</samp></div><div class="card-body" style="padding:0px"><table class="table"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Client</td><td>The client to be disconnected.</td></tr>
</tbody></table></div></div><div class="docs-content" style="margin:1em .5em 1em .5em;">
<p>For server sockets with client IP connections, this method will terminate all socket connections made to a specific client IP and free the resources allocated to it.  If <a data-bs-toggle="tooltip" title="A callback trigger for when the state of the NetSocket is changed." href="#tf-Feedback">Feedback</a> is defined, a <code>DISCONNECTED</code> state message will also be issued for each socket connection.</p>
<p>If only one socket connection needs to be disconnected, please use <a data-bs-toggle="tooltip" title="Disconnects a single socket that is connected to a client IP address." href="#tm-DisconnectSocket">DisconnectSocket()</a>.</p>
      
<div class="sub-header">Error Codes</div><table class="table table-sm borderless"><tbody><tr><th class="col-md-1">Okay</th><td>Operation successful.</td></tr>
<tr><th class="col-md-1">NullArgs</th><td>Function call missing argument value(s)</td></tr>
<tr><th class="col-md-1">WrongClass</th><td>The Client object is not of type <code>NetClient</code>.</td></tr>
</tbody></table></div></div></td></tr>
<tr data-bs-toggle="collapse" data-bs-target="#tmx-DisconnectSocket" role="button" style="scroll-margin:3em;"><th class="col-md-1 text-primary">DisconnectSocket</th><td id="tm-DisconnectSocket">Disconnects a single socket that is connected to a client IP address.</td></tr><tr><td colspan="2" class="hiddenRow"><div id="tmx-DisconnectSocket" class="accordion-body collapse"><div class="card" style="border-radius: 0;"><div class="card-header action-header" style="border-radius: 0;"><samp>ERR ns::DisconnectSocket(OBJECTPTR Object, objClientSocket * Socket)</samp></div><div class="card-body" style="padding:0px"><table class="table"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Socket</td><td>The client socket to be disconnected.</td></tr>
</tbody></table></div></div><div class="docs-content" style="margin:1em .5em 1em .5em;">
<p>This method will disconnect a socket connection for a given client.  If <a data-bs-toggle="tooltip" title="A callback trigger for when the state of the NetSocket is changed." href="#tf-Feedback">Feedback</a> is defined, a <code>DISCONNECTED</code> state message will also be issued.</p>
<p>NOTE: To terminate the connection of a socket acting as the client, either free the object or return/raise <code>ERR::Terminate</code> during <a data-bs-toggle="tooltip" title="Callback that is triggered when the socket receives data." href="#tf-Incoming">Incoming</a> feedback.</p>
      
<div class="sub-header">Error Codes</div><table class="table table-sm borderless"><tbody><tr><th class="col-md-1">Okay</th><td>Operation successful.</td></tr>
<tr><th class="col-md-1">NullArgs</th><td>Function call missing argument value(s)</td></tr>
</tbody></table></div></div></td></tr>
<tr data-bs-toggle="collapse" data-bs-target="#tmx-GetLocalIPAddress" role="button" style="scroll-margin:3em;"><th class="col-md-1 text-primary">GetLocalIPAddress</th><td id="tm-GetLocalIPAddress">Returns the IP address that the socket is locally bound to.</td></tr><tr><td colspan="2" class="hiddenRow"><div id="tmx-GetLocalIPAddress" class="accordion-body collapse"><div class="card" style="border-radius: 0;"><div class="card-header action-header" style="border-radius: 0;"><samp>ERR ns::GetLocalIPAddress(OBJECTPTR Object, struct IPAddress * Address)</samp></div><div class="card-body" style="padding:0px"><table class="table"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Address</td><td>Pointer to an IPAddress structure which will be set to the result of the query if successful.</td></tr>
</tbody></table></div></div><div class="docs-content" style="margin:1em .5em 1em .5em;">
<p>This method performs the POSIX equivalent of <code>getsockname()</code>.  It returns the current address to which the NetSocket is bound.</p>
      
<div class="sub-header">Error Codes</div><table class="table table-sm borderless"><tbody><tr><th class="col-md-1">Okay</th><td>Operation successful.</td></tr>
<tr><th class="col-md-1">Failed</th><td>General failure.</td></tr>
<tr><th class="col-md-1">NullArgs</th><td>Function call missing argument value(s)</td></tr>
</tbody></table></div></div></td></tr>
<tr data-bs-toggle="collapse" data-bs-target="#tmx-JoinMulticastGroup" role="button" style="scroll-margin:3em;"><th class="col-md-1 text-primary">JoinMulticastGroup</th><td id="tm-JoinMulticastGroup">Join a multicast group for receiving multicast packets (UDP only).</td></tr><tr><td colspan="2" class="hiddenRow"><div id="tmx-JoinMulticastGroup" class="accordion-body collapse"><div class="card" style="border-radius: 0;"><div class="card-header action-header" style="border-radius: 0;"><samp>ERR ns::JoinMulticastGroup(OBJECTPTR Object, CSTRING Group)</samp></div><div class="card-body" style="padding:0px"><table class="table"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Group</td><td>The multicast group address to join (e.g. <code>224.1.1.1</code>).</td></tr>
</tbody></table></div></div><div class="docs-content" style="margin:1em .5em 1em .5em;">
<p>This method joins a multicast group, allowing the socket to receive packets sent to the specified multicast address. This is only available for UDP sockets.</p>
<p>The socket must be bound to a local address before joining a multicast group.</p>
      
<div class="sub-header">Error Codes</div><table class="table table-sm borderless"><tbody><tr><th class="col-md-1">Okay</th><td>Successfully joined the multicast group.</td></tr>
<tr><th class="col-md-1">Failed</th><td>Failed to join multicast group.</td></tr>
<tr><th class="col-md-1">Args</th><td>Invalid multicast address.</td></tr>
<tr><th class="col-md-1">NoSupport</th><td>Socket is not configured for UDP mode.</td></tr>
</tbody></table></div></div></td></tr>
<tr data-bs-toggle="collapse" data-bs-target="#tmx-LeaveMulticastGroup" role="button" style="scroll-margin:3em;"><th class="col-md-1 text-primary">LeaveMulticastGroup</th><td id="tm-LeaveMulticastGroup">Leave a multicast group (UDP only).</td></tr><tr><td colspan="2" class="hiddenRow"><div id="tmx-LeaveMulticastGroup" class="accordion-body collapse"><div class="card" style="border-radius: 0;"><div class="card-header action-header" style="border-radius: 0;"><samp>ERR ns::LeaveMulticastGroup(OBJECTPTR Object, CSTRING Group)</samp></div><div class="card-body" style="padding:0px"><table class="table"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Group</td><td>The multicast group address to leave.</td></tr>
</tbody></table></div></div><div class="docs-content" style="margin:1em .5em 1em .5em;">
<p>This method leaves a previously joined multicast group, stopping the reception of packets sent to the specified multicast address.</p>
      
<div class="sub-header">Error Codes</div><table class="table table-sm borderless"><tbody><tr><th class="col-md-1">Okay</th><td>Successfully left the multicast group.</td></tr>
<tr><th class="col-md-1">Failed</th><td>Failed to leave multicast group.</td></tr>
<tr><th class="col-md-1">Args</th><td>Invalid multicast address.</td></tr>
<tr><th class="col-md-1">NoSupport</th><td>Socket is not configured for UDP mode.</td></tr>
</tbody></table></div></div></td></tr>
<tr data-bs-toggle="collapse" data-bs-target="#tmx-RecvFrom" role="button" style="scroll-margin:3em;"><th class="col-md-1 text-primary">RecvFrom</th><td id="tm-RecvFrom">Receive a datagram packet from any address (UDP only).</td></tr><tr><td colspan="2" class="hiddenRow"><div id="tmx-RecvFrom" class="accordion-body collapse"><div class="card" style="border-radius: 0;"><div class="card-header action-header" style="border-radius: 0;"><samp>ERR ns::RecvFrom(OBJECTPTR Object, struct IPAddress * Source, APTR Buffer, INT BufferSize, INT * BytesRead)</samp></div><div class="card-body" style="padding:0px"><table class="table"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Source</td><td>Source IP address of the received packet.</td></tr>
<tr><td>Buffer</td><td>Pointer to the buffer where received data will be stored.</td></tr>
<tr><td>BufferSize</td><td>Size of the receive buffer in bytes.</td></tr>
<tr><td>BytesRead</td><td>Number of bytes actually received.</td></tr>
</tbody></table></div></div><div class="docs-content" style="margin:1em .5em 1em .5em;">
<p>This method receives a datagram packet from any source address.  It is only available for sockets configured with the UDP flag.  Unlike TCP connections, UDP is connectionless so packets can be received from any source without establishing a connection first.</p>
<p>The method is non-blocking and will return immediately.  If no data is available, <code>ERR::Okay</code> will be returned with <code>BytesRead</code> set to zero.</p>
<p>The source address and port of the received packet will be provided in the output parameters.</p>
<p>For TCP sockets, use the standard Read action instead.</p>
      
<div class="sub-header">Error Codes</div><table class="table table-sm borderless"><tbody><tr><th class="col-md-1">Okay</th><td>Data was received successfully, or no data available.</td></tr>
<tr><th class="col-md-1">Args</th><td>Invalid arguments provided.</td></tr>
<tr><th class="col-md-1">NoSupport</th><td>Socket is not configured for UDP mode.</td></tr>
<tr><th class="col-md-1">BufferOverflow</th><td>Receive buffer is too small for the incoming packet.</td></tr>
</tbody></table></div></div></td></tr>
<tr data-bs-toggle="collapse" data-bs-target="#tmx-SendTo" role="button" style="scroll-margin:3em;"><th class="col-md-1 text-primary">SendTo</th><td id="tm-SendTo">Send a datagram packet to a specific address (UDP only).</td></tr><tr><td colspan="2" class="hiddenRow"><div id="tmx-SendTo" class="accordion-body collapse"><div class="card" style="border-radius: 0;"><div class="card-header action-header" style="border-radius: 0;"><samp>ERR ns::SendTo(OBJECTPTR Object, struct IPAddress * Dest, APTR Data, INT Length, INT * BytesSent)</samp></div><div class="card-body" style="padding:0px"><table class="table"><thead><tr><th class="col-md-1">Parameter</th><th>Description</th></tr></thead><tbody><tr><td>Dest</td><td>The destination IP address (IPv4 or IPv6) and port number.</td></tr>
<tr><td>Data</td><td>Pointer to the data buffer to send.</td></tr>
<tr><td>Length</td><td>Number of bytes to send from Data.</td></tr>
<tr><td>BytesSent</td><td>Number of bytes actually sent.</td></tr>
</tbody></table></div></div><div class="docs-content" style="margin:1em .5em 1em .5em;">
<p>This method sends a datagram packet to a specified IP address and port.  It is only available for sockets configured with the UDP flag.  Unlike TCP connections, UDP is connectionless so packets can be sent to any address without establishing a connection first.</p>
<p>The method is non-blocking and will return immediately.  If the network buffer is full, an <code>ERR::BufferOverflow</code> error will be returned and the client should retry the operation later.</p>
<p>For TCP sockets, use the standard Write action instead.</p>
      
<div class="sub-header">Error Codes</div><table class="table table-sm borderless"><tbody><tr><th class="col-md-1">Okay</th><td>The packet was sent successfully.</td></tr>
<tr><th class="col-md-1">OutOfRange</th><td>Invalid port number specified.</td></tr>
<tr><th class="col-md-1">BufferOverflow</th><td>The network buffer is full, retry later.</td></tr>
<tr><th class="col-md-1">InvalidState</th><td>Socket is not configured for UDP mode.</td></tr>
<tr><th class="col-md-1">NetworkUnreachable</th><td>The destination network is unreachable.</td></tr>
<tr><th class="col-md-1">NullArgs</th><td>Invalid arguments provided.</td></tr>
</tbody></table></div></div></td></tr>
</tbody></table><div class="footer copyright text-right">NetSocket class documentation © Paul Manias © 2005-2025</div></div><div class="docs-content" style="display:none;" id="NSF"><h1>NSF Type</h1><p class="lead"></p><table class="table"><thead><tr><th class="col-md-1">Name</th><th>Description</th></tr></thead><tbody><tr><th>NSF::BROADCAST</th><td>Enable broadcast (UDP only).</td></tr>
<tr><th>NSF::DISABLE_SERVER_VERIFY</th><td>Disable SSL certificate verification (for testing only).</td></tr>
<tr><th>NSF::LOG_ALL</th><td>Print extra log messages.</td></tr>
<tr><th>NSF::MULTI_CONNECT</th><td>Allow multiple connections from the same IP when in server mode.</td></tr>
<tr><th>NSF::SERVER</th><td>Puts the socket into server mode.  In this state the netsocket object will wait for incoming connections from clients.</td></tr>
<tr><th>NSF::SSL</th><td>Use Secure Sockets Layer for all communication.</td></tr>
<tr><th>NSF::SYNCHRONOUS</th><td>Use synchronous (blocking) network calls.</td></tr>
<tr><th>NSF::UDP</th><td>Use UDP (connectionless datagram protocol) instead of TCP.</td></tr>
</tbody></table><div class="footer copyright text-right">NetSocket module documentation © Paul Manias © 2005-2025</div></div>
<div class="docs-content" style="display:none;" id="NTC"><h1>NTC Type</h1><p class="lead">NetSocket states</p><table class="table"><thead><tr><th class="col-md-1">Name</th><th>Description</th></tr></thead><tbody><tr><th>NTC::CONNECTED</th><td>There is an active connection at present.</td></tr>
<tr><th>NTC::CONNECTING</th><td>A connection is being established.</td></tr>
<tr><th>NTC::DISCONNECTED</th><td>There is no connection.</td></tr>
<tr><th>NTC::HANDSHAKING</th><td>An SSL connection is being established.</td></tr>
<tr><th>NTC::MULTISTATE</th><td>In server mode the NetSocket will be set to MULTISTATE to indicate one or more client connections.</td></tr>
<tr><th>NTC::RESOLVING</th><td>The host name is being resolved.</td></tr>
</tbody></table><div class="footer copyright text-right">NetSocket module documentation © Paul Manias © 2005-2025</div></div>
<div class="docs-content" style="display:none;" id="struct-IPAddress"><h1>IPAddress Structure</h1><p class="lead"></p><table class="table"><thead><tr><th class="col-md-1">Field</th><th class="col-md-1">Type</th><th>Description</th></tr></thead><tbody><tr><th>Data</th><td><span class="text-nowrap">INT</span></td><td>128-bit array for supporting both V4 (32-bit host order) and V6 (8-bit byte order) IP addresses.</td></tr>
<tr><th>Type</th><td><span class="text-nowrap">IPADDR</span></td><td>Identifies the address Data value as a V4 or V6 address type.</td></tr>
<tr><th>Port</th><td><span class="text-nowrap">INT</span></td><td>For UDP packets, identifies the client port number in host byte order.</td></tr>
</tbody></table><div class="footer copyright text-right">NetSocket class documentation © Paul Manias © 2005-2025</div></div>
</div></div></div><script type="text/javascript" src="../../js/bootstrap.bundle.min.js"></script><script type="text/javascript" src="../../js/base.js"></script><script type="text/javascript">
const ready = fn => document.readyState !== 'loading' ? fn() : document.addEventListener('DOMContentLoaded', fn);

   var xslt = false;
   var url = window.location.pathname;
   var filename = url.substring(url.lastIndexOf('/')+1);
   if (filename.endsWith(".xml")) { // XSLT is being used to view this document
      filename = filename.substr(0, filename.length-3) + 'html';
      xslt = true;
   }

   // Auto-open the relevant sidebar branch

   var nl = document.querySelectorAll('li[class="api-ref"] > a[href="' + filename + '"]');
   if (nl.length > 0) {
      // Target the last matching element to avoid confusion with matching module names (e.g. Audio module == Audio class)
      var el = nl.item(nl.length-1)
      var parent = getParentNode(el, '[class="collapse"]');
      if (parent) new bootstrap.Collapse(parent, { show: true }); // Causes animation

      el.style.backgroundColor = '#d2f4ea';
   }

   var page = glParameters["page"];
   if (isEmpty(page)) page = glParameters["function"];
   var div = document.getElementById(page);
   if (!div) div = document.getElementById("default-page");
   if (div) div.style.display = "block";

   cancelAnimations();

ready(function(){
   // Initialise tooltips
   var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'))
   var tooltipList = tooltipTriggerList.map(function (tooltipTriggerEl) {
     return new bootstrap.Tooltip(tooltipTriggerEl)
   })

   // In XSLT mode, changing all HTML links to XML is helpful for navigation (if heavy handed)
   if (xslt) {
      var nl = document.querySelectorAll('a[href*=".html"]');
      nl.forEach((el) => {
         el.href = el.href.substr(0, el.href.length-5) + '.xml'
      })
   }
});

         </script></body></html>
