<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="module.xsl"?>

<book>
  <info>
    <name>XPath</name>
    <type>module</type>
    <comment>Provides XPath 2.0 and XQuery support for the XML module.</comment>
    <version>1</version>
    <copyright>Paul Manias Â© 2025</copyright>
    <description>
<p>The XPath module provides comprehensive support for XPath 2.0 and XQuery languages, enabling powerful querying and navigation of XML documents.  It operates in conjunction with the <class name="XML">XML</class> class to provide a standards-compliant query engine with extensive functionality.</p>
<header>XPath 2.0 Path Expressions</header>
<p>The module supports the full XPath 2.0 specification for navigating XML documents, including all 13 standard axes (<code>child</code>, <code>descendant</code>, <code>descendant-or-self</code>, <code>following</code>, <code>following-sibling</code>, <code>parent</code>, <code>ancestor</code>, <code>ancestor-or-self</code>, <code>preceding</code>, <code>preceding-sibling</code>, <code>self</code>, <code>attribute</code>, and <code>namespace</code>), node tests for element names, wildcards (<code>*</code>), and attribute selectors (<code>@attr</code>), numeric position filters (<code>[1]</code>, <code>[2]</code>), comparison operators, and complex boolean expressions in predicates.  Both absolute paths (<code>/root/element</code>), relative paths (<code>element/subelement</code>), and recursive descent (<code>//element</code>) are supported.</p>
<header>XQuery Language Support</header>
<p>The module implements core XQuery functionality including FLWOR expressions (<code>for</code>, <code>let</code>, <code>where</code>, <code>order by</code>, and <code>return</code> clauses) for advanced querying, sequence operations for constructing, filtering, and manipulating sequences of nodes and values, and a comprehensive type system supporting strings, numbers, booleans, node sets, dates, durations, and QNames.</p>
<header>Function Library</header>
<p>A rich set of standard functions is provided across multiple categories:</p>
<list type="bullet">
<li>Node Functions: <code>position()</code>, <code>last()</code>, <code>count()</code>, <code>id()</code>, <code>name()</code>, <code>local-name()</code>, <code>namespace-uri()</code>, <code>root()</code>, <code>node-name()</code>, <code>base-uri()</code></li>
<li>String Functions: <code>concat()</code>, <code>substring()</code>, <code>contains()</code>, <code>starts-with()</code>, <code>ends-with()</code>, <code>string-length()</code>, <code>normalize-space()</code>, <code>upper-case()</code>, <code>lower-case()</code>, <code>translate()</code>, <code>string-join()</code>, <code>encode-for-uri()</code>, <code>escape-html-uri()</code></li>
<li>Numeric Functions: <code>number()</code>, <code>sum()</code>, <code>floor()</code>, <code>ceiling()</code>, <code>round()</code>, <code>round-half-to-even()</code>, <code>abs()</code>, <code>min()</code>, <code>max()</code>, <code>avg()</code></li>
<li>Boolean Functions: <code>boolean()</code>, <code>not()</code>, <code>true()</code>, <code>false()</code>, <code>exists()</code>, <code>empty()</code>, <code>lang()</code></li>
<li>Sequence Functions: <code>distinct-values()</code>, <code>index-of()</code>, <code>insert-before()</code>, <code>remove()</code>, <code>reverse()</code>, <code>subsequence()</code>, <code>unordered()</code>, <code>deep-equal()</code>, <code>zero-or-one()</code>, <code>one-or-more()</code>, <code>exactly-one()</code></li>
<li>Regular Expressions: <code>matches()</code>, <code>replace()</code>, <code>tokenize()</code>, <code>analyze-string()</code></li>
<li>Date and Time Functions: <code>current-date()</code>, <code>current-time()</code>, <code>current-dateTime()</code>, date and time component extractors, timezone adjustments, duration calculations</li>
<li>Document Functions: <code>doc()</code>, <code>doc-available()</code>, <code>collection()</code>, <code>unparsed-text()</code>, <code>unparsed-text-lines()</code>, <code>document-uri()</code></li>
<li>QName Functions: <code>QName()</code>, <code>resolve-QName()</code>, <code>prefix-from-QName()</code>, <code>local-name-from-QName()</code>, <code>namespace-uri-from-QName()</code>, <code>namespace-uri-for-prefix()</code>, <code>in-scope-prefixes()</code></li>
<li>URI Functions: <code>resolve-uri()</code>, <code>iri-to-uri()</code></li>
<li>Formatting Functions: <code>format-date()</code>, <code>format-time()</code>, <code>format-dateTime()</code>, <code>format-integer()</code></li>
<li>Utility Functions: <code>error()</code>, <code>trace()</code></li>
</list>
<header>Expression Compilation</header>
<p>XPath and XQuery expressions are compiled into an optimised internal representation for efficient reuse.  Compiled expressions are thread-safe and can be shared across multiple XML documents.  The compilation step validates syntax and reports detailed error messages.  Compiled expressions are managed as resources and can be freed when no longer needed.</p>
<header>Evaluation Modes</header>
<p>The module provides two distinct modes for query evaluation.  Value evaluation returns typed results (&amp;XPathValue) that can represent node sets, strings, numbers, booleans, dates, or sequences.  Node iteration invokes a callback function for each matching node, enabling streaming processing of large result sets.</p>
<header>Usage Patterns</header>
<p>Compiling and evaluating queries:</p>
<pre>APTR query;
if (xp::Compile(xml, &quot;/bookstore/book[@price &lt; 10]/title&quot;, &amp;query) IS ERR::Okay) {
   XPathValue *result;
   if (xp::Evaluate(xml, query, &amp;result) IS ERR::Okay) {
      // Process result...
      FreeResource(result);
   }
   FreeResource(query);
}
</pre>
<p>Node iteration with callbacks:</p>
<pre>APTR query;
if (xp::Compile(xml, &quot;//chapter[@status='draft']&quot;, &amp;query) IS ERR::Okay) {
   auto callback = C_FUNCTION(process_node);
   xp::Query(xml, query, &amp;callback);
   FreeResource(query);
}
</pre>
<header>Extensions</header>
<p>The module includes several Parasol-specific extensions beyond the standard specification.  Content matching with the <code>[=...]</code> syntax allows matching on encapsulated content, e.g., <code>/menu[=contentmatch]</code>.  Backslash (<code>\</code>) can be used as an escape character in attribute strings.  The <code>@*</code> syntax matches any attribute, e.g., <code>/root/section[@*=&quot;alpha&quot;]</code>.</p></description>
    <classes>
      <class>XQuery</class>
    </classes>
  </info>

  <types>
    <constants lookup="XPathNodeType">
      <const name="ATTRIBUTE_VALUE_TEMPLATE"/>
      <const name="AXIS_SPECIFIER"/>
      <const name="BINARY_OP"/>
      <const name="CASTABLE_EXPRESSION"/>
      <const name="CAST_EXPRESSION"/>
      <const name="COMMENT_CONSTRUCTOR"/>
      <const name="COMPUTED_ATTRIBUTE_CONSTRUCTOR"/>
      <const name="COMPUTED_ELEMENT_CONSTRUCTOR"/>
      <const name="CONDITIONAL"/>
      <const name="CONSTRUCTOR_CONTENT"/>
      <const name="COUNT_CLAUSE"/>
      <const name="DIRECT_ATTRIBUTE_CONSTRUCTOR"/>
      <const name="DIRECT_ELEMENT_CONSTRUCTOR"/>
      <const name="DIRECT_TEXT_CONSTRUCTOR"/>
      <const name="DOCUMENT_CONSTRUCTOR"/>
      <const name="EMPTY_SEQUENCE"/>
      <const name="EXPRESSION"/>
      <const name="FILTER"/>
      <const name="FLWOR_EXPRESSION"/>
      <const name="FOR_BINDING"/>
      <const name="FOR_EXPRESSION"/>
      <const name="FUNCTION_CALL"/>
      <const name="GROUP_CLAUSE"/>
      <const name="GROUP_KEY"/>
      <const name="INSTANCE_OF_EXPRESSION"/>
      <const name="LET_BINDING"/>
      <const name="LET_EXPRESSION"/>
      <const name="LITERAL"/>
      <const name="LOCATION_PATH"/>
      <const name="NAME_TEST"/>
      <const name="NODE_TEST"/>
      <const name="NODE_TYPE_TEST"/>
      <const name="NUMBER"/>
      <const name="ORDER_CLAUSE"/>
      <const name="ORDER_SPEC"/>
      <const name="PATH"/>
      <const name="PI_CONSTRUCTOR"/>
      <const name="PREDICATE"/>
      <const name="PROCESSING_INSTRUCTION_TEST"/>
      <const name="QUANTIFIED_BINDING"/>
      <const name="QUANTIFIED_EXPRESSION"/>
      <const name="ROOT"/>
      <const name="STEP"/>
      <const name="STRING"/>
      <const name="TEXT_CONSTRUCTOR"/>
      <const name="TREAT_AS_EXPRESSION"/>
      <const name="TYPESWITCH_CASE"/>
      <const name="TYPESWITCH_DEFAULT_CASE"/>
      <const name="TYPESWITCH_EXPRESSION"/>
      <const name="UNARY_OP"/>
      <const name="UNION"/>
      <const name="VARIABLE_REFERENCE"/>
      <const name="WHERE_CLAUSE"/>
      <const name="WILDCARD"/>
    </constants>

  </types>
  <structs>
  </structs>
</book>
