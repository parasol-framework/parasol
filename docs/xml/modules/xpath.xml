<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="module.xsl"?>

<book>
  <info>
    <name>XPath</name>
    <type>module</type>
    <comment>Provides XPath 2.0 and XQuery support for the XML module.</comment>
    <version>1</version>
    <copyright>Paul Manias Â© 2025</copyright>
    <description>
<p>The XPath module provides comprehensive support for XPath 2.0 and XQuery languages, enabling powerful querying and navigation of XML documents.  It operates in conjunction with the <class name="XML">XML</class> class to provide a standards-compliant query engine with extensive functionality.</p>
<header>XPath 2.0 Path Expressions</header>
<p>The module supports the full XPath 2.0 specification for navigating XML documents, including all 13 standard axes (<code>child</code>, <code>descendant</code>, <code>descendant-or-self</code>, <code>following</code>, <code>following-sibling</code>, <code>parent</code>, <code>ancestor</code>, <code>ancestor-or-self</code>, <code>preceding</code>, <code>preceding-sibling</code>, <code>self</code>, <code>attribute</code>, and <code>namespace</code>), node tests for element names, wildcards (<code>*</code>), and attribute selectors (<code>@attr</code>), numeric position filters (<code>[1]</code>, <code>[2]</code>), comparison operators, and complex boolean expressions in predicates.  Both absolute paths (<code>/root/element</code>), relative paths (<code>element/subelement</code>), and recursive descent (<code>//element</code>) are supported.</p>
<header>XQuery Language Support</header>
<p>The module implements core XQuery functionality including FLWOR expressions (<code>for</code>, <code>let</code>, <code>where</code>, <code>order by</code>, and <code>return</code> clauses) for advanced querying, sequence operations for constructing, filtering, and manipulating sequences of nodes and values, and a comprehensive type system supporting strings, numbers, booleans, node sets, dates, durations, and QNames.</p>
<header>Function Library</header>
<p>A rich set of standard functions is provided across multiple categories:</p>
<list type="bullet">
<li>Node Functions: <code>position()</code>, <code>last()</code>, <code>count()</code>, <code>id()</code>, <code>name()</code>, <code>local-name()</code>, <code>namespace-uri()</code>, <code>root()</code>, <code>node-name()</code>, <code>base-uri()</code></li>
<li>String Functions: <code>concat()</code>, <code>substring()</code>, <code>contains()</code>, <code>starts-with()</code>, <code>ends-with()</code>, <code>string-length()</code>, <code>normalize-space()</code>, <code>upper-case()</code>, <code>lower-case()</code>, <code>translate()</code>, <code>string-join()</code>, <code>encode-for-uri()</code>, <code>escape-html-uri()</code></li>
<li>Numeric Functions: <code>number()</code>, <code>sum()</code>, <code>floor()</code>, <code>ceiling()</code>, <code>round()</code>, <code>round-half-to-even()</code>, <code>abs()</code>, <code>min()</code>, <code>max()</code>, <code>avg()</code></li>
<li>Boolean Functions: <code>boolean()</code>, <code>not()</code>, <code>true()</code>, <code>false()</code>, <code>exists()</code>, <code>empty()</code>, <code>lang()</code></li>
<li>Sequence Functions: <code>distinct-values()</code>, <code>index-of()</code>, <code>insert-before()</code>, <code>remove()</code>, <code>reverse()</code>, <code>subsequence()</code>, <code>unordered()</code>, <code>deep-equal()</code>, <code>zero-or-one()</code>, <code>one-or-more()</code>, <code>exactly-one()</code></li>
<li>Regular Expressions: <code>matches()</code>, <code>replace()</code>, <code>tokenize()</code>, <code>analyze-string()</code></li>
<li>Date and Time Functions: <code>current-date()</code>, <code>current-time()</code>, <code>current-dateTime()</code>, date and time component extractors, timezone adjustments, duration calculations</li>
<li>Document Functions: <code>doc()</code>, <code>doc-available()</code>, <code>collection()</code>, <code>unparsed-text()</code>, <code>unparsed-text-lines()</code>, <code>document-uri()</code></li>
<li>QName Functions: <code>QName()</code>, <code>resolve-QName()</code>, <code>prefix-from-QName()</code>, <code>local-name-from-QName()</code>, <code>namespace-uri-from-QName()</code>, <code>namespace-uri-for-prefix()</code>, <code>in-scope-prefixes()</code></li>
<li>URI Functions: <code>resolve-uri()</code>, <code>iri-to-uri()</code></li>
<li>Formatting Functions: <code>format-date()</code>, <code>format-time()</code>, <code>format-dateTime()</code>, <code>format-integer()</code></li>
<li>Utility Functions: <code>error()</code>, <code>trace()</code></li>
</list>
<header>Expression Compilation</header>
<p>XPath and XQuery expressions are compiled into an optimised internal representation for efficient reuse.  Compiled expressions are thread-safe and can be shared across multiple XML documents.  The compilation step validates syntax and reports detailed error messages.  Compiled expressions are managed as resources and can be freed when no longer needed.</p>
<header>Evaluation Modes</header>
<p>The module provides two distinct modes for query evaluation.  Value evaluation returns typed results (&amp;XPathValue) that can represent node sets, strings, numbers, booleans, dates, or sequences.  Node iteration invokes a callback function for each matching node, enabling streaming processing of large result sets.</p>
<header>Usage Patterns</header>
<p>Compiling and evaluating queries:</p>
<pre>APTR query;
if (xp::Compile(xml, &quot;/bookstore/book[@price &lt; 10]/title&quot;, &amp;query) IS ERR::Okay) {
   XPathValue *result;
   if (xp::Evaluate(xml, query, &amp;result) IS ERR::Okay) {
      // Process result...
      FreeResource(result);
   }
   FreeResource(query);
}
</pre>
<p>Node iteration with callbacks:</p>
<pre>APTR query;
if (xp::Compile(xml, &quot;//chapter[@status='draft']&quot;, &amp;query) IS ERR::Okay) {
   auto callback = C_FUNCTION(process_node);
   xp::Query(xml, query, &amp;callback);
   FreeResource(query);
}
</pre>
<header>Extensions</header>
<p>The module includes several Parasol-specific extensions beyond the standard specification.  Content matching with the <code>[=...]</code> syntax allows matching on encapsulated content, e.g., <code>/menu[=contentmatch]</code>.  Backslash (<code>\</code>) can be used as an escape character in attribute strings.  The <code>@*</code> syntax matches any attribute, e.g., <code>/root/section[@*=&quot;alpha&quot;]</code>.</p></description>
  </info>

  <function>
    <name>Compile</name>
    <comment>Compiles an XPath or XQuery expression into an executable form.</comment>
    <prototype>ERR xp::Compile(objXML * XML, CSTRING Query, APTR * Result)</prototype>
    <input>
      <param type="objXML *" name="XML">The XML document context for the query (can be NULL if not needed).</param>
      <param type="CSTRING" name="Query">A valid XPath or XQuery expression string.</param>
      <param type="APTR *" name="Result">Receives a pointer to an XPathNode object on success.</param>
    </input>
    <description>
<p>Call the Compile function to convert a valid XPath or XQuery expression string into a compiled form that can be executed against an XML document.  The resulting compiled expression can be reused multiple times for efficiency and must be freed using FreeResource when no longer needed.  They are re-usable between different XML documents and are treated as read-only for thread-safety.</p>
<p>The XML parameter is not required for compilation, but can potentially enhance syntax checking when parsing the expression.  An additional benefit is that error messages will be defined in the #ErrorMsg field of the XML object if parsing fails.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>Evaluate</name>
    <comment>Evaluates a compiled XPath or XQuery expression against an XML document.</comment>
    <prototype>ERR xp::Evaluate(objXML * XML, APTR Query, struct XPathValue ** Result)</prototype>
    <input>
      <param type="objXML *" name="XML">The XML document to evaluate the query against.</param>
      <param type="APTR" name="Query">The compiled XPath or XQuery expression.</param>
      <param type="struct XPathValue **" name="Result">Receives the result of the evaluation.</param>
    </input>
    <description>
<p>Use Evaluate to run a previously compiled XPath or XQuery expression against an XML document. The result of the evaluation is returned in the Result parameter as !XPathValue, which can represent various types of data including node sets, strings, numbers, or booleans.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>Query</name>
    <comment>For node-based queries, evaluates a compiled expression and calls a function for each matching node.</comment>
    <prototype>ERR xp::Query(objXML * XML, APTR Query, FUNCTION * Callback)</prototype>
    <input>
      <param type="objXML *" name="XML">The XML document to evaluate the query against.</param>
      <param type="APTR" name="Query">The compiled XPath or XQuery expression.</param>
      <param type="FUNCTION *" name="Callback">Pointer to a callback function that will be called for each matching node.  Can be NULL if searching for the first matching node.</param>
    </input>
    <description>
<p>Use the Query function to scan an XML document for tags or attributes that match a compiled XPath or XQuery expression. For every matching node, a user-defined callback function is invoked, allowing custom processing of each result.</p>
<p>If no callback is provided, the search stops after the first match and the <class name="XML">XML</class> object's cursor markers will reflect the position of the node.</p>
<p>Note that valid function execution can return <code>ERR:Search</code> if zero matches are found.</p>
    </description>
    <result type="ERR">
      <error code="Okay">At least one matching node was found and processed.</error>
      <error code="Search">No matching node was found.</error>
      <error code="NoData">The XML document contains no data to search.</error>
      <error code="Syntax">The provided query expression has syntax errors.</error>
      <error code="NullArgs">At least one required parameter was not provided.</error>
    </result>
  </function>

  <types>
    <constants lookup="XPathNodeType">
      <const name="ATTRIBUTE_VALUE_TEMPLATE"/>
      <const name="AXIS_SPECIFIER"/>
      <const name="BINARY_OP"/>
      <const name="COMMENT_CONSTRUCTOR"/>
      <const name="COMPUTED_ATTRIBUTE_CONSTRUCTOR"/>
      <const name="COMPUTED_ELEMENT_CONSTRUCTOR"/>
      <const name="CONDITIONAL"/>
      <const name="CONSTRUCTOR_CONTENT"/>
      <const name="COUNT_CLAUSE"/>
      <const name="DIRECT_ATTRIBUTE_CONSTRUCTOR"/>
      <const name="DIRECT_ELEMENT_CONSTRUCTOR"/>
      <const name="DIRECT_TEXT_CONSTRUCTOR"/>
      <const name="DOCUMENT_CONSTRUCTOR"/>
      <const name="EMPTY_SEQUENCE"/>
      <const name="EXPRESSION"/>
      <const name="FILTER"/>
      <const name="FLWOR_EXPRESSION"/>
      <const name="FOR_BINDING"/>
      <const name="FOR_EXPRESSION"/>
      <const name="FUNCTION_CALL"/>
      <const name="GROUP_CLAUSE"/>
      <const name="GROUP_KEY"/>
      <const name="LET_BINDING"/>
      <const name="LET_EXPRESSION"/>
      <const name="LITERAL"/>
      <const name="LOCATION_PATH"/>
      <const name="NAME_TEST"/>
      <const name="NODE_TEST"/>
      <const name="NODE_TYPE_TEST"/>
      <const name="NUMBER"/>
      <const name="ORDER_CLAUSE"/>
      <const name="ORDER_SPEC"/>
      <const name="PATH"/>
      <const name="PI_CONSTRUCTOR"/>
      <const name="PREDICATE"/>
      <const name="PROCESSING_INSTRUCTION_TEST"/>
      <const name="QUANTIFIED_BINDING"/>
      <const name="QUANTIFIED_EXPRESSION"/>
      <const name="ROOT"/>
      <const name="STEP"/>
      <const name="STRING"/>
      <const name="TEXT_CONSTRUCTOR"/>
      <const name="UNARY_OP"/>
      <const name="UNION"/>
      <const name="VARIABLE_REFERENCE"/>
      <const name="WHERE_CLAUSE"/>
      <const name="WILDCARD"/>
    </constants>

  </types>
  <structs>
  </structs>
</book>
