<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="module.xsl"?>

<book>
  <info>
    <name>Core</name>
    <type>module</type>
    <copyright>Paul Manias 1996-2025</copyright>
    <classes>
      <class>CompressedStream</class>
      <class>Compression</class>
      <class>Config</class>
      <class>File</class>
      <class>MetaClass</class>
      <class>Module</class>
      <class>Script</class>
      <class>StorageDevice</class>
      <class>Task</class>
      <class>Thread</class>
      <class>Time</class>
    </classes>
    <categories>
      <category>Events</category>
      <category>Fields</category>
      <category>Files</category>
      <category>Memory</category>
      <category>Messages</category>
      <category>Objects</category>
      <category>System</category>
    </categories>
  </info>

  <function>
    <name>AccessMemory</name>
    <category>Memory</category>
    <comment>Grants access to memory blocks by identifier.</comment>
    <prototype>ERR AccessMemory(MEMORYID Memory, MEM Flags, INT MilliSeconds, APTR * Result)</prototype>
    <input>
      <param type="MEMORYID" name="Memory">The ID of the memory block to access.</param>
      <param type="MEM" name="Flags" lookup="MEM">Set to <code>READ</code>, <code>WRITE</code> or <code>READ_WRITE</code>.</param>
      <param type="INT" name="MilliSeconds">The millisecond interval to wait before a timeout occurs.  Use at least 40ms for best results.</param>
      <param type="APTR *" name="Result">Must refer to an <code>APTR</code> for storing the resolved address.</param>
    </input>
    <description>
<p>Call AccessMemory() to resolve a memory ID to its address and acquire a lock so that it is inaccessible to other threads.</p>
<p>Memory blocks should never be locked for extended periods of time.  Ensure that all locks are matched with a call to <function>ReleaseMemory</function> within the same code block.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="Args">The <code>MilliSeconds</code> value is less or equal to zero.</error>
      <error code="TimeOut">Function timed-out before successful completion.</error>
      <error code="MemoryDoesNotExist">The supplied <code>Memory</code> ID does not refer to an existing memory block.</error>
      <error code="SystemLocked">Part of the system is unreachable due to a persistent lock.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>AccessObject</name>
    <category>Objects</category>
    <comment>Grants exclusive access to objects via unique ID.</comment>
    <prototype>ERR AccessObject(OBJECTID Object, INT MilliSeconds, OBJECTPTR * Result)</prototype>
    <input>
      <param type="OBJECTID" name="Object">The unique ID of the target object.</param>
      <param type="INT" name="MilliSeconds">The limit in milliseconds before a timeout occurs.  The maximum limit is <code>60000</code>, and <code>100</code> is recommended.</param>
      <param type="OBJECTPTR *" name="Result">A pointer storage variable that will store the resulting object address.</param>
    </input>
    <description>
<p>This function resolves an object ID to its address and acquires a lock on the object so that other threads cannot use it simultaneously.</p>
<p>If the <code>Object</code> is already locked, the function will wait until it becomes available.   This must occur within the amount of time specified in the <code>Milliseconds</code> parameter.  If the time expires, the function will return with an <code>ERR::TimeOut</code> error code.  If successful, <code>ERR::Okay</code> is returned and a reference to the object's address is stored in the <code>Result</code> variable.</p>
<p>It is crucial that calls to AccessObject() are followed with a call to <function>ReleaseObject</function> once the lock is no longer required.  Calls to AccessObject() will also nest, so they must be paired with <function>ReleaseObject</function> correctly.</p>
<p>It is recommended that C++ developers use the <code>ScopedObjectLock</code> class to acquire object locks rather than making direct calls to AccessObject().  The following example illustrates lock acquisition within a 1 second time limit:</p>
<pre>{
   pf::ScopedObjectLock&lt;OBJECTPTR&gt; obj(my_object_id, 1000);
   if (lock.granted()) {
      obj.acDraw();
   }
}
</pre>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="TimeOut">Function timed-out before successful completion.</error>
      <error code="SystemLocked">Part of the system is unreachable due to a persistent lock.</error>
      <error code="NoMatchingObject">No matching object was found for the given object ID.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>Action</name>
    <category>Objects</category>
    <comment>This function is responsible for executing action routines.</comment>
    <prototype>ERR Action(AC Action, OBJECTPTR Object, APTR Parameters)</prototype>
    <input>
      <param type="AC" name="Action" lookup="AC">An action or method ID must be specified.</param>
      <param type="OBJECTPTR" name="Object">The target object.</param>
      <param type="APTR" name="Parameters">Optional parameter structure associated with <code>Action</code>.</param>
    </input>
    <description>
<p>This function is the key entry point for executing actions and method routines.  An action is a predefined function call that can be called on any object, while a method is a function call that is specific to a class implementation. You can find a complete list of available actions and their associated details in the Parasol Wiki. The actions and methods supported by any class will be referenced in their auto-generated documentation.</p>
<p>Here are two examples that demonstrate how to make an action call.  The first performs an activation, which does not require any additional arguments.  The second performs a move operation, which requires three additional arguments to be passed to the Action() function:</p>
<pre>1. Action(AC::Activate, Picture, NULL);

2. struct acMove move = { 30, 15, 0 };
   Action(AC::Move, Window, &amp;move);
</pre>
<p>In all cases, action calls in C++ can be simplified by using their corresponding stub functions:</p>
<pre>1.  acActivate(Picture);

2a. acMove(Window, 30, 15, 0);

2b. Window-&gt;move(30, 15, 0);
</pre>
<p>If the class of an object does not support the <code>Action</code> ID, an error code of <code>ERR::NoSupport</code> is returned.  To test an object to see if its class supports an action, use the <function>CheckAction</function> function.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="NoAction">The <code>Action</code> is not supported by the object's supporting class.</error>
      <error code="IllegalActionID">The <code>Action</code> parameter is invalid.</error>
      <error code="ObjectCorrupt">The <code>Object</code> state is corrupted.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>ActionList</name>
    <category>Objects</category>
    <comment>Returns a pointer to the global action table.</comment>
    <prototype>void ActionList(struct ActionTable ** Actions, INT * Size)</prototype>
    <input>
      <param type="struct ActionTable **" name="Actions">A pointer to the Core's action table <code>struct ActionTable *</code> is returned. Please note that the first entry in the <code>ActionTable</code> list has all fields driven to <code>NULL</code>, because valid action ID's start from one, not zero.  The final action in the list is also terminated with <code>NULL</code> fields in order to indicate an end to the list.  Knowing this is helpful when scanning the list or calculating the total number of actions supported by the Core.</param>
      <param type="INT *" name="Size">Total number of elements in the returned list.</param>
    </input>
    <description>
<p>This function returns an array of all actions supported by the Core, including name, arguments and structure size.  The ID of each action is indicated by its index within the array.</p>
<p>The <code>Name</code> field specifies the name of the action.  The <code>Args</code> field refers to the action's argument definition structure, which lists the argument names and their relevant types.  This is matched by the <code>Size</code> field, which indicates the byte-size of the action's related argument structure.  If the action does not support arguments, the <code>Args</code> and <code>Size</code> fields will be set to <code>NULL</code>.  The following illustrates two argument definition examples:</p>
<pre>struct FunctionField argsCopyData[] = {
   { "Destination", FD_INT  },
   { NULL, 0 }
};

struct FunctionField argsResize[] = {
   { "Width",  FD_DOUBLE },
   { "Height", FD_DOUBLE },
   { "Depth",  FD_DOUBLE },
   { NULL, 0 }
};
</pre>
<p>The argument types that can be used by actions are limited to those listed in the following table:</p>
<types lookup="FD">
<type name="LONG">A 32-bit integer value ranging from -2,147,483,647 to 2,147,483,648.</type>
<type name="LARGE">A 64-bit integer value.</type>
<type name="PTR">A standard address space pointer.</type>
<type name="STRING">A pointer to a null-terminated string.</type>
<type name="DOUBLE">A 64-bit floating point value.</type>
<type name="OBJECT">This flag is sometimes set in conjunction with the <code>FD_INT</code> type.  It indicates that the argument refers to an object ID.</type>
<type name="PTRSIZE">This argument type can only be used if it follows an <code>FD_PTR</code> type, and if the argument itself is intended to reflect the size of the buffer referred to by the previous <code>FD_PTR</code> argument.</type>
<type name="RESULT">This special flag is set in conjunction with the other data-based argument types. Example: If the developer is required to supply a pointer to a <code>LONG</code> field in which the function will store a result, the correct argument definition will be <code>FD_RESULT|FD_INT|FD_PTR</code>. To make the definition of these argument types easier, <code>FD_PTRRESULT</code> and <code>FD_INTRESULT</code> macros are also available for use.</type>
</types>
    </description>
  </function>

  <function>
    <name>AddInfoTag</name>
    <category>Files</category>
    <comment>Adds new tags to <st>FileInfo</st> structures.</comment>
    <prototype>ERR AddInfoTag(struct FileInfo * Info, CSTRING Name, CSTRING Value)</prototype>
    <input>
      <param type="struct FileInfo *" name="Info">Pointer to a valid <st>FileInfo</st> structure.</param>
      <param type="CSTRING" name="Name">The name of the tag, which must be declared in camel-case.</param>
      <param type="CSTRING" name="Value">The value to associate with the tag name.  If <code>NULL</code>, any existing tag with a matching <code>Name</code> will be removed.</param>
    </input>
    <description>
<p>This function adds file tags to <st>FileInfo</st> structures.  It is intended for use by the Core and external drivers only.  Tags allow extended attributes to be associated with a file, for example the number of seconds of audio in an MP3 file.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>AddMsgHandler</name>
    <category>Messages</category>
    <comment>Adds a new message handler for processing incoming messages.</comment>
    <prototype>ERR AddMsgHandler(APTR Custom, MSGID MsgType, FUNCTION * Routine, struct MsgHandler ** Handle)</prototype>
    <input>
      <param type="APTR" name="Custom">A custom pointer that will be passed to the message handler when messages are received.</param>
      <param type="MSGID" name="MsgType" lookup="MSGID">The message type that the handler will intercept.  If zero, all incoming messages are passed to the handler.</param>
      <param type="FUNCTION *" name="Routine">Refers to the function that will handle incoming messages.</param>
      <param type="struct MsgHandler **" name="Handle">The resulting handle of the new message handler - retain for <function>FreeResource</function>.</param>
    </input>
    <description>
<p>This function allows handlers to be added for the interception of incoming messages.  Message handling works as follows:</p>
<p>During a call to <function>ProcessMessages</function>, each incoming message will be scanned to determine if a message handler is able to process that message.  All handlers that accept the message type will be called with a copy of the message structure and any additional data.  The message is then removed from the message queue.</p>
<p>When calling AddMsgHandler(), you can provide an optional <code>Custom</code> pointer that will have meaning to the handler.  The <code>MsgType</code> acts as a filter so that only messages with the same type identifier will be passed to the handler.  The <code>Routine</code> parameter must point to the function handler, which will follow this definition:</p>
<pre>ERR handler(APTR Custom, MSGID MsgID, INT MsgType, APTR Message, INT MsgSize)</pre>
<p>The handler must return <code>ERR::Okay</code> if the message was handled.  This means that the message will not be passed to message handlers that are yet to receive the message.  Throw <code>ERR::NothingDone</code> if the message has been ignored or <code>ERR::Continue</code> if the message was processed but may be analysed by other handlers.  Throw <code>ERR::Terminate</code> to break the current <function>ProcessMessages</function> loop.  When using Fluid, this is best achieved by writing <code>check(errorcode)</code> in the handler.</p>
<p>The handler will be identified by a unique pointer returned in the Handle parameter.  This handle will be garbage collected or can be passed to <function>FreeResource</function> once it is no longer required.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Message handler successfully processed.</error>
      <error code="AllocMemory">A call to AllocMemory() failed to create a new memory block.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>AdjustLogLevel</name>
    <category>System</category>
    <comment>Adjusts the base-line of all log messages.</comment>
    <prototype>INT AdjustLogLevel(INT Delta)</prototype>
    <input>
      <param type="INT" name="Delta">The level of adjustment to make to new log messages.  Zero is no change.  The maximum level is +/- 6.</param>
    </input>
    <description>
<p>This function adjusts the detail level of all outgoing log messages.  To illustrate, setting the <code>Delta</code> value to 1 would result in level 5 (API) log messages being bumped to level 6.  If the user's maximum log level output is 5, no further API messages will be output until the base-line is reduced to normal.</p>
<p>The main purpose of AdjustLogLevel() is to reduce log noise.  For instance, creating a new desktop window will result in a large number of new log messages.  Raising the base-line by 2 before creating the window would eliminate the noise if the user has the log level set to 5 (API).  Re-running the program with a log level of 7 or more would make the messages visible again.</p>
<p>Adjustments to the base-line are accumulative, so small increments of 1 or 2 are encouraged.  To revert logging to the previous base-line, call this function again with a negation of the previously passed value.</p>
    </description>
    <result type="INT">Returns the absolute base-line value that was active prior to calling this function.</result>
  </function>

  <function>
    <name>AllocMemory</name>
    <category>Memory</category>
    <comment>Allocates a new memory block on the heap.</comment>
    <prototype>ERR AllocMemory(INT Size, MEM Flags, APTR * Address, MEMORYID * ID)</prototype>
    <input>
      <param type="INT" name="Size">The size of the memory block.</param>
      <param type="MEM" name="Flags" lookup="MEM">Optional flags.</param>
      <param type="APTR *" name="Address">Refer to an <code>APTR</code> to store the address of the allocated memory block.</param>
      <param type="MEMORYID *" name="ID">Refer to a <code>MEMORYID</code> to store the UID of the allocated memory block.</param>
    </input>
    <description>
<p>The AllocMemory() function will allocate a new block of memory on the program's heap.  The client will need to define the minimum byte <code>Size</code>, optional <code>Flags</code> and a variable to store the resulting <code>Address</code> and/or <code>ID</code> of the memory block. For example:</p>
<pre>
APTR address;
if (!AllocMemory(1000, MEM::DATA, &amp;address, NULL)) {
   ...
   FreeResource(address);
}
</pre>
<p>A number of flag definitions are available that affect the memory allocation process.  They are:</p>
<types lookup="MEM"/>
<p>Notice that memory allocation can be returned as an address pointer and/or as a unique memory ID.  Typically a private address with no ID reference is sufficient.</p>
<p>If the client retrieves both the ID and Address pointer, an internal call will be made to <function>AccessMemory</function> to lock the memory block.  This means that before freeing the memory block the client must call <function>ReleaseMemory</function> to unlock it. Blocks that are persistently locked will remain in memory until the process is terminated.</p>
<p>Memory that is allocated through AllocMemory() is automatically cleared with zero-byte values.  When allocating large blocks it may be wise to turn off this feature, achieved by setting the <code>MEM::NO_CLEAR</code> flag.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="Failed">The block could not be allocated due to insufficient memory space.</error>
      <error code="Args">Invalid arguments passed to function.</error>
      <error code="ArrayFull">Although memory space for the block was available, all available memory records are in use.</error>
      <error code="AccessMemory">The block was allocated but access to it was not granted, causing failure.</error>
    </result>
  </function>

  <function>
    <name>AllocateID</name>
    <category>System</category>
    <comment>Generates unique ID's for general purposes.</comment>
    <prototype>INT AllocateID(IDTYPE Type)</prototype>
    <input>
      <param type="IDTYPE" name="Type" lookup="IDTYPE">The type of ID that is required.</param>
    </input>
    <description>
<p>This function generates unique ID's that can be used in other Core functions.  A <code>Type</code> indicator is required and the resulting number will be unique to that <code>Type</code> only.</p>
<p>ID allocations are permanent, so there is no need to free the allocated ID once it is no longer required.</p>
    </description>
    <result type="INT">A unique ID matching the requested type will be returned.  This function can return zero if the Type is unrecognised, or if an internal error occurred.</result>
  </function>

  <function>
    <name>AnalysePath</name>
    <category>Files</category>
    <comment>Analyses paths to determine their type (file, folder or volume).</comment>
    <prototype>ERR AnalysePath(CSTRING Path, LOC * Type)</prototype>
    <input>
      <param type="CSTRING" name="Path">The path to analyse.</param>
      <param type="LOC *" name="Type" lookup="LOC">The result will be stored in the variable referred to by this parameter.  The return types are <code>DIRECTORY</code>, <code>FILE</code> and <code>VOLUME</code>.  Set this parameter to <code>NULL</code> if you are only interested in checking if the file exists.</param>
    </input>
    <description>
<p>This function will analyse a path and determine the type of file that the path is referring to.  For instance, a path of <code>user:documents/</code> would indicate a folder reference.  A path of <code>system:</code> would be recognised as a volume. A path of <code>user:documents/copyright.txt</code> would be recognised as a file.</p>
<p>Ambiguous references are analysed to get the correct type - for example <code>user:documents/helloworld</code> could refer to a folder or file, so the path is analysed to check the file type.  On exceptional occasions where the path could be interpreted as either a folder or a file, preference is given to the folder.</p>
<p>File path approximation is supported if the <code>Path</code> is prefixed with a <code>~</code> character (e.g. <code>~pictures:photo</code> could be matched to <code>photo.jpg</code> in the same folder).</p>
<p>To check if a volume name is valid, call <function>ResolvePath</function> first and then pass the resulting path to this function.</p>
<p>If the queried path does not exist, a fail code is returned.  This behaviour makes the AnalysePath() function a good candidate for testing the validity of a path string.</p>
    </description>
    <result type="ERR">
      <error code="Okay">The path was analysed and the result is stored in the <code>Type</code> variable.</error>
      <error code="DoesNotExist">Resource does not exist.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>AsyncAction</name>
    <category>Objects</category>
    <comment>Execute an action in parallel, via a separate thread.</comment>
    <prototype>ERR AsyncAction(AC Action, OBJECTPTR Object, APTR Args, FUNCTION * Callback)</prototype>
    <input>
      <param type="AC" name="Action" lookup="AC">An action or method ID must be specified here.</param>
      <param type="OBJECTPTR" name="Object">A pointer to the object that is going to perform the action.</param>
      <param type="APTR" name="Args">If the action or method is documented as taking parameters, provide the correct parameter structure here.</param>
      <param type="FUNCTION *" name="Callback">This function will be called after the thread has finished executing the action.</param>
    </input>
    <description>
<p>This function follows the same principles of execution as the Action() function, with the difference of executing the action in parallel via a dynamically allocated thread.  Please refer to the <function>Action</function> function for general information on action execution.</p>
<p>To receive feedback of the action's completion, use the <code>Callback</code> parameter and supply a function.  The prototype for the callback routine is <code>callback(ACTIONID ActionID, OBJECTPTR Object, ERR Error, APTR Meta)</code></p>
<p>It is crucial that the target object is not destroyed while the thread is executing.  Use the <code>Callback</code> routine to receive notification of the thread's completion and then free the object if desired.  The callback will be processed when the main thread makes a call to <function>ProcessMessages</function>, so as to maintain an orderly execution process within the application.</p>
<p>The 'Error' parameter in the callback reflects the error code returned by the action after it has been called.  Note that if AsyncAction() fails, the callback will never be executed because the thread attempt will have been aborted.</p>
<p>Please note that there is some overhead involved when safely initialising and executing a new thread.  This function is at its most effective when used to perform lengthy processes such as the loading and parsing of data.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="Init">Error in Init()ialising an object.</error>
      <error code="IllegalMethodID">Illegal method ID (number outside of valid range).</error>
      <error code="MissingClass">The class could not be found in the system.</error>
      <error code="NewObject">A call to NewObject() failed to produce a new object.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>BroadcastEvent</name>
    <category>Events</category>
    <comment>Broadcast an event to all event listeners in the system.</comment>
    <prototype>ERR BroadcastEvent(APTR Event, INT EventSize)</prototype>
    <input>
      <param type="APTR" name="Event">Pointer to an event structure.</param>
      <param type="INT" name="EventSize">The size of the <code>Event</code> structure, in bytes.</param>
    </input>
    <description>
<p>Use BroadcastEvent() to broadcast an event to all listeners for that event in the system.  An event structure is required that must start with a 64-bit <code>EventID</code> acquired from <function>GetEventID</function>, followed by any required data that is relevant to that event.  Here are some examples:</p>
<pre>typedef struct { EVENTID EventID; char Name[1]; } evVolumeCreated;
typedef struct { EVENTID EventID; OBJECTID TaskID; } evTaskCreated;
typedef struct { EVENTID EventID; OBJECTID TaskID; OBJECTID ProcessID; } evTaskRemoved;
</pre>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>CheckAction</name>
    <category>Objects</category>
    <comment>Checks objects to see whether or not they support certain actions.</comment>
    <prototype>ERR CheckAction(OBJECTPTR Object, AC Action)</prototype>
    <input>
      <param type="OBJECTPTR" name="Object">The target object.</param>
      <param type="AC" name="Action" lookup="AC">A registered action or method ID.</param>
    </input>
    <description>
<p>This function returns <code>ERR::True</code> if an object's class supports a given action or method ID.  For example:</p>
<pre>if (CheckAction(pic, AC::Query) IS ERR::True) {
   // The Query action is supported.
}
</pre>
    </description>
    <result type="ERR">
      <error code="True">The object supports the specified action.</error>
      <error code="False">The action is not supported.</error>
      <error code="LostClass">The object has lost its class reference.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>CheckMemoryExists</name>
    <category>Memory</category>
    <comment>Checks if a memory block still exists.</comment>
    <prototype>ERR CheckMemoryExists(MEMORYID ID)</prototype>
    <input>
      <param type="MEMORYID" name="ID">The ID of the memory block that will be checked.</param>
    </input>
    <description>
<p>Use CheckMemoryExists() to confirm if a specific memory block still exists by referencing its <code>ID</code>.</p>
    </description>
    <result type="ERR">
      <error code="Okay">The block exists.</error>
      <error code="False">The block does not exist.</error>
    </result>
  </function>

  <function>
    <name>CheckObjectExists</name>
    <category>Objects</category>
    <comment>Checks if a particular object is still available in the system.</comment>
    <prototype>ERR CheckObjectExists(OBJECTID Object)</prototype>
    <input>
      <param type="OBJECTID" name="Object">The object identity to verify.</param>
    </input>
    <description>
<p>The CheckObjectExists() function verifies the presence of any object created by <function>NewObject</function>.</p>
    </description>
    <result type="ERR">
      <error code="True">The object exists.</error>
      <error code="False">The object ID does not exist.</error>
      <error code="LockFailed">Failed to lock a required resource.</error>
    </result>
  </function>

  <function>
    <name>CompareFilePaths</name>
    <category>Files</category>
    <comment>Checks if two file paths refer to the same physical file.</comment>
    <prototype>ERR CompareFilePaths(CSTRING PathA, CSTRING PathB)</prototype>
    <input>
      <param type="CSTRING" name="PathA">File location 1.</param>
      <param type="CSTRING" name="PathB">File location 2.</param>
    </input>
    <description>
<p>This function will test two file paths, checking if they refer to the same file in a storage device.  It uses a string comparison on the resolved path names, then attempts a second test based on an in-depth analysis of file attributes if the string comparison fails.  In the event of a match, <code>ERR::Okay</code> is returned.  All other error codes indicate a mis-match or internal failure.</p>
<p>The targeted paths do not have to refer to an existing file or folder in order to match (i.e. match on string comparison succeeds).</p>
    </description>
    <result type="ERR">
      <error code="Okay">The file paths refer to the same file.</error>
      <error code="False">The file paths refer to different files.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>CopyFile</name>
    <category>Files</category>
    <comment>Makes copies of folders and files.</comment>
    <prototype>ERR CopyFile(CSTRING Source, CSTRING Dest, FUNCTION * Callback)</prototype>
    <input>
      <param type="CSTRING" name="Source">The source location.</param>
      <param type="CSTRING" name="Dest">The destination location.</param>
      <param type="FUNCTION *" name="Callback">Optional callback for receiving feedback during the operation.</param>
    </input>
    <description>
<p>This function is used to copy files and folders to new locations.  When copying folders it will do so recursively, so as to copy all sub-folders and files within the location.</p>
<p>It is important that you are aware that different types of string formatting can give different results.  The following examples illustrate:</p>
<p>Copying <code>parasol:makefile</code> to <code>parasol:documents</code> results in a file called <code>parasol:documents</code>.</p>
<p>Copying <code>parasol:makefile</code> to <code>parasol:documents/</code> results in a file called <code>parasol:documents/makefile</code>.</p>
<p>Copying <code>parasol:pictures/</code> to <code>parasol:documents/</code> results in a folder at <code>parasol:documents/pictures</code> and includes a copy of all folders and files found within the pictures folder.</p>
<p>Copying <code>parasol:pictures/</code> to <code>parasol:documents</code> results in a folder at <code>parasol:documents</code> (if the documents folder already exists, it receives additional content from the pictures folder).</p>
<p>This function will overwrite any destination file(s) that already exist.</p>
<p>The Source parameter should always clarify the type of location that is being copied.  For example if copying a folder, a forward slash must terminate the string or it will be assumed that a file is the source.</p>
<p>The Callback parameter can be set with a function that matches this prototype:</p>
<p>
<code>LONG Callback(struct FileFeedback *)</code></p>
<p>For each file that is processed during the copy operation, a &amp;FileFeedback structure is passed that describes the source file and its target.  The callback must return a constant value that can potentially affect file processing. Valid values are <code>FFR::Okay</code> (copy the file), <code>FFR::Skip</code> (do not copy the file) and <code>FFR::Abort</code> (abort the process completely and return <code>ERR::Cancelled</code> as an error code).</p>
    </description>
    <result type="ERR">
      <error code="Okay">The source was copied to its destination successfully.</error>
      <error code="Failed">A failure occurred during the copy process.</error>
      <error code="Args">Invalid arguments passed to function.</error>
    </result>
  </function>

  <function>
    <name>CreateFolder</name>
    <category>Files</category>
    <comment>Makes new folders.</comment>
    <prototype>ERR CreateFolder(CSTRING Path, PERMIT Permissions)</prototype>
    <input>
      <param type="CSTRING" name="Path">The location of the folder.</param>
      <param type="PERMIT" name="Permissions" lookup="PERMIT">Security permissions to apply to the created Dir(s).  Set to <code>NULL</code> if only the current user should have access.</param>
    </input>
    <description>
<p>This function creates new folders.  You are required to specify the full path of the new folder.  Standard permission flags can be passed to determine the new permissions to set against the newly created Dir(s).  If no permission flags are passed, only the current user will have access to the new folder (assuming that the file system supports security settings on the given media).  This function will create multiple folders if the complete path does not exist at the time of the call.</p>
<p>On Unix systems you can define the owner and group ID's for the new folder by calling the <function>SetDefaultPermissions</function> function prior to CreateFolder().</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="Failed">General failure.</error>
      <error code="NoSupport">Virtual file system does not support folder creation.</error>
      <error code="FileExists">An identically named file or folder already exists at the <code>Path</code>.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>CreateLink</name>
    <category>Files</category>
    <comment>Creates symbolic links on Unix file systems.</comment>
    <prototype>ERR CreateLink(CSTRING From, CSTRING To)</prototype>
    <input>
      <param type="CSTRING" name="From">The symbolic link will be created at the location specified here.</param>
      <param type="CSTRING" name="To">The file that you are linking to is specified here.</param>
    </input>
    <description>
<p>Use the CreateLink() function to create symbolic links on Unix file systems. The link connects a new file created at <code>From</code> to an existing file referenced at <code>To</code>. The <code>To</code> link is allowed to be relative to the <code>From</code> location - for instance, you can link <code>documents:myfiles/newlink.txt</code> to <code>../readme.txt</code> or <code>folder/readme.txt</code>. The <code>..</code> path component must be used when making references to parent folders.</p>
<p>The permission flags for the link are inherited from the file that you are linking to.  If the file location referenced at <code>From</code> already exists as a file or folder, the function will fail with an <code>ERR::FileExists</code> error code.</p>
<p>This function does not automatically create folders in circumstances where new folders are required to complete the <code>From</code> link.  You will need to call <function>CreateFolder</function> to ensure that the necessary paths exist beforehand.  If the file referenced at To does not exist, the link will be created without error, but any attempts to open the link will fail until the target file or folder exists.</p>
    </description>
    <result type="ERR">
      <error code="Okay">The link was created successfully.</error>
      <error code="NoSupport">The file system or the host operating system does not support symbolic links.</error>
      <error code="Memory">General memory error.</error>
      <error code="LowCapacity">There is no room on the device to create the new link.</error>
      <error code="NoPermission">The user does not have permission to create the link, or the file system is mounted read-only.</error>
      <error code="BufferOverflow">One or both of the provided arguments is too long.</error>
      <error code="FileExists">The location referenced at From already exists.</error>
      <error code="ResolvePath">A volume could not be resolved.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>CurrentContext</name>
    <category>Objects</category>
    <comment>Returns a pointer to the object that has the current context.</comment>
    <prototype>OBJECTPTR CurrentContext()</prototype>
    <description>
<p>This function returns a pointer to the object that has the current context.  Context is primarily used to manage resource allocations.  Manipulating the context is sometimes necessary to ensure that a resource is tracked to the correct object.</p>
<p>To get the context of the caller (the client), use <function>ParentContext</function>.</p>
    </description>
    <result type="OBJECTPTR">Returns an object pointer (of which the process has exclusive access to).  Cannot return <code>NULL</code> except in the initial start-up and late shut-down sequence of the Core.</result>
  </function>

  <function>
    <name>CurrentTask</name>
    <category>System</category>
    <comment>Returns the active Task object.</comment>
    <prototype>objTask * CurrentTask()</prototype>
    <description>
<p>This function returns the <class name="Task">Task</class> object of the active process.</p>
<p>If there is a legitimate circumstance where there is no current task (e.g. if this function is called during Core initialisation) then the "system task" may be returned, which has ownership of Core resources.</p>
    </description>
    <result type="objTask *">Returns a pointer to the current Task object or NULL if failure.</result>
  </function>

  <function>
    <name>DeleteFile</name>
    <category>Files</category>
    <comment>Deletes files and folders.</comment>
    <prototype>ERR DeleteFile(CSTRING Path, FUNCTION * Callback)</prototype>
    <input>
      <param type="CSTRING" name="Path">String referring to the file or folder to be deleted.  Folders must be denoted with a trailing slash.</param>
      <param type="FUNCTION *" name="Callback">Optional callback for receiving feedback during the operation.</param>
    </input>
    <description>
<p>This function will delete a file or folder when given a valid file location.  The current user must have delete access to the given file. When deleting folders, all content will be scanned and deleted recursively. Individual deletion failures are ignored, although an error will be returned if the top-level folder still contains content on its deletion.</p>
<p>This function does not allow for the approximation of file names.  To approximate a file location, open it as a <class name="File">File</class> object or use <function>ResolvePath</function> first.</p>
<p>The <code>Callback</code> parameter can be set with a function that matches the prototype <code>LONG Callback(struct FileFeedback *)</code>.</p>
<p>Prior to the deletion of any file, a <st>FileFeedback</st> structure is passed that describes the file's location.  The callback must return a constant value that can potentially affect file processing.  Valid values are <code>FFR::Okay</code> (delete the file), <code>FFR::Skip</code> (do not delete the file) and <code>FFR::Abort</code> (abort the process completely and return <code>ERR::Cancelled</code> as an error code).</p>
    </description>
    <result type="ERR">
      <error code="Okay">The file or folder was deleted successfully.</error>
      <error code="File">The location could not be opened for deletion.</error>
      <error code="FileNotFound">File not found.</error>
      <error code="NoSupport">The filesystem driver does not support deletion.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>DeleteVolume</name>
    <category>Files</category>
    <comment>Deletes volumes from the system.</comment>
    <prototype>ERR DeleteVolume(CSTRING Name)</prototype>
    <input>
      <param type="CSTRING" name="Name">The name of the volume.</param>
    </input>
    <description>
<p>This function deletes volume names from the system.  Once a volume is deleted, any further references to it will result in errors unless the volume is recreated.</p>
    </description>
    <result type="ERR">
      <error code="Okay">The volume was removed.</error>
      <error code="LockFailed">Failed to lock a required resource.</error>
      <error code="NoPermission">An attempt to delete a system volume was denied.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>FieldName</name>
    <category>Fields</category>
    <comment>Resolves a field ID to its registered name.</comment>
    <prototype>CSTRING FieldName(UINT FieldID)</prototype>
    <input>
      <param type="UINT" name="FieldID">The unique field hash to resolve.</param>
    </input>
    <description>
<p>Resolves a field identifier to its name by checking the internal dictionary.  The field must have previously been referenced by a class blueprint in order for its name to be registered.</p>
<p>If <code>FieldID</code> is not registered, the value is returned as a printable hex string.</p>
    </description>
    <result type="CSTRING">The name of the field is returned.</result>
  </function>

  <function>
    <name>FindClass</name>
    <category>Objects</category>
    <comment>Returns the internal MetaClass for a given class ID.</comment>
    <prototype>objMetaClass * FindClass(CLASSID ClassID)</prototype>
    <input>
      <param type="CLASSID" name="ClassID">A class ID such as one retrieved from <function>ResolveClassName</function>.</param>
    </input>
    <description>
<p>This function will find a specific class by ID and return its <class name="MetaClass">MetaClass</class>.  If the class is not already loaded, the internal dictionary is checked to discover a module binary registered with that ID.  If this succeeds, the module is loaded into memory and the correct MetaClass will be returned.</p>
<p>In any event of failure, <code>NULL</code> is returned.</p>
<p>If the ID of a named class is not known, call <function>ResolveClassName</function> first and pass the resulting ID to this function.</p>
    </description>
    <result type="objMetaClass *">Returns a pointer to the <class name="MetaClass">MetaClass</class> structure that has been found as a result of the search, or <code>NULL</code> if no matching class was found.</result>
  </function>

  <function>
    <name>FindField</name>
    <category>Fields</category>
    <comment>Finds field descriptors for any class, by ID.</comment>
    <prototype>struct Field * FindField(OBJECTPTR Object, UINT FieldID, OBJECTPTR * Target)</prototype>
    <input>
      <param type="OBJECTPTR" name="Object">The target object.</param>
      <param type="UINT" name="FieldID">The 'FID' number to lookup.</param>
      <param type="OBJECTPTR *" name="Target">(Optional) The object that represents the field is returned here (in case a field belongs to an integrated child object).</param>
    </input>
    <description>
<p>The FindField() function checks if an object supports a specified field by scanning its class descriptor for a <code>FieldID</code>. If a matching field is declared, its descriptor is returned.  For example:</p>
<pre>if (auto field = FindField(Display, FID_Width, NULL)) {
   log.msg("The field name is \"%s\".", field-&gt;Name);
}
</pre>
<p>The resulting <st>Field</st> structure is immutable.</p>
<p>Note: To lookup the field definition of a <class name="MetaClass">MetaClass</class>, use the <class name="MetaClass" method="FindField">MetaClass.FindField()</class> method.</p>
    </description>
    <result type="struct Field *">Returns a pointer to the <st>Field</st> descriptor, otherwise <code>NULL</code> if not found.</result>
  </function>

  <function>
    <name>FindObject</name>
    <category>Objects</category>
    <comment>Searches for objects by name.</comment>
    <prototype>ERR FindObject(CSTRING Name, CLASSID ClassID, FOF Flags, OBJECTID * ObjectID)</prototype>
    <input>
      <param type="CSTRING" name="Name">The name of an object to search for.</param>
      <param type="CLASSID" name="ClassID">Optional.  Set to a class ID to filter the results down to a specific class type.</param>
      <param type="FOF" name="Flags" lookup="FOF">Optional flags.</param>
      <param type="OBJECTID *" name="ObjectID">An object id variable for storing the result.</param>
    </input>
    <description>
<p>The FindObject() function searches for all objects that match a given name and can filter by class.</p>
<p>The following example illustrates typical usage, and finds the most recent object created with a given name:</p>
<pre>OBJECTID id;
FindObject("SystemPointer", CLASSID::POINTER, FOF::NIL, &amp;id);
</pre>
<p>If FindObject() cannot find any matching objects then it will return an error code.</p>
    </description>
    <result type="ERR">
      <error code="Okay">At least one matching object was found and stored in the <code>ObjectID</code>.</error>
      <error code="Search">No objects matching the given name could be found.</error>
      <error code="Args">Invalid arguments passed to function.</error>
      <error code="LockFailed">Failed to lock a required resource.</error>
      <error code="EmptyString">A required string value contains no characters.</error>
      <error code="DoesNotExist">Resource does not exist.</error>
    </result>
  </function>

  <function>
    <name>FreeResource</name>
    <category>Memory</category>
    <comment>Frees resources originating from AllocMemory().</comment>
    <prototype>ERR FreeResource(MEMORYID ID)</prototype>
    <input>
      <param type="MEMORYID" name="ID">The unique ID of the memory block.</param>
    </input>
    <description>
<p>This function will free any resource that originates from AllocMemory(), using its <code>ID</code> for identification.  C++ headers also include a variant of this function that allows a direct memory pointer to be used as the identifier (however we do recommend the use of IDs to improve memory safety).</p>
<p>In some circumstances the termination of the block will not take place immediately.  If the block is locked then it will be marked for deletion and not be collected until the lock count reaches zero.</p>
<p>Crash protection measures are built-in.  If the memory header or tail is missing from the block, it is assumed that code has over-written the memory boundaries.  All caught errors are reported to the application log and warrant priority attention.</p>
    </description>
    <result type="ERR">
      <error code="Okay">The memory block was freed or marked for deletion.</error>
      <error code="InvalidData">The bounds of the block are damaged.</error>
      <error code="MemoryDoesNotExist">Memory block does not exist.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>GenCRC32</name>
    <category>System</category>
    <comment>Generates 32-bit CRC checksum values.</comment>
    <prototype>UINT GenCRC32(UINT CRC, APTR Data, UINT Length)</prototype>
    <input>
      <param type="UINT" name="CRC">If streaming data to this function, this value should reflect the most recently returned CRC integer.  Otherwise set to zero.</param>
      <param type="APTR" name="Data">The data to generate a CRC value for.</param>
      <param type="UINT" name="Length">The length of the <code>Data</code> buffer.</param>
    </input>
    <description>
<p>This function is used internally for the generation of 32-bit CRC checksums.  You may use it for your own purposes to generate CRC values over a length of buffer space.  This function may be called repeatedly by feeding it previous CRC values, making it ideal for processing streamed data.</p>
    </description>
    <result type="UINT">Returns the computed 32 bit CRC value for the given data.</result>
  </function>

  <function>
    <name>GetActionMsg</name>
    <category>Objects</category>
    <comment>Returns a message structure if called from an action that was executed by the message system.</comment>
    <prototype>struct Message * GetActionMsg()</prototype>
    <description>
<p>This function is for use by action and method support routines only.  It will return a <st>Message</st> structure if the action currently under execution has been called directly from the <function>ProcessMessages</function> function.  In all other cases a <code>NULL</code> pointer is returned.</p>
    </description>
    <result type="struct Message *">A <st>Message</st> structure is returned if the function is called in valid circumstances, otherwise <code>NULL</code>.</result>
  </function>

  <function>
    <name>GetClassID</name>
    <category>Objects</category>
    <comment>Returns the class ID of an ID-referenced object.</comment>
    <prototype>CLASSID GetClassID(OBJECTID Object)</prototype>
    <input>
      <param type="OBJECTID" name="Object">The object to be examined.</param>
    </input>
    <description>
<p>Call this function with any valid object ID to learn the identifier for its base class.  This is the quickest way to retrieve the class of an object without having to gain exclusive access to the object first.</p>
<p>Note that if the object's pointer is already known, the quickest way to learn of its class is to call the <code>classID()</code> C++ method.</p>
    </description>
    <result type="CLASSID">Returns the base class ID of the object or zero if failure.</result>
  </function>

  <function>
    <name>GetErrorMsg</name>
    <category>Logging</category>
    <comment>Translates error codes into human readable strings.</comment>
    <prototype>CSTRING GetErrorMsg(ERR Error)</prototype>
    <input>
      <param type="ERR" name="Error">The error code to lookup.</param>
    </input>
    <description>
<p>The GetErrorMsg() function converts error codes into human readable strings.  If the <code>Error</code> is invalid, a string of "Unknown error code" is returned.</p>
    </description>
    <result type="CSTRING">A human readable string for the error code is returned.  By default error codes are returned in English, however if a translation table exists for the user's own language, the string will be translated.</result>
  </function>

  <function>
    <name>GetEventID</name>
    <category>Events</category>
    <comment>Generates unique event ID's suitable for event broadcasting.</comment>
    <prototype>INT64 GetEventID(EVG Group, CSTRING SubGroup, CSTRING Event)</prototype>
    <input>
      <param type="EVG" name="Group" lookup="EVG">The group to which the event belongs.</param>
      <param type="CSTRING" name="SubGroup">The sub-group to which the event belongs (case-sensitive).</param>
      <param type="CSTRING" name="Event">The name of the event (case-sensitive).</param>
    </input>
    <description>
<p>Use GetEventID() to generate a 64-bit event identifier.  This identifier can be used for broadcasting and subscribing to events.  Events are described in three parts - <code>Group</code>, <code>SubGroup</code> and the <code>Event</code> name, or in string format <code>group.subgroup.event</code>.</p>
<p>The <code>Group</code> is strictly limited to one of the following definitions:</p>
<types lookup="EVG"/>
<p>The <code>SubGroup</code> and <code>Event</code> parameters are string-based and there are no restrictions on naming.  If a <code>SubGroup</code> or <code>Event</code> name is <code>NULL</code>, this will act as a wildcard for subscribing to multiple events.  For example, subscribing to the network group with <code>SubGroup</code> and <code>Event</code> set to <code>NULL</code> will allow for a subscription to all network events that are broadcast.  A <code>Group</code> setting of zero is not allowed.</p>
    </description>
    <result type="INT64">The event ID is returned as a 64-bit integer.</result>
  </function>

  <function>
    <name>GetObjectPtr</name>
    <category>Objects</category>
    <comment>Returns a direct pointer for any object ID.</comment>
    <prototype>OBJECTPTR GetObjectPtr(OBJECTID Object)</prototype>
    <input>
      <param type="OBJECTID" name="Object">The ID of the object to lookup.</param>
    </input>
    <description>
<p>This function translates an object ID to its respective address pointer.</p>
    </description>
    <result type="OBJECTPTR">The address of the object is returned, or <code>NULL</code> if the ID does not relate to an object.</result>
  </function>

  <function>
    <name>GetOwnerID</name>
    <category>Objects</category>
    <comment>Returns the unique ID of an object's owner.</comment>
    <prototype>OBJECTID GetOwnerID(OBJECTID Object)</prototype>
    <input>
      <param type="OBJECTID" name="Object">The ID of an object to query.</param>
    </input>
    <description>
<p>This function returns an identifier for the owner of any valid object.  This is the fastest way to retrieve the owner of an object if only the ID is known.</p>
<p>If the object address is already known then the fastest means of retrieval is via the <code>ownerID()</code> C++ class method.</p>
    </description>
    <result type="OBJECTID">Returns the ID of the object's owner.  If the object does not have a owner (i.e. if it is untracked) or if the provided ID is invalid, this function will return NULL.</result>
  </function>

  <function>
    <name>GetResource</name>
    <category>System</category>
    <comment>Retrieves miscellaneous resource identifiers.</comment>
    <prototype>INT64 GetResource(RES Resource)</prototype>
    <input>
      <param type="RES" name="Resource" lookup="RES">The ID of the resource that you want to obtain.</param>
    </input>
    <description>
<p>The GetResource() function is used to retrieve miscellaneous resource information from the system core.  Refer to the Resource identifier for the full list of available resource codes and their meaning.</p>
<p>C++ developers should use the <code>GetResourcePtr()</code> macro if a resource identifier is known to return a pointer.</p>
    </description>
    <result type="INT64">Returns the value of the resource that you have requested.  If the resource ID is not known by the Core, <code>NULL</code> is returned.</result>
  </function>

  <function>
    <name>GetSystemState</name>
    <category>System</category>
    <comment>Returns miscellaneous data values from the Core.</comment>
    <prototype>const struct SystemState * GetSystemState()</prototype>
    <description>
<p>The GetSystemState() function is used to retrieve miscellaneous resource and environment values, such as resource paths, the Core's version number and the name of the host platform.</p>
    </description>
    <result type="const struct SystemState *">A read-only <st>SystemState</st> structure is returned.</result>
  </function>

  <function>
    <name>IdentifyFile</name>
    <category>Files</category>
    <comment>Analyse a file and identify a class that can process it.</comment>
    <prototype>ERR IdentifyFile(CSTRING Path, CLASSID Filter, CLASSID * Class, CLASSID * SubClass)</prototype>
    <input>
      <param type="CSTRING" name="Path">The location of the object data.</param>
      <param type="CLASSID" name="Filter">Restrict the search to classes in this subset, or use <code>CLASSID::NIL</code> to search all classes.</param>
      <param type="CLASSID *" name="Class">Must refer to a <code>CLASSID</code> variable that will store the resulting class ID.</param>
      <param type="CLASSID *" name="SubClass">Optional argument that can refer to a variable that will store the resulting sub-class ID (if the result is a base-class, this variable will receive a value of zero).</param>
    </input>
    <description>
<p>This function examines the relationship between file data and Parasol classes.  For instance, a JPEG file would be identified as a datatype of the <class name="Picture">Picture</class> class.  An MP3 file would be identified as a datatype of the <class name="Sound">Sound</class> class.</p>
<p>The method involves analysing the <code>Path</code>'s file extension and comparing it to the supported extensions of all available classes.  If a class supports the file extension, the ID of that class will be returned. If the file extension is not listed in the class dictionary or if it is listed more than once, the first 80 bytes of the file's data will be loaded and checked against classes that can match against file header information.  If a match is found, the ID of the matching class will be returned.</p>
<p>The <code>ERR::Search</code> code is returned if a suitable class does not match the targeted file.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="Search">A suitable class could not be found for the data source.</error>
      <error code="FileNotFound">File not found.</error>
      <error code="Args">Invalid arguments passed to function.</error>
      <error code="Read">Error reading data from file.</error>
    </result>
  </function>

  <function>
    <name>InitObject</name>
    <category>Objects</category>
    <comment>Initialises an object so that it is ready for use.</comment>
    <prototype>ERR InitObject(OBJECTPTR Object)</prototype>
    <input>
      <param type="OBJECTPTR" name="Object">The object to initialise.</param>
    </input>
    <description>
<p>This function initialises objects so that they can be used for their intended purpose. Initialisation is compulsory, and a client may not call any actions or methods on an object until it has been initialised.  Exceptions to this rule only apply to the <code>GetKey()</code> and <code>SetKey()</code> actions.</p>
<p>If the initialisation of an object fails due to a support problem (for example, if a PNG <class name="Picture">Picture</class> object attempts to load a JPEG file), the initialiser will search for a sub-class that can handle the data.  If a sub-class that can support the object's configuration is available, the object's interface will be shared between both the base-class and the sub-class.</p>
<p>If an object does not support the data or its configuration, an error code of <code>ERR::NoSupport</code> will be returned. Other appropriate error codes can be returned if initialisation fails.</p>
    </description>
    <result type="ERR">
      <error code="Okay">The object was initialised.</error>
      <error code="LostClass">The object has lost its class reference.</error>
      <error code="DoubleInit">Warning - Attempt to initialise an object twice.</error>
      <error code="ObjectCorrupt">The object structure is corrupt or has not been initialised.</error>
    </result>
  </function>

  <function>
    <name>ListChildren</name>
    <category>Objects</category>
    <comment>Returns a list of all children belonging to an object.</comment>
    <prototype>ERR ListChildren(OBJECTID Object, pf::vector&lt;ChildEntry&gt; * List)</prototype>
    <input>
      <param type="OBJECTID" name="Object">An object to query.</param>
      <param type="pf::vector&lt;ChildEntry&gt; *" name="List">Must refer to an array of <st>ChildEntry</st> structures.</param>
    </input>
    <description>
<p>The ListChildren() function returns a list of all children belonging to an object.  The client must provide an empty vector of <st>ChildEntry</st> structures to host the results, which include unique object ID's and their class identifiers.</p>
<p>Note that any child objects marked with the <code>LOCAL</code> flag will be excluded because they are private members of the targeted object.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Zero or more children were found and listed.</error>
      <error code="Args">Invalid arguments passed to function.</error>
      <error code="LockFailed">Failed to lock a required resource.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>LoadFile</name>
    <category>Files</category>
    <comment>Loads files into a local cache for fast file processing.</comment>
    <prototype>ERR LoadFile(CSTRING Path, LDF Flags, struct CacheFile ** Cache)</prototype>
    <input>
      <param type="CSTRING" name="Path">The location of the file to be cached.</param>
      <param type="LDF" name="Flags" lookup="LDF">Optional flags are specified here.</param>
      <param type="struct CacheFile **" name="Cache">A pointer to a CacheFile structure is returned here if successful.</param>
    </input>
    <description>
<p>The LoadFile() function loads complete files into memory and caches the content for use by other areas of the system or application.</p>
<p>This function will first determine if the requested file has already been cached.  If this is true then the CacheFile structure is returned immediately.  Note that if the file was previously cached but then modified, this will be treated as a cache miss and the file will be loaded into a new buffer.</p>
<p>File content will be loaded into a readable memory buffer that is referenced by the Data field of the CacheFile structure.  A hidden null byte is appended at the end of the buffer to assist the processing of text files. Other pieces of information about the file can be derived from the CacheFile meta data.</p>
<p>Calls to LoadFile() must be matched with a call to <function>UnloadFile</function> to decrement the cache counter. When the counter returns to zero, the file can be unloaded from the cache during the next resource collection phase.</p>
    </description>
    <result type="ERR">
      <error code="Okay">The file was cached successfully.</error>
      <error code="Search">If <code>CHECK_EXISTS</code> is specified, this failure indicates that the file is not cached.</error>
      <error code="AllocMemory">A call to AllocMemory() failed to create a new memory block.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>LockObject</name>
    <category>Objects</category>
    <comment>Lock an object to prevent contention between threads.</comment>
    <prototype>ERR LockObject(OBJECTPTR Object, INT MilliSeconds)</prototype>
    <input>
      <param type="OBJECTPTR" name="Object">The address of the object to lock.</param>
      <param type="INT" name="MilliSeconds">The total number of milliseconds to wait before giving up.  If <code>-1</code>, the function will wait indefinitely.</param>
    </input>
    <description>
<p>Use LockObject() to gain exclusive access to an object at thread-level.  This function provides identical behaviour to that of <function>AccessObject</function>, but with a slight speed advantage as the object ID does not need to be resolved to an address.  Calls to LockObject() will nest, and must be matched with a call to <function>ReleaseObject</function> to unlock the object.</p>
<p>Be aware that while this function is faster than <function>AccessObject</function>, it is unsafe if other threads could terminate the object without a suitable barrier in place.</p>
<p>If it is guaranteed that an object is not being shared between threads, object locking is unnecessary.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="TimeOut">Function timed-out before successful completion.</error>
      <error code="MarkedForDeletion">A resource cannot be accessed as it is marked for deletion.</error>
      <error code="SystemLocked">Part of the system is unreachable due to a persistent lock.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>MemoryIDInfo</name>
    <category>Memory</category>
    <comment>Returns information on memory ID's.</comment>
    <prototype>ERR MemoryIDInfo(MEMORYID ID, struct MemInfo * MemInfo, INT Size)</prototype>
    <input>
      <param type="MEMORYID" name="ID">Pointer to a valid memory ID.</param>
      <param type="struct MemInfo *" name="MemInfo">Pointer to a <st>MemInfo</st> structure.</param>
      <param type="INT" name="Size">Size of the <st>MemInfo</st> structure.</param>
    </input>
    <description>
<p>This function returns the attributes of a memory block, including the start address, parent object, memory ID, size and flags.  The following example illustrates correct use of this function:</p>
<pre>MemInfo info;
if (!MemoryIDInfo(memid, &amp;info)) {
   log.msg("Memory block #%d is %d bytes large.", info.MemoryID, info.Size);
}
</pre>
<p>If the call fails, the <st>MemInfo</st> structure's fields will be driven to <code>NULL</code> and an error code is returned.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="Args">Invalid arguments passed to function.</error>
      <error code="MemoryDoesNotExist">Memory block does not exist.</error>
      <error code="SystemLocked">Part of the system is unreachable due to a persistent lock.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>MemoryPtrInfo</name>
    <category>Memory</category>
    <comment>Returns information on memory addresses.</comment>
    <prototype>ERR MemoryPtrInfo(APTR Address, struct MemInfo * MemInfo, INT Size)</prototype>
    <input>
      <param type="APTR" name="Address">Pointer to a valid memory area.</param>
      <param type="struct MemInfo *" name="MemInfo">Pointer to a <st>MemInfo</st> structure to be populated.</param>
      <param type="INT" name="Size">Size of the <st>MemInfo</st> structure.</param>
    </input>
    <description>
<p>This function can be used to get details on the attributes of a memory block.  It will return information on the start address, parent object, memory ID, size and flags of the memory address that you are querying.  The following code segment illustrates correct use of this function:</p>
<pre>MemInfo info;
if (!MemoryPtrInfo(ptr, &amp;info)) {
   log.msg("Address %p is %d bytes large.", info.Start, info.Size);
}
</pre>
<p>If the call to MemoryPtrInfo() fails then the <st>MemInfo</st> structure's fields will be driven to <code>NULL</code> and an error code will be returned.</p>
<p>Please note that referencing by a pointer requires a slow reverse-lookup to be employed in this function's search routine.  We recommend that calls to this function are avoided unless circumstances absolutely require it.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="MemoryDoesNotExist">Memory block does not exist.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>MoveFile</name>
    <category>Files</category>
    <comment>Moves folders and files to new locations.</comment>
    <prototype>ERR MoveFile(CSTRING Source, CSTRING Dest, FUNCTION * Callback)</prototype>
    <input>
      <param type="CSTRING" name="Source">The source path.</param>
      <param type="CSTRING" name="Dest">The destination path.</param>
      <param type="FUNCTION *" name="Callback">Optional callback for receiving feedback during the operation.</param>
    </input>
    <description>
<p>This function is used to move files and folders to new locations.  It can also be used for renaming purposes and is able to move data from one type of media to another.  When moving folders, any contents within the folder will also be moved across to the new location.</p>
<p>It is important that you are aware that different types of string formatting can give different results.  The following examples illustrate:</p>
<pre>
<b>Source               Destination          Result</b>
parasol:makefile     parasol:documents    parasol:documents
parasol:makefile     parasol:documents/   parasol:documents/makefile
parasol:pictures/    parasol:documents/   parasol:documents/pictures
parasol:pictures/    parasol:documents    parasol:documents (Existing documents folder destroyed)
</pre>
<p>This function will overwrite the destination location if it already exists.</p>
<p>The <code>Source</code> argument should always clarify the type of location that is being copied - e.g. if you are copying a folder, you must specify a forward slash at the end of the string or the function will assume that you are moving a file.</p>
<p>The <code>Callback</code> parameter can be set with a function that matches this prototype:</p>
<p>
<code>LONG Callback(struct FileFeedback *)</code></p>
<p>For each file that is processed during the move operation, a <st>FileFeedback</st> structure is passed that describes the source file and its target.  The callback must return a constant value that can potentially affect file processing. Valid values are <code>FFR::Okay</code> (move the file), <code>FFR::Skip</code> (do not move the file) and <code>FFR::Abort</code> (abort the process completely and return <code>ERR::Cancelled</code> as an error code).</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="Failed">General failure.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>NewObject</name>
    <category>Objects</category>
    <comment>Creates new objects.</comment>
    <prototype>ERR NewObject(CLASSID ClassID, NF Flags, OBJECTPTR * Object)</prototype>
    <input>
      <param type="CLASSID" name="ClassID">A class ID from <code>system/register.h</code> or generated by <function>ResolveClassName</function>.</param>
      <param type="NF" name="Flags" lookup="NF">Optional flags.</param>
      <param type="OBJECTPTR *" name="Object">Pointer to an address variable that will store a reference to the new object.</param>
    </input>
    <description>
<p>The NewObject() function is used to create new objects and register them for use within the Core.  After creating a new object, the client can proceed to set the object's field values and initialise it with <action>Init</action> so that it can be used as intended.</p>
<p>The new object will be modeled according to the class blueprint indicated by <code>ClassID</code>.  Pre-defined class ID's are defined in their documentation and the <code>parasol/system/register.h</code> include file.  ID's for unregistered classes can be computed using the <function>ResolveClassName</function> function.</p>
<p>A pointer to the new object will be returned in the <code>Object</code> parameter.  By default, object allocations are context sensitive and will be collected when their owner is terminated.  It is possible to track an object to a different owner by using the <function>SetOwner</function> function.</p>
<p>To destroy an object, call <function>FreeResource</function>.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="MissingClass">The <code>ClassID</code> is invalid or refers to a class that is not installed.</error>
      <error code="AllocMemory">A call to AllocMemory() failed to create a new memory block.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>NotifySubscribers</name>
    <category>Objects</category>
    <comment>Send a notification event to action subscribers.</comment>
    <prototype>void NotifySubscribers(OBJECTPTR Object, AC Action, APTR Args, ERR Error)</prototype>
    <input>
      <param type="OBJECTPTR" name="Object">Pointer to the object that is to receive the notification message.</param>
      <param type="AC" name="Action" lookup="AC">The action ID for notification.</param>
      <param type="APTR" name="Args">Pointer to an action parameter structure that is relevant to the <code>Action</code> ID.</param>
      <param type="ERR" name="Error">The error code that is associated with the action result.</param>
    </input>
    <description>
<p>This function can be used by classes that need fine-tuned control over notification events, as managed by the <function>SubscribeAction</function> function.  Normally the Core will automatically notify subscribers after an action is executed.  Using NotifySubscribers(), the client can instead manually notify subscribers during the execution of the action.</p>
<p>Another useful aspect is that the client can control the parameter values that are passed on to the subscribers.</p>
<p>NOTE: The use of NotifySubscribers() does not prevent the core from sending out an action notification as it normally would, which will cause duplication.  To prevent this, the client must logical-or the return code of the action function with <code>ERR::Notified</code>, e.g. <code>ERR::Okay|ERR::Notified</code>.</p>
<p>In the following example the <class name="Surface">Surface</class> class uses NotifySubscribers() to convert a Move event to a Redimension event.  The parameter values are customised to support this, and the function returns <code>ERR::Notified</code> to prevent the core from sending out a Move notification.</p>
<pre>ERR SURFACE_Move(extSurface *Self, struct acMove *Args)
{
   if (!Args) return ERR::NullArgs|ERR::Notified;

   ...

   struct acRedimension redimension = { Self-&gt;X, Self-&gt;Y, 0, Self-&gt;Width, Self-&gt;Height, 0 };
   NotifySubscribers(Self, AC::Redimension, &amp;redimension, ERR::Okay);
   return ERR::Okay|ERR::Notified;
}
</pre>
    </description>
  </function>

  <function>
    <name>OpenDir</name>
    <category>Files</category>
    <comment>Opens a folder for content scanning.</comment>
    <prototype>ERR OpenDir(CSTRING Path, RDF Flags, struct DirInfo ** Info)</prototype>
    <input>
      <param type="CSTRING" name="Path">The folder location to be scanned.  Using an empty string will scan for volume names.</param>
      <param type="RDF" name="Flags" lookup="RDF">Optional flags.</param>
      <param type="struct DirInfo **" name="Info">A <st>DirInfo</st> structure will be returned in the pointer referenced here.</param>
    </input>
    <description>
<p>The OpenDir() function is used to open a folder for scanning via the <function>ScanDir</function> function.  If the provided Path can be accessed, a <st>DirInfo</st> structure will be returned in the Info parameter, which will need to be passed to <function>ScanDir</function>.  Once the scanning process is complete, call the <function>FreeResource</function> function.</p>
<p>When opening a folder, it is necessary to indicate the type of files that are of interest.  If no flags are defined, the scanner will return file and folder names only.  Only a subset of the available <code>RDF</code> flags may be used, namely <code>SIZE</code>, <code>DATE</code>, <code>PERMISSIONS</code>, <code>FILE</code>, <code>FOLDER</code>, <code>QUALIFY</code>, <code>TAGS</code>.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="DirEmpty">The folder is empty.</error>
      <error code="Args">Invalid arguments passed to function.</error>
      <error code="AllocMemory">A call to AllocMemory() failed to create a new memory block.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>ParentContext</name>
    <category>Objects</category>
    <comment>Returns the context of the client.</comment>
    <prototype>OBJECTPTR ParentContext()</prototype>
    <description>
<p>This function is used to return the context of the caller (the client), as opposed to <function>CurrentContext</function>, which returns the operating context.  This feature is commonly used by methods that need to acquire a reference to the client for resource management reasons.</p>
<p>Note that this function can return <code>NULL</code> if called when running at process-level, although this would never be the case when called from an action or method.</p>
    </description>
    <result type="OBJECTPTR">An object reference is returned, or <code>NULL</code> if there is no parent context.</result>
  </function>

  <function>
    <name>PreciseTime</name>
    <category>System</category>
    <comment>Returns the current system time, in microseconds.</comment>
    <prototype>INT64 PreciseTime()</prototype>
    <description>
<p>This function returns the current 'system time' in microseconds (1 millionth of a second).  The value is monotonic if the host platform allows it (typically expressed as the amount of time that has elapsed since the system was switched on).  The benefit of monotonic time is that it is unaffected by changes to the system clock, such as daylight savings adjustments or manual changes by the user.</p>
    </description>
    <result type="INT64">Returns the system time in microseconds.  Could return zero in the extremely unlikely event of an error.</result>
  </function>

  <function>
    <name>ProcessMessages</name>
    <category>Messages</category>
    <comment>Processes system messages that are queued in the task's message buffer.</comment>
    <prototype>ERR ProcessMessages(PMF Flags, INT TimeOut)</prototype>
    <input>
      <param type="PMF" name="Flags" lookup="PMF">Optional flags are specified here (clients should set a value of zero).</param>
      <param type="INT" name="TimeOut">A TimeOut value, measured in milliseconds.  If zero, the function will return as soon as all messages on the queue are processed.  If less than zero, the function does not return until a request for termination is received or a user message requires processing.</param>
    </input>
    <description>
<p>The ProcessMessages() function is used to process the task's message queue.  Messages are dispatched to message handlers in the order in which they arrived and the queue is emptied so that space is available for more messages.</p>
<p>Responding to incoming messages is a vital process - the queue is the standard means of communication between your task and the rest of the system and other tasks within it.  Failing to call the ProcessMessages() function on a regular basis may cause a back-log of messages to be generated, as well as causing problems with areas such as the graphical interface. If an area of your program is likely to loop continuously for a measurable period of time without returning, consider calling ProcessMessages() at a rate of 50 times per second to ensure that incoming messages are processed.</p>
<p>User messages that are on the queue are passed to message handlers.  If no message handler exists to interpret the message, then it is removed from the queue without being processed. Message handlers are added with the <function>AddMsgHandler</function> function.  If a message handler returns the error code <code>ERR::Terminate</code>, then ProcessMessages() will stop processing the queue and returns immediately with <code>ERR::Okay</code>.</p>
<p>If a message with a <code>MSGID::QUIT</code> ID is found on the queue, then the function returns immediately with the error code <code>ERR::Terminate</code>.  The program must respond to the terminate request by exiting immediately.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="Terminate">A <code>MSGID::QUIT</code> message type was found on the message queue.</error>
      <error code="TimeOut">Function timed-out before successful completion.</error>
    </result>
  </function>

  <function>
    <name>QueueAction</name>
    <category>Objects</category>
    <comment>Delay the execution of an action by adding the call to the message queue.</comment>
    <prototype>ERR QueueAction(AC Action, OBJECTID Object, APTR Args)</prototype>
    <input>
      <param type="AC" name="Action" lookup="AC">The ID of an action or method to execute.</param>
      <param type="OBJECTID" name="Object">The target object.</param>
      <param type="APTR" name="Args">The relevant argument structure for the <code>Action</code>, or <code>NULL</code> if not required.</param>
    </input>
    <description>
<p>Use QueueAction() to execute an action by way of the local message queue.  This means that the supplied <code>Action</code> and <code>Args</code> will be combined into a message for the queue.  This function then returns immediately.</p>
<p>The action will be executed on the next cycle of <function>ProcessMessages</function> in line with the FIFO order of queued messages.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="Failed">General failure.</error>
      <error code="OutOfRange">The <code>Action</code> ID is invalid.</error>
      <error code="IllegalMethodID">Illegal method ID (number outside of valid range).</error>
      <error code="MissingClass">The class could not be found in the system.</error>
      <error code="NoMatchingObject">No matching object was found for the given object ID.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>ReadFileToBuffer</name>
    <category>Files</category>
    <comment>Reads a file into a buffer.</comment>
    <prototype>ERR ReadFileToBuffer(CSTRING Path, APTR Buffer, INT BufferSize, INT * Result)</prototype>
    <input>
      <param type="CSTRING" name="Path">The path of the file.</param>
      <param type="APTR" name="Buffer">Pointer to a buffer that will receive the file content.</param>
      <param type="INT" name="BufferSize">The byte size of the <code>Buffer</code>.</param>
      <param type="INT *" name="Result">The total number of bytes read into the <code>Buffer</code> will be returned here (optional).</param>
    </input>
    <description>
<p>This function provides a simple method for reading file content into a <code>Buffer</code>.  In some cases this procedure may be optimised for the host platform, which makes it the fastest way to read file content in simple cases.</p>
<p>File path approximation is supported if the <code>Path</code> is prefixed with a <code>~</code> character (e.g. <code>~pictures:photo</code> could be matched to <code>photo.jpg</code> in the same folder).</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="File">File error, e.g. file not found.</error>
      <error code="Args">Invalid arguments passed to function.</error>
      <error code="Read">Error reading data from file.</error>
      <error code="InvalidPath">Invalid file or folder path detected.</error>
      <error code="OpenFile">The file could not be opened.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>ReadInfoTag</name>
    <category>Files</category>
    <comment>Read a named tag from a <st>FileInfo</st> structure.</comment>
    <prototype>ERR ReadInfoTag(struct FileInfo * Info, CSTRING Name, CSTRING * Value)</prototype>
    <input>
      <param type="struct FileInfo *" name="Info">Pointer to a valid <st>FileInfo</st> structure.</param>
      <param type="CSTRING" name="Name">The name of the tag, which must be declared in camel-case as tags are case-sensitive.</param>
      <param type="CSTRING *" name="Value">The discovered string value is returned here if found.</param>
    </input>
    <description>
<p>ReadInfoTag() will read the value of a named tag in a <st>FileInfo</st> structure.  The tag must have been added with <function>AddInfoTag</function> or <code>ERR::NotFound</code> will be returned.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="NotFound">A search routine in this function failed.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>ReallocMemory</name>
    <category>Memory</category>
    <comment>Reallocates memory blocks.</comment>
    <prototype>ERR ReallocMemory(APTR Memory, UINT Size, APTR * Address, MEMORYID * ID)</prototype>
    <input>
      <param type="APTR" name="Memory">Pointer to a memory block obtained from <function>AllocMemory</function>.</param>
      <param type="UINT" name="Size">The size of the new memory block.</param>
      <param type="APTR *" name="Address">Point to an <code>APTR</code> variable to store the resulting pointer to the new memory block.</param>
      <param type="MEMORYID *" name="ID">Point to a <code>MEMORYID</code> variable to store the resulting memory block's unique ID.</param>
    </input>
    <description>
<p>This function is used to reallocate memory blocks to new lengths. You can shrink or expand a memory block as you wish.  The data of your original memory block will be copied over to the new block.  If the new block is of a larger size, the left-over bytes will be populated with zero-byte values. If the new block is smaller, you will lose some of the original data.</p>
<p>The original block will be destroyed as a result of calling this function unless the reallocation process fails, in which case your existing memory block will remain valid.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="Args">Invalid arguments passed to function.</error>
      <error code="Memory">The memory block to be re-allocated is invalid.</error>
      <error code="AllocMemory">A call to AllocMemory() failed to create a new memory block.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>RegisterFD</name>
    <category>System</category>
    <comment>Registers a file descriptor for monitoring when the task is asleep.</comment>
    <prototype>ERR RegisterFD(HOSTHANDLE FD, RFD Flags, void (*Routine)(HOSTHANDLE, APTR) , APTR Data)</prototype>
    <input>
      <param type="HOSTHANDLE" name="FD">The file descriptor that is to be watched.</param>
      <param type="RFD" name="Flags" lookup="RFD">Set to at least one of <code>READ</code>, <code>WRITE</code>, <code>EXCEPT</code>, <code>REMOVE</code>.</param>
      <param type="void (*Routine)(HOSTHANDLE, APTR)" name="Routine">The routine that will read from the descriptor when data is detected on it.  The prototype is <code>void Routine(HOSTHANDLE FD, APTR Data)</code>.</param>
      <param type="APTR" name="Data">User specific data pointer that will be passed to the <code>Routine</code>.  Separate data pointers apply to the read and write states of operation.</param>
    </input>
    <description>
<p>This function will register a file descriptor that will be monitored for activity when the task is sleeping.  When activity occurs on the descriptor, the callback referenced in <code>Routine</code> will be called.  The callback should read all information from the descriptor, as the process will not be able to sleep if data is back-logged.</p>
<p>The file descriptor should be configured as non-blocking before registration.  Blocking descriptors may cause the program to hang if not handled carefully.</p>
<p>File descriptors support read and write states simultaneously, and a callback routine can be applied to either state. Set the <code>RFD::READ</code> flag to apply the <code>Routine</code> to the read callback and <code>RFD::WRITE</code> for the write callback.  If neither flag is specified, <code>RFD::READ</code> is assumed.  A file descriptor may have up to one subscription per flag, for example a read callback can be registered, followed by a write callback in a second call. Individual callbacks can be removed by combining the read/write flags with <code>RFD::REMOVE</code>.</p>
<p>The capabilities of this function and FD handling in general is developed to suit the host platform. On POSIX compliant systems, standard file descriptors are used.  In Microsoft Windows, object handles are used and blocking restrictions do not apply, except to sockets.</p>
<p>Call the <code>DeregisterFD()</code> macro to simplify unsubscribing once the file descriptor is no longer needed or is destroyed.</p>
    </description>
    <result type="ERR">
      <error code="Okay">The <code>FD</code> was successfully registered.</error>
      <error code="Args">The <code>FD</code> was set to a value of <code>-1</code>.</error>
      <error code="NoSupport">The host platform does not support the provided <code>FD</code>.</error>
    </result>
  </function>

  <function>
    <name>ReleaseMemory</name>
    <category>Memory</category>
    <comment>Releases a lock from a memory based resource.</comment>
    <prototype>ERR ReleaseMemory(MEMORYID MemoryID)</prototype>
    <input>
      <param type="MEMORYID" name="MemoryID">A reference to a memory resource for release.</param>
    </input>
    <description>
<p>Successful calls to <function>AccessMemory</function> must be paired with a call to ReleaseMemory() so that the memory can be made available to other processes.  Releasing the resource decreases the access count, and if applicable a thread that is in the queue for access may then be able to acquire a lock.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="Search">A search routine in this function failed.</error>
      <error code="SystemLocked">Part of the system is unreachable due to a persistent lock.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>ReleaseObject</name>
    <category>Objects</category>
    <comment>Release a locked object.</comment>
    <prototype>void ReleaseObject(OBJECTPTR Object)</prototype>
    <input>
      <param type="OBJECTPTR" name="Object">Pointer to the object to be released.</param>
    </input>
    <description>
<p>Release a lock previously obtained from <function>AccessObject</function> or <function>LockObject</function>.  Locks will nest, so a release is required for every lock that has been granted.</p>
    </description>
  </function>

  <function>
    <name>ResolveClassID</name>
    <category>Objects</category>
    <comment>Resolve a valid <code>CLASSID</code> to its name.</comment>
    <prototype>CSTRING ResolveClassID(CLASSID ID)</prototype>
    <input>
      <param type="CLASSID" name="ID">The ID of the class that needs to be resolved.</param>
    </input>
    <description>
<p>This function will resolve a valid class ID to its equivalent name.  The name is resolved by checking the class database, so the class must be registered in the database for this function to return successfully.</p>
<p>Registration is achieved by ensuring that the class is compiled into the build.</p>
    </description>
    <result type="CSTRING">Returns the name of the class, or <code>NULL</code> if the ID is not recognised.  Standard naming conventions apply, so it can be expected that the string is capitalised and without spaces, e.g. <code>NetSocket</code>.</result>
  </function>

  <function>
    <name>ResolveClassName</name>
    <category>Objects</category>
    <comment>Resolves any class name to a <code>CLASSID</code> UID.</comment>
    <prototype>CLASSID ResolveClassName(CSTRING Name)</prototype>
    <input>
      <param type="CSTRING" name="Name">The name of the class that requires resolution.</param>
    </input>
    <description>
<p>This function will resolve a class <code>Name</code> to its <code>CLASSID</code> UID and verifies that the class is installed.  It is case insensitive.</p>
    </description>
    <result type="CLASSID">Returns the class ID identified from the class name, or <code>NULL</code> if the class could not be found.</result>
  </function>

  <function>
    <name>ResolveGroupID</name>
    <category>Files</category>
    <comment>Converts a group ID to its corresponding name.</comment>
    <prototype>CSTRING ResolveGroupID(INT Group)</prototype>
    <input>
      <param type="INT" name="Group">The group ID.</param>
    </input>
    <description>
<p>This function converts group ID's obtained from the file system into their corresponding names.  If the <code>Group</code> ID is invalid then <code>NULL</code> will be returned.</p>
    </description>
    <result type="CSTRING">The group name is returned, or <code>NULL</code> if the ID cannot be resolved.</result>
  </function>

  <function>
    <name>ResolvePath</name>
    <category>Files</category>
    <comment>Converts volume-based paths into absolute paths applicable to the host platform.</comment>
    <prototype>ERR ResolvePath(const std::string_view &amp; Path, RSF Flags, std::string * Result)</prototype>
    <input>
      <param type="const std::string_view &amp;" name="Path">The path to be resolved.</param>
      <param type="RSF" name="Flags" lookup="RSF">Optional flags.</param>
      <param type="std::string *" name="Result">Must point to a <code>std::string</code> variable so that the resolved path can be stored.  If <code>NULL</code>, ResolvePath() will work as normal and return a valid error code without the result string.</param>
    </input>
    <description>
<p>This function will convert a file path to its resolved form, according to the host system.  For example, a Linux system might resolve <code>drive1:documents/readme.txt</code> to <code>/documents/readme.txt</code>.  A Windows system might resolve the path to <code>c:\documents\readme.txt</code>.</p>
<p>The resulting path is guaranteed to be absolute, meaning the use of sequences such as <code>..</code>, <code>//</code> and <code>./</code> will be eliminated.</p>
<p>If the path can be resolved to more than one file, ResolvePath() will attempt to discover the correct path by checking the validity of each possible location.  For instance, if resolving a path of <code>user:document.txt</code> and the <code>user:</code> volume refers to both <code>system:users/joebloggs/</code> and <code>system:users/default/</code>, the routine will check both directories for the existence of the <code>document.txt</code> file to determine the correct location.  This approach can be problematic if the intent is to create a new file, in which case <code>RSF::NO_FILE_CHECK</code> will circumvent it.</p>
<p>When checking the file location, ResolvePath() requires an exact match to the provided file name.  If the file name can be approximated (i.e. the file extension can be ignored) then use the <code>RSF::APPROXIMATE</code> flag.</p>
<p>To resolve the location of executable programs on Unix systems, use the <code>RSF::PATH</code> flag.  This uses the <code>PATH</code> environment variable to resolve the file name specified in the <code>Path</code> parameter.</p>
<p>The resolved path will be copied to the <code>std::string</code> provided in the <code>Result</code> parameter.  This will overwrite any existing content in the string.</p>
<types lookup="RSF"/>
<p>If the path resolves to a virtual drive, it may not be possible to confirm whether the target file exists if the virtual driver does not support this check.  This is common when working with network drives.</p>
    </description>
    <result type="ERR">
      <error code="Okay">The <code>Path</code> was resolved.</error>
      <error code="Search">The given volume does not exist.</error>
      <error code="FileNotFound">The path was resolved, but the referenced file or folder does not exist (use <code>NO_FILE_CHECK</code> to avoid this error code).</error>
      <error code="LockFailed">Failed to lock a required resource.</error>
      <error code="AllocMemory">The result string could not be allocated.</error>
      <error code="Loop">The volume refers back to itself.</error>
      <error code="NullArgs">Invalid parameters were specified.</error>
    </result>
  </function>

  <function>
    <name>ResolveUserID</name>
    <category>Files</category>
    <comment>Converts a user ID to its corresponding name.</comment>
    <prototype>CSTRING ResolveUserID(INT User)</prototype>
    <input>
      <param type="INT" name="User">The user ID.</param>
    </input>
    <description>
<p>This function converts user ID's obtained from the file system into their corresponding names.  If the <code>User</code> ID is invalid then <code>NULL</code> will be returned.</p>
    </description>
    <result type="CSTRING">The user name is returned, or <code>NULL</code> if the ID cannot be resolved.</result>
  </function>

  <function>
    <name>ScanDir</name>
    <category>Files</category>
    <comment>Scans the content of a folder, by item.</comment>
    <prototype>ERR ScanDir(struct DirInfo * Info)</prototype>
    <input>
      <param type="struct DirInfo *" name="Info">Pointer to a <st>DirInfo</st> structure for storing scan results.</param>
    </input>
    <description>
<p>The ScanDir() function is used to scan for files and folders in a folder that you have opened using the <function>OpenDir</function> function. The ScanDir() function is intended to be used in a simple loop, returning a single item for each function call that you make.  The following code sample illustrates typical usage:</p>
<pre>DirInfo *info;
if (!OpenDir(path, RDF::FILE|RDF::FOLDER, &amp;info)) {
   while (!ScanDir(info)) {
      log.msg("File: %s", info-&gt;Name);
   }
   FreeResource(info);
}
</pre>
<p>For each item that you scan, you will be able to read the Info structure for information on that item.  The <st>DirInfo</st> structure contains a <st>FileInfo</st> pointer that consists of the following fields:</p>
<struct lookup="FileInfo"/>
<p>The <code>RDF</code> flags that may be returned in the Flags field are <code>VOLUME</code>, <code>FOLDER</code>, <code>FILE</code>, <code>LINK</code>.</p>
    </description>
    <result type="ERR">
      <error code="Okay">An item was successfully scanned from the folder.</error>
      <error code="DirEmpty">There are no more items to scan.</error>
      <error code="Args">Invalid arguments passed to function.</error>
    </result>
  </function>

  <function>
    <name>ScanMessages</name>
    <category>Messages</category>
    <comment>Scans a message queue for multiple occurrences of a message type.</comment>
    <prototype>ERR ScanMessages(INT * Handle, MSGID Type, APTR Buffer, INT Size)</prototype>
    <input>
      <param type="INT *" name="Handle">Pointer to a 32-bit value that must initially be set to zero.  The ScanMessages() function will automatically update this variable with each call so that it can remember its analysis position.</param>
      <param type="MSGID" name="Type" lookup="MSGID">The message type to filter for, or zero to scan all messages in the queue.</param>
      <param type="APTR" name="Buffer">Optional pointer to a buffer that is large enough to hold any message data.</param>
      <param type="INT" name="Size">The byte-size of the supplied <code>Buffer</code>.</param>
    </input>
    <description>
<p>Use the ScanMessages() function to scan the local message queue for information without affecting the state of the queue.  To use this function effectively, make repeated calls to ScanMessages() to analyse the queue until it returns an error code other than <code>ERR::Okay</code>.</p>
<p>The following example illustrates a scan for <code>MSGID::QUIT</code> messages:</p>
<pre>while (!ScanMessages(&amp;handle, MSGID::QUIT, NULL, NULL)) {
   ...
}
</pre>
<p>Messages will often (but not always) carry data that is relevant to the message type.  To retrieve this data a buffer must be supplied.  If the <code>Buffer</code> is too small as indicated by the <code>Size</code>, the message data will be trimmed to fit without any further indication.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="Search">No more messages are left on the queue, or no messages that match the given <code>Type</code> are on the queue.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>SendMessage</name>
    <category>Messages</category>
    <comment>Add a message to the local message queue.</comment>
    <prototype>ERR SendMessage(MSGID Type, MSF Flags, APTR Data, INT Size)</prototype>
    <input>
      <param type="MSGID" name="Type" lookup="MSGID">The message Type/ID being sent.  Unique type ID's can be obtained from <function>AllocateID</function>.</param>
      <param type="MSF" name="Flags" lookup="MSF">Optional flags.</param>
      <param type="APTR" name="Data">Pointer to the data that will be written to the queue.  Set to <code>NULL</code> if there is no data to write.</param>
      <param type="INT" name="Size">The byte-size of the <code>Data</code> being written to the message queue.</param>
    </input>
    <description>
<p>The SendMessage() function will add a message to the end of the local message queue.  Messages must be associated with a <code>Type</code> identifier and this can help the receiver process any accompanying Data.  Some common message types are pre-defined, such as <code>MSGID::QUIT</code>.  Custom messages should use a unique type ID obtained from <function>AllocateID</function>.</p>
    </description>
    <result type="ERR">
      <error code="Okay">The message was successfully written to the message queue.</error>
      <error code="Args">Invalid arguments passed to function.</error>
    </result>
  </function>

  <function>
    <name>SetContext</name>
    <category>Objects</category>
    <comment>Declares the owner of future allocated resources.</comment>
    <prototype>OBJECTPTR SetContext(OBJECTPTR Object)</prototype>
    <input>
      <param type="OBJECTPTR" name="Object">Pointer to the object that will take on the new context.  If <code>NULL</code>, no change to the context will be made.</param>
    </input>
    <description>
<p>This function defines the object that has control of the current thread.  Once called, all further resource allocations are assigned to that object.  This is significant for the automatic collection of memory and object resources.  For example:</p>
<pre>InitObject(display);
auto ctx = SetContext(display);

   NewObject(CLASSID::BITMAP, &amp;bitmap);
   AllocMemory(1000, MEM::DATA, &amp;memory, NULL);

SetContext(ctx);
FreeResource(display-&gt;UID);
</pre>
<p>The above code allocates a <class name="Bitmap">Bitmap</class> and a memory block, both of which will be contained by the display. When <function>FreeResource</function> is called, both the bitmap and memory block will be automatically removed as they have a dependency on the display's existence.  Please keep in mind that the following is incorrect:</p>
<pre>InitObject(display);
auto ctx = SetContext(display);

   NewObject(CLASSID::BITMAP, &amp;bitmap);
   AllocMemory(1000, MEM::DATA, &amp;memory, NULL);

SetContext(ctx);
FreeResource(display-&gt;UID); // The bitmap and memory would be auto-collected
FreeResource(bitmap-&gt;UID);  // Reference is no longer valid
FreeResource(memory);  // Reference is no longer valid
</pre>
<p>As the bitmap and memory block would have been freed as members of the display, their references are invalid when manually terminated in the following instructions.</p>
<p>SetContext() is intended for use by modules and classes.  Do not use it in an application unless conditions necessitate its use.  The Core automatically manages the context when calling class actions, methods and interactive fields.</p>
    </description>
    <result type="OBJECTPTR">Returns a pointer to the previous context.  Because contexts nest, the client must call SetContext() a second time with this pointer in order to keep the process stable.</result>
  </function>

  <function>
    <name>SetDefaultPermissions</name>
    <category>Files</category>
    <comment>Forces the user and group permissions to be applied to new files and folders.</comment>
    <prototype>void SetDefaultPermissions(INT User, INT Group, PERMIT Permissions)</prototype>
    <input>
      <param type="INT" name="User">User ID to apply to new files.</param>
      <param type="INT" name="Group">Group ID to apply to new files.</param>
      <param type="PERMIT" name="Permissions" lookup="PERMIT">Permission flags to be applied to new files.</param>
    </input>
    <description>
<p>By default, user, group and permission information for new files is inherited either from the system defaults or from the file source in copy operations.  Use this function to override this behaviour with new default values.  All threads of the process will be affected.</p>
<p>To revert behaviour to the default settings, set the <code>User</code> and/or <code>Group</code> values to <code>-1</code> and the <code>Permissions</code> value to zero.</p>
    </description>
  </function>

  <function>
    <name>SetName</name>
    <category>Objects</category>
    <comment>Sets the name of an object.</comment>
    <prototype>ERR SetName(OBJECTPTR Object, CSTRING Name)</prototype>
    <input>
      <param type="OBJECTPTR" name="Object">The target object.</param>
      <param type="CSTRING" name="Name">The new name for the object.</param>
    </input>
    <description>
<p>This function sets the name of an <code>Object</code>.  This enhances log messages and allows the object to be found in searches. Please note that the length of the <code>Name</code> will be limited to the value indicated in the core header file, under the <code>MAX_NAME_LEN</code> definition.  Names exceeding the allowed length are trimmed to fit.</p>
<p>Object names are limited to alpha-numeric characters and the underscore symbol.  Invalid characters are replaced with an underscore.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="Search">The <code>Object</code> is not recognised by the system - the address may be invalid.</error>
      <error code="LockFailed">Failed to lock a required resource.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>SetOwner</name>
    <category>Objects</category>
    <comment>Changes object ownership dynamically.</comment>
    <prototype>ERR SetOwner(OBJECTPTR Object, OBJECTPTR Owner)</prototype>
    <input>
      <param type="OBJECTPTR" name="Object">The object to modify.</param>
      <param type="OBJECTPTR" name="Owner">The new owner for the <code>Object</code>.</param>
    </input>
    <description>
<p>This function changes the ownership of an existing object.  Ownership is an attribute that affects an object's placement within the object hierarchy as well as impacting on the resource tracking of the object in question. Internally, setting a new owner will cause three things to happen:</p>
<list type="sorted">
<li>The new owner's class will receive notification via the <action>NewChild</action> action.  If the owner rejects the object by sending back an error, SetOwner() will fail immediately.</li>
<li>The object's class will then receive notification via the <action>NewOwner</action> action.</li>
<li>The resource tracking of the new owner will be modified so that the object is accepted as its child.  This means that if and when the owning object is destroyed, the new child object will be destroyed with it.</li>
</list>
<p>If the <code>Object</code> does not support the NewOwner action, or the <code>Owner</code> does not support the NewChild action, then the process will not fail.  It will continue on the assumption that neither party is concerned about ownership management.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="Args">Invalid arguments passed to function.</error>
      <error code="SystemLocked">Part of the system is unreachable due to a persistent lock.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
      <error code="Recursion">Detected a recursive function call.</error>
    </result>
  </function>

  <function>
    <name>SetResource</name>
    <category>System</category>
    <comment>Sets miscellaneous resource identifiers.</comment>
    <prototype>INT64 SetResource(RES Resource, INT64 Value)</prototype>
    <input>
      <param type="RES" name="Resource" lookup="RES">The ID of the resource to be set.</param>
      <param type="INT64" name="Value">The new value to set for the resource.</param>
    </input>
    <description>
<p>The SetResource() function is used to manipulate miscellaneous system resources.  Currently the following resources are supported:</p>
<types lookup="RES" type="Resource">
<type name="ALLOC_MEM_LIMIT">Adjusts the memory limit imposed on <function>AllocMemory</function>.  The <code>Value</code> specifies the memory limit in bytes.</type>
<type name="LOG_LEVEL">Adjusts the current debug level.  The <code>Value</code> must be between 0 and 9, where 1 is the lowest level of debug output (errors only) and 0 is off.</type>
<type name="PRIVILEGED_USER">If the <code>Value</code> is set to 1, this resource option puts the process in privileged mode (typically this enables full administrator rights).  This feature will only work for Unix processes that are granted admin rights when launched.  Setting the Value to 0 reverts to the user's permission settings.  SetResource() will return an error code indicating the level of success.</type>
</types>
    </description>
    <result type="INT64">Returns the previous value of the <code>Resource</code>.  If the <code>Resource</code> value is invalid, <code>NULL</code> is returned.</result>
  </function>

  <function>
    <name>SetResourcePath</name>
    <category>System</category>
    <comment>Redefines the location of a system resource path.</comment>
    <prototype>ERR SetResourcePath(RP PathType, CSTRING Path)</prototype>
    <input>
      <param type="RP" name="PathType" lookup="RP">The ID of the resource path to set.</param>
      <param type="CSTRING" name="Path">The new location to set for the resource path.</param>
    </input>
    <description>
<p>The SetResourcePath() function changes the default locations of the Core's resource paths.</p>
<p>To read a resource path, use the <function>GetSystemState</function> function.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>SetVolume</name>
    <category>Files</category>
    <comment>Create or modify a filesystem volume.</comment>
    <prototype>ERR SetVolume(CSTRING Name, CSTRING Path, CSTRING Icon, CSTRING Label, CSTRING Device, VOLUME Flags)</prototype>
    <input>
      <param type="CSTRING" name="Name">Required.  The name of the volume.</param>
      <param type="CSTRING" name="Path">Required.  The path to be associated with the volume.  If setting multiple paths, separate each path with a semi-colon character.  Each path must terminate with a forward slash to denote a folder.</param>
      <param type="CSTRING" name="Icon">An icon can be associated with the volume so that it has graphical representation when viewed in the UI.  The required icon string format is <code>category/name</code>.</param>
      <param type="CSTRING" name="Label">An optional label or short comment may be applied to the volume.  This may be useful if the volume name has little meaning to the user (e.g. <code>drive1</code>, <code>drive2</code> ...).</param>
      <param type="CSTRING" name="Device">If the volume references the root of a device, specify a device name of <code>portable</code>, <code>fixed</code>, <code>cd</code>, <code>network</code> or <code>usb</code>.</param>
      <param type="VOLUME" name="Flags" lookup="VOLUME">Optional flags.</param>
    </input>
    <description>
<p>SetVolume() is used to create or modify a volume that is associated with one or more paths.  If the named volume already exists, it possible to append more paths or replace them entirely.  Volume changes that are made with this function will only apply to the current process, and are lost after the program closes.</p>
<p>Flags that may be passed are as follows:</p>
<types lookup="VOLUME"/>
    </description>
    <result type="ERR">
      <error code="Okay">The volume was successfully added.</error>
      <error code="LockFailed">Failed to lock a required resource.</error>
      <error code="NullArgs">A valid name and path string was not provided.</error>
    </result>
  </function>

  <function>
    <name>SubscribeAction</name>
    <category>Objects</category>
    <comment>Monitor action calls made against an object.</comment>
    <prototype>ERR SubscribeAction(OBJECTPTR Object, AC Action, FUNCTION * Callback)</prototype>
    <input>
      <param type="OBJECTPTR" name="Object">The target object.</param>
      <param type="AC" name="Action" lookup="AC">The ID of the action that will be monitored.  Methods are not supported.</param>
      <param type="FUNCTION *" name="Callback">A C/C++ function to callback when the action is triggered.</param>
    </input>
    <description>
<p>The SubscribeAction() function allows a client to receive a callback each time that an action is executed on an object.  This strategy is referred to as "action monitoring" and is often used for responding to UI events and the termination of objects.</p>
<p>Subscriptions are context sensitive, so the <code>Callback</code> will execute in the space attributed to to the caller.</p>
<p>The following example illustrates how to listen to a <class name="Surface">Surface</class> object's Redimension action and respond to resize events:</p>
<pre>SubscribeAction(surface, AC::Redimension, C_FUNCTION(notify_resize, meta_ptr));
</pre>
<p>The template below illustrates how the <code>Callback</code> function should be constructed:</p>
<pre>void notify_resize(OBJECTPTR Object, ACTIONID Action, ERR Result, APTR Parameters, APTR CallbackMeta)
{
   auto Self = (objClassType *)CurrentContext();

   // Code here...
   if ((Result == ERR::Okay) and (Parameters)) {
      auto resize = (struct acRedimension *)Parameters;
   }
}
</pre>
<p>The <code>Object</code> is the original subscription target, as-is the Action ID.  The Result is the error code that was generated at the end of the action call.  If this is not set to <code>ERR::Okay</code>, assume that the action did not have an effect on state.  The <code>Parameters</code> are the original arguments provided by the client - be aware that these can legitimately be <code>NULL</code> even if an action specifies a required parameter structure.  Notice that because subscriptions are context sensitive, <function>CurrentContext</function> can be used to get a reference to the object that initiated the subscription.</p>
<p>To terminate an action subscription, use the <function>UnsubscribeAction</function> function.  Subscriptions are not resource tracked, so it is critical to match the original call with an unsubscription.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="Args">Invalid arguments passed to function.</error>
      <error code="OutOfRange">The Action parameter is invalid.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>SubscribeEvent</name>
    <category>Events</category>
    <comment>Subscribe to a system event.</comment>
    <prototype>ERR SubscribeEvent(INT64 Event, FUNCTION * Callback, APTR * Handle)</prototype>
    <input>
      <param type="INT64" name="Event">An event identifier.</param>
      <param type="FUNCTION *" name="Callback">The function that will be subscribed to the event.</param>
      <param type="APTR *" name="Handle">Pointer to an address that will receive the event handle.</param>
    </input>
    <description>
<p>Use the SubscribeEvent() function to listen for system events.  An event ID (obtainable from <function>GetEventID</function>) must be provided, as well as a reference to a function that will be called each time that the event is broadcast.</p>
<p>An event handle will be returned in the <code>Handle</code> parameter to identify the subscription.  This must be retained to later unsubscribe from the event with the <function>UnsubscribeEvent</function> function.</p>
<p>The prototype for the <code>Callback</code> function is <code>Function(APTR Event, LONG Size, APTR CallbackMeta)</code>, where <code>Event</code> is the event structure that matches to the subscribed EventID.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="AllocMemory">A call to AllocMemory() failed to create a new memory block.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>SubscribeTimer</name>
    <category>System</category>
    <comment>Subscribes an object or function to the timer service.</comment>
    <prototype>ERR SubscribeTimer(DOUBLE Interval, FUNCTION * Callback, APTR * Subscription)</prototype>
    <input>
      <param type="DOUBLE" name="Interval">The total number of seconds to wait between timer calls.</param>
      <param type="FUNCTION *" name="Callback">A callback function is required that will be called on each time cycle.</param>
      <param type="APTR *" name="Subscription">Optional.  The subscription will be assigned an identifier that is returned in this parameter.</param>
    </input>
    <description>
<p>This function creates a new timer subscription that will be called at regular intervals for the calling object.</p>
<p>A callback function must be provided that follows this prototype: <code>ERR Function(OBJECTPTR Subscriber, INT64 Elapsed, INT64 CurrentTime)</code></p>
<p>The <code>Elapsed</code> parameter is the total number of microseconds that have elapsed since the last call.  The <code>CurrentTime</code> parameter is set to the <function>PreciseTime</function> value just prior to the <code>Callback</code> being called.  The callback function can return <code>ERR::Terminate</code> at any time to cancel the subscription.  All other error codes are ignored.  Fluid callbacks should call <code>check(ERR::Terminate)</code> to perform the equivalent of this behaviour.</p>
<p>To change the interval, call <function>UpdateTimer</function> with the new value.  To release a timer subscription, call <function>UpdateTimer</function> with the resulting SubscriptionID and an Interval of zero.</p>
<p>Timer management is provisioned by the <function>ProcessMessages</function> function.  Failure to regularly process incoming messages will lead to unreliable timer cycles.  It should be noted that the smaller the Interval that has been used, the more imperative regular message checking becomes.  Prolonged processing inside a timer routine can also impact on other timer subscriptions that are waiting to be processed.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="Args">Invalid arguments passed to function.</error>
      <error code="ArrayFull">The task's timer array is at capacity - no more subscriptions can be granted.</error>
      <error code="SystemLocked">Part of the system is unreachable due to a persistent lock.</error>
      <error code="InvalidState">The subscriber is marked for termination.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>UnloadFile</name>
    <category>Files</category>
    <comment>Unloads files from the file cache.</comment>
    <prototype>void UnloadFile(struct CacheFile * Cache)</prototype>
    <input>
      <param type="struct CacheFile *" name="Cache">A pointer to a CacheFile structure returned from <function>LoadFile</function>.</param>
    </input>
    <description>
<p>This function unloads cached files that have been previously loaded with the <function>LoadFile</function> function.</p>
    </description>
  </function>

  <function>
    <name>UnsubscribeAction</name>
    <category>Objects</category>
    <comment>Terminates action subscriptions.</comment>
    <prototype>ERR UnsubscribeAction(OBJECTPTR Object, AC Action)</prototype>
    <input>
      <param type="OBJECTPTR" name="Object">The object that you are unsubscribing from.</param>
      <param type="AC" name="Action" lookup="AC">The ID of the action that will be unsubscribed, or zero for all actions.</param>
    </input>
    <description>
<p>The UnsubscribeAction() function will terminate subscriptions made by <function>SubscribeAction</function>.</p>
<p>To terminate multiple subscriptions in a single call, set the <code>Action</code> parameter to zero.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="Args">Invalid arguments passed to function.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>UnsubscribeEvent</name>
    <category>Events</category>
    <comment>Removes an event subscription.</comment>
    <prototype>void UnsubscribeEvent(APTR Handle)</prototype>
    <input>
      <param type="APTR" name="Handle">An event handle returned from <function>SubscribeEvent</function></param>
    </input>
    <description>
<p>Use UnsubscribeEvent() to remove an existing event subscription.  A valid handle returned from the <function>SubscribeEvent</function> function must be provided.</p>
    </description>
  </function>

  <function>
    <name>UpdateMessage</name>
    <category>Messages</category>
    <comment>Updates the data of any message that is queued.</comment>
    <prototype>ERR UpdateMessage(INT Message, MSGID Type, APTR Data, INT Size)</prototype>
    <input>
      <param type="INT" name="Message">The ID of the message that will be updated.</param>
      <param type="MSGID" name="Type" lookup="MSGID">The type of the message.</param>
      <param type="APTR" name="Data">Pointer to a buffer that contains the new data for the message.</param>
      <param type="INT" name="Size">The byte-size of the <code>Data</code> that has been supplied.  It must not exceed the size of the message that is being updated.</param>
    </input>
    <description>
<p>The UpdateMessage() function provides a facility for updating the content of existing messages on the local queue. The client must provide the ID of the message to update and the new message Type and/or Data to set against the message.</p>
<p>If <code>Data</code> is defined, its size should equal that of the data already set against the message.  The size will be trimmed if it exceeds that of the existing message, as this function cannot expand the size of the queue.</p>
    </description>
    <result type="ERR">
      <error code="Okay">The message was successfully updated.</error>
      <error code="Search">The supplied <code>Message</code> ID does not refer to a message in the queue.</error>
      <error code="AccessMemory">Access to a shared memory block was denied.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>UpdateTimer</name>
    <category>System</category>
    <comment>Modify or remove a subscription created by SubscribeTimer().</comment>
    <prototype>ERR UpdateTimer(APTR Subscription, DOUBLE Interval)</prototype>
    <input>
      <param type="APTR" name="Subscription">The timer subscription to modify.</param>
      <param type="DOUBLE" name="Interval">The new interval for the timer (measured in seconds), or zero to remove.</param>
    </input>
    <description>
<p>This function complements <function>SubscribeTimer</function>.  It can change the interval for an existing timer subscription, or remove it if the Interval is set to zero.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="Search">A search routine in this function failed.</error>
      <error code="SystemLocked">Part of the system is unreachable due to a persistent lock.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>WaitForObjects</name>
    <category>Messages</category>
    <comment>Process incoming messages while waiting on objects to complete their activities.</comment>
    <prototype>ERR WaitForObjects(PMF Flags, INT TimeOut, struct ObjectSignal * ObjectSignals)</prototype>
    <input>
      <param type="PMF" name="Flags" lookup="PMF">Optional flags are specified here.</param>
      <param type="INT" name="TimeOut">A time-out value measured in milliseconds.  If this value is negative then no time-out applies and the function will not return until an incoming message or signal breaks it.</param>
      <param type="struct ObjectSignal *" name="ObjectSignals">A null-terminated array of objects to monitor for signals.</param>
    </input>
    <description>
<p>WaitForObjects() acts as a front-end to <function>ProcessMessages</function>, with an ability to wait for a list of objects that are expected to signal an end to their activities.  An object can be signalled via the Signal() action, or via termination. This function will only return once ALL of the objects are signalled or a time-out occurs.</p>
<p>Note that if an object has been signalled prior to entry to this function, its signal flag will be cleared and the object will not be monitored.</p>
<p>If this function is called recursively, the state of the earlier call will be preserved so that it will not be affected by subsequent calls.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="Failed">General failure.</error>
      <error code="TimeOut">Function timed-out before successful completion.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
      <error code="OutsideMainThread">An operation has been attempted that is only possible from within the main thread.</error>
    </result>
  </function>

  <function>
    <name>WaitTime</name>
    <category>System</category>
    <comment>Waits for a specified amount of seconds and/or microseconds.</comment>
    <prototype>void WaitTime(INT Seconds, INT MicroSeconds)</prototype>
    <input>
      <param type="INT" name="Seconds">The number of seconds to wait for.</param>
      <param type="INT" name="MicroSeconds">The number of microseconds to wait for.  Please note that a microsecond is one-millionth of a second - <code>1/1000000</code>.  The value cannot exceed <code>999999</code>.</param>
    </input>
    <description>
<p>This function waits for a period of time as specified by the <code>Seconds</code> and <code>MicroSeconds</code> parameters.  While waiting, your process will continue to process incoming messages in order to prevent the process' message queue from developing a back-log.</p>
<p>WaitTime() can return earlier than the indicated timeout if a message handler returns <code>ERR::Terminate</code>, or if a <code>MSGID::QUIT</code> message is sent to the task's message queue.</p>
    </description>
  </function>

  <types>
    <constants lookup="AC" comment="Action identifiers.">
      <const name="Activate"/>
      <const name="Clear"/>
      <const name="Clipboard"/>
      <const name="CopyData"/>
      <const name="DataFeed"/>
      <const name="Deactivate"/>
      <const name="Disable"/>
      <const name="DragDrop"/>
      <const name="Draw"/>
      <const name="END"/>
      <const name="Enable"/>
      <const name="Flush"/>
      <const name="Focus"/>
      <const name="Free"/>
      <const name="FreeWarning"/>
      <const name="GetKey"/>
      <const name="Hide"/>
      <const name="Init"/>
      <const name="Lock"/>
      <const name="LostFocus"/>
      <const name="Move"/>
      <const name="MoveToBack"/>
      <const name="MoveToFront"/>
      <const name="MoveToPoint"/>
      <const name="NewChild"/>
      <const name="NewObject"/>
      <const name="NewOwner"/>
      <const name="NewPlacement"/>
      <const name="Next"/>
      <const name="Prev"/>
      <const name="Query"/>
      <const name="Read"/>
      <const name="Redimension"/>
      <const name="Redo"/>
      <const name="Refresh"/>
      <const name="Rename"/>
      <const name="Reset"/>
      <const name="Resize"/>
      <const name="SaveImage"/>
      <const name="SaveSettings"/>
      <const name="SaveToObject"/>
      <const name="Seek"/>
      <const name="SetField"/>
      <const name="SetKey"/>
      <const name="Show"/>
      <const name="Signal"/>
      <const name="Undo"/>
      <const name="Unlock"/>
      <const name="Write"/>
    </constants>

    <constants lookup="ALIGN" comment="Universal values for alignment of graphics and text">
      <const name="BOTTOM">Align to bottom</const>
      <const name="CENTER">Synonym for <code>HORIZONTAL | VERTICAL</code></const>
      <const name="HORIZONTAL">Align to horizontal center</const>
      <const name="LEFT">Align to left</const>
      <const name="MIDDLE">Synonym for <code>HORIZONTAL | VERTICAL</code></const>
      <const name="RIGHT">Align to right</const>
      <const name="TOP">Align to top</const>
      <const name="VERTICAL">Align to vertical center</const>
    </constants>

    <constants lookup="CCF" comment="Class categories">
      <const name="AUDIO">Audio classes interface with audio hardware and drivers for audio playback and recording purposes.</const>
      <const name="COMMAND">Command classes perform specific procedures, like copying or moving a file, managing volumes or executing a program.</const>
      <const name="DATA">Data classes parse, query and manipulate data.</const>
      <const name="FILESYSTEM">FileSystem classes are based on file management and interaction with file based data.</const>
      <const name="GRAPHICS">Graphics classes provide graphics management and drawing services.</const>
      <const name="GUI">GUI classes are used in the development of graphical user interfaces.</const>
      <const name="IO">I/O classes manage hardware and software based input and output.</const>
      <const name="MISC">Miscellaneous classes do not fit into any of the other available categories.</const>
      <const name="MULTIMEDIA">Classes that represent more than one media type, e.g. video files.</const>
      <const name="NETWORK">Network classes interface with system drivers to simplify network communications.</const>
      <const name="SYSTEM">System classes are designed to provide low-level services related to system management.</const>
      <const name="TOOL">Tools provide interactive services for the user.</const>
    </constants>

    <constants lookup="CF" comment="Compression stream formats">
      <const name="DEFLATE">The 'deflate' format</const>
      <const name="GZIP">The 'gzip' format</const>
      <const name="ZLIB">The 'zlib' format</const>
    </constants>

    <constants lookup="CLF" comment="Flags for the MetaClass.">
      <const name="INHERIT_LOCAL">Inherit the functionality of local objects defined in the class spec.</const>
      <const name="NO_OWNERSHIP">Objects created will not be tracked to the creating process, nor any parent object (<function module="Core">SetOwner</function> will not work either).</const>
    </constants>

    <constants lookup="CLIPMODE" comment="Clipboard modes">
      <const name="COPY">Copy from the clipboard.</const>
      <const name="CUT">Cut from the clipboard.</const>
      <const name="PASTE">Paste from the clipboard.</const>
    </constants>

    <constants lookup="CMF" comment="Compression flags">
      <const name="APPLY_SECURITY">When decompressing, apply individual file permissions if they are available in the compression file.</const>
      <const name="CREATE_FILE">Create a new archive only if the source file does not already exist.</const>
      <const name="NEW">Force the creation of a new file archive.  Any existing file data at the target location will be destroyed.</const>
      <const name="NO_LINKS">Treat symbolic links as normal files/folders.</const>
      <const name="PASSWORD">A password has been set on the object.</const>
      <const name="READ_ONLY">Forces read-only access, which is strongly recommended if an existing archive is being opened with no modifications intended.  If this flag is not set, initialisation can fail if the user does not have write access to the source file.</const>
    </constants>

    <constants lookup="CNF" comment="Flags for the Config class.">
      <const name="AUTO_SAVE">When the configuration object is freed, automatically save the configuration data back to the original file source.</const>
      <const name="NEW">On initialisation, do not load any data from the referenced configuration file.</const>
      <const name="OPTIONAL_FILES">Files are optional (do not fail if a requested file does not exist).</const>
      <const name="STRIP_QUOTES">Removes quotes from key values that are quote-encapsulated.</const>
    </constants>

    <constants lookup="CON" comment="Gamepad controller buttons.">
      <const name="DPAD_DOWN">Directional pad down.</const>
      <const name="DPAD_LEFT">Directional pad left.</const>
      <const name="DPAD_RIGHT">Directional pad right.</const>
      <const name="DPAD_UP">Directional pad up.</const>
      <const name="GAMEPAD_E">East button (B)</const>
      <const name="GAMEPAD_N">North button (Y)</const>
      <const name="GAMEPAD_S">South button (A)</const>
      <const name="GAMEPAD_W">West button (X)</const>
      <const name="LEFT_BUMPER_1">Gamepad left-hand bumper 1 (top, primary).</const>
      <const name="LEFT_BUMPER_2">Gamepad left-hand bumper 2 (lower).</const>
      <const name="LEFT_THUMB">Left thumb stick depressed.</const>
      <const name="RIGHT_BUMPER_1">Gamepad right-hand bumper 1 (top, primary).</const>
      <const name="RIGHT_BUMPER_2">Gamepad right-hand bumper 2 (lower).</const>
      <const name="RIGHT_THUMB">Right thumb stick depressed.</const>
      <const name="SELECT">Gamepad select or back button.</const>
      <const name="START">Gamepad start button.</const>
    </constants>

    <constants lookup="DATA" comment="Data codes">
      <const name="AUDIO">Audio file data, recognised by the Sound class</const>
      <const name="CONTENT">Document content (between XML tags) - sent by document objects only</const>
      <const name="DEVICE_INPUT">Device activity</const>
      <const name="FILE">File location (the data will reflect the complete file path)</const>
      <const name="IMAGE">Image file data, recognised by the Image class</const>
      <const name="INPUT_READY">Device input that has been transformed into user input</const>
      <const name="RAW">Raw unprocessed data</const>
      <const name="RECEIPT">Receipt for item data, in response to an earlier request</const>
      <const name="RECORD">Database record</const>
      <const name="REQUEST">Make a request for item data</const>
      <const name="TEXT">Standard ASCII text</const>
      <const name="XML">Markup based text data.  NOTE - For clipboard data, the top-level encapsulating tag must declare the type of XML, e.g. 'html', 'ripple'.  For plain XML, use 'xml'</const>
    </constants>

    <constants lookup="DEVICE">
      <const name="BOOKMARK">This marker indicates that the presented volume is a bookmark and not a device name.</const>
      <const name="COMPACT_DISC">Compact disc style device</const>
      <const name="FIXED">Catch-all for fixed media devices that are not directly identifiable.</const>
      <const name="FLOPPY_DISK">Floppy disk style device</const>
      <const name="HARD_DISK">Hard disk style device</const>
      <const name="MEMORY">Device is RAM, ROM, WORM, NVRAM, flashdisk or other form of memory.  Does not guarantee a fast connection as it could be over a slow USB 1.1 connection for example</const>
      <const name="MODEM">Device is a modem.</const>
      <const name="NETWORK">Device represents a network link</const>
      <const name="PRINTER">Device is a paper-based printer.</const>
      <const name="PRINTER_3D">Device is a three dimensional printer.</const>
      <const name="READ">Device is readable</const>
      <const name="REMOVABLE">Device media is removable from the hardware</const>
      <const name="REMOVEABLE">Device media is removable from the hardware</const>
      <const name="SCANNER">Device is a two dimensional scanner.</const>
      <const name="SCANNER_3D">Device is a three dimensional scanner.</const>
      <const name="SOFTWARE">Device is virtual/software defined</const>
      <const name="TAPE">Tape/Stream style device</const>
      <const name="TEMPORARY">All storage is temporary</const>
      <const name="USB">Removable USB storage device.  May be further qualified by <code>HARD_DISK</code>, <code>FLOPPY_DISK</code> etc</const>
      <const name="WRITE">Device is writeable</const>
    </constants>

    <constants lookup="DMF">
      <const name="FIXED_CENTER_X">The CenterX field is a fixed size.</const>
      <const name="FIXED_CENTER_Y">The CenterY field is a fixed size.</const>
      <const name="FIXED_DEPTH">The Depth field is a fixed size.</const>
      <const name="FIXED_HEIGHT">The Height field is a fixed size.</const>
      <const name="FIXED_RADIUS_X">The RadiusX field is a fixed size.</const>
      <const name="FIXED_RADIUS_Y">The RadiusY field is a fixed size.</const>
      <const name="FIXED_WIDTH">The Width field is a fixed suze.</const>
      <const name="FIXED_X">The X field is a fixed coordinate.</const>
      <const name="FIXED_X_OFFSET">The XOffset field is a fixed coordinate.</const>
      <const name="FIXED_Y">The Y field is a fixed coordinate.</const>
      <const name="FIXED_Y_OFFSET">The YOffset field is a fixed coordinate.</const>
      <const name="FIXED_Z">The Z field is a fixed coordinate.</const>
      <const name="SCALED_CENTER_X">The CenterX field is scaled to this object's parent.</const>
      <const name="SCALED_CENTER_Y">The CenterY field is scaled to this object's parent.</const>
      <const name="SCALED_DEPTH">The Depth field is scaled to this object's parent.</const>
      <const name="SCALED_HEIGHT">The Height field is scaled to this object's parent.</const>
      <const name="SCALED_RADIUS_X">The RadiusX field is scaled to this object's parent.</const>
      <const name="SCALED_RADIUS_Y">The RadiusY field is a scaled size to this object's parent.</const>
      <const name="SCALED_WIDTH">The Width field is scaled to this object's parent.</const>
      <const name="SCALED_X">The X field is scaled to this object's parent.</const>
      <const name="SCALED_X_OFFSET">The XOffset field is scaled to this object's parent.</const>
      <const name="SCALED_Y">The Y field is scaled to this object's parent.</const>
      <const name="SCALED_Y_OFFSET">The YOffset field is scaled to this object's parent.</const>
      <const name="SCALED_Z">The Z field is a scaled coordinate to this object's parent.</const>
      <const name="STATUS_CHANGE_H"/>
      <const name="STATUS_CHANGE_V"/>
    </constants>

    <constants lookup="DRL" comment="Compass directions.">
      <const name="EAST"/>
      <const name="NORTH"/>
      <const name="NORTH_EAST"/>
      <const name="NORTH_WEST"/>
      <const name="SOUTH"/>
      <const name="SOUTH_EAST"/>
      <const name="SOUTH_WEST"/>
      <const name="WEST"/>
    </constants>

    <constants lookup="EDGE" comment="Edge flags">
      <const name="ALL"/>
      <const name="BOTTOM"/>
      <const name="BOTTOM_LEFT"/>
      <const name="BOTTOM_RIGHT"/>
      <const name="LEFT"/>
      <const name="RIGHT"/>
      <const name="TOP"/>
      <const name="TOP_LEFT"/>
      <const name="TOP_RIGHT"/>
    </constants>

    <constants lookup="EVG" comment="Event categories.">
      <const name="ANDROID">Android specific events that do not already fit existing categories.</const>
      <const name="APP">Custom event dispatched from an application</const>
      <const name="AUDIO">Audio system events.</const>
      <const name="CLASS">Custom event dispatched from a class that doesn't fit within the rest of the event framework</const>
      <const name="DISPLAY">Video display events.</const>
      <const name="FILESYSTEM">File system events.</const>
      <const name="GUI">Events generated by the Graphical User Interface.</const>
      <const name="HARDWARE">Hardware device events that are not covered by other types.</const>
      <const name="IO">Input/Output events.</const>
      <const name="NETWORK">Network events.</const>
      <const name="POWER">Power Management - can also include app-specific events relating to resource management.</const>
      <const name="SYSTEM">System-wide events</const>
      <const name="USER">User activity events (such as user login).</const>
    </constants>

    <constants lookup="FBK" comment="Flags for file feedback.">
      <const name="COPY_FILE">A file is to be, or has been copied.</const>
      <const name="DELETE_FILE">A file is to be, or has been deleted.</const>
      <const name="MOVE_FILE">A file is to be, or has been moved.</const>
    </constants>

    <constants lookup="FD" comment="Field descriptors.">
      <const name="ALLOC">CLASSDEF Indicates the returned value is a dynamic allocation that needs to be manually freed (by default is a memory pointer, can be an object if combined with <code>FD_OBJECT</code>)</const>
      <const name="ARRAY">Indicates an array of values.  Follow with <code>ARRAYSIZE</code> if used in a function.</const>
      <const name="ARRAYSIZE">FUNCDEF Overrides <code>LOOKUP</code>.  Pair with <code>ARRAY</code> to indicate total elements in the array.  It is preferred that any null terminator is not counted.  If <code>ARRAYSIZE</code> not specified, <code>ARRAY</code> must be null-terminated.</const>
      <const name="BUFFER">FUNCDEF Overrides <code>WRITE</code>.  Indicates a buffer that can be filled with data by the function if paired with <code>RESULT</code>; must be paired with <code>BUFSIZE</code> in second argument.</const>
      <const name="BUFSIZE">FUNCDEF Overrides <code>LOOKUP</code>.  Pair with <code>BUFFER</code> to indicate the byte size of the buffer memory.</const>
      <const name="BYTE">8 bit integer.</const>
      <const name="CPP">Use the C++ variant of the indicated type, e.g. <code>ARRAY</code> is a <code>std::vector</code>.</const>
      <const name="CUSTOM"/>
      <const name="DOUBLE">64 bit float.</const>
      <const name="DOUBLERESULT">For actions and methods</const>
      <const name="ERROR">FUNCDEF</const>
      <const name="FLAGS">CLASSDEF</const>
      <const name="FLOAT">32 bit float.  Not valid for use in class definitions.</const>
      <const name="FUNCTION">Intended for callbacks, uses the rkFunction structure.</const>
      <const name="FUNCTIONPTR">Synonym for <code>PTR | FUNCTION</code></const>
      <const name="I">Synonym for <code>INIT</code></const>
      <const name="INIT">CLASSDEF</const>
      <const name="INT">32 bit integer.</const>
      <const name="INT64">64 bit integer.</const>
      <const name="INT64RESULT">For actions and methods</const>
      <const name="INTRESULT">For actions and methods</const>
      <const name="LOCAL">CLASSDEF Pointer to an object that is local to the class</const>
      <const name="LOOKUP">CLASSDEF</const>
      <const name="OBJECT">Supplementary, can be used with ints (for IDs) or pointers</const>
      <const name="OBJECTID">Synonym for <code>INT | OBJECT</code></const>
      <const name="OBJECTPTR">Synonym for <code>PTR | OBJECT</code></const>
      <const name="POINTER">Pointer (32 or 64 bit).</const>
      <const name="PRIVATE">Synonym for <code>SYSTEM</code></const>
      <const name="PTR">Synonym for <code>POINTER</code></const>
      <const name="PTRBUFFER">The next argument should be <code>INT|BUFSIZE</code></const>
      <const name="PTRRESULT">Use for pointer-based value results only</const>
      <const name="PTRSIZE">Synonym for <code>BUFSIZE</code></const>
      <const name="PTR_DOUBLERESULT">Use for pointer-based value results only.</const>
      <const name="PTR_INT64RESULT">Use for pointer-based value results only.</const>
      <const name="PTR_INTRESULT">Use for pointer-based value results only.</const>
      <const name="R">Synonym for <code>READ</code></const>
      <const name="READ">CLASSDEF</const>
      <const name="RESOURCE">The referenced struct or pointer is a special resource.  Changes some behaviours, e.g. a resourced struct will use direct value references rather than being copied in Fluid.</const>
      <const name="RESULT">FUNCDEF Overrides <code>READ</code></const>
      <const name="RGB">Supplementary, if an int type then format is <code>0xAARRGGBB</code>, if pointer then refers to an RGB structure.</const>
      <const name="RI">Synonym for <code>READ | INIT</code></const>
      <const name="RW">Synonym for <code>READ | WRITE</code></const>
      <const name="SCALED">Supplementary, indicates a float value for multiplicative scaling.</const>
      <const name="STR">Synonym for <code>STRING</code></const>
      <const name="STRING">Pointer to a string.</const>
      <const name="STRRESULT">Synonym for <code>STR | RESULT</code></const>
      <const name="STRUCT">Supplementary, defines the field as a structure reference.  MUST be combined with <code>FD_POINTER</code>.  If used in a class, it is possible to name the structure definition in field-&gt;Arg</const>
      <const name="SYNONYM">CLASSDEF Use to declare fields that duplicate the functionality of another field.</const>
      <const name="SYSTEM">CLASSDEF System, internal and private fields.</const>
      <const name="TAGS">FUNCDEF Overrides <code>INIT</code></const>
      <const name="UNIT">A value that describes a display unit.</const>
      <const name="UNSIGNED">Supplementary, integer value is unsigned.</const>
      <const name="VARTAGS">FUNCDEF Overrides <code>FLAGS</code>.  Use for 64-bit taglists that require value definitions, e.g. <code>TDOUBLE</code>, <code>TINT</code> etc.</const>
      <const name="VIRTUAL">CLASSDEF Ensures that the field has no physical representation in the structure.</const>
      <const name="VOID"/>
      <const name="VOLATILE">[Not yet allocated a bit]  Used on result pointers, usually strings, to indicate that the consecutive reads will overwrite the content of previous return values.  This indicates to scripting languages to make a copy of the data before the next interaction with the object.</const>
      <const name="W">Synonym for <code>WRITE</code></const>
      <const name="WORD">16 bit integer.</const>
      <const name="WRITE">CLASSDEF</const>
    </constants>

    <constants lookup="FDB" comment="Feedback event indicators.">
      <const name="COMPRESS_FILE"/>
      <const name="DECOMPRESS_FILE"/>
      <const name="DECOMPRESS_OBJECT"/>
      <const name="REMOVE_FILE"/>
    </constants>

    <constants lookup="FDL" comment="Options for the File Delete() method.">
      <const name="FEEDBACK">Automatically manage user feedback for deleting files by presenting dialog boxes.</const>
    </constants>

    <constants lookup="FDT" comment="Flags for the SetDate() file method.">
      <const name="ACCESSED">The date on which the file was last accessed by a user or application.</const>
      <const name="ARCHIVED">The date on which the file was most recently archived.  Not supported by most filesystems.</const>
      <const name="CREATED">The date on which the file was created.  On some host platforms this datestamp may be read-only.</const>
      <const name="MODIFIED">The date on which the file was last modified.</const>
    </constants>

    <constants lookup="FFR" comment="Return codes available to the feedback routine">
      <const name="ABORT">Abort the entire operation.</const>
      <const name="OKAY">Continue processing uninterrupted.</const>
      <const name="SKIP">Skip processing of this entity.</const>
    </constants>

    <constants lookup="FL" comment="File flags">
      <const name="APPROXIMATE">Allows fuzzy matching of the file path when opening an existing file.  This means that the file extension will be ignored; for instance attempting to open a file of 'screenshot.png' when only a file name of 'screenshot.jpg' exists in the same folder, the 'screenshot.jpg' file will be opened instead.  If multiple files could potentially match to the file name, the file object will select the first match that is encountered.</const>
      <const name="BUFFER">Activates a special mode in which the file data is stored in a memory buffer rather than a disk file.  Set the Size field to a value of at least 1 so that the initial buffer size is configured.  In this mode many of the available file operations are meaningless except for the Read, Write and Seek actions.</const>
      <const name="DEVICE">The file is a system device (must set if opening a device for read/write operations)</const>
      <const name="DIRECTORY">The file object represents a folder.</const>
      <const name="EXCLUDE_FILES">Exclude files when scanning this folder.</const>
      <const name="EXCLUDE_FOLDERS">Exclude folders when scanning this folder.</const>
      <const name="FILE">Explicitly declares the file object as an entity that stores content (as opposed to a device or folder for example).</const>
      <const name="FOLDER">The file object represents a folder.</const>
      <const name="LINK">Read-Only.  Indicates that the file is a symbolic link or shortcut to another file.</const>
      <const name="LOOP">In loop mode, the file object's position marker for read/write operations is allowed to extend past the actual file size.  Any read/write operation beyond the file size will loop back to the file at a corrected offset - for example, reading position 330 of a 100 byte file will start the operation from the 30th byte.  Loop mode does not affect any other area besides the read, write and seek operations.  The loop feature is typically used to create multimedia data streams with minimal effort.</const>
      <const name="NEW">Required when creating a new file.  If a file with the same name exists, its contents will be destroyed. If however the existing file is locked, the initalisation process will fail.</const>
      <const name="READ">Required if the file needs to be opened for read access.</const>
      <const name="RESET_DATE">For internal use only</const>
      <const name="STREAM">File data is streamed (e.g. PIPE, FIFO, socket) and may be accessed locally or via a network.</const>
      <const name="WRITE">Prepares a file for writing data, starting at byte position 0.  To start writing from the end of a file, use the Seek action after the file has been initialised.</const>
    </constants>

    <constants lookup="FOF" comment="Flags that can be passed to FindObject()">
      <const name="SMART_NAMES">Parse numeric object names as ID references and support use of the 'Owner' reserved keyword.</const>
    </constants>

    <constants lookup="IDTYPE" comment="Types for AllocateID()">
      <const name="FUNCTION">Function ID's are used to track <code>FUNCTION</code> types and are assigned to the function ID field.</const>
      <const name="GLOBAL">Global ID's have no specific association with anything.</const>
      <const name="MESSAGE">Message ID's are allocated for the purpose of sending uniquely identifiable messages between tasks.</const>
    </constants>

    <constants lookup="JET" comment="JET constants are documented in GetInputEvent()">
      <const name="ABS_XY">The X, Y values are defined as absolute coordinates, relative to the top-left of the display.</const>
      <const name="BUTTON_1">Left mouse button; XBox A button, PS square button.  Value is pressure sensitive, ranging between 0 - 1.0 (0 is released, 1.0 is fully depressed).</const>
      <const name="BUTTON_10">Non-specific button assignment.</const>
      <const name="BUTTON_2">Right mouse button; XBox X button, PS cross button.</const>
      <const name="BUTTON_3">Middle mouse button; XBox Y button, PS triangle.</const>
      <const name="BUTTON_4">Alt. mouse button 1; XBox B button, PS circle.</const>
      <const name="BUTTON_5">Alt. mouse button 2.</const>
      <const name="BUTTON_6">Non-specific button assignment.</const>
      <const name="BUTTON_7">Non-specific button assignment.</const>
      <const name="BUTTON_8">Non-specific button assignment.</const>
      <const name="BUTTON_9">Non-specific button assignment.</const>
      <const name="CROSSED_IN">This message is sent by the input system when the mouse pointer enters an area for the first time.  The message value refers to the object ID of the container being monitored for movement.</const>
      <const name="CROSSED_OUT">This message is sent by the input system when the mouse pointer leaves an area.  The message value refers to the object ID of the container being monitored for movement.</const>
      <const name="DEVICE_TILT_XY">Controller tilted on the X/Y axis.  Value indicates angle, -ve = left, +ve = right</const>
      <const name="DEVICE_TILT_Z">Controller is rising or falling.  Value expressed as 'speed',</const>
      <const name="DISPLAY_EDGE">Recently supplied input occurred at the edge of the display.</const>
      <const name="PEN_TILT_XY">For pen-based input, this type indicates the vertical tilt of the pen device.  A value of 0 indicates that the pen is laid flat with nib at the bottom, 0.5 is 90 degrees, 1.0 is laid flat with nib at the top.</const>
      <const name="PRESSURE">Amount of pressure applied, ranges from 0 (none) to 1.0 (normal) and possibly higher if user presses hard enough</const>
      <const name="WHEEL">Mouse wheel rotation - the value generally reflects the number of 'clicks' rotated on the wheel.</const>
      <const name="WHEEL_TILT">Some mouse wheels can be tilted to the left or right.  Ranges from -1.0 to +1.0</const>
    </constants>

    <constants lookup="JTYPE" comment="JTYPE flags are used to categorise input types.">
      <const name="ANALOG">Analog movement (ranging from -1.0 to 1.0)</const>
      <const name="ANCHORED">Cursor has been anchored with LockCursor()</const>
      <const name="BUTTON">Input is a physical button or switch</const>
      <const name="CROSSING">Crossing events manage the entering and leaving of an area.</const>
      <const name="DBL_CLICK">Set by the input system if the <code>Type</code> is a button and the button has been clicked in quick succession so as to be classed as a double-click.</const>
      <const name="DIGITAL">D-Pad or digital joystick source (restricted to +/- 1)</const>
      <const name="DRAGGED">Set if sufficient movement occurred between the original click and its point of release (usually requires a 3 or more pixel difference).</const>
      <const name="DRAG_ITEM">This special flag is set by the input system if the pointer is click-dragging an object at the time of the event.</const>
      <const name="EXT_MOVEMENT">Extended or indirect movement information.  This covers all types of movement that are unconnected to coordinate positioning -  mouse wheel movement and pen tilt are two such examples.</const>
      <const name="MOVEMENT">X/Y coordinate movement only. Movement such as the wheel mouse spinning is not covered by this type as it does not influence the coordinate system.</const>
      <const name="REPEATED">Input is a repeated entry (i.e. user is holding down a button and a repetition timer is being triggered)</const>
      <const name="SECONDARY">Indicates to the receiver of this message that it is not the primary/original recipient</const>
    </constants>

    <constants lookup="KEY" comment="Raw key codes">
      <const name="A"/>
      <const name="APOSTROPHE"/>
      <const name="AT"/>
      <const name="B"/>
      <const name="BACK"/>
      <const name="BACKSPACE"/>
      <const name="BACK_SLASH"/>
      <const name="BREAK"/>
      <const name="C"/>
      <const name="CALL"/>
      <const name="CAMERA"/>
      <const name="CANCEL"/>
      <const name="CAPS_LOCK"/>
      <const name="CLEAR"/>
      <const name="COMMA"/>
      <const name="D"/>
      <const name="DELETE"/>
      <const name="DOT"/>
      <const name="DOWN"/>
      <const name="E"/>
      <const name="EIGHT"/>
      <const name="END"/>
      <const name="END_CALL"/>
      <const name="ENTER"/>
      <const name="EQUALS"/>
      <const name="ESCAPE"/>
      <const name="EXECUTE"/>
      <const name="F"/>
      <const name="F1"/>
      <const name="F10"/>
      <const name="F11"/>
      <const name="F12"/>
      <const name="F13"/>
      <const name="F14"/>
      <const name="F15"/>
      <const name="F16"/>
      <const name="F17"/>
      <const name="F18"/>
      <const name="F19"/>
      <const name="F2"/>
      <const name="F20"/>
      <const name="F3"/>
      <const name="F4"/>
      <const name="F5"/>
      <const name="F6"/>
      <const name="F7"/>
      <const name="F8"/>
      <const name="F9"/>
      <const name="FIND"/>
      <const name="FIVE"/>
      <const name="FORWARD"/>
      <const name="FOUR"/>
      <const name="G"/>
      <const name="H"/>
      <const name="HELP"/>
      <const name="HOME"/>
      <const name="I"/>
      <const name="INSERT"/>
      <const name="J"/>
      <const name="K"/>
      <const name="L"/>
      <const name="LEFT"/>
      <const name="LENS_FOCUS"/>
      <const name="LESS_GREATER"/>
      <const name="LIST_END"/>
      <const name="L_ALT"/>
      <const name="L_COMMAND"/>
      <const name="L_CONTROL"/>
      <const name="L_SHIFT"/>
      <const name="L_SQUARE"/>
      <const name="M"/>
      <const name="MACRO"/>
      <const name="MENU"/>
      <const name="MINUS"/>
      <const name="MUTE"/>
      <const name="N"/>
      <const name="NEXT"/>
      <const name="NINE"/>
      <const name="NP_0"/>
      <const name="NP_1"/>
      <const name="NP_2"/>
      <const name="NP_3"/>
      <const name="NP_4"/>
      <const name="NP_5"/>
      <const name="NP_6"/>
      <const name="NP_7"/>
      <const name="NP_8"/>
      <const name="NP_9"/>
      <const name="NP_BAR"/>
      <const name="NP_DECIMAL"/>
      <const name="NP_DIVIDE"/>
      <const name="NP_DOT"/>
      <const name="NP_ENTER"/>
      <const name="NP_MINUS"/>
      <const name="NP_MULTIPLY"/>
      <const name="NP_PLUS"/>
      <const name="NP_PLUS_MINUS"/>
      <const name="NP_SEPARATOR"/>
      <const name="NUM_LOCK"/>
      <const name="O"/>
      <const name="ONE"/>
      <const name="P"/>
      <const name="PAGE_DOWN"/>
      <const name="PAGE_UP"/>
      <const name="PAUSE"/>
      <const name="PERIOD"/>
      <const name="PLAY"/>
      <const name="PLUS"/>
      <const name="POUND"/>
      <const name="POWER"/>
      <const name="PREVIOUS"/>
      <const name="PRINT"/>
      <const name="PRT_SCR"/>
      <const name="Q"/>
      <const name="R"/>
      <const name="REDO"/>
      <const name="REVERSE_QUOTE"/>
      <const name="REWIND"/>
      <const name="RIGHT"/>
      <const name="R_ALT"/>
      <const name="R_COMMAND"/>
      <const name="R_CONTROL"/>
      <const name="R_SHIFT"/>
      <const name="R_SQUARE"/>
      <const name="S"/>
      <const name="SCR_LOCK"/>
      <const name="SELECT"/>
      <const name="SEMI_COLON"/>
      <const name="SEVEN"/>
      <const name="SIX"/>
      <const name="SLASH"/>
      <const name="SLEEP"/>
      <const name="SPACE"/>
      <const name="STAR"/>
      <const name="STOP"/>
      <const name="SYSRQ"/>
      <const name="T"/>
      <const name="TAB"/>
      <const name="THREE"/>
      <const name="TWO"/>
      <const name="U"/>
      <const name="UNDO"/>
      <const name="UP"/>
      <const name="V"/>
      <const name="VOLUME_DOWN"/>
      <const name="VOLUME_UP"/>
      <const name="W"/>
      <const name="WAKE"/>
      <const name="WIN_CONTROL"/>
      <const name="X"/>
      <const name="Y"/>
      <const name="Z"/>
      <const name="ZERO"/>
    </constants>

    <constants lookup="KQ" comment="Special qualifier flags">
      <const name="ALT">Synonym for <code>L_ALT | R_ALT</code></const>
      <const name="ALTGR">Synonym for <code>R_ALT</code></const>
      <const name="CAPS_LOCK">Caps-Lock is on</const>
      <const name="COMMAND">Synonym for <code>L_COMMAND | R_COMMAND</code></const>
      <const name="CONTROL">Synonym for <code>L_CONTROL | R_CONTROL</code></const>
      <const name="CTRL">Synonym for <code>L_CONTROL | R_CONTROL</code></const>
      <const name="DEAD_KEY">This key will be affected by a previously pressed dead-key</const>
      <const name="INFO">Synonym for <code>REPEAT | RELEASED | PRESSED | NOT_PRINTABLE | CAPS_LOCK</code></const>
      <const name="INSTRUCTION_KEYS">Synonym for <code>ALT | CONTROL</code></const>
      <const name="L_ALT">Left Alt is held</const>
      <const name="L_COMMAND">Left Logo/Special</const>
      <const name="L_CONTROL">Control Key is held</const>
      <const name="L_CTRL">Control Key is held</const>
      <const name="L_SHIFT">Left Shift is held</const>
      <const name="NOT_PRINTABLE">The represented key value is not printable</const>
      <const name="NUM_LOCK">NumLock is on</const>
      <const name="NUM_PAD">Identifies numeric keypad keys</const>
      <const name="PRESSED">Key is being held or tapped</const>
      <const name="QUALIFIERS">Synonym for <code>SHIFT | COMMAND | ALT | CONTROL</code></const>
      <const name="RELEASED">The key is being released</const>
      <const name="REPEAT">This is a repeated key</const>
      <const name="R_ALT">Right Alt is held</const>
      <const name="R_COMMAND">Right Logo/Special</const>
      <const name="R_CONTROL">Control Key is held</const>
      <const name="R_CTRL">Control Key is held</const>
      <const name="R_SHIFT">Right Shift is held</const>
      <const name="SCR_LOCK">Scroll Lock is on</const>
      <const name="SHIFT">Synonym for <code>L_SHIFT | R_SHIFT</code></const>
    </constants>

    <constants lookup="LAYOUT" comment="Universal values for alignment of graphic layouts in documents.">
      <const name="BACKGROUND">Graphic is placed behind text.  The text will not be wrapped around the object</const>
      <const name="EMBEDDED">Graphic is embedded in the text stream (treated as a character).  The height of the line can be extended to match the height of the graphic in this mode.</const>
      <const name="FOREGROUND">Graphic is placed in front of the text.  The text will not be wrapped around the object</const>
      <const name="IGNORE_CURSOR">The object has a fixed X/Y position, unrelated to the cursor</const>
      <const name="LEFT">The text boundary is extended to the left edge of the page.</const>
      <const name="LOCK">Lock the position of the graphic to the top left of the view and not the scrolling position of the page.</const>
      <const name="RIGHT">The text boundary is extended to the right edge of the page.</const>
      <const name="SQUARE">The default.  Text will clip around the image's border</const>
      <const name="TIGHT">Text wraps to the shape of the image (alpha blended/masked images only)</const>
      <const name="TILE">The graphic will be tiled.  Tiled graphics also meet the <code>BACKGROUND</code> criteria (no wrapping).</const>
      <const name="WIDE">The text boundary is extended to the left and right edges of the page.</const>
    </constants>

    <constants lookup="LDF" comment="Flags for LoadFile()">
      <const name="CHECK_EXISTS">Limits the routine to checking the file cache for the existence of the file.  If found, the relevant cache entry is returned. The open count is not incremented by this action (it is therefore unnecessary to follow-up with a call to UnloadFile()).  If no up-to-date cache entry is available, <code>ERR::Search</code> is returned.</const>
    </constants>

    <constants lookup="LOC" comment="AnalysePath() values">
      <const name="DIRECTORY">The path refers to a folder.</const>
      <const name="FILE">The path refers to a file.</const>
      <const name="VOLUME">The path refers to a volume name.</const>
    </constants>

    <constants lookup="MAX">
      <const name="FILENAME"/>
      <const name="NAME_LEN"/>
    </constants>

    <constants lookup="MEM" comment="Memory types used by AllocMemory().  The lower 16 bits are stored with allocated blocks, the upper 16 bits are function-relative only.">
      <const name="AUDIO">The memory space is reserved by an audio device such as a sound card.</const>
      <const name="CALLER">This flag is usable only in routines that are supporting a class method.  It forces the memory allocation to be tracked to the object that made the method call.  This is particularly important in methods that return memory blocks that do not form a part of the object itself.</const>
      <const name="CODE">Set if the memory will contain executable program code.</const>
      <const name="DATA">The default type, <code>DATA</code>, is used to indicate a standard memory allocation from system RAM.</const>
      <const name="HIDDEN">Hidden blocks are not recorded and are excluded from resource tracking.</const>
      <const name="MANAGED">Enables custom resource management for the memory block.  The start of the block will need to be reserved with a pointer to a <code>ResourceManager</code> structure, which is included as part of the block's declared Size.  The <code>Free()</code> callback will be called when the block is removed.</const>
      <const name="NO_BLOCK">Permanently turn off all accesses to this memory block.  This means that multiple threads can have full read/write access to the memory block at once regardless of other acces flags.</const>
      <const name="NO_BLOCKING">Permanently turn off all accesses to this memory block.  This means that multiple threads can have full read/write access to the memory block at once regardless of other acces flags.</const>
      <const name="NO_CLEAR">Do not clear the memory on allocation (saves time).</const>
      <const name="NO_LOCK">For AllocMemory() only, indicates that the (private) memory block should not be locked on return.</const>
      <const name="NO_POOL">Gives a hint to the allocator to allocate the block outside of the memory pool.</const>
      <const name="READ">The memory is explicitly marked as readable.</const>
      <const name="READ_WRITE">Synonym for <code>READ | WRITE</code></const>
      <const name="STRING">Identifies the memory content as a null terminated string. Useful for debugging and run-time type identification in scripts.</const>
      <const name="TEXTURE">The memory space is reserved by a video driver for hosting texture graphics.</const>
      <const name="TMP_LOCK">Enables temporary locking restrictions.  Prevents processes from sleeping while holding a lock on the memory block.</const>
      <const name="UNTRACKED">Allocating an untracked memory block will prevent the memory block from being tracked back to the object holding the current context.</const>
      <const name="VIDEO">The memory space is reserved by a video device such as a graphics card for display purposes, e.g. framebuffer.</const>
      <const name="WRITE">The memory is explicitly marked as writeable.</const>
    </constants>

    <constants lookup="MFF" comment="Flags for the File Watch() method.">
      <const name="ATTRIB">File permissions or datestamp changed.</const>
      <const name="CLOSED">An opened file has been closed.</const>
      <const name="CREATE">New file/link created or renamed in folder.</const>
      <const name="DEEP">Receive notifications from sub-folders (Windows only).</const>
      <const name="DELETE">Existing file deleted</const>
      <const name="FILE">File identifier; if passed to <class name="File" method="Watch">File.Watch()</class> then indicates a preference for file events only.</const>
      <const name="FOLDER">Folder identifier; if passed to <class name="File" method="Watch">File.Watch()</class> then indicates a preference for folder events only.</const>
      <const name="MODIFY">File modified via write or truncation.</const>
      <const name="MOVED">Existing file moved or renamed.</const>
      <const name="OPENED">Existing file was opened.</const>
      <const name="READ">File was accessed (read).</const>
      <const name="RENAME">Existing file moved or renamed.</const>
      <const name="SELF">Event applies to the monitored folder and not a contained item</const>
      <const name="UNMOUNT">Host filesystem was unmounted.</const>
      <const name="WRITE">File modified via write or truncation.</const>
    </constants>

    <constants lookup="MHF" comment="Internal options for requesting function tables from modules.">
      <const name="DEFAULT">Use structures to group exported functions (Linux, C/C++ standard)</const>
      <const name="STATIC">Keep the module code in memory</const>
      <const name="STRUCTURE">Use structures to group exported functions (Linux, C/C++ standard)</const>
    </constants>

    <constants lookup="MOF" comment="Module flags">
      <const name="LINK_LIBRARY">Module refers to a symbolic link library (e.g. libz DLL or SO)</const>
      <const name="STATIC">This flag prevents the loaded module code from being unloaded when the module object is freed.  This may be needed in cases where a module is designed with the presumption that it will remain in memory after being loaded by the developer.</const>
      <const name="SYSTEM_PROBE">Indicates that the module is being probed.  Do not use outside of the core library.</const>
    </constants>

    <constants lookup="MOVE" comment="Generic flags for controlling movement.">
      <const name="ALL">Synonym for <code>DOWN | UP | LEFT | RIGHT</code></const>
      <const name="DOWN"/>
      <const name="LEFT"/>
      <const name="RIGHT"/>
      <const name="UP"/>
    </constants>

    <constants lookup="MSF" comment="Message flags.">
      <const name="ADD">The default behaviour - this will add the message to the end of the queue.</const>
      <const name="MESSAGE_ID">The Type parameter refers to a unique message ID rather than a message type for this call.</const>
      <const name="NO_DUPLICATE">If the <code>Type</code> parameter matches a message already inside the queue, the new message will not be added and the function will immediately return with <code>ERR::Okay</code>.</const>
      <const name="UPDATE">If the <code>Type</code> parameter matches a message already inside the queue, the data for that message will be deleted, then the new message will be added to the end of the queue.</const>
      <const name="WAIT">Wait before inserting the message if the queue is at maximum capacity.</const>
    </constants>

    <constants lookup="MSGID" comment="Reserved message ID's that are handled internally.">
      <const name="ACTION"/>
      <const name="BREAK"/>
      <const name="COMMAND"/>
      <const name="CORE_END"/>
      <const name="DEBUG"/>
      <const name="EVENT"/>
      <const name="FREE"/>
      <const name="QUIT"/>
      <const name="THREAD_ACTION"/>
      <const name="THREAD_CALLBACK"/>
      <const name="VALIDATE_PROCESS"/>
      <const name="WAIT_FOR_OBJECTS"/>
    </constants>

    <constants lookup="MTF" comment="MoveToPoint flags">
      <const name="ANIM"/>
      <const name="RELATIVE"/>
      <const name="X"/>
      <const name="Y"/>
      <const name="Z"/>
    </constants>

    <constants lookup="NETMSG">
      <const name="END"/>
      <const name="START"/>
    </constants>

    <constants lookup="NF" comment="Flags that can be passed to NewObject().  If a flag needs to be stored with the object, it must be specified in the lower word.">
      <const name="COLLECT">Marked for garbage collection.</const>
      <const name="FREE">Read-only indicator for when the object is being freed.</const>
      <const name="FREE_ON_UNLOCK">Read-only indicator for when the object is marked for deletion.</const>
      <const name="INITIALISED">Read-only indicator if the object has been initialised.</const>
      <const name="LOCAL">Classes can allocate local objects to stop them from being associated with the client.</const>
      <const name="MESSAGE">Action has been called against the object through the message system (managed by <function module="Core">ProcessMessages</function>).</const>
      <const name="NAME">Use the Name parameter to name the created object.  This flag is not required if using <code>UNIQUE</code>.</const>
      <const name="PRIVATE"/>
      <const name="RECLASSED">The object switched from the base-class to a sub-class during initialisation.</const>
      <const name="SIGNALLED">The object has been signalled and is awaiting processing.</const>
      <const name="TIMER_SUB">The object is subscribed to a timer interval.</const>
      <const name="UNIQUE">Use to allocate an object that has a guaranteed unique name.  This will prevent code from shadowing any object that exists with the same name, which can be imperative when creating shared objects.  If it is discovered that an identically named object exists, <function module="Core">NewObject</function> will return <code>ERR::ObjectExists</code>.  This flag works in conjunction with the <code>Name</code> parameter.</const>
      <const name="UNTRACKED">An object created with this flag will not be tracked back to the object that created it.</const>
    </constants>

    <constants lookup="OPF">
      <const name="ARGS"/>
      <const name="DETAIL"/>
      <const name="ERROR"/>
      <const name="MAX_DEPTH"/>
      <const name="MODULE_PATH"/>
      <const name="OPTIONS"/>
      <const name="PRIVILEGED"/>
      <const name="ROOT_PATH"/>
      <const name="SCAN_MODULES"/>
      <const name="SHOW_ERRORS"/>
      <const name="SHOW_IO"/>
      <const name="SHOW_MEMORY"/>
      <const name="SYSTEM_PATH"/>
    </constants>

    <constants lookup="PERMIT" comment="Permission flags">
      <const name="ALL_DELETE">Synonym for <code>EVERYONE_DELETE</code></const>
      <const name="ALL_EXEC">Synonym for <code>EVERYONE_EXEC</code></const>
      <const name="ALL_READ">Synonym for <code>EVERYONE_READ</code></const>
      <const name="ALL_WRITE">Synonym for <code>EVERYONE_WRITE</code></const>
      <const name="ARCHIVE">Marks the file for future backup.  The flag should be cleared after the backup has succeeded.</const>
      <const name="DELETE">Owner can delete.  If the file system does not support this, deletion is enabled via the <code>WRITE</code> flag.</const>
      <const name="EVERYONE_ACCESS">Synonym for <code>EVERYONE_READ | EVERYONE_WRITE | EVERYONE_EXEC | EVERYONE_DELETE</code></const>
      <const name="EVERYONE_DELETE">Synonym for <code>DELETE | GROUP_DELETE | OTHERS_DELETE</code></const>
      <const name="EVERYONE_EXEC">Synonym for <code>EXEC | GROUP_EXEC | OTHERS_EXEC</code></const>
      <const name="EVERYONE_READ">Synonym for <code>READ | GROUP_READ | OTHERS_READ</code></const>
      <const name="EVERYONE_READWRITE">Synonym for <code>EVERYONE_READ | EVERYONE_WRITE</code></const>
      <const name="EVERYONE_WRITE">Synonym for <code>WRITE | GROUP_WRITE | OTHERS_WRITE</code></const>
      <const name="EXEC">User/Owner can execute.</const>
      <const name="GROUP">Synonym for <code>GROUP_READ | GROUP_WRITE | GROUP_EXEC | GROUP_DELETE</code></const>
      <const name="GROUPID">Allows executables to run with a set group id.</const>
      <const name="GROUP_DELETE">Group members can delete.</const>
      <const name="GROUP_EXEC">Group members can execute.</const>
      <const name="GROUP_READ">Group members can read.</const>
      <const name="GROUP_WRITE">Group members can write.</const>
      <const name="HIDDEN">Recommends that the file is hidden from view by default.</const>
      <const name="INHERIT">Inherit permissions from parent folder and logical OR them with preset permission flags.</const>
      <const name="NETWORK">File is hosted on another machine.</const>
      <const name="OFFLINE">File content for this networked file has not been cached on the local PC.</const>
      <const name="OTHERS">Synonym for <code>OTHERS_READ | OTHERS_WRITE | OTHERS_EXEC | OTHERS_DELETE</code></const>
      <const name="OTHERS_DELETE">Others can delete.</const>
      <const name="OTHERS_EXEC">Others can execute.</const>
      <const name="OTHERS_READ">Others can read.</const>
      <const name="OTHERS_WRITE">Others can write.</const>
      <const name="PASSWORD">File is password protected.</const>
      <const name="READ">User/Owner has read access.  This will not allow compiled code to be executed.</const>
      <const name="USER">Synonym for <code>READ | WRITE | EXEC | DELETE</code></const>
      <const name="USERID">Allows executables to run with a set user id.</const>
      <const name="USER_EXEC">Synonym for <code>EXEC</code></const>
      <const name="USER_READ">Synonym for <code>READ</code></const>
      <const name="USER_WRITE">Synonym for <code>WRITE</code></const>
      <const name="WRITE">User/Owner can write.</const>
    </constants>

    <constants lookup="PMF" comment="Flags for ProcessMessages">
    </constants>

    <constants lookup="PTC" comment="Predefined cursor styles">
      <const name="CROSSHAIR">The cross hair is used for targeting specific pixel points (common in paint programs).</const>
      <const name="CUSTOM">Works in conjunction with the SetCustomCursor() function to represent a program defined bitmap.</const>
      <const name="DEFAULT">The default cursor (usually an arrow pointing to the upper left).</const>
      <const name="DRAGGABLE">Used to indicate that a surface or object can be dragged by the user.</const>
      <const name="END"/>
      <const name="HAND">The hand cursor is often used for indicating click-able content (hyper-links, icons etc).</const>
      <const name="HAND_LEFT">Similar to the standard hand cursor, but points to the left.</const>
      <const name="HAND_RIGHT">Similar to the standard hand cursor, but points to the right.</const>
      <const name="INVISIBLE">The cursor graphic is invisible (but will continue to operate as normal in all other respects).</const>
      <const name="MAGNIFIER">Represents a magnifying glass.</const>
      <const name="NO_CHANGE"/>
      <const name="PAINTBRUSH">The paintbrush cursor is typically employed by paint programs.</const>
      <const name="SIZE_BOTTOM">Sizing cursor - for resizing the bottom edge of any rectangular area.</const>
      <const name="SIZE_BOTTOM_LEFT">Sizing cursor - for resizing the bottom left corner of any rectangular area.</const>
      <const name="SIZE_BOTTOM_RIGHT">Sizing cursor - for resizing the bottom right corner of any rectangular area.</const>
      <const name="SIZE_LEFT">Sizing cursor - for resizing the left edge of any rectangular area.</const>
      <const name="SIZE_RIGHT">Sizing cursor - for resizing the right edge of any rectangular area.</const>
      <const name="SIZE_TOP">Sizing cursor - for resizing the top edge of any rectangular area.</const>
      <const name="SIZE_TOP_LEFT">Sizing cursor - for resizing the top left corner of any rectangular area.</const>
      <const name="SIZE_TOP_RIGHT">Sizing cursor - for resizing the top right corner of any rectangular area.</const>
      <const name="SIZING">Multi-directional sizing cursor - for resizing in any direction.</const>
      <const name="SLEEP">The sleep cursor is used to inform the user that the computer is busy.</const>
      <const name="SPLIT_HORIZONTAL">The horizontal split cursor is typically used for splitting rectangles in half, or dragging a horizontal split within a large rectangular space.</const>
      <const name="SPLIT_VERTICAL">The vertical split cursor is typically used for splitting rectangles in half, or dragging a vertical split within a large rectangular space.</const>
      <const name="STOP">The stop cursor is used to inform the user that an operation is not possible (e.g. drag and drop to an unsupported object area).</const>
      <const name="TEXT">The text cursor is popular for the precise positioning of text cursors.</const>
    </constants>

    <constants lookup="RDF" comment="Flags for the OpenDir() function.">
      <const name="ARCHIVE">Feedback only - archive bit is set.</const>
      <const name="DATE">Retrieve the date stamp of each file.</const>
      <const name="FILE">Read all files in the folder.</const>
      <const name="FILES">Read all files in the folder.</const>
      <const name="FOLDER">Read all folders/volumes in the folder.</const>
      <const name="FOLDERS">Read all folders/volumes in the folder.</const>
      <const name="HIDDEN">Feedback only - file/folder is hidden.</const>
      <const name="LINK">Feedback only - file/folder is actually a link to another location.</const>
      <const name="PERMISSIONS">Get permission/security information.</const>
      <const name="QUALIFIED">Return fully qualified folder names (i.e. trailing slash or colon for each name).</const>
      <const name="QUALIFY">Return fully qualified folder names (i.e. trailing slash or colon for each name).</const>
      <const name="READ_ALL">Synonym for <code>SIZE | DATE | PERMISSIONS | FILES | FOLDERS</code></const>
      <const name="READ_ONLY">Read-only (not permissions related and might indicate read-only media).</const>
      <const name="SIZE">Retrieve the byte size of each file.</const>
      <const name="STREAM">Path is connected via a stream, e.g. network connection.</const>
      <const name="TAGS">Receive additional information for each file, such as comments, author and copyright.  The results are stored in the <code>Tags</code> field of each file.</const>
      <const name="TIME">Retrieve the date stamp of each file.</const>
      <const name="VIRTUAL">Path is to a virtual device.</const>
      <const name="VOLUME">Feedback only - indicates a volume.</const>
    </constants>

    <constants lookup="RES">
      <const name="CORE_IDL">Refers to the Core module's compressed IDL string.</const>
      <const name="CPU_SPEED">The average top-speed of all CPU cores in Mhz.</const>
      <const name="FREE_MEMORY">The total amount of free memory.</const>
      <const name="FREE_SWAP">The total amount of free swap memory.</const>
      <const name="JNI_ENV">Return the current JNI environment string.</const>
      <const name="KEY_STATE">Maintains the state of key qualifiers such as caps-lock and the shift keys.</const>
      <const name="LOG_DEPTH">The current depth of log messages.</const>
      <const name="LOG_LEVEL">The current level of log detail (larger numbers indicate more detail).</const>
      <const name="MAX_PROCESSES">The maximum number of processes that can be supported at any time.</const>
      <const name="OPEN_INFO">Pointer to the OpenInfo structure originally used to initialise the system.</const>
      <const name="PRIVILEGED">This is set to <code>true</code> if the process has elevated privileges (such as superuser or administrative rights).</const>
      <const name="PRIVILEGED_USER">If this value is set to 1, the process will operate in privileged mode (typically this enables full administrator rights).  This feature will only work for Unix processes that are granted admin rights when launched.  Setting the Value to 0 reverts to the user's permission settings.  SetResource() will return an error code indicating the level of success.</const>
      <const name="PROCESS_STATE">Life-cycle stage of the running process</const>
      <const name="STATIC_BUILD">Returns true if the runtime is a statically linked build.</const>
      <const name="THREAD_ID">Return the ID of the current thread.</const>
      <const name="TOTAL_MEMORY">The total amount of installed memory.</const>
      <const name="TOTAL_SHARED_MEMORY">The total amount of shared memory in use (system wide).</const>
      <const name="TOTAL_SWAP">The total amount of available swap space.</const>
    </constants>

    <constants lookup="RFD" comment="Flags for RegisterFD()">
      <const name="ALWAYS_CALL">Always call this FD's handler prior to the process going to sleep.</const>
      <const name="EXCEPT">Activate the callback if error conditions are pending.</const>
      <const name="READ">Activate the callback if there is data available to read.</const>
      <const name="RECALL">Set if the subscriber needs to manually check for incoming/outgoing data.  This is supported as a one-off check, so the flag will be disabled automatically when the subscriber is called.</const>
      <const name="REMOVE">Stop monitoring this file descriptor.</const>
      <const name="SOCKET">Identifies the file descriptor as a socket (Linux systems only).</const>
      <const name="WRITE">Activate the callback if there is room to write to the FD's buffer.</const>
    </constants>

    <constants lookup="RP" comment="Path types for SetResourcePath()">
      <const name="MODULE_PATH">An alternative path leading to the system modules (normally <code>system:modules/</code>).  Introduced for platforms such as Android, where modules are stored in asset folders.</const>
      <const name="ROOT_PATH">Overrides the root path, which defaults to the location at which Parasol is installed.</const>
      <const name="SYSTEM_PATH">The path of the <code>system:</code> volume, which otherwise defaults to <code>[root]:system/</code>.</const>
    </constants>

    <constants lookup="RSF" comment="Flags for ResolvePath()">
      <const name="APPROXIMATE">Ignores file extensions for the purpose of file name matching.</const>
      <const name="CASE_SENSITIVE">For use on host systems that use case-insensitive file systems such as Windows; this option checks that the discovered file is a case-sensitive match to the Path.</const>
      <const name="CHECK_VIRTUAL">If the volume referenced by Path is traced to another volume that is reserved by a virtual file system driver, <code>ERR::VirtualVolume</code> is returned. The volume is still resolved as far as possible and the resulting path will be returned by this function.</const>
      <const name="NO_DEEP_SCAN">Do not perform more than one iteration when resolving the source file path.</const>
      <const name="NO_FILE_CHECK">Do not test for the existence of the targeted file or folder during the resolution process.</const>
      <const name="PATH">Use the <code>PATH</code> environment variable to resolve the file name in the <code>Path</code> parameter.</const>
    </constants>

    <constants lookup="SCF" comment="Script flags">
      <const name="EXIT_ON_ERROR">The script will automatically terminate its execution process if an error is detected.</const>
      <const name="LOG_ALL">Enables execution debugging.  More information will be printed to the console in this mode.</const>
    </constants>

    <constants lookup="SEEK" comment="Seek positions">
      <const name="CURRENT">Use an index at the end of the last read/write operation.</const>
      <const name="END">Use an index at the end of the data buffer.</const>
      <const name="RELATIVE">The index is between 0 and 1.0 and relative to the data size.</const>
      <const name="START">Use an index at position zero.</const>
    </constants>

    <constants lookup="STR">
      <const name="CASE">Perform a case-sensitive match.</const>
      <const name="MATCH_CASE">Perform a case-sensitive match.</const>
      <const name="MATCH_LEN">The strings must be of equal length to be matched.</const>
    </constants>

    <constants lookup="STT" comment="Types for StrDatatype().">
      <const name="FLOAT">The string represents a floating point number.</const>
      <const name="HEX">The string represents a hexadecimal number.</const>
      <const name="NUMBER">The string represents a whole number.</const>
      <const name="STRING">The string represents plain-text.</const>
    </constants>

    <constants lookup="THF" comment="Thread flags">
      <const name="AUTO_FREE">Automatically destroy the Thread object when the user routine has completed.</const>
    </constants>

    <constants lookup="TOI">
      <const name="ANDROID_ASSETMGR"/>
      <const name="ANDROID_CLASS"/>
      <const name="ANDROID_ENV"/>
      <const name="LOCAL_CACHE"/>
      <const name="LOCAL_STORAGE"/>
    </constants>

    <constants lookup="TSF" comment="Task flags">
      <const name="ATTACHED">Forces the new process to be attached to the parent (child will close when parent closes).</const>
      <const name="DETACHED">Forces the new process to be detached from the parent.</const>
      <const name="PIPE">Enable the output pipe to the launched process so that it can read data.</const>
      <const name="PRIVILEGED">The child process will inherit the system privileges of its parent.</const>
      <const name="QUIET">Divert all process output to <code>/dev/null</code> or the nearest equivalent for non-Unix systems.</const>
      <const name="RESET_PATH">The new process will start in its own folder and not the folder of the parent process.</const>
      <const name="SHELL">Enables shell mode.  On Unix systems, this means that a shell (usually BASH) will be used to launch the process.</const>
      <const name="VERBOSE">Enable verbose logging.</const>
      <const name="WAIT">The parent process will halt when the task is running.  Control is returned to the parent process once the child process terminates.</const>
    </constants>

    <constants lookup="TSTATE" comment="Indicates the state of a process.">
      <const name="PAUSED">The process is asleep.</const>
      <const name="RUNNING">The process is currently executing code.</const>
      <const name="STOPPING">The process is in its termination phase.</const>
      <const name="TERMINATED">The process has closed.</const>
    </constants>

    <constants lookup="VAS" comment="For use by VirtualVolume()">
      <const name="CASE_SENSITIVE">Set to true if the volume's paths are case-sensitive.</const>
      <const name="CLOSE_DIR"/>
      <const name="CREATE_LINK"/>
      <const name="DELETE"/>
      <const name="DEREGISTER">Remove the virtual volume from the system.</const>
      <const name="DRIVER_SIZE"/>
      <const name="GET_DEVICE_INFO"/>
      <const name="GET_INFO"/>
      <const name="IDENTIFY_FILE"/>
      <const name="IGNORE_FILE"/>
      <const name="MAKE_DIR"/>
      <const name="OPEN_DIR"/>
      <const name="READ_LINK"/>
      <const name="RENAME"/>
      <const name="SAME_FILE"/>
      <const name="SCAN_DIR"/>
      <const name="TEST_PATH"/>
      <const name="WATCH_PATH"/>
    </constants>

    <constants lookup="VLF" comment="VlogF flags">
      <const name="API"/>
      <const name="BRANCH"/>
      <const name="CRITICAL"/>
      <const name="DETAIL"/>
      <const name="ERROR"/>
      <const name="FUNCTION"/>
      <const name="INFO"/>
      <const name="TRACE"/>
      <const name="WARNING"/>
    </constants>

    <constants lookup="VOLUME" comment="Options for SetVolume()">
      <const name="HIDDEN">Hides the volume so that it will not show up when reading volumes from the root path <code>:</code>.</const>
      <const name="PRIORITY">If the volume already exists, the path will be inserted at the beginning of the path list so that it has priority over the others.</const>
      <const name="REPLACE">If the volume already exists, all paths that are attached to it will be replaced with the new path setting.</const>
      <const name="SYSTEM">Identifies the volume as being created by the system (this flag is not for client use).</const>
    </constants>

  </types>
  <structs>
    <struct name="ActionArray">
      <field name="Routine" type="APTR">Pointer to the function entry point</field>
      <field name="ActionCode" type="AC" lookup="AC">Action identifier</field>
    </struct>

    <struct name="ActionTable" comment="Structure for ActionList">
      <field name="Hash" type="UINT">Hash of the action name.</field>
      <field name="Size" type="INT">Byte-size of the structure for this action.</field>
      <field name="Name" type="CSTRING">Name of the action.</field>
      <field name="Args" type="const struct FunctionField *">List of fields that are passed to this action.</field>
    </struct>

    <struct name="ChildEntry" comment="Structure for ListChildren() function">
      <field name="ObjectID" type="OBJECTID">Object ID</field>
      <field name="ClassID" type="CLASSID">The class ID of the referenced object.</field>
    </struct>

    <struct name="ClipRectangle" comment="Generic structure for rectangular clipping.">
      <field name="Left" type="INT">Left-most coordinate</field>
      <field name="Top" type="INT">Top coordinate</field>
      <field name="Right" type="INT">Right-most coordinate</field>
      <field name="Bottom" type="INT">Bottom coordinate</field>
    </struct>

    <struct name="ColourFormat" typeName="COLOURFORMAT">
      <field name="RedShift" type="UBYTE">Right shift value for red (15/16 bit formats only)</field>
      <field name="GreenShift" type="UBYTE">Right shift value for green</field>
      <field name="BlueShift" type="UBYTE">Right shift value for blue</field>
      <field name="AlphaShift" type="UBYTE">Right shift value for alpha</field>
      <field name="RedMask" type="UBYTE">Unshifted mask value for red (ranges from 0x00 to 0xff)</field>
      <field name="GreenMask" type="UBYTE">Unshifted mask value for green</field>
      <field name="BlueMask" type="UBYTE">Unshifted mask value for blue</field>
      <field name="AlphaMask" type="UBYTE">Unshifted mask value for alpha</field>
      <field name="RedPos" type="UBYTE">Left shift/positional value for red</field>
      <field name="GreenPos" type="UBYTE">Left shift/positional value for green</field>
      <field name="BluePos" type="UBYTE">Left shift/positional value for blue</field>
      <field name="AlphaPos" type="UBYTE">Left shift/positional value for alpha</field>
      <field name="BitsPerPixel" type="UBYTE">Number of bits per pixel for this format.</field>
    </struct>

    <struct name="CompressedItem">
      <field name="OriginalSize" type="INT64">Original size of the file</field>
      <field name="CompressedSize" type="INT64">Compressed size of the file</field>
      <field name="Next" type="struct CompressedItem *">Used only if this is a linked-list.</field>
      <field name="Path" type="CSTRING">Path to the file (includes folder prefixes).  Archived folders will include the trailing slash.</field>
      <field name="Permissions" type="PERMIT" lookup="PERMIT">Original permissions - see <code>PERMIT</code> flags.</field>
      <field name="UserID" type="INT">Original user ID</field>
      <field name="GroupID" type="INT">Original group ID</field>
      <field name="OthersID" type="INT">Original others ID</field>
      <field name="Flags" type="FL" lookup="FL"><code>FL</code> flags</field>
      <field name="Created" type="struct DateTime">Date and time of the file's creation.</field>
      <field name="Modified" type="struct DateTime">Date and time last modified.</field>
    </struct>

    <struct name="CompressionFeedback">
      <field name="FeedbackID" type="FDB" lookup="FDB">Set to one of the FDB event indicators</field>
      <field name="Index" type="INT">Index of the current file</field>
      <field name="Path" type="CSTRING">Name of the current file/path in the archive</field>
      <field name="Dest" type="CSTRING">Destination file/path during decompression</field>
      <field name="Progress" type="INT64">Progress indicator (byte position for the file being de/compressed).</field>
      <field name="OriginalSize" type="INT64">Original size of the file</field>
      <field name="CompressedSize" type="INT64">Compressed size of the file</field>
      <field name="Year" type="INT16">Year of the original file's datestamp.</field>
      <field name="Month" type="INT16">Month of the original file's datestamp.</field>
      <field name="Day" type="INT16">Day of the original file's datestamp.</field>
      <field name="Hour" type="INT16">Hour of the original file's datestamp.</field>
      <field name="Minute" type="INT16">Minute of the original file's datestamp.</field>
      <field name="Second" type="INT16">Second of the original file's datestamp.</field>
    </struct>

    <struct name="DateTime" comment="Generic structure for date-time management.">
      <field name="Year" type="INT16">Year</field>
      <field name="Month" type="BYTE">Month 1 to 12</field>
      <field name="Day" type="BYTE">Day 1 to 31</field>
      <field name="Hour" type="BYTE">Hour 0 to 23</field>
      <field name="Minute" type="BYTE">Minute 0 to 59</field>
      <field name="Second" type="BYTE">Second 0 to 59</field>
      <field name="TimeZone" type="BYTE">TimeZone -13 to +13</field>
    </struct>

    <struct name="DirInfo" comment="Used by OpenDir() only">
      <field name="Info" type="struct FileInfo *">Pointer to a <st>FileInfo</st> structure</field>
    </struct>

    <struct name="Edges" comment="Generic structure for declaring edge coordinates.">
      <field name="Left" type="INT">Left-most coordinate</field>
      <field name="Top" type="INT">Top coordinate</field>
      <field name="Right" type="INT">Right-most coordinate</field>
      <field name="Bottom" type="INT">Bottom coordinate</field>
    </struct>

    <struct name="FRGB" comment="32-bit floating point RGB colour components.">
      <field name="Red" type="FLOAT">Red component value</field>
      <field name="Green" type="FLOAT">Green component value</field>
      <field name="Blue" type="FLOAT">Blue component value</field>
      <field name="Alpha" type="FLOAT">Alpha component value</field>
    </struct>

    <struct name="Field" comment="Used to describe the public fields of a class.">
      <field name="Arg" type="MAXINT">An option to complement the field type.  Can be a pointer or an integer value</field>
      <field name="GetValue" type="FUNCTION *" prototype="ERR (*GetValue)(APTR, APTR)">A virtual function that will retrieve the value for this field.</field>
      <field name="SetValue" type="APTR">A virtual function that will set the value for this field.</field>
      <field name="WriteValue" type="FUNCTION *" prototype="ERR (*WriteValue)(OBJECTPTR, struct Field *, int, const void *, int)">An internal function for writing to this field.</field>
      <field name="Name" type="CSTRING">The English name for the field, e.g. <code>Width</code></field>
      <field name="FieldID" type="UINT">Provides a fast way of finding fields, e.g. <code>FID_Width</code></field>
      <field name="Offset" type="UINT16">Field offset within the object</field>
      <field name="Index" type="UINT16">Field array index</field>
      <field name="Flags" type="UINT">Special flags that describe the field</field>
    </struct>

    <struct name="FieldArray" comment="Used to construct class blueprints for the MetaClass.">
      <field name="Name" type="CSTRING">The name of the field, e.g. <code>Width</code></field>
      <field name="GetField" type="APTR"><code>void GetField(*Object, APTR Result);</code></field>
      <field name="SetField" type="APTR"><code>ERR SetField(*Object, APTR Value);</code></field>
      <field name="Arg" type="MAXINT">Can be a pointer or an integer value</field>
      <field name="Flags" type="UINT">Special flags that describe the field</field>
    </struct>

    <struct name="FieldDef" comment="Used to define constants for field references.">
      <field name="Name" type="CSTRING">The name of the constant.</field>
      <field name="Value" type="INT">The value of the constant.</field>
    </struct>

    <struct name="FileFeedback">
      <field name="Size" type="INT64">Size of the file</field>
      <field name="Position" type="INT64">Current seek position within the file if moving or copying</field>
      <field name="Path" type="STRING">Path to the file</field>
      <field name="Dest" type="STRING">Destination file/path if moving or copying</field>
      <field name="FeedbackID" type="FBK" lookup="FBK">Set to one of the <code>FBK</code> values</field>
      <field name="Reserved" type="BYTE" size="32">Reserved in case of future expansion</field>
    </struct>

    <struct name="FileInfo" comment="Metadata for describing a file.">
      <field name="Size" type="INT64">The size of the file's content.</field>
      <field name="TimeStamp" type="INT64">64-bit time stamp - usable only for comparison (e.g. sorting).</field>
      <field name="Next" type="struct FileInfo *">Next structure in the list, or <code>NULL</code>.</field>
      <field name="Name" type="STRING">The name of the file.</field>
      <field name="Flags" type="RDF" lookup="RDF">Additional flags to describe the file.</field>
      <field name="Permissions" type="PERMIT" lookup="PERMIT">Standard permission flags.</field>
      <field name="UserID" type="INT">User  ID (Unix systems only).</field>
      <field name="GroupID" type="INT">Group ID (Unix systems only).</field>
      <field name="Created" type="struct DateTime">The date/time of the file's creation.</field>
      <field name="Modified" type="struct DateTime">The date/time of the last file modification.</field>
    </struct>

    <struct name="Function" comment="Function list array structure">
      <field name="Address" type="APTR">Pointer to the function entry point</field>
      <field name="Name" type="CSTRING">Name of the function</field>
      <field name="Args" type="const struct FunctionField *">A list of parameters accepted by the function</field>
    </struct>

    <struct name="FunctionField" comment="Used by ActionTable and Function structures to declare lists of parameters.">
      <field name="Name" type="CSTRING">Name of the field</field>
      <field name="Type" type="UINT">Type of the field</field>
    </struct>

    <struct name="HSV" comment="Colour structure for Hue, Saturation and Value/Light components.">
      <field name="Hue" type="DOUBLE">Between 0 and 359.999</field>
      <field name="Saturation" type="DOUBLE">Between 0 and 1.0</field>
      <field name="Value" type="DOUBLE">Between 0 and 1.0.  Corresponds to Value, Lightness or Brightness</field>
      <field name="Alpha" type="DOUBLE">Alpha blending value from 0 to 1.0.</field>
    </struct>

    <struct name="InputEvent">
      <field name="Next" type="const struct InputEvent *">Next event in the chain</field>
      <field name="Value" type="DOUBLE">The value associated with the Type</field>
      <field name="Timestamp" type="INT64">PreciseTime() of the recorded input</field>
      <field name="RecipientID" type="OBJECTID">Surface that the input message is being conveyed to</field>
      <field name="OverID" type="OBJECTID">Surface that is directly under the mouse pointer at the time of the event</field>
      <field name="AbsX" type="DOUBLE">Absolute horizontal position of mouse cursor (relative to the top left of the display)</field>
      <field name="AbsY" type="DOUBLE">Absolute vertical position of mouse cursor (relative to the top left of the display)</field>
      <field name="X" type="DOUBLE">Horizontal position relative to the surface that the pointer is over - unless a mouse button is held or pointer is anchored - then the coordinates are relative to the click-held surface</field>
      <field name="Y" type="DOUBLE">Vertical position relative to the surface that the pointer is over - unless a mouse button is held or pointer is anchored - then the coordinates are relative to the click-held surface</field>
      <field name="DeviceID" type="OBJECTID">The hardware device that this event originated from</field>
      <field name="Type" type="JET" lookup="JET">JET constant that describes the event</field>
      <field name="Flags" type="JTYPE" lookup="JTYPE">Broad descriptors for the given <code>Type</code> (see <code>JTYPE</code> flags).  Automatically defined when delivered to the pointer object</field>
      <field name="Mask" type="JTYPE" lookup="JTYPE">Mask to use for checking against subscribers</field>
    </struct>

    <struct name="MemInfo" typeName="MEMINFO">
      <field name="Start" type="APTR">The starting address of the memory block (does not apply to shared blocks).</field>
      <field name="ObjectID" type="OBJECTID">The object that owns the memory block.</field>
      <field name="Size" type="UINT">The size of the memory block.</field>
      <field name="Flags" type="MEM" lookup="MEM">The type of memory.</field>
      <field name="MemoryID" type="MEMORYID">The unique ID for this block.</field>
      <field name="AccessCount" type="INT16">Total number of active locks on this block.</field>
    </struct>

    <struct name="Message" comment="Message header.">
      <field name="Time" type="INT64">A timestamp acquired from <function module="Core">PreciseTime</function> when the message was first passed to <function module="Core">SendMessage</function>.</field>
      <field name="UID" type="INT">A unique identifier automatically created by <function module="Core">SendMessage</function>.</field>
      <field name="Type" type="MSGID" lookup="MSGID">A message type identifier as defined by the client.</field>
      <field name="Size" type="INT">The byte-size of the message data, or zero if no data is provided.</field>
    </struct>

    <struct name="ObjectSignal" comment="Required in calls to WaitForObjects().">
      <field name="Object" type="OBJECTPTR">Reference to an object to monitor.</field>
    </struct>

    <struct name="RGB16" comment="16-bit RGB colour value.">
      <field name="Red" type="UINT16">Red component value</field>
      <field name="Green" type="UINT16">Green component value</field>
      <field name="Blue" type="UINT16">Blue component value</field>
      <field name="Alpha" type="UINT16">Alpha component value</field>
    </struct>

    <struct name="RGB32" comment="32-bit RGB colour value.">
      <field name="Red" type="UINT">Red component value</field>
      <field name="Green" type="UINT">Green component value</field>
      <field name="Blue" type="UINT">Blue component value</field>
      <field name="Alpha" type="UINT">Alpha component value</field>
    </struct>

    <struct name="RGB8" comment="8-bit RGB colour value." typeName="RGB8">
      <field name="Red" type="UBYTE">Red component value</field>
      <field name="Green" type="UBYTE">Green component value</field>
      <field name="Blue" type="UBYTE">Blue component value</field>
      <field name="Alpha" type="UBYTE">Alpha component value</field>
    </struct>

    <struct name="RGBPalette">
      <field name="AmtColours" type="INT">Total colours</field>
      <field name="Col" type="struct RGB8" size="256">RGB Palette</field>
    </struct>

    <struct name="SystemState" comment="Returned by the GetSystemState() function.">
      <field name="Platform" type="CSTRING">String-based field indicating the user's platform.  Currently returns <code>Native</code>, <code>Windows</code>, <code>OSX</code> or <code>Linux</code>.</field>
      <field name="ConsoleFD" type="HOSTHANDLE">Internal</field>
      <field name="Stage" type="INT">The current operating stage.  <code>-1</code> = Initialising, <code>0</code> indicates normal operating status; <code>1</code> means that the program is shutting down; <code>2</code> indicates a program restart; <code>3</code> is for mode switches.</field>
    </struct>

    <struct name="Unit">
      <field name="Value" type="DOUBLE">The unit value.</field>
      <field name="Type" type="UINT">Additional type information</field>
    </struct>

    <struct name="dcAudio" comment="Data feed structure for Audio">
      <field name="Size" type="INT">Byte size of this structure</field>
      <field name="Format" type="INT">Format of the audio data</field>
    </struct>

    <struct name="dcDeviceInput">
      <field name="Values" type="DOUBLE" size="2">The value(s) associated with the Type</field>
      <field name="Timestamp" type="INT64"><function module="Core">PreciseTime</function> of the recorded input</field>
      <field name="DeviceID" type="OBJECTID">The hardware device that this event originated from (note: This ID can be to a private/inaccessible object, the point is that the ID is unique)</field>
      <field name="Flags" type="JTYPE" lookup="JTYPE">Broad descriptors for the given <code>Type</code>.  Automatically defined when delivered to the pointer object</field>
      <field name="Type" type="JET" lookup="JET"><code>JET</code> constant</field>
    </struct>

    <struct name="dcKeyEntry" comment="Data feed structure for Keypress">
      <field name="Flags" type="INT">Shift/Control/CapsLock...</field>
      <field name="Value" type="INT">ASCII value of the key A/B/C/D...</field>
      <field name="Timestamp" type="INT64"><function module="Core">PreciseTime</function> at which the keypress was recorded</field>
      <field name="Unicode" type="INT">Unicode value for pre-calculated key translations</field>
    </struct>

    <struct name="dcRequest" comment="Data feed item request">
      <field name="Item" type="INT">Identifier for retrieval from the source</field>
      <field name="Preference" type="BYTE" size="4">Data preferences for the returned item(s)</field>
    </struct>

  </structs>
</book>
