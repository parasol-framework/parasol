<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="module.xsl"?>

<book>
  <info>
    <name>Core</name>
    <type>module</type>
    <copyright>Paul Manias 1996-2023</copyright>
    <classes>
      <class>CompressedStream</class>
      <class>Compression</class>
      <class>Config</class>
      <class>File</class>
      <class>MetaClass</class>
      <class>Module</class>
      <class>Script</class>
      <class>StorageDevice</class>
      <class>Task</class>
      <class>Thread</class>
      <class>Time</class>
    </classes>
    <categories>
      <category>Events</category>
      <category>Fields</category>
      <category>Files</category>
      <category>Locks</category>
      <category>Memory</category>
      <category>Messages</category>
      <category>Objects</category>
      <category>Strings</category>
      <category>System</category>
      <category>Unicode</category>
    </categories>
  </info>

  <function>
    <name>AccessMemory</name>
    <category>Memory</category>
    <comment>Grants access to memory blocks by identifier.</comment>
    <prototype>ERROR AccessMemory(MEMORYID Memory, LONG Flags, LONG MilliSeconds, APTR * Result)</prototype>
    <input>
      <param type="MEMORYID" name="Memory">The ID of the memory block that you want to access.</param>
      <param type="LONG" name="Flags" lookup="MEM">Set to MEM_READ, MEM_WRITE or MEM_READ_WRITE according to requirements.</param>
      <param type="LONG" name="MilliSeconds">The millisecond interval to wait before a timeout occurs.  Do not set below 40ms for consistent operation.</param>
      <param type="APTR *" name="Result">Must point to an APTR variable that will store the resolved address.</param>
    </input>
    <description>
<p>Call AccessMemory() to resolve a memory ID to its address and acquire a lock so that it is inaccessible to other threads.</p>
<p>Memory blocks should never be locked for extended periods of time.  Ensure that all locks are matched with a call to <function module="Core">ReleaseMemory</function> within the same code block.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="Args">Invalid arguments passed to function.</error>
      <error code="LockFailed">Failed to lock a required resource.</error>
      <error code="TimeOut">Function timed-out before successful completion.</error>
      <error code="MarkedForDeletion">A resource cannot be accessed as it is marked for deletion.</error>
      <error code="MemoryDoesNotExist">Memory block does not exist.</error>
      <error code="DeadLock">Dead-lock detected - procedure aborted.</error>
      <error code="SystemLocked">Part of the system is unreachable due to a persistent lock.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>AccessObject</name>
    <category>Objects</category>
    <comment>Grants exclusive access to objects via unique ID.</comment>
    <prototype>ERROR AccessObject(OBJECTID Object, LONG MilliSeconds, OBJECTPTR * Result)</prototype>
    <input>
      <param type="OBJECTID" name="Object">The unique ID of the target object.</param>
      <param type="LONG" name="MilliSeconds">The limit in milliseconds before a timeout occurs.  The maximum limit is 60000, and 100 is recommended.</param>
      <param type="OBJECTPTR *" name="Result">A pointer storage variable that will store the resulting object address.</param>
    </input>
    <description>
<p>This function resolves an object ID to its address and acquires a lock on the object so that other threads cannot use it simultaneously.</p>
<p>If the object is already locked, it will wait until the object becomes available.   This must occur within the amount of time specified in the Milliseconds parameter.  If the time expires, the function will return with an <code>ERR_TimeOut</code> error code.  If successful, <code>ERR_Okay</code> is returned and a reference to the object's address is stored in the Result variable.</p>
<p>It is crucial that calls to AccessObject() are followed with a call to <function module="Core">ReleaseObject</function> once the lock is no longer required.  Calls to AccessObject() will also nest, so they must be paired with <function module="Core">ReleaseObject</function> correctly.</p>
<p>It is recommended that C++ developers use the <code>ScopedObjectLock</code> class to acquire object locks rather than making direct calls to AccessObject().  The following example illustrates lock acquisition within a 1 second time limit:</p>
<pre>{
   pf::ScopedObjectLock<OBJECTPTR> obj(my_object_id, 1000);
   if (lock.granted()) {
      obj.acDraw();
   }
}
</OBJECTPTR>
</pre>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="TimeOut">Function timed-out before successful completion.</error>
      <error code="MarkedForDeletion">A resource cannot be accessed as it is marked for deletion.</error>
      <error code="MissingClass">The class could not be found in the system.</error>
      <error code="NoMatchingObject">No matching object was found for the given object ID.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>Action</name>
    <category>Objects</category>
    <comment>This function is responsible for executing action routines.</comment>
    <prototype>ERROR Action(LONG Action, OBJECTPTR Object, APTR Parameters)</prototype>
    <input>
      <param type="LONG" name="Action" lookup="AC">An action or method ID must be specified here (e.g. AC_Query).</param>
      <param type="OBJECTPTR" name="Object">A pointer to the object that is going to perform the action.</param>
      <param type="APTR" name="Parameters">If the action or method is documented as taking parameters, point to the relevant parameter structure here.</param>
    </input>
    <description>
<p>This function is the key entry point for executing actions and method routines.  An action is a predefined function call that can be called on any object, while a method is a function call that is specific to a class implementation. You can find a complete list of available actions and their associated details in the Action List document. The actions and methods supported by any class will be referenced in their auto-generated documentation.</p>
<p>Here are two examples that demonstrate how to make an action call.  The first performs an activation, which does not require any additional arguments.  The second performs a move operation, which requires three additional arguments to be passed to the Action() function:</p>
<pre>1. Action(AC_Activate, Picture, NULL);

2. struct acMove move = { 30, 15, 0 };
   Action(AC_Move, Window, &amp;move);
</pre>
<p>In all cases, action calls in C++ can be simplified by using their corresponding helper functions:</p>
<pre>1.  acActivate(Picture);

2a. acMove(Window, 30, 15, 0);

2b. Window-&gt;move(30, 15, 0);
</pre>
<p>If the class of an object does not support the action ID, an error code of <code>ERR_NoSupport</code> is returned.  To test an object to see if its class supports an action, use the <function module="Core">CheckAction</function> function.</p>
<p>In circumstances where an object ID is known without its pointer, the use of <function module="Core">ActionMsg</function> or <function module="Core">QueueAction</function> may be desirable to avoid acquiring an object lock.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="NoAction">The object does not support this operation.</error>
      <error code="IllegalActionID">Illegal action ID (number outside of valid range).</error>
      <error code="ObjectCorrupt">The object structure is corrupt or has not been initialised.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>ActionList</name>
    <category>Objects</category>
    <comment>Returns a pointer to the global action table.</comment>
    <prototype>void ActionList(struct ActionTable ** Actions, LONG * Size)</prototype>
    <input>
      <param type="struct ActionTable **" name="Actions">A pointer to the Core's action table (struct ActionTable *) is returned. Please note that the first entry in the ActionTable list has all fields driven to NULL, because valid action ID's start from one, not zero.  The final action in the list is also terminated with NULL fields in order to indicate an end to the list.  Knowing this is helpful when scanning the list or calculating the total number of actions supported by the Core.</param>
      <param type="LONG *" name="Size">Total number of elements in the returned list.</param>
    </input>
    <description>
<p>This function returns an array of all actions supported by the Core, including name, arguments and structure size.  The ID of each action is indicated by its index within the array.</p>
<p>The Name field specifies the name of the action.  The Args field refers to the action's argument definition structure, which lists the argument names and their relevant types.  This is matched by the Size field, which indicates the byte-size of the action's related argument structure.  If the action does not support arguments, the Args and Size fields will be set to NULL.  The following illustrates two argument definition examples:</p>
<pre>struct FunctionField argsCopyData[] = {
   { "Destination", FD_LONG  },
   { NULL, 0 }
};

struct FunctionField argsResize[] = {
   { "Width",  FD_DOUBLE },
   { "Height", FD_DOUBLE },
   { "Depth",  FD_DOUBLE },
   { NULL, 0 }
};
</pre>
<p>The argument types that can be used by actions are limited to those listed in the following table:</p>
<types lookup="FD">
<type name="LONG">A 32-bit integer value ranging from -2,147,483,647 to 2,147,483,648.</type>
<type name="LARGE">A 64-bit integer value.</type>
<type name="PTR">A standard address space pointer.</type>
<type name="STRING">A pointer to a null-terminated string.</type>
<type name="DOUBLE">A 64-bit floating point value.</type>
<type name="OBJECT">This flag is sometimes set in conjunction with the FD_LONG type.  It indicates that the argument refers to an object ID.</type>
<type name="PTRSIZE">This argument type can only be used if it follows an FD_PTR type, and if the argument itself is intended to reflect the size of the buffer referred to by the previous FD_PTR argument.</type>
<type name="RESULT">This special flag is set in conjunction with the other data-based argument types. Example: If the developer is required to supply a pointer to a LONG field in which the function will store a result, the correct argument definition will be FD_RESULT|FD_LONG|FD_PTR. To make the definition of these argument types easier, FD_PTRRESULT and FD_LONGRESULT macros are also available for use.</type>
</types>
    </description>
  </function>

  <function>
    <name>ActionMsg</name>
    <category>Objects</category>
    <comment>Execute an action or method by way of object ID.</comment>
    <prototype>ERROR ActionMsg(LONG Action, OBJECTID Object, APTR Args)</prototype>
    <input>
      <param type="LONG" name="Action">The ID of the action or method to be executed.</param>
      <param type="OBJECTID" name="Object">The target object.</param>
      <param type="APTR" name="Args">The parameter structure required by Action.</param>
    </input>
    <description>
<p>Use ActionMsg() to execute an action when only the object ID is known.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="Failed">General failure.</error>
      <error code="OutOfRange">A specified number is outside of the valid range.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>ActionThread</name>
    <category>Objects</category>
    <comment>Execute an action in parallel, via a separate thread.</comment>
    <prototype>ERROR ActionThread(LONG Action, OBJECTPTR Object, APTR Args, FUNCTION * Callback, LONG Key)</prototype>
    <input>
      <param type="LONG" name="Action" lookup="AC">An action or method ID must be specified here.</param>
      <param type="OBJECTPTR" name="Object">A pointer to the object that is going to perform the action.</param>
      <param type="APTR" name="Args">If the action or method is documented as taking parameters, point to the relevant parameter structure here.  Pre-defined parameter structures are obtained from the "system/actions.h" include file.</param>
      <param type="FUNCTION *" name="Callback">This function will be called after the thread has finished executing the action.</param>
      <param type="LONG" name="Key">An optional key value to be passed to the callback routine.</param>
    </input>
    <description>
<p>This function follows the same principles of execution as the Action() function, with the difference of executing the action in parallel via a dynamically allocated thread.  Please refer to the <function module="Core">Action</function> function for general information on action execution.</p>
<p>To receive feedback of the action's completion, use the Callback parameter and supply a function.  The function prototype for the callback routine is <code>callback(ACTIONID ActionID, OBJECTPTR Object, ERROR Error, LONG Key)</code></p>
<p>It is crucial that the target object is not destroyed while the thread is executing.  Use the Callback routine to receive notification of the thread's completion and then free the object if desired.  The callback will be processed in the next call to <function module="Core">ProcessMessages</function>, so as to maintain an orderly execution process within the application.</p>
<p>The 'Error' parameter in the callback reflects the error code returned by the action after it has been called.  Note that if ActionThread() fails, the callback will never be executed because the thread attempt will have been aborted.</p>
<p>Please note that there is some overhead involved when safely initialising and executing a new thread.  This function is at its most effective when used to perform lengthy processes such as the loading and parsing of data.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="Init">Error in Init()ialising an object.</error>
      <error code="IllegalMethodID">Illegal method ID (number outside of valid range).</error>
      <error code="MissingClass">The class could not be found in the system.</error>
      <error code="NewObject">A call to NewObject() failed to produce a new object.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>AddInfoTag</name>
    <category>Files</category>
    <comment>Adds new tags to FileInfo structures.</comment>
    <prototype>ERROR AddInfoTag(struct FileInfo * Info, CSTRING Name, CSTRING Value)</prototype>
    <input>
      <param type="struct FileInfo *" name="Info">Pointer to a valid FileInfo structure.</param>
      <param type="CSTRING" name="Name">The name of the tag.</param>
      <param type="CSTRING" name="Value">The value to associate with the tag name.  If NULL, any existing tag with a matching Name will be removed.</param>
    </input>
    <description>
<p>This function adds file tags to FileInfo structures.  It is intended for use by the FileSystem module and related drivers only.  Tags allow extended attributes to be associated with a file, for example the number of seconds of audio in an MP3 file.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>AddMsgHandler</name>
    <category>Messages</category>
    <comment>Adds a new message handler for processing incoming messages.</comment>
    <prototype>ERROR AddMsgHandler(APTR Custom, LONG MsgType, FUNCTION * Routine, struct MsgHandler ** Handle)</prototype>
    <input>
      <param type="APTR" name="Custom">A custom pointer that will be passed to the message handler when messages are received.</param>
      <param type="LONG" name="MsgType">The message type that the handler wishes to intercept.  If zero, all incoming messages are passed to the handler.</param>
      <param type="FUNCTION *" name="Routine">Refers to the function that will handle incoming messages.</param>
      <param type="struct MsgHandler **" name="Handle">The resulting handle of the new message handler - this will be needed for FreeResource().</param>
    </input>
    <description>
<p>This function allows handlers to be added for the interception of incoming messages.  Message handling works as follows:</p>
<p>During a call to <function module="Core">ProcessMessages</function>, each incoming message will be scanned to determine if a message handler is able to process that message.  All handlers that accept the message type will be called with a copy of the message structure and any additional data.  The message is then removed from the message queue.</p>
<p>When calling AddMsgHandler(), you can provide an optional Custom pointer that will have meaning to the handler.  The MsgType acts as a filter so that only messages with the same type identifier will be passed to the handler.  The Routine parameter must point to the function handler, which will follow this definition:</p>
<pre>ERROR handler(APTR Custom, LONG MsgID, LONG MsgType, APTR Message, LONG MsgSize)</pre>
<p>The handler must return <code>ERR_Okay</code> if the message was handled.  This means that the message will not be passed to message handlers that are yet to receive the message.  Throw <code>ERR_NothingDone</code> if the message has been ignored or <code>ERR_Continue</code> if the message was processed but may be analysed by other handlers.  Throw <code>ERR_Terminate</code> to break the current ProcessMessages() loop.  When using Fluid, this is best achieved by writing <code>check(errorcode)</code> in the handler.</p>
<p>The handler will be identified by a unique pointer returned in the Handle parameter.  This handle will be garbage collected or can be passed to <function module="Core">FreeResource</function> once it is no longer required.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="AllocMemory">A call to AllocMemory() failed to create a new memory block.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>AdjustLogLevel</name>
    <category>System</category>
    <comment>Adjusts the base-line of all log messages.</comment>
    <prototype>LONG AdjustLogLevel(LONG Adjust)</prototype>
    <input>
      <param type="LONG" name="Adjust">The level of adjustment to make to new log messages.  Zero is the default (no change).  The maximum level is 6.</param>
    </input>
    <description>
<p>This function adjusts the detail level of all messages that are sent to the program log via <function module="Core">LogF</function>.  To illustrate by example, setting the Adjust value to 1 would result in level 5 log messages being raised to level 6.  If the user's maximum log level output is 5, such messages would no longer appear in the log until the base-line is reduced to normal.</p>
<p>The main purpose of AdjustLogLevel() is to reduce log noise.  For instance, creating a new desktop window will result in a large number of new log messages.  Raising the base-line by 2 before creating the window would be a reasonable means of eliminating that noise if the user has the log level set to 5 (debug).  If there is a need to see the mesages, re-running the program with a deeper log level of 7 or more would make them visible.</p>
<p>Adjustments to the base-line are accumulative, so small increments of 1 or 2 are encouraged.  To revert logging to the previous base-line, call this function again with a negation of the previously passed value.</p>
    </description>
    <result type="LONG">Returns the absolute base-line value that was active prior to calling this function.</result>
  </function>

  <function>
    <name>AllocMemory</name>
    <category>Memory</category>
    <comment>Allocates a new memory block on the heap.</comment>
    <prototype>ERROR AllocMemory(LONG Size, LONG Flags, APTR * Address, MEMORYID * ID)</prototype>
    <input>
      <param type="LONG" name="Size">The size of the memory block.</param>
      <param type="LONG" name="Flags" lookup="MEM">Optional flags.</param>
      <param type="APTR *" name="Address">Set this argument to refer to an APTR type to store an address reference to the allocated memory block.</param>
      <param type="MEMORYID *" name="ID">Set this argument to refer to a MEMORYID type to store a unique ID reference to the allocated memory block.</param>
    </input>
    <description>
<p>The AllocMemory() function will allocate a new block of memory on the program's heap.  The client will need to define the minimum byte Size, optional Flags and a variable to store the resulting Address and/or ID of the memory block. Here is an example:</p>
<pre>
APTR address;
if (!AllocMemory(1000, MEM_DATA, &amp;address, NULL)) {
   ...
   FreeResource(address);
}
</pre>
<p>A number of flag definitions are available that affect the memory allocation process.  They are:</p>
<types lookup="MEM"/>
<p>Notice that memory allocation can be returned as an address pointer and/or as a unique memory ID.  Typically a private address with no ID reference is sufficient.</p>
<p>If the client retrieves both the ID and Address pointer, an internal call will be made to <function module="Core">AccessMemory</function> to lock the memory block.  This means that before freeing the memory block the client must call <function module="Core">ReleaseMemory</function> to unlock it. Blocks that are persistently locked will remain in memory until the process is terminated.</p>
<p>Memory that is allocated through AllocMemory() is automatically cleared with zero-byte values.  When allocating large blocks it may be wise to turn off this feature, achieved by setting the <code>MEM_NO_CLEAR</code> flag.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="Failed">General failure.</error>
      <error code="Args">Invalid arguments passed to function.</error>
      <error code="SystemCorrupt">The operating system has been badly corrupted.</error>
      <error code="ArrayFull">Array has reached capacity and cannot be expanded.</error>
      <error code="AccessMemory">Access to a shared memory block was denied.</error>
    </result>
  </function>

  <function>
    <name>AllocMutex</name>
    <category>Locks</category>
    <comment>Allocate a mutex suitable for managing synchronisation between threads.</comment>
    <prototype>ERROR AllocMutex(ALF Flags, APTR * Result)</prototype>
    <input>
      <param type="ALF" name="Flags" lookup="ALF">Optional flags.</param>
      <param type="APTR *" name="Result">A reference to the new mutex will be returned in this variable if the call succeeds.</param>
    </input>
    <description>
<p>This function allocates a mutex that is suitable for keeping threads synchronised (inter-process synchronisation is not supported).  Mutexes are locked and unlocked using the <function module="Core">LockMutex</function> and <function module="Core">UnlockMutex</function> functions.</p>
<p>The underlying implementation is dependent on the host platform.  In Microsoft Windows, critical sections will be used and may nest (<code>ALF::RECURSIVE</code> always applies).  Unix systems employ pthread mutexes and will only nest if the <code>ALF::RECURSIVE</code> option is specified.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="AllocMemory">A call to AllocMemory() failed to create a new memory block.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>AllocSharedMutex</name>
    <category>Locks</category>
    <comment>Allocate a mutex suitable for managing synchronisation between processes.</comment>
    <prototype>ERROR AllocSharedMutex(CSTRING Name, APTR * Mutex)</prototype>
    <input>
      <param type="CSTRING" name="Name">A unique identifier for the mutex, expressed as a string.</param>
      <param type="APTR *" name="Mutex">A reference to the new mutex will be returned in this variable.</param>
    </input>
    <description>
<p>This function allocates a mutex that is suitable for keeping both processes and threads synchronised.  Shared mutexes are named, which allows other processes to find them.  It is recommended that names consist of random characters so as to limit the potential for cross-contamination with other programs.</p>
<p>Mutexes are locked and unlocked using the <function module="Core">LockSharedMutex</function> and <function module="Core">UnlockSharedMutex</function> functions.  Shared mutexes carry a speed penalty in comparison to private mutexes, and therefore should only be used as circumstances dictate.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="AllocMemory">A call to AllocMemory() failed to create a new memory block.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>AllocateID</name>
    <category>System</category>
    <comment>Generates unique ID's for general purposes.</comment>
    <prototype>LONG AllocateID(IDTYPE Type)</prototype>
    <input>
      <param type="IDTYPE" name="Type" lookup="IDTYPE">The type of ID that is required.</param>
    </input>
    <description>
<p>This function generates unique ID's that can be used in other Core functions.  A type ID is required and the resulting number will be unique to that type only.</p>
<p>ID allocations are permanent, so there is no need to free the allocated ID once it is no longer required.</p>
    </description>
    <result type="LONG">A unique ID matching the requested type will be returned.  This function can return zero if the Type is unrecognised, or if an internal error occurred.</result>
  </function>

  <function>
    <name>AnalysePath</name>
    <category>Files</category>
    <comment>Analyses paths to determine their type (file, folder or volume).</comment>
    <prototype>ERROR AnalysePath(CSTRING Path, LOC * Type)</prototype>
    <input>
      <param type="CSTRING" name="Path">The path to analyse.</param>
      <param type="LOC *" name="Type" lookup="LOC">The result will be stored in the LONG variable referred to by this argument.  The return types are DIRECTORY, FILE and VOLUME.  You can set this argument to NULL if you are only interested in checking if the file exists.</param>
    </input>
    <description>
<p>This function will analyse a path and determine the type of file that the path is referring to.  For instance, a path of <code>user:documents/</code> would indicate a folder reference.  A path of <code>system:</code> would be recognised as a volume. A path of <code>user:documents/copyright.txt</code> would be recognised as a file.</p>
<p>Ambiguous references are analysed to get the correct type - for example <code>user:documents/helloworld</code> could refer to a folder or file, so the path is analysed to check the file type.  On exceptional occasions where the path could be interpreted as either a folder or a file, preference is given to the folder.</p>
<p>File path approximation is supported if the Path is prefixed with a <code>~</code> character (e.g. <code>~pictures:photo</code> could be matched to <code>photo.jpg</code> in the same folder).</p>
<p>To check if a volume name is valid, call <function module="Core">ResolvePath</function> first and then pass the resulting path to this function.</p>
<p>If the queried path does not exist, a fail code is returned.  This behaviour makes the AnalysePath() function a good candidate for testing the validity of a path string.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="DoesNotExist">Resource does not exist.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>Base64Decode</name>
    <category>Strings</category>
    <comment>Decodes a base 64 string to its binary form.</comment>
    <prototype>ERROR Base64Decode(struct pfBase64Decode * State, CSTRING Input, LONG InputSize, APTR Output, LONG * Written)</prototype>
    <input>
      <param type="struct pfBase64Decode *" name="State">Pointer to an pfBase64Decode structure, initialised to zero.</param>
      <param type="CSTRING" name="Input">A base 64 input string.  The pointer will be updated when the function returns.</param>
      <param type="LONG" name="InputSize">The size of the input string.</param>
      <param type="APTR" name="Output">The output buffer.  The size of the buffer must be greater or equal to the size of Input.</param>
      <param type="LONG *" name="Written">The total number of bytes written to Output is returned here.</param>
    </input>
    <description>
<p>This function will decode a base 64 string to its binary form.  It is designed to support streaming from the source Input and gracefully handles buffer over-runs by forwarding data to the next call.</p>
<p>To use this function effectively, call it repeatedly in a loop until all of the input is exhausted.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="Args">Invalid arguments passed to function.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>Base64Encode</name>
    <category>Strings</category>
    <comment>Encodes a binary source into a base 64 string.</comment>
    <prototype>LONG Base64Encode(struct pfBase64Encode * State, const void * Input, LONG InputSize, STRING Output, LONG OutputSize)</prototype>
    <input>
      <param type="struct pfBase64Encode *" name="State">Pointer to an pfBase64Decode structure, initialised to zero.</param>
      <param type="const void *" name="Input">The binary data to encode.</param>
      <param type="LONG" name="InputSize">The amount of data to encode.  Set to zero to finalise the output.</param>
      <param type="STRING" name="Output">Destination buffer for the encoded output.</param>
      <param type="LONG" name="OutputSize">Size of the destination buffer.  Must be at least (InputSize * 4 / 3) + 1.</param>
    </input>
    <description>
<p>This is a state-based function that will encode raw data and output it as base-64 encoded text.  To use, the State structure must initially be set to zero (automatic if using C++).  Call this function repeatedly with new Input data and it will be written to the supplied Output pointer.  Once all incoming data has been consumed, call this function a final time with an Input of NULL and InputSize of zero.</p>
<p>It is required that the Output is sized to at least <code>(4 / 3) + 1</code> of InputSize when encoding.  For the final output, the size must be at least 6 bytes.</p>
    </description>
    <result type="LONG">The total number of bytes output is returned.</result>
  </function>

  <function>
    <name>BroadcastEvent</name>
    <category>Events</category>
    <comment>Broadcast an event to all event listeners in the system.</comment>
    <prototype>ERROR BroadcastEvent(APTR Event, LONG EventSize)</prototype>
    <input>
      <param type="APTR" name="Event">Pointer to an event structure.</param>
      <param type="LONG" name="EventSize">The size of the Event structure, in bytes.</param>
    </input>
    <description>
<p>Use BroadcastEvent() to broadcast an event to all listeners for that event in the system.  An Event structure is required that must start with a 64-bit EventID acquired from <function module="Core">GetEventID</function>, followed by any required data that is relevant to that event.  The C/C++ template is as follows:</p>
<pre>typedef struct rkEvent {
   EVENTID EventID;
   // Data follows
} rkEvent;
</pre>
<p>This document does not describe the available system events.  For more information about them, please refer to the System Events Reference manual.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>CheckAction</name>
    <category>Objects</category>
    <comment>Checks objects to see whether or not they support certain actions.</comment>
    <prototype>ERROR CheckAction(OBJECTPTR Object, LONG Action)</prototype>
    <input>
      <param type="OBJECTPTR" name="Object">The target object.</param>
      <param type="LONG" name="Action">A registered action ID.</param>
    </input>
    <description>
<p>This function checks if an object's class supports a given action or method ID.  For instance:</p>
<pre>if (!CheckAction(pic, AC_Query)) {
   // The Query action is supported.
}
</pre>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="False">The result is false.</error>
      <error code="LostClass">The object has lost its class reference.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>CheckMemoryExists</name>
    <category>Memory</category>
    <comment>Checks if a memory block still exists.</comment>
    <prototype>ERROR CheckMemoryExists(MEMORYID ID)</prototype>
    <input>
      <param type="MEMORYID" name="ID">The ID of the memory block that will be checked.</param>
    </input>
    <description>
<p>Use CheckMemoryExists() to confirm if a specific memory block still exists by referencing its ID.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="False">The result is false.</error>
      <error code="SystemCorrupt">The operating system has been badly corrupted.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>CheckObjectExists</name>
    <category>Objects</category>
    <comment>Checks if a particular object is still available in the system.</comment>
    <prototype>ERROR CheckObjectExists(OBJECTID Object)</prototype>
    <input>
      <param type="OBJECTID" name="Object">The object identity to verify.</param>
    </input>
    <description>
<p>The CheckObjectExists() function verifies the presence of any object created by <function module="Core">NewObject</function>.</p>
    </description>
    <result type="ERROR">
      <error code="True">Operation successful.</error>
      <error code="False">The result is false.</error>
      <error code="LockFailed">Failed to lock a required resource.</error>
    </result>
  </function>

  <function>
    <name>CompareFilePaths</name>
    <category>Files</category>
    <comment>Checks if two file paths refer to the same physical file.</comment>
    <prototype>ERROR CompareFilePaths(CSTRING PathA, CSTRING PathB)</prototype>
    <input>
      <param type="CSTRING" name="PathA">File location 1.</param>
      <param type="CSTRING" name="PathB">File location 2.</param>
    </input>
    <description>
<p>This function will test two file paths, checking if they refer to the same file in a storage device.  It uses a string comparison on the resolved path names, then attempts a second test based on an in-depth analysis of file attributes if the string comparison fails.  In the event of a match, <code>ERR_Okay</code> is returned.  All other error codes indicate a mis-match or internal failure.</p>
<p>The targeted paths do not have to refer to an existing file or folder in order to match (i.e. match on string comparison succeeds).</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="False">The result is false.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>CopyFile</name>
    <category>Files</category>
    <comment>Makes copies of folders and files.</comment>
    <prototype>ERROR CopyFile(CSTRING Source, CSTRING Dest, FUNCTION * Callback)</prototype>
    <input>
      <param type="CSTRING" name="Source">The source location.</param>
      <param type="CSTRING" name="Dest">The destination location.</param>
      <param type="FUNCTION *" name="Callback">Optional callback for receiving feedback during the operation.</param>
    </input>
    <description>
<p>This function is used to copy files and folders to new locations.  When copying folders it will do so recursively, so as to copy all sub-folders and files within the location.</p>
<p>It is important that you are aware that different types of string formatting can give different results.  The following examples illustrate:</p>
<p>Copying <code>parasol:makefile</code> to <code>parasol:documents</code> results in a file called <code>parasol:documents</code>.</p>
<p>Copying <code>parasol:makefile</code> to <code>parasol:documents/</code> results in a file called <code>parasol:documents/makefile</code>.</p>
<p>Copying <code>parasol:pictures/</code> to <code>parasol:documents/</code> results in a folder at <code>parasol:documents/pictures</code> and includes a copy of all folders and files found within the pictures folder.</p>
<p>Copying <code>parasol:pictures/</code> to <code>parasol:documents</code> results in a folder at <code>parasol:documents</code> (if the documents folder already exists, it receives additional content from the pictures folder).</p>
<p>This function will overwrite any destination file(s) that already exist.</p>
<p>The Source parameter should always clarify the type of location that is being copied.  For example if copying a folder, a forward slash must terminate the string or it will be assumed that a file is the source.</p>
<p>The Callback parameter can be set with a function that matches this prototype:</p>
<p>
<code>LONG Callback(struct FileFeedback *)</code></p>
<p>For each file that is processed during the copy operation, a <struct>FileFeedback</struct> structure is passed that describes the source file and its target.  The callback must return a constant value that can potentially affect file processing. Valid values are <code>FFR::Okay</code> (copy the file), <code>FFR::Skip</code> (do not copy the file) and <code>FFR::Abort</code> (abort the process completely and return <code>ERR_Cancelled</code> as an error code).</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="Failed">General failure.</error>
      <error code="Args">Invalid arguments passed to function.</error>
    </result>
  </function>

  <function>
    <name>CreateFolder</name>
    <category>Files</category>
    <comment>Makes new folders.</comment>
    <prototype>ERROR CreateFolder(CSTRING Path, PERMIT Permissions)</prototype>
    <input>
      <param type="CSTRING" name="Path">The location of the folder.</param>
      <param type="PERMIT" name="Permissions" lookup="PERMIT">Security permissions to apply to the created Dir(s).  Set to NULL if only the current user should have access.</param>
    </input>
    <description>
<p>This function creates new folders.  You are required to specify the full path of the new folder.  Standard permission flags can be passed to determine the new permissions to set against the newly created Dir(s).  If no permission flags are passed, only the current user will have access to the new folder (assuming that the file system supports security settings on the given media).  This function will create multiple folders if the complete path does not exist at the time of the call.</p>
<p>On Unix systems you can define the owner and group ID's for the new folder by calling the <function module="Core">SetDefaultPermissions</function> function prior to CreateFolder().</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="Failed">General failure.</error>
      <error code="NoSupport">This request is not supported.</error>
      <error code="FileExists">The destination file or folder already exists.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>CreateLink</name>
    <category>Files</category>
    <comment>Creates symbolic links on Unix file systems.</comment>
    <prototype>ERROR CreateLink(CSTRING From, CSTRING To)</prototype>
    <input>
      <param type="CSTRING" name="From">The symbolic link will be created at the location specified here.</param>
      <param type="CSTRING" name="To">The file that you are linking to is specified here.</param>
    </input>
    <description>
<p>Use the CreateLink() function to create symbolic links on Unix file systems. The link connects a new file created at From to an existing file referenced at To. The To link is allowed to be relative to the From location - for instance, you can link <code>documents:myfiles/newlink.txt</code> to <code>../readme.txt</code> or <code>folder/readme.txt</code>. The <code>..</code> path component must be used when making references to parent folders.</p>
<p>The permission flags for the link are inherited from the file that you are linking to.  If the file location referenced at From already exists as a file or folder, the function will fail with an ERR_FileExists error code.</p>
<p>This function does not automatically create folders in circumstances where new folders are required to complete the From link.  You will need to call <function module="Core">CreateFolder</function> to ensure that the necessary paths exist beforehand.  If the file referenced at To does not exist, the link will be created without error, but any attempts to open the link will fail until the target file or folder exists.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="NoSupport">This request is not supported.</error>
      <error code="Memory">General memory error.</error>
      <error code="LowCapacity">Array is at low capacity.</error>
      <error code="NoPermission">General security violation.</error>
      <error code="BufferOverflow">A buffer overflow has occurred.</error>
      <error code="FileExists">The destination file or folder already exists.</error>
      <error code="ResolvePath">A volume could not be resolved.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>CurrentContext</name>
    <category>Objects</category>
    <comment>Returns a pointer to the object that has the current context.</comment>
    <prototype>OBJECTPTR CurrentContext()</prototype>
    <description>
<p>This function returns a pointer to the object that has the current context.  Context is primarily used to manage resource allocations.  Manipulating the context is sometimes necessary to ensure that a resource is tracked to the correct object.</p>
<p>To get the parent context (technically the 'context of the current context'), use GetParentContext(), which is implemented as a macro.  This is used in method and action routines where the context of the object's caller may be needed.</p>
    </description>
    <result type="OBJECTPTR">Returns an object pointer (of which the Task has exclusive access to).  Cannot return NULL except in the initial start-up and late shut-down sequence of the Core.</result>
  </function>

  <function>
    <name>CurrentTask</name>
    <category>System</category>
    <comment>Returns the active Task object.</comment>
    <prototype>objTask * CurrentTask()</prototype>
    <description>
<p>This function returns the <class name="Task">Task</class> object of the active process.</p>
<p>If there is a legitimate circumstance where there is no current task (e.g. if the function is called during Core initialisation) then the "system task" may be returned, which has ownership of Core resources.</p>
    </description>
    <result type="objTask *">Returns a pointer to the current Task object or NULL if failure.</result>
  </function>

  <function>
    <name>DeleteFile</name>
    <category>Files</category>
    <comment>Deletes files and folders.</comment>
    <prototype>ERROR DeleteFile(CSTRING Path, FUNCTION * Callback)</prototype>
    <input>
      <param type="CSTRING" name="Path">String referring to the file or folder to be deleted.  Folders must be denoted with a trailing slash.</param>
      <param type="FUNCTION *" name="Callback">Optional callback for receiving feedback during the operation.</param>
    </input>
    <description>
<p>This function will delete a file or folder when given a valid file location.  The current user must have delete access to the given file. When deleting folders, all content will be scanned and deleted recursively. Individual deletion failures are ignored, although an error will be returned if the top-level folder still contains content on its deletion.</p>
<p>This function does not allow for the approximation of file names.  To approximate a file location, open it as a <class name="File">File</class> object or use <function module="Core">ResolvePath</function> first.</p>
<p>The Callback parameter can be set with a function that matches this prototype:</p>
<p>
<code>LONG Callback(struct FileFeedback *)</code></p>
<p>Prior to the deletion of any file, a <struct>FileFeedback</struct> structure is passed that describes the file's location.  The callback must return a constant value that can potentially affect file processing.  Valid values are <code>FFR::Okay</code> (delete the file), <code>FFR::Skip</code> (do not delete the file) and <code>FFR::Abort</code> (abort the process completely and return <code>ERR_Cancelled</code> as an error code).</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="File">File error, e.g. file not found.</error>
      <error code="FileNotFound">File not found.</error>
      <error code="NoSupport">This request is not supported.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>DeleteVolume</name>
    <category>Files</category>
    <comment>Deletes volumes from the system.</comment>
    <prototype>ERROR DeleteVolume(CSTRING Name)</prototype>
    <input>
      <param type="CSTRING" name="Name">The name of the volume.</param>
    </input>
    <description>
<p>This function deletes volume names from the system.  Once a volume is deleted, any further references to it will result in errors unless the volume is recreated.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="LockFailed">Failed to lock a required resource.</error>
      <error code="NoPermission">General security violation.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>FieldName</name>
    <category>Fields</category>
    <comment>Resolves a field ID to its registered name.</comment>
    <prototype>CSTRING FieldName(ULONG FieldID)</prototype>
    <input>
      <param type="ULONG" name="FieldID">The unique field hash to resolve.</param>
    </input>
    <description>
<p>Resolves a field identifier to its name.  For this to work successfully, the field must have been registered with the internal dictionary.  This is handled automatically when a new class is added to the system.</p>
<p>If the FieldID is not registered, the value is returned back as a hex string.  The inclusion of this feature guarantees that an empty string will never be returned.</p>
    </description>
    <result type="CSTRING">The name of the field is returned.</result>
  </function>

  <function>
    <name>FindClass</name>
    <category>Objects</category>
    <comment>Returns all class objects for a given class ID.</comment>
    <prototype>objMetaClass * FindClass(CLASSID ClassID)</prototype>
    <input>
      <param type="CLASSID" name="ClassID">A class ID such as one retrieved from <function module="Core">ResolveClassName</function>.</param>
    </input>
    <description>
<p>This function will find a specific class by ID and return its <class name="MetaClass">MetaClass</class>.  If the class is not in memory, the internal dictionary is checked to discover a module binary registered with that ID.  If this succeeds, the module is loaded into memory and the class will be returned.  In any event of failure, NULL is returned.</p>
<p>If the ID of a named class is not known, call <function module="Core">ResolveClassName</function> first and pass the resulting ID to this function.</p>
    </description>
    <result type="objMetaClass *">Returns a pointer to the MetaClass structure that has been found as a result of the search, or NULL if no matching class was found.</result>
  </function>

  <function>
    <name>FindField</name>
    <category>Fields</category>
    <comment>Finds field descriptors for any class, by ID.</comment>
    <prototype>struct Field * FindField(OBJECTPTR Object, ULONG FieldID, OBJECTPTR * Target)</prototype>
    <input>
      <param type="OBJECTPTR" name="Object">The target object.</param>
      <param type="ULONG" name="FieldID">The 'FID' number to lookup.</param>
      <param type="OBJECTPTR *" name="Target">(Optional) The object that represents the field is returned here (in case a field belongs to an integrated child object).</param>
    </input>
    <description>
<p>The FindField() function checks if an object supports a specified field by scanning its class descriptor for a FieldID. If a matching field is declared, its descriptor is returned.  For example:</p>
<pre>if (auto field = FindField(Screen, FID_Width, NULL)) {
   log.msg("The field name is \"%s\".", field-&gt;Name);
}
</pre>
<p>The resulting Field structure is immutable.</p>
<p>Note: To lookup the field definition of a MetaClass, use the <class name="MetaClass" index="FindField()">MetaClass:FindField()</class> method.</p>
    </description>
    <result type="struct Field *">Returns a pointer to the field descriptor, otherwise NULL if not found.</result>
  </function>

  <function>
    <name>FindObject</name>
    <category>Objects</category>
    <comment>Searches for objects by name.</comment>
    <prototype>ERROR FindObject(CSTRING Name, CLASSID ClassID, FOF Flags, OBJECTID * ObjectID)</prototype>
    <input>
      <param type="CSTRING" name="Name">The name of an object to search for.</param>
      <param type="CLASSID" name="ClassID">Optional.  Set to a class ID to filter the results down to a specific class type.</param>
      <param type="FOF" name="Flags" lookup="FOF">Optional flags.</param>
      <param type="OBJECTID *" name="ObjectID">An object id variable for storing the result.</param>
    </input>
    <description>
<p>The FindObject() function searches for all objects that match a given name and can filter by class.</p>
<p>The following example is a typical illustration of this function's use.  It finds the most recent object created with a given name:</p>
<pre>OBJECTID id;
FindObject("SystemPointer", ID_POINTER, 0, &amp;id);
</pre>
<p>If FindObject() cannot find any matching objects then it will return an error code.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="Search">A search routine in this function failed.</error>
      <error code="Args">Invalid arguments passed to function.</error>
      <error code="LockFailed">Failed to lock a required resource.</error>
      <error code="EmptyString">A required string value contains no characters.</error>
      <error code="DoesNotExist">Resource does not exist.</error>
    </result>
  </function>

  <function>
    <name>FreeMutex</name>
    <category>Locks</category>
    <comment>Deallocate a private mutex.</comment>
    <prototype>void FreeMutex(APTR Mutex)</prototype>
    <input>
      <param type="APTR" name="Mutex">Pointer to a mutex.</param>
    </input>
    <description>
<p>This function will deallocate a mutex.  It is vital that no thread is sleeping on the mutex at the time this function is called.  The outcome when calling this function on a mutex still in use is undefined.</p>
    </description>
  </function>

  <function>
    <name>FreeResource</name>
    <category>Memory</category>
    <comment>Frees resources originating from AllocMemory().</comment>
    <prototype>ERROR FreeResource(MEMORYID ID)</prototype>
    <input>
      <param type="MEMORYID" name="ID">The unique ID of the memory block.</param>
    </input>
    <description>
<p>This function will free any resource that originates from AllocMemory(), using its ID for identification.  C++ headers also include a variant of this function that allows a direct memory pointer to be used as the identifier (however we do recommend the use of IDs to improve memory safety).</p>
<p>In some circumstances the termination of the block will not take place immediately.  If the block is locked then it will be marked for deletion and not be collected until the lock count reaches zero.</p>
<p>Crash protection measures are built-in.  If the memory header or tail is missing from the block, it is assumed that code has over-written the memory boundaries.  All caught errors are reported to the application log and warrant priority attention.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="InvalidData">There is an error in the provided data.</error>
      <error code="MemoryDoesNotExist">Memory block does not exist.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>FreeSharedMutex</name>
    <category>Locks</category>
    <comment>Deallocate a shared mutex.</comment>
    <prototype>void FreeSharedMutex(APTR Mutex)</prototype>
    <input>
      <param type="APTR" name="Mutex">Reference to a shared mutex.</param>
    </input>
    <description>
<p>This function will deallocate a shared mutex.  It is vital that no thread is sleeping on the mutex at the time this function is called.  The outcome when calling this function on a mutex still in use is undefined.</p>
    </description>
  </function>

  <function>
    <name>GenCRC32</name>
    <category>System</category>
    <comment>Generates 32-bit CRC checksum values.</comment>
    <prototype>ULONG GenCRC32(ULONG CRC, APTR Data, ULONG Length)</prototype>
    <input>
      <param type="ULONG" name="CRC">If streaming data to this function, this value should reflect the most recently returned CRC integer.  Otherwise set to zero.</param>
      <param type="APTR" name="Data">The data to generate a CRC value for.</param>
      <param type="ULONG" name="Length">The length of the Data buffer.</param>
    </input>
    <description>
<p>This function is used internally for the generation of 32-bit CRC checksums.  You may use it for your own purposes to generate CRC values over a length of buffer space.  This function may be called repeatedly by feeding it previous CRC values, making it ideal for processing streamed data.</p>
    </description>
    <result type="ULONG">Returns the computed 32 bit CRC value for the given data.</result>
  </function>

  <function>
    <name>GetActionMsg</name>
    <category>Objects</category>
    <comment>Returns a message structure if called from an action that was executed by the message system.</comment>
    <prototype>struct Message * GetActionMsg()</prototype>
    <description>
<p>This function is for use by action and method support routines only.  It will return a Message structure if the action currently under execution has been called directly from the <function module="Core">ProcessMessages</function> function.  In all other cases a NULL pointer is returned.</p>
<p>The Message structure reflects the contents of a standard <function module="Core">GetMessage</function> call.  Of particular interest may be the Time field, which indicates the time-stamp at which the action message was originally sent to the object.</p>
    </description>
    <result type="struct Message *">A Message structure is returned if the function is called in valid circumstances, otherwise NULL.  The Message structure's fields are described in the <function module="Core">GetMessage</function> function.</result>
  </function>

  <function>
    <name>GetClassID</name>
    <category>Objects</category>
    <comment>Returns the class ID of an ID-referenced object.</comment>
    <prototype>CLASSID GetClassID(OBJECTID Object)</prototype>
    <input>
      <param type="OBJECTID" name="Object">The object to be examined.</param>
    </input>
    <description>
<p>Call this function with any valid object ID to learn the identifier for its base class.  This is the quickest way to retrieve the class of an object without having to gain exclusive access to the object first.</p>
<p>Note that if the object's pointer is already known, the quickest way to learn of its class is to read the ClassID field in the object header.</p>
    </description>
    <result type="CLASSID">Returns the base class ID of the object or zero if failure.</result>
  </function>

  <function>
    <name>GetErrorMsg</name>
    <category>Logging</category>
    <comment>Translates error codes into human readable strings.</comment>
    <prototype>CSTRING GetErrorMsg(ERROR Error)</prototype>
    <input>
      <param type="ERROR" name="Error">The error code to lookup.</param>
    </input>
    <description>
<p>The GetErrorMsg() function converts error codes into human readable strings.  If the Code is invalid, a string of "Unknown error code" is returned.</p>
    </description>
    <result type="CSTRING">A human readable string for the error code is returned.  By default error codes are returned in English, however if a translation table exists for the user's own language, the string will be translated.</result>
  </function>

  <function>
    <name>GetEventID</name>
    <category>Events</category>
    <comment>Generates unique event ID's suitable for event broadcasting.</comment>
    <prototype>LARGE GetEventID(LONG Group, CSTRING SubGroup, CSTRING Event)</prototype>
    <input>
      <param type="LONG" name="Group" lookup="EVG">The group to which the event belongs.</param>
      <param type="CSTRING" name="SubGroup">The sub-group to which the event belongs.</param>
      <param type="CSTRING" name="Event">The name of the event.</param>
    </input>
    <description>
<p>Use GetEventID() to generate a 64-bit event identifier.  This identifier can be used for broadcasting and subscribing to events.  Events are described in three parts - Group, SubGroup and the Event name, or in string format <code>group.subgroup.event</code>.</p>
<p>The Group is strictly limited to one of the following definitions:</p>
<types lookup="EVG"/>
<p>The SubGroup and Event parameters are string-based and there are no restrictions on naming.  If a SubGroup or Event name is NULL, this will act as a wildcard for subscribing to multiple events.  For example, subscribing to the network group with SubGroup and Event set to NULL will allow for a subscription to all network events that are broadcast.  A Group setting of zero is not allowed.</p>
    </description>
    <result type="LARGE">The EventID is returned as a 64-bit integer.</result>
  </function>

  <function>
    <name>GetField</name>
    <category>Fields</category>
    <comment>Retrieves single field values from objects.</comment>
    <prototype>ERROR GetField(OBJECTPTR Object, FIELD Field, APTR Result)</prototype>
    <input>
      <param type="OBJECTPTR" name="Object">Pointer to an object.</param>
      <param type="FIELD" name="Field">The ID of the field to read, OR'd with a type indicator.</param>
      <param type="APTR" name="Result">Pointer to the variable that will store the result.</param>
    </input>
    <description>
<p>The GetField() function is used to read field values from objects.  There is no requirement for the client to have an understanding of the target object in order to read information from it.</p>
<p>The following code segment illustrates how to read values from an object:</p>
<pre>GetField(Object, FID_X|TLONG, &amp;x);
GetField(Object, FID_Y|TLONG, &amp;y);
</pre>
<p>As GetField() is based on field ID's that reflect field names ("FID's"), you will find that there are occasions where there is no reserved ID for the field that you wish to read.  To convert field names into their relevant IDs, call the <function module="Core">StrHash</function> function.  Reserved field ID's are listed in the <code>parasol/system/fields.h</code> include file.</p>
<p>The type of the Result parameter must be OR'd into the Field parameter.  When reading a field you must give consideration to the type of the source, in order to prevent a type mismatch from occurring.  All numeric types are compatible with each other and strings can also be converted to numeric types automatically.  String and pointer types are interchangeable.</p>
<p>Available field types are as follows:</p>
<types>
<type name="TLONG">A 32-bit integer value.</type>
<type name="TDOUBLE">A 64-bit floating point value.</type>
<type name="TLARGE">A 64-bit integer value.</type>
<type name="TPTR">A standard 32-bit address space pointer.</type>
<type name="TSTR">A 32-bit pointer that refers to a string.</type>
</types>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="Args">Invalid arguments passed to function.</error>
      <error code="NoFieldAccess">Access to a field was denied.</error>
      <error code="UnsupportedField">The specified field is not supported by the object's class.</error>
    </result>
  </function>

  <function>
    <name>GetFieldArray</name>
    <category>Fields</category>
    <comment>Retrieves array field values from objects.</comment>
    <prototype>ERROR GetFieldArray(OBJECTPTR Object, FIELD Field, APTR * Result, LONG * Elements)</prototype>
    <input>
      <param type="OBJECTPTR" name="Object">Pointer to an object.</param>
      <param type="FIELD" name="Field">The ID of the field that will be read.</param>
      <param type="APTR *" name="Result">A direct pointer to the array values will be returned in this parameter.</param>
      <param type="LONG *" name="Elements">The total number of elements in the array will be returned in this parameter.</param>
    </input>
    <description>
<p>Use the GetFieldArray() function to read an array field from an object, including the length of that array.  This supplements the <function module="Core">GetField</function> function, which does not support returning the array length.</p>
<p>This function returns the array as-is with no provision for type conversion.  If the array is null terminated, it is standard practice not to count the null terminator in the total returned by Elements.</p>
<p>To achieve a minimum level of type safety, the anticipated type of array values can be specified by OR'ing a field type with the field identifier, e.g. <code>TLONG</code> or <code>TSTR</code>.  If no type is incorporated then a check will not be performed.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="NoFieldAccess">Access to a field was denied.</error>
      <error code="UnsupportedField">The specified field is not supported by the object's class.</error>
      <error code="Mismatch">A mis-match has been detected that prevents further processing.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>GetFieldVariable</name>
    <category>Fields</category>
    <comment>Retrieves field values by converting them into strings.</comment>
    <prototype>ERROR GetFieldVariable(OBJECTPTR Object, CSTRING Field, STRING Buffer, LONG Size)</prototype>
    <input>
      <param type="OBJECTPTR" name="Object">Pointer to an object.</param>
      <param type="CSTRING" name="Field">The name of the field that is to be retrieved.</param>
      <param type="STRING" name="Buffer">Pointer to a buffer space large enough to hold the expected field value.  If the buffer is not large enough, the result will be truncated.  A buffer of 256 bytes is considered large enough for most occasions.  For generic field reading purposes, a buffer as large as 64kb may be desired.</param>
      <param type="LONG" name="Size">The size of the buffer that has been provided, in bytes.</param>
    </input>
    <description>
<p>The GetFieldVariable() function is used to retrieve the value of a field without any advance knowledge of the field's type or details.  It also supports some advanced features such as flag name lookups and the retrieval of values from array indexes.  Although this function is simple to use, it is the slowest of the field retrieval instructions as it relies on string-based field names and converts all results into a string buffer that you must provide.</p>
<p>This function does not support pointer based fields as they cannot be translated, although an exception is made for string field types.</p>
<p>If the field name refers to a flag or lookup based field type, it is possible to test if a specific flag has been set. This is achieved by specifying a dot immediately after the field name, then the name of the flag or lookup to test. If the test passes, a value of 1 is returned, otherwise 0.</p>
<p>String conversion for flag and lookup based fields is also supported (by default, integer values are returned for these field types when no other test is applied).  This feature is enabled by prefixing the field name with a <code>$</code> symbol. If multiple fields are set, the resulting flags will be separated with the traditional OR symbol <code>|</code>.</p>
<p>If the field name refers to an array, it is possible to index specific values within that array by specifying a dot after the field name, then the index number to lookup.</p>
<p>To check if a string is defined (rather than retrieving the entire string content which can be time consuming), prefix the Field name with a question mark.  A value of 1 will be returned in the Buffer if the string has a minimum length of 1 character, otherwise a value of 0 is returned in the Buffer.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="Args">Invalid arguments passed to function.</error>
      <error code="NoFieldAccess">Access to a field was denied.</error>
      <error code="UnsupportedField">The specified field is not supported by the object's class.</error>
      <error code="Mismatch">A mis-match has been detected that prevents further processing.</error>
    </result>
  </function>

  <function>
    <name>GetMessage</name>
    <category>Messages</category>
    <comment>Reads messages from message queues.</comment>
    <prototype>ERROR GetMessage(MEMORYID Queue, LONG Type, MSF Flags, APTR Buffer, LONG Size)</prototype>
    <input>
      <param type="MEMORYID" name="Queue">The memory ID of the message queue is specified here.  If zero, the message queue of the local task will be used.</param>
      <param type="LONG" name="Type">Filter down to this message type or set to zero to receive the next message on the queue.</param>
      <param type="MSF" name="Flags" lookup="MSF">This argument is reserved for future use.  Set it to zero.</param>
      <param type="APTR" name="Buffer">Pointer to a buffer that is large enough to hold the incoming message information.  If set to NULL then all accompanying message data will be destroyed.</param>
      <param type="LONG" name="Size">The byte-size of the buffer that you have supplied.</param>
    </input>
    <description>
<p>The GetMessage() function is used to read messages that have been stored in message queues.  You can use this function to read the next immediate message stored on the queue, or the first message on the queue that matches a particular Type.  It is also possible to call this function in a loop to clear out all messages, until an error code other than <code>ERR_Okay</code> is returned.</p>
<p>Messages will often (although not always) carry data that is relevant to the message type.  To retrieve this data you need to supply a buffer, preferably one that is large enough to receive all the data that you expect from your messages.  If the buffer is too small, the message data will be cut off to fit inside the buffer.</p>
<p>Message data is written to the supplied buffer with a Message structure, which is immediately followed up with the actual message data.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="Search">A search routine in this function failed.</error>
      <error code="Args">Invalid arguments passed to function.</error>
      <error code="AccessMemory">Access to a shared memory block was denied.</error>
    </result>
  </function>

  <function>
    <name>GetObjectPtr</name>
    <category>Objects</category>
    <comment>Returns a direct pointer for any object ID.</comment>
    <prototype>OBJECTPTR GetObjectPtr(OBJECTID Object)</prototype>
    <input>
      <param type="OBJECTID" name="Object">The ID of the object to lookup.</param>
    </input>
    <description>
<p>This function translates object ID's to their respective address pointers.</p>
    </description>
    <result type="OBJECTPTR">The address of the object is returned, or NULL if the ID does not relate to an object.</result>
  </function>

  <function>
    <name>GetOwnerID</name>
    <category>Objects</category>
    <comment>Returns the unique ID of an object's owner.</comment>
    <prototype>OBJECTID GetOwnerID(OBJECTID Object)</prototype>
    <input>
      <param type="OBJECTID" name="Object">The ID of an object to query.</param>
    </input>
    <description>
<p>This function returns an identifier for the owner of any valid object.  This is the fastest way to retrieve the owner of an object if only the ID is known.</p>
<p>If the object address is already known then the fastest means of retrieval is via the ownerID() C++ class method.</p>
    </description>
    <result type="OBJECTID">Returns the ID of the object's owner.  If the object does not have a owner (i.e. if it is untracked) or if the provided ID is invalid, this function will return NULL.</result>
  </function>

  <function>
    <name>GetResource</name>
    <category>System</category>
    <comment>Retrieves miscellaneous resource identifiers.</comment>
    <prototype>LARGE GetResource(RES Resource)</prototype>
    <input>
      <param type="RES" name="Resource" lookup="RES">The ID of the resource that you want to obtain.</param>
    </input>
    <description>
<p>The GetResource() function is used to retrieve miscellaneous resource information from the system core.  Refer to the Resource identifier for the full list of available resource codes and their meaning.</p>
<p>C++ developers should use the GetResourcePtr() macro if a resource identifier is known to return a pointer.</p>
    </description>
    <result type="LARGE">Returns the value of the resource that you have requested.  If the resource ID is not known by the Core, NULL is returned.</result>
  </function>

  <function>
    <name>GetSystemState</name>
    <category>System</category>
    <comment>Returns miscellaneous data values from the Core.</comment>
    <prototype>const struct SystemState * GetSystemState()</prototype>
    <description>
<p>The GetSystemState() function is used to retrieve miscellaneous resource and environment values, such as resource paths, the Core's version number and the name of the host platform.</p>
    </description>
    <result type="const struct SystemState *">A read-only SystemState structure is returned.</result>
  </function>

  <function>
    <name>IdentifyFile</name>
    <category>Files</category>
    <comment>Analyse a file and identify a class that can process it.</comment>
    <prototype>ERROR IdentifyFile(CSTRING Path, CLASSID * Class, CLASSID * SubClass)</prototype>
    <input>
      <param type="CSTRING" name="Path">The location of the object data.</param>
      <param type="CLASSID *" name="Class">Must refer to a CLASSID variable that will store the resulting class ID.</param>
      <param type="CLASSID *" name="SubClass">Optional argument that can refer to a variable that will store the resulting sub-class ID (if the result is a base-class, this variable will receive a value of zero).</param>
    </input>
    <description>
<p>This function examines the relationship between file data and installed classes.  It allows for instance, a JPEG file to be identified as a datatype of the <class name="Picture">Picture</class> class, or an MP3 file to be identified as a datatype of the <class name="Sound">Sound</class> class.</p>
<p>The method involves analysing the Path's file extension and comparing it to the supported extensions of all available classes.  If a class supports the file extension then the ID of that class will be returned. If the file extension is not listed in the class dictionary or if it is listed more than once, the first 80 bytes of the file's data will be loaded and checked against classes that can match against file header information.  If a match is found, the ID of the matching class will be returned.</p>
<p>This function returns an error code of <code>ERR_Search</code> in the event that a suitable class is not available to match against the given file.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="Search">A search routine in this function failed.</error>
      <error code="FileNotFound">File not found.</error>
      <error code="Args">Invalid arguments passed to function.</error>
      <error code="Read">Error reading data from file.</error>
    </result>
  </function>

  <function>
    <name>InitObject</name>
    <category>Objects</category>
    <comment>Initialises an object so that it is ready for use.</comment>
    <prototype>ERROR InitObject(OBJECTPTR Object)</prototype>
    <input>
      <param type="OBJECTPTR" name="Object">The object to initialise.</param>
    </input>
    <description>
<p>This function initialises objects so that they can be used for their intended purpose. The process of initialisation is compulsory, and a client may not use any other actions on an object until it has been initialised.  Exceptions to this rule only apply to the GetVar() and SetVar() actions.</p>
<p>If the initialisation of an object fails due to a support problem (for example, if a PNG <class name="Picture">Picture</class> object attempts to load a JPEG file), the initialiser will search for a sub-class that can handle the data.  If a sub-class that can provide ample support exists, a partial transfer of ownership will occur and the object's  management will be shared between both the base class and the sub-class.</p>
<p>If an object does not support the data or its configuration, an error code of <code>ERR_NoSupport</code> will be returned. Other appropriate error codes can be returned if initialisation fails.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="LostClass">The object has lost its class reference.</error>
      <error code="ObjectCorrupt">The object structure is corrupt or has not been initialised.</error>
    </result>
  </function>

  <function>
    <name>ListChildren</name>
    <category>Objects</category>
    <comment>Returns a list of all children belonging to an object.</comment>
    <prototype>ERROR ListChildren(OBJECTID Object, pf::vector&lt;ChildEntry&gt; * List)</prototype>
    <input>
      <param type="OBJECTID" name="Object">An object to query.</param>
      <param type="pf::vector&lt;ChildEntry&gt; *" name="List">Must refer to an array of ChildEntry structures.</param>
    </input>
    <description>
<p>The ListChildren() function returns a list of all children belonging to an object.  The client must provide an empty vector of ChildEntry structures to host the results, which include unique object ID's and their class identifiers.</p>
<p>Note that any child objects marked with the <code>INTEGRAL</code> flag will be excluded because they are private members of the targeted object.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="Args">Invalid arguments passed to function.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>LoadFile</name>
    <category>Files</category>
    <comment>Loads files into a local cache for fast file processing.</comment>
    <prototype>ERROR LoadFile(CSTRING Path, LDF Flags, struct CacheFile ** Cache)</prototype>
    <input>
      <param type="CSTRING" name="Path">The location of the file to be cached.</param>
      <param type="LDF" name="Flags" lookup="LDF">Optional flags are specified here.</param>
      <param type="struct CacheFile **" name="Cache">A pointer to a CacheFile structure is returned here if successful.</param>
    </input>
    <description>
<p>The LoadFile() function loads complete files into memory and caches the content for use by other areas of the system or application.</p>
<p>This function will first determine if the requested file has already been cached.  If this is true then the <struct>CacheFile</struct> structure is returned immediately.  Note that if the file was previously cached but then modified, this will be treated as a cache miss and the file will be loaded into a new buffer.</p>
<p>File content will be loaded into a readable memory buffer that is referenced by the Data field of the <struct>CacheFile</struct> structure.  A hidden null byte is appended at the end of the buffer to assist the processing of text files. Other pieces of information about the file can be derived from the <struct>CacheFile</struct> meta data.</p>
<p>Calls to LoadFile() must be matched with a call to <function module="Core">UnloadFile</function> to decrement the cache counter. When the counter returns to zero, the file can be unloaded from the cache during the next resource collection phase.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="Search">A search routine in this function failed.</error>
      <error code="AllocMemory">A call to AllocMemory() failed to create a new memory block.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>LockMutex</name>
    <category>Locks</category>
    <comment>Acquire a lock on a mutex.</comment>
    <prototype>ERROR LockMutex(APTR Mutex, LONG MilliSeconds)</prototype>
    <input>
      <param type="APTR" name="Mutex">Reference to a mutex allocated from AllocMutex()</param>
      <param type="LONG" name="MilliSeconds">Timeout in milliseconds.</param>
    </input>
    <description>
<p>This function will lock a mutex allocated by <function module="Core">AllocMutex</function>.  If the mutex is already locked by another thread, the caller will sleep until the mutex is released or a time-out occurs.  If multiple threads are waiting on the mutex, the order of acquisition is dependent on the rules of the host platform.  It is recommended that the client makes no assumption as to the queue order and that the next thread to acquire the mutex will be randomly selected.</p>
<p>If the mutex was acquired with the <code>ALF::RECURSIVE</code> flag, then multiple calls to this function within the same thread will nest.  It will be necessary to call UnlockMutex() for every lock that has been acquired.</p>
<p>Please note that in Microsoft Windows, mutexes are implemented as critical sections and the time-out is not supported in the normal manner.  If the MilliSeconds parameter is set to zero, the mutex will be tested immediately and the return is immediate.  For any other value, the thread will sleep until the mutex is available and the requested timeout will not be honoured.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="TimeOut">Function timed-out before successful completion.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>LockObject</name>
    <category>Objects</category>
    <comment>Lock an object to prevent contention between threads.</comment>
    <prototype>ERROR LockObject(OBJECTPTR Object, LONG MilliSeconds)</prototype>
    <input>
      <param type="OBJECTPTR" name="Object">The address of the object to lock.</param>
      <param type="LONG" name="MilliSeconds">The total number of milliseconds to wait before giving up.  If -1, the function will wait indefinitely.</param>
    </input>
    <description>
<p>Use LockObject() to gain exclusive access to an object at thread-level.  This function provides identical behaviour to that of <function module="Core">AccessObject</function>, but with a slight speed advantage as the object ID does not need to be resolved to an address.  Calls to LockObject() will nest, and must be matched with a call to <function module="Core">ReleaseObject</function> to unlock the object.</p>
<p>Be aware that while this function is faster than <function module="Core">AccessObject</function>, its use may be considered unsafe if other threads could terminate the object without a suitable barrier in place.</p>
<p>If it is guaranteed that an object is not being shared between threads, object locking is unnecessary.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="TimeOut">Function timed-out before successful completion.</error>
      <error code="MarkedForDeletion">A resource cannot be accessed as it is marked for deletion.</error>
      <error code="SystemLocked">Part of the system is unreachable due to a persistent lock.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>LockSharedMutex</name>
    <category>Locks</category>
    <comment>Acquire a lock on a shared mutex.</comment>
    <prototype>ERROR LockSharedMutex(APTR Mutex, LONG MilliSeconds)</prototype>
    <input>
      <param type="APTR" name="Mutex">Reference to a mutex allocated from <function module="Core">AllocSharedMutex</function></param>
      <param type="LONG" name="MilliSeconds">Timeout in milliseconds.</param>
    </input>
    <description>
<p>This function will lock a shared mutex allocated by <function module="Core">AllocSharedMutex</function>.  If the mutex is already locked by another thread or process, the caller will sleep until the mutex is released or a time-out occurs.  If multiple threads are waiting on the mutex, the order of acquisition is dependent on the rules of the host platform.  It is recommended that the client makes no assumption as to the queue order and that the next thread to acquire the mutex will be randomly selected.</p>
<p>If the mutex was acquired with the <code>ALF::RECURSIVE</code> flag, then multiple calls to this function within the same thread will nest.  It will be necessary to call <function module="Core">UnlockSharedMutex</function> for every lock that has been acquired.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="TimeOut">Function timed-out before successful completion.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>MemoryIDInfo</name>
    <category>Memory</category>
    <comment>Returns information on memory ID's.</comment>
    <prototype>ERROR MemoryIDInfo(MEMORYID ID, struct MemInfo * MemInfo, LONG Size)</prototype>
    <input>
      <param type="MEMORYID" name="ID">Pointer to a valid memory ID.</param>
      <param type="struct MemInfo *" name="MemInfo">Pointer to a MemInfo structure.</param>
      <param type="LONG" name="Size">Size of the MemInfo structure.</param>
    </input>
    <description>
<p>This function returns the attributes of a memory block, including the start address, parent object, memory ID, size and flags.  The following code segment illustrates correct use of this function:</p>
<pre>MemInfo info;
if (!MemoryIDInfo(memid, &amp;info)) {
   log.msg("Memory block #%d is %d bytes large.", info.MemoryID, info.Size);
}
</pre>
<p>If the call fails, the MemInfo structure's fields will be driven to NULL and an error code is returned.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="Args">Invalid arguments passed to function.</error>
      <error code="SystemCorrupt">The operating system has been badly corrupted.</error>
      <error code="MemoryDoesNotExist">Memory block does not exist.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>MemoryPtrInfo</name>
    <category>Memory</category>
    <comment>Returns information on memory addresses.</comment>
    <prototype>ERROR MemoryPtrInfo(APTR Address, struct MemInfo * MemInfo, LONG Size)</prototype>
    <input>
      <param type="APTR" name="Address">Pointer to a valid memory area.</param>
      <param type="struct MemInfo *" name="MemInfo">Pointer to a MemInfo structure to be filled out.</param>
      <param type="LONG" name="Size">Size of the MemInfo structure.</param>
    </input>
    <description>
<p>This function can be used to get details on the attributes of a memory block.  It will return information on the start address, parent object, memory ID, size and flags of the memory address that you are querying.  The following code segment illustrates correct use of this function:</p>
<pre>MemInfo info;
if (!MemoryPtrInfo(ptr, &amp;info)) {
   log.msg("Address %p is %d bytes large.", info.Start, info.Size);
}
</pre>
<p>If the call to MemoryPtrInfo() fails then the MemInfo structure's fields will be driven to NULL and an error code will be returned.</p>
<p>Please note that referencing by a pointer requires a slow reverse-lookup to be employed in this function's search routine.  We recommend that calls to this function are avoided unless circumstances absolutely require it.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="MemoryDoesNotExist">Memory block does not exist.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>MoveFile</name>
    <category>Files</category>
    <comment>Moves folders and files to new locations.</comment>
    <prototype>ERROR MoveFile(CSTRING Source, CSTRING Dest, FUNCTION * Callback)</prototype>
    <input>
      <param type="CSTRING" name="Source">The source path.</param>
      <param type="CSTRING" name="Dest">The destination path.</param>
      <param type="FUNCTION *" name="Callback">Optional callback for receiving feedback during the operation.</param>
    </input>
    <description>
<p>This function is used to move files and folders to new locations.  It can also be used for renaming purposes and is able to move data from one type of media to another.  When moving folders, any contents within the folder will also be moved across to the new location.</p>
<p>It is important that you are aware that different types of string formatting can give different results.  The following examples illustrate:</p>
<pre>
<b>Source               Destination          Result</b>
parasol:makefile     parasol:documents    parasol:documents
parasol:makefile     parasol:documents/   parasol:documents/makefile
parasol:pictures/    parasol:documents/   parasol:documents/pictures
parasol:pictures/    parasol:documents    parasol:documents (Existing documents folder destroyed)
</pre>
<p>This function will overwrite the destination location if it already exists.</p>
<p>The Source argument should always clarify the type of location that is being copied - e.g. if you are copying a folder, you must specify a forward slash at the end of the string or the function will assume that you are moving a file.</p>
<p>The Callback parameter can be set with a function that matches this prototype:</p>
<p>
<code>LONG Callback(struct FileFeedback *)</code></p>
<p>For each file that is processed during the move operation, a <struct>FileFeedback</struct> structure is passed that describes the source file and its target.  The callback must return a constant value that can potentially affect file processing. Valid values are <code>FFR::Okay</code> (move the file), <code>FFR::Skip</code> (do not move the file) and <code>FFR::Abort</code> (abort the process completely and return <code>ERR_Cancelled</code> as an error code).</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="Failed">General failure.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>NewObject</name>
    <category>Objects</category>
    <comment>Creates new objects.</comment>
    <prototype>ERROR NewObject(LARGE ClassID, NF Flags, OBJECTPTR * Object)</prototype>
    <input>
      <param type="LARGE" name="ClassID">A class ID from "system/register.h" or generated by <function module="Core">ResolveClassName</function>.</param>
      <param type="NF" name="Flags" lookup="NF">Optional flags.</param>
      <param type="OBJECTPTR *" name="Object">Pointer to an address variable that will store a reference to the new object.</param>
    </input>
    <description>
<p>The NewObject() function is used to create new objects and register them for use within the Core.  After creating a new object, the client can proceed to set the object's field values and initialise it with <action>Init</action> so that it can be used as intended.</p>
<p>The new object will be modeled according to the class blueprint indicated by ClassID.  Pre-defined class ID's are defined in their documentation and the <code>parasol/system/register.h</code> include file.  ID's for unregistered classes can be computed using the <function module="Core">ResolveClassName</function> function.</p>
<p>A pointer to the new object will be returned in the Object parameter.  By default, object allocations are context sensitive and will be collected when their owner is terminated.  It is possible to track an object to a different owner by using the <function module="Core">SetOwner</function> function.</p>
<p>To destroy an object, call <function module="Core">FreeResource</function>.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="Failed">General failure.</error>
      <error code="MissingClass">The class could not be found in the system.</error>
      <error code="ObjectExists">Object exists.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>NotifySubscribers</name>
    <category>Objects</category>
    <comment>Used to send notification messages to action subscribers.</comment>
    <prototype>void NotifySubscribers(OBJECTPTR Object, LONG Action, APTR Args, ERROR Error)</prototype>
    <input>
      <param type="OBJECTPTR" name="Object">Pointer to the object that is to receive the notification message.</param>
      <param type="LONG" name="Action" lookup="AC">The action ID for notification.</param>
      <param type="APTR" name="Args">Pointer to an action parameter structure that is relevant to the ActionID.</param>
      <param type="ERROR" name="Error">The error code that is associated with the action result.</param>
    </input>
    <description>
<p>This function can be used by classes that need total control over notification management.  The system default for notifying action subscribers is to call them immediately after an action has taken place.  This may be inconvenient if the code for an action needs to execute code post-notification.  Using NotifySubscribers() allows these scenarios to be addressed.  Another possible use is for customised parameter values to be sent to subscribers instead of the original values.</p>
<p>NOTE: Calling NotifySubscribers() does nothing to prevent the core from sending out an action notification as it normally would, thus causing duplication.  To prevent this the client must logical-or the return code of the action function with <code>ERF_Notified</code>, e.g. <code>ERR_Okay|ERF_Notified</code>.</p>
    </description>
  </function>

  <function>
    <name>OpenDir</name>
    <category>Files</category>
    <comment>Opens a folder for content scanning.</comment>
    <prototype>ERROR OpenDir(CSTRING Path, RDF Flags, struct DirInfo ** Info)</prototype>
    <input>
      <param type="CSTRING" name="Path">The folder location to be scanned.  Using an empty string will scan for volume names.</param>
      <param type="RDF" name="Flags" lookup="RDF">Optional flags.</param>
      <param type="struct DirInfo **" name="Info">A DirInfo structure will be returned in the pointer referenced here.</param>
    </input>
    <description>
<p>The OpenDir() function is used to open a folder for scanning via the <function module="Core">ScanDir</function> function.  If the provided Path can be accessed, a DirInfo structure will be returned in the Info parameter, which will need to be passed to <function module="Core">ScanDir</function>.  Once the scanning process is complete, call the <function module="Core">FreeResource</function> function.</p>
<p>When opening a folder, it is necessary to indicate the type of files that are of interest.  If no flags are defined, the scanner will return file and folder names only.  Only a subset of the available <code>RDF</code> flags may be used, namely <code>SIZE</code>, <code>DATE</code>, <code>PERMISSIONS</code>, <code>FILE</code>, <code>FOLDER</code>, <code>QUALIFY</code>, <code>TAGS</code>.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="DirEmpty">The folder is empty.</error>
      <error code="Args">Invalid arguments passed to function.</error>
      <error code="AllocMemory">A call to AllocMemory() failed to create a new memory block.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>PreciseTime</name>
    <category>System</category>
    <comment>Returns the current system time, in microseconds.</comment>
    <prototype>LARGE PreciseTime()</prototype>
    <description>
<p>This function returns the current 'system time' in microseconds (1 millionth of a second).  The value is monotonic if the host platform allows it (typically expressed as the amount of time that has elapsed since the system was switched on).  The benefit of monotonic time is that it is unaffected by changes to the system clock, such as daylight savings adjustments or manual changes by the user.</p>
    </description>
    <result type="LARGE">Returns the system time in microseconds.  An error is extremely unlikely, but zero is returned in the event of one.</result>
  </function>

  <function>
    <name>ProcessMessages</name>
    <category>Messages</category>
    <comment>Processes system messages that are queued in the task's message buffer.</comment>
    <prototype>ERROR ProcessMessages(PMF Flags, LONG TimeOut)</prototype>
    <input>
      <param type="PMF" name="Flags" lookup="PMF">Optional flags are specified here (clients should set a value of zero).</param>
      <param type="LONG" name="TimeOut">A TimeOut value, measured in milliseconds.  If zero, the function will return as soon as all messages on the queue are processed.  If less than zero, the function does not return until a request for termination is received or a user message requires processing.</param>
    </input>
    <description>
<p>The ProcessMessages() function is used to process the task's message queue.  Messages are dispatched to message handlers in the order in which they arrived and the queue is emptied so that space is available for more messages.</p>
<p>Responding to incoming messages is a vital process - the queue is the standard means of communication between your task and the rest of the system and other tasks within it.  Failing to call the ProcessMessages() function on a regular basis may cause a back-log of messages to be generated, as well as causing problems with areas such as the graphical interface. If an area of your program is likely to loop continuously for a measurable period of time without returning, consider calling ProcessMessages() at a rate of 50 times per second to ensure that incoming messages are processed.</p>
<p>User messages that are on the queue are passed to message handlers.  If no message handler exists to interpret the message, then it is removed from the queue without being processed. Message handlers are added with the <function module="Core">AddMsgHandler</function> function.  If a message handler returns the error code <code>ERR_Terminate</code>, then ProcessMessages() will stop processing the queue and returns immediately with <code>ERR_Okay</code>.</p>
<p>If a message with a <code>MSGID_QUIT</code> ID is found on the queue, then the function returns immediately with the error code ERR_Terminate.  The program must respond to the terminate request by exiting immediately.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="Terminate">Please terminate future calls.</error>
      <error code="TimeOut">Function timed-out before successful completion.</error>
    </result>
  </function>

  <function>
    <name>QueueAction</name>
    <category>Objects</category>
    <comment>Delay the execution of an action by adding the call to the message queue.</comment>
    <prototype>ERROR QueueAction(LONG Action, OBJECTID Object, APTR Args)</prototype>
    <input>
      <param type="LONG" name="Action">The ID of an action or method to execute.</param>
      <param type="OBJECTID" name="Object">The target object.</param>
      <param type="APTR" name="Args">The relevant argument structure for the Action, or NULL if not required.</param>
    </input>
    <description>
<p>Use QueueAction() to execute an action by way of the local message queue.  This means that the supplied Action and the Args will be bundled into a message that will be placed in the queue.  This function then returns immediately.</p>
<p>The action will be executed on the next cycle of <function module="Core">ProcessMessages</function> in line with the FIFO order of queued messages.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="Failed">General failure.</error>
      <error code="OutOfRange">A specified number is outside of the valid range.</error>
      <error code="IllegalMethodID">Illegal method ID (number outside of valid range).</error>
      <error code="MissingClass">The class could not be found in the system.</error>
      <error code="NoMatchingObject">No matching object was found for the given object ID.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>ReadFileToBuffer</name>
    <category>Files</category>
    <comment>Reads a file into a buffer.</comment>
    <prototype>ERROR ReadFileToBuffer(CSTRING Path, APTR Buffer, LONG BufferSize, LONG * Result)</prototype>
    <input>
      <param type="CSTRING" name="Path">The path of the file.</param>
      <param type="APTR" name="Buffer">Pointer to a buffer that will receive the file content.</param>
      <param type="LONG" name="BufferSize">The byte size of the Buffer.</param>
      <param type="LONG *" name="Result">The total number of bytes read into the Buffer will be returned here (optional).</param>
    </input>
    <description>
<p>This function provides a simple method for reading file content into a buffer.  In some cases this procedure may be optimised for the host platform, which makes it the fastest way to read file content in simple cases.</p>
<p>File path approximation is supported if the Path is prefixed with a <code>~</code> character (e.g. <code>~pictures:photo</code> could be matched to <code>photo.jpg</code> in the same folder).</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="File">File error, e.g. file not found.</error>
      <error code="Args">Invalid arguments passed to function.</error>
      <error code="Read">Error reading data from file.</error>
      <error code="InvalidPath">Invalid file or folder path detected.</error>
      <error code="OpenFile">The file could not be opened.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>ReadInfoTag</name>
    <category>Files</category>
    <comment>Read a named tag from a FileInfo structure.</comment>
    <prototype>ERROR ReadInfoTag(struct FileInfo * Info, CSTRING Name, CSTRING * Value)</prototype>
    <input>
      <param type="struct FileInfo *" name="Info">Pointer to a valid FileInfo structure.</param>
      <param type="CSTRING" name="Name">The name of the tag.</param>
      <param type="CSTRING *" name="Value">The discovered string value is returned here if found.</param>
    </input>
    <description>
<p>Call ReadInfoTag() to retrieve the string value associated with a named tag in a FileInfo structure.  The tag must have been added with AddInfoTag() or <code>ERR_NotFound</code> will be returned.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="NotFound">A search routine in this function failed.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>ReallocMemory</name>
    <category>Memory</category>
    <comment>Reallocates memory blocks.</comment>
    <prototype>ERROR ReallocMemory(APTR Memory, LONG Size, APTR * Address, MEMORYID * ID)</prototype>
    <input>
      <param type="APTR" name="Memory">Pointer to a memory block obtained from AllocMemory().</param>
      <param type="LONG" name="Size">The size of the new memory block.</param>
      <param type="APTR *" name="Address">Point to an APTR variable to store the resulting pointer to the new memory block.</param>
      <param type="MEMORYID *" name="ID">Point to a MEMORYID variable to store the resulting memory block's unique ID.</param>
    </input>
    <description>
<p>This function is used to reallocate memory blocks to new lengths. You can shrink or expand a memory block as you wish. The data of your original memory block will be copied over to the new block.  If the new block is of a larger size, the left-over bytes will be filled with zero-byte values. If the new block is smaller, you will lose some of the original data.</p>
<p>The original block will be destroyed as a result of calling this function unless the reallocation process fails, in which case your existing memory block will remain valid.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="Args">Invalid arguments passed to function.</error>
      <error code="Memory">General memory error.</error>
      <error code="AllocMemory">A call to AllocMemory() failed to create a new memory block.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>RegisterFD</name>
    <category>System</category>
    <comment>Registers a file descriptor for monitoring when the task is asleep.</comment>
    <prototype>ERROR RegisterFD(HOSTHANDLE FD, RFD Flags, void (*Routine)(HOSTHANDLE, APTR) , APTR Data)</prototype>
    <input>
      <param type="HOSTHANDLE" name="FD">The file descriptor that is to be watched.</param>
      <param type="RFD" name="Flags" lookup="RFD">Set to at least one of READ, WRITE, EXCEPT, REMOVE.</param>
      <param type="void (*Routine)(HOSTHANDLE, APTR)" name="Routine">The routine that will read from the descriptor when data is detected on it.  The template for the function is "void Routine(LONG FD, APTR Data)".</param>
      <param type="APTR" name="Data">User specific data pointer that will be passed to the Routine.  Separate data pointers apply to the read and write states of operation.</param>
    </input>
    <description>
<p>This function will register a file descriptor that will be monitored for activity when the task is sleeping.  If activity occurs on the descriptor then the function specified in the Routine parameter will be called.  The routine must read all of information from the descriptor, as the running process will not be able to sleep until all the data is cleared.</p>
<p>The file descriptor should be configured as non-blocking before registration.  Blocking descriptors may cause the program to hang if not handled carefully.</p>
<p>File descriptors support read and write states simultaneously and a callback routine can be applied to either state. Set the <code>RFD::READ</code> flag to apply the Routine to the read callback and <code>RFD::WRITE</code> for the write callback.  If neither flag is specified, <code>RFD::READ</code> is assumed.  A file descriptor may have up to 1 subscription per flag, for example a read callback can be registered, followed by a write callback in a second call. Individual callbacks can be removed by combining the read/write flags with <code>RFD::REMOVE</code>.</p>
<p>The capabilities of this function and FD handling in general is developed to suit the host platform. On POSIX compliant systems, standard file descriptors are used.  In Microsoft Windows, object handles are used and blocking restrictions do not apply, except to sockets.</p>
<p>Call the DeregisterFD() macro to simplify unsubscribing once the file descriptor is no longer needed or is destroyed.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="Args">Invalid arguments passed to function.</error>
      <error code="NoSupport">This request is not supported.</error>
    </result>
  </function>

  <function>
    <name>ReleaseMemory</name>
    <category>Memory</category>
    <comment>Releases a lock from a memory based resource.</comment>
    <prototype>ERROR ReleaseMemory(MEMORYID MemoryID)</prototype>
    <input>
      <param type="MEMORYID" name="MemoryID">A reference to a memory resource for release.</param>
    </input>
    <description>
<p>Successful calls to <function module="Core">AccessMemory</function> must be paired with a call to ReleaseMemory() so that the memory can be made available to other processes.  By releasing the resource, the access count will decrease, and if applicable a thread that is in the queue for access may then be able to acquire a lock.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="Search">A search routine in this function failed.</error>
      <error code="SystemLocked">Part of the system is unreachable due to a persistent lock.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>ReleaseObject</name>
    <category>Objects</category>
    <comment>Release a locked private object.</comment>
    <prototype>void ReleaseObject(OBJECTPTR Object)</prototype>
    <input>
      <param type="OBJECTPTR" name="Object">Pointer to the object to be released.</param>
    </input>
    <description>
<p>Release a lock previously obtained from <function module="Core">AccessObject</function> or <function module="Core">LockObject</function>.  Locks will nest, so a release is required for every lock that has been granted.</p>
    </description>
  </function>

  <function>
    <name>ResolveClassID</name>
    <category>Objects</category>
    <comment>Converts a valid class ID to its equivalent name.</comment>
    <prototype>CSTRING ResolveClassID(CLASSID ID)</prototype>
    <input>
      <param type="CLASSID" name="ID">The ID of the class that needs to be resolved.</param>
    </input>
    <description>
<p>This function will resolve a valid class ID to its equivalent name.  The name is resolved by scanning the class database, so the class must be registered in the database for this function to return successfully. Registration is achieved by loading the module that hosts the class, after which the class is permanently saved in the database.</p>
    </description>
    <result type="CSTRING">Returns the name of the class, or NULL if the ID is not recognised.  Standard naming conventions apply, so it can be expected that the string is capitalised and without spaces, e.g. "NetSocket".</result>
  </function>

  <function>
    <name>ResolveClassName</name>
    <category>Objects</category>
    <comment>Resolves any class name to a unique identification ID.</comment>
    <prototype>CLASSID ResolveClassName(CSTRING Name)</prototype>
    <input>
      <param type="CSTRING" name="Name">The name of the class that requires resolution.</param>
    </input>
    <description>
<p>This function will resolve a class name to its unique ID.</p>
<p>Class ID's are used by functions such as <function module="Core">NewObject</function> for fast processing.</p>
    </description>
    <result type="CLASSID">Returns the class ID identified from the class name, or NULL if the class could not be found.</result>
  </function>

  <function>
    <name>ResolveGroupID</name>
    <category>Files</category>
    <comment>Converts a group ID to its corresponding name.</comment>
    <prototype>CSTRING ResolveGroupID(LONG Group)</prototype>
    <input>
      <param type="LONG" name="Group">The group ID.</param>
    </input>
    <description>
<p>This function converts group ID's obtained from the file system into their corresponding names.  If the group ID is invalid then NULL will be returned.</p>
    </description>
    <result type="CSTRING">The group name is returned, or NULL if the ID cannot be resolved.</result>
  </function>

  <function>
    <name>ResolvePath</name>
    <category>Files</category>
    <comment>Converts volume-based paths into absolute paths applicable to the host platform.</comment>
    <prototype>ERROR ResolvePath(CSTRING Path, RSF Flags, STRING * Result)</prototype>
    <input>
      <param type="CSTRING" name="Path">The path to be resolved.</param>
      <param type="RSF" name="Flags" lookup="RSF">Optional flags.</param>
      <param type="STRING *" name="Result">Must point to an empty STRING variable so that the resolved path can be stored.  If NULL, ResolvePath() will work as normal and return a valid error code without the result string.</param>
    </input>
    <description>
<p>This function will convert a file path to its resolved form, according to the host system.  For example, a Linux system might resolve <code>drive1:documents/readme.txt</code> to <code>/documents/readme.txt</code>.  A Windows system might resolve the path to <code>c:\documents\readme.txt</code>.</p>
<p>The resulting path is guaranteed to be absolute, meaning the use of sequences such as <code>..</code>, <code>//</code> and <code>./</code> will be eliminated.</p>
<p>If the path can be resolved to more than one file, the ResolvePath() method will attempt to guess the correct path by checking the validity of each possible location.  For instance, if resolving a path of <code>user:document.txt</code> and the <code>user:</code> volume refers to both <code>system:users/joebloggs/</code> and <code>system:users/default/</code>, the routine will check both directories for the existence of the <code>document.txt</code> file to determine the correct location.  While helpful, this can cause problems if the intent is to create a new file.  To circumvent this feature, use the <code>RSF::NO_FILE_CHECK</code> setting in the Flags parameter.</p>
<p>When checking for the location of a file, ResolvePath() will only accept an exact file name match.  If the path must be treated as an approximation (i.e. file extensions can be ignored) then use the <code>RSF::APPROXIMATE</code> flag to tell the function to ignore extensions for the purpose of file name matching.</p>
<p>To resolve the location of executable programs on Unix systems, use the <code>RSF::PATH</code> flag.  This uses the PATH environment variable to resolve the file name specified in the Path parameter.</p>
<p>The resolved path will be returned in the Result parameter as an allocated memory block.  It must be removed once it is no longer required with FreeResource().</p>
<types lookup="RSF"/>
<p>If the path resolves to a virtual drive, it may not be possible to confirm whether the target file exists if the virtual driver does not support this check.  This is common when working with network drives.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="Search">A search routine in this function failed.</error>
      <error code="FileNotFound">File not found.</error>
      <error code="LockFailed">Failed to lock a required resource.</error>
      <error code="AllocMemory">A call to AllocMemory() failed to create a new memory block.</error>
      <error code="Loop">An infinite loop was detected.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>ResolveUserID</name>
    <category>Files</category>
    <comment>Converts a user ID to its corresponding name.</comment>
    <prototype>CSTRING ResolveUserID(LONG User)</prototype>
    <input>
      <param type="LONG" name="User">The user ID.</param>
    </input>
    <description>
<p>This function converts user ID's obtained from the file system into their corresponding names.  If the user ID is invalid then NULL will be returned.</p>
    </description>
    <result type="CSTRING">The user name is returned, or NULL if the ID cannot be resolved.</result>
  </function>

  <function>
    <name>ScanDir</name>
    <category>Files</category>
    <comment>Scans the content of a folder, by item.</comment>
    <prototype>ERROR ScanDir(struct DirInfo * Info)</prototype>
    <input>
      <param type="struct DirInfo *" name="Info">Pointer to a DirInfo structure for storing scan results.</param>
    </input>
    <description>
<p>The ScanDir() function is used to scan for files and folders in a folder that you have opened using the <function module="Core">OpenDir</function> function. The ScanDir() function is intended to be used in a simple loop, returning a single item for each function call that you make.  The following code sample illustrates typical usage:</p>
<pre>DirInfo *info;
if (!OpenDir(path, RDF::FILE|RDF::FOLDER, &amp;info)) {
   while (!ScanDir(info)) {
      log.msg("File: %s", info-&gt;Name);
   }
   FreeResource(info);
}
</pre>
<p>For each item that you scan, you will be able to read the Info structure for information on that item.  The DirInfo structure contains a FileInfo pointer that consists of the following fields:</p>
<struct lookup="FileInfo"/>
<p>The <code>RDF</code> flags that may be returned in the Flags field are <code>VOLUME</code>, <code>FOLDER</code>, <code>FILE</code>, <code>LINK</code>.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="DirEmpty">The folder is empty.</error>
      <error code="Args">Invalid arguments passed to function.</error>
    </result>
  </function>

  <function>
    <name>ScanMessages</name>
    <category>Messages</category>
    <comment>Scans a message queue for multiple occurrences of a message type.</comment>
    <prototype>ERROR ScanMessages(APTR Queue, LONG * Index, LONG Type, APTR Buffer, LONG Size)</prototype>
    <input>
      <param type="APTR" name="Queue">An address pointer for a message queue (use AccessMemory() to get an address from a message queue ID).</param>
      <param type="LONG *" name="Index">Pointer to a 32-bit value that must initially be set to zero.  The ScanMessages() function will automatically update this variable with each call so that it can remember its analysis position.</param>
      <param type="LONG" name="Type">The message type to filter for, or zero to scan all messages in the queue.</param>
      <param type="APTR" name="Buffer">Pointer to a buffer that is large enough to hold the message information.  Set to NULL if you are not interested in the message data.</param>
      <param type="LONG" name="Size">The byte-size of the supplied Buffer.</param>
    </input>
    <description>
<p>Use the ScanMessages() function to scan a message queue for information without affecting the state of the queue.  To use this function, you need to establish a connection to the queue by using the <function module="Core">AccessMemory</function> function first to gain access.  Then make repeated calls to ScanMessages() to analyse the queue until it returns an error code other than <code>ERR_Okay</code>.  Use <function module="Core">ReleaseMemory</function> to let go of the message queue when you are done with it.</p>
<p>Here is an example that scans the queue of the active task:</p>
<pre>if (!AccessMemory(GetResource(RES::MESSAGE_QUEUE), MEM_READ, &amp;queue)) {
   while (!ScanMessages(queue, &amp;index, MSGID_QUIT, NULL, NULL)) {
      ...
   }
   ReleaseMemory(queue);
}
</pre>
<p>Messages will often (although not always) carry data that is relevant to the message type.  To retrieve this data you need to supply a buffer, preferably one that is large enough to receive all the data that you expect from your messages.  If the buffer is too small, the message data will be cut off to fit inside the buffer.</p>
<p>Message data is written to the supplied buffer with a Message structure (struct Message), which is immediately followed up with the actual message data.  The message structure includes the following fields:</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="Search">A search routine in this function failed.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>SendMessage</name>
    <category>Messages</category>
    <comment>Send messages to message queues.</comment>
    <prototype>ERROR SendMessage(OBJECTID Task, LONG Type, MSF Flags, APTR Data, LONG Size)</prototype>
    <input>
      <param type="OBJECTID" name="Task">ID of a task to target.  If zero, the local message queue is targeted.</param>
      <param type="LONG" name="Type" lookup="MSGID">The message Type/ID being sent.  Unique type ID's can be obtained from <function module="Core">AllocateID</function>.</param>
      <param type="MSF" name="Flags" lookup="MSF">Optional flags.</param>
      <param type="APTR" name="Data">Pointer to the data that will be written to the queue.  Set to NULL if there is no data to write.</param>
      <param type="LONG" name="Size">The byte-size of the data being written to the message queue.</param>
    </input>
    <description>
<p>The SendMessage() function is used to send messages to message queues.  Messages must be associated with a Type identifier and this can help the receiver process any accompanying Data.  Some common message types are pre-defined, such as <code>MSGID_QUIT</code>.  Custom messages should use a unique type ID obtained from <function module="Core">AllocateID</function>.</p>
<p>If the target message queue is full, or if the size of the message is larger than the total size of the queue, this function will immediately return with an <code>ERR_ArrayFull</code> error code.  If you are prepared to wait for the queue handler to process the waiting messages, specify <code>WAIT</code> in the Flags parameter.  There is a maximum time-out period of 10 seconds in case the task responsible for handling the queue is failing to process its messages.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="Args">Invalid arguments passed to function.</error>
      <error code="TimeOut">Function timed-out before successful completion.</error>
      <error code="ArrayFull">Array has reached capacity and cannot be expanded.</error>
      <error code="AccessMemory">Access to a shared memory block was denied.</error>
    </result>
  </function>

  <function>
    <name>SetArray</name>
    <category>Fields</category>
    <comment>Used to set array fields in objects.</comment>
    <prototype>ERROR SetArray(OBJECTPTR Object, FIELD Field, APTR Array, LONG Elements)</prototype>
    <input>
      <param type="OBJECTPTR" name="Object">Pointer to the target object.</param>
      <param type="FIELD" name="Field">The universal ID of the field you wish to write to, OR'd with a type indicator.</param>
      <param type="APTR" name="Array">Pointer to the array values.</param>
      <param type="LONG" name="Elements">The number of elements listed in the Array.</param>
    </input>
    <description>
<p>The SetArray() function is used as an alternative to <function module="Core">SetField</function> for the purpose of writing arrays to objects.</p>
<p>The following code segment illustrates how to write an array to an object field:</p>
<pre>LONG array[100];
SetArray(Object, FID_Table|TLONG, array, 100);
</pre>
<p>An indicator of the type of the elements in the Array must be OR'd into the Field parameter.  Available field types are listed in <function module="Core">SetField</function>.  Note that the type that you choose must be a match to the type expected for elements in the array.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="NoFieldAccess">Access to a field was denied.</error>
      <error code="FieldTypeMismatch">Field type mismatch while getting or setting a field.</error>
      <error code="UnsupportedField">The specified field is not supported by the object's class.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>SetContext</name>
    <category>Objects</category>
    <comment>Alters the nominated owner of newly created objects.</comment>
    <prototype>OBJECTPTR SetContext(OBJECTPTR Object)</prototype>
    <input>
      <param type="OBJECTPTR" name="Object">Pointer to the object that will take on the new context.  If NULL, no change to the context will be made.</param>
    </input>
    <description>
<p>This function defines the object that has control of the current thread.  Once called, all further resource allocations are assigned to that object.  This is significant for the automatic collection of memory and object allocations.  For example:</p>
<pre>InitObject(display);
auto ctx = SetContext(display);

   NewObject(ID_BITMAP, &amp;bitmap);
   AllocMemory(1000, MEM_DATA, &amp;memory, NULL);

SetContext(ctx);
FreeResource(display-&gt;UID);
</pre>
<p>The above code allocates a Bitmap and a memory block, both of which will be contained by the display. When <function module="Core">FreeResource</function> is called, both the bitmap and memory block will be automatically removed as they have a dependency on the display's existence.  Please keep in mind that the following is incorrect:</p>
<pre>InitObject(display);
auto ctx = SetContext(display);

   NewObject(ID_BITMAP, &amp;bitmap);
   AllocMemory(1000, MEM_DATA, &amp;memory, NULL);

SetContext(ctx);
FreeResource(display-&gt;UID); // The bitmap and memory would be auto-collected
FreeResource(bitmap-&gt;UID);  // Reference is no longer valid
FreeResource(memory);  // Reference is no longer valid
</pre>
<p>As the bitmap and memory block would have been freed as members of the display, their references are invalid when manually terminated in the following instructions.</p>
<p>SetContext() is intended for use by modules and classes.  Do not use it in an application unless conditions necessitate its use.  The Core automatically manages the context when calling class actions, methods and interactive fields.</p>
    </description>
    <result type="OBJECTPTR">Returns a pointer to the previous context.  Because contexts nest, the client must call SetContext() a second time with this pointer in order to keep the process stable.</result>
  </function>

  <function>
    <name>SetDefaultPermissions</name>
    <category>Files</category>
    <comment>Forces the user and group permissions to be applied to new files and folders.</comment>
    <prototype>void SetDefaultPermissions(LONG User, LONG Group, PERMIT Permissions)</prototype>
    <input>
      <param type="LONG" name="User">User ID to apply to new files.</param>
      <param type="LONG" name="Group">Group ID to apply to new files.</param>
      <param type="PERMIT" name="Permissions" lookup="PERMIT">Permission flags to be applied to new files.</param>
    </input>
    <description>
<p>By default, user, group and permission information for new files is inherited either from the system defaults or from the file source in copy operations.  Use this function to override this behaviour with new default values.  All threads of the process will be affected.</p>
<p>To revert behaviour to the default settings, set the User and/or Group values to -1 and the Permissions value to zero.</p>
    </description>
  </function>

  <function>
    <name>SetField</name>
    <category>Fields</category>
    <comment>Used to set field values of objects.</comment>
    <prototype>ERROR SetField(OBJECTPTR Object, FIELD Field, ...)</prototype>
    <input>
      <param type="OBJECTPTR" name="Object">Pointer to the target object.</param>
      <param type="FIELD" name="Field">The universal ID of the field to update, OR'd with a type indicator.</param>
      <param type="..." name="Value">The value that will be written to the field.</param>
    </input>
    <description>
<p>The SetField() function is used to write field values to objects.</p>
<p>The following code segment illustrates how to write values to an object:</p>
<pre>SetField(Object, FID_X|TLONG, 100);
SetField(Object, FID_Statement|TSTR, "string");
</pre>
<p>Fields are referenced by unique ID's that reflect their names.  On occasion you may find that there is no reserved ID for the field that you wish to access.  To convert field names into their relevant IDs, call the <function module="Core">StrHash</function> function.  Reserved field ID's are listed in the <code>parasol/system/fields.h</code> include file.</p>
<p>The type of the Value parameter must be OR'd into the Field parameter. When writing a field you must give consideration to the type of the target, in order to prevent a type mismatch from occurring.  All numeric types are compatible with each other and strings can also be converted to numeric types automatically.  String and pointer types are interchangeable.</p>
<p>Available field types are as follows:</p>
<types>
<type name="TLONG">A 32-bit integer value.</type>
<type name="TDOUBLE">A 64-bit floating point value.</type>
<type name="TLARGE">A 64-bit integer value.</type>
<type name="TPTR">A standard 32-bit address space pointer.</type>
<type name="TSTR">A 32-bit pointer that refers to a string.</type>
</types>
<p>There is no requirement for you to have a working knowledge of the target object's field configuration in order to write information to it.</p>
<p>To set a field with a fixed-size array, please use the <function module="Core">SetArray</function> function.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="Args">Invalid arguments passed to function.</error>
      <error code="NoFieldAccess">Access to a field was denied.</error>
      <error code="UnsupportedField">The specified field is not supported by the object's class.</error>
    </result>
  </function>

  <function>
    <name>SetName</name>
    <category>Objects</category>
    <comment>Sets the name of an object.</comment>
    <prototype>ERROR SetName(OBJECTPTR Object, CSTRING Name)</prototype>
    <input>
      <param type="OBJECTPTR" name="Object">The target object.</param>
      <param type="CSTRING" name="Name">The new name for the object.</param>
    </input>
    <description>
<p>This function sets the name of an object.  This enhances log messages and allows the object to be found in searches. Please note that the length of the Name will be limited to the value indicated in the core header file, under the <code>MAX_NAME_LEN</code> definition.  Names exceeding the allowed length are trimmed to fit.</p>
<p>Object names are limited to alpha-numeric characters and the underscore symbol.  Invalid characters are replaced with an underscore.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="Search">A search routine in this function failed.</error>
      <error code="LockFailed">Failed to lock a required resource.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>SetOwner</name>
    <category>Objects</category>
    <comment>Changes object ownership dynamically.</comment>
    <prototype>ERROR SetOwner(OBJECTPTR Object, OBJECTPTR Owner)</prototype>
    <input>
      <param type="OBJECTPTR" name="Object">Pointer to the object to modify.</param>
      <param type="OBJECTPTR" name="Owner">Pointer to the new owner for the object.</param>
    </input>
    <description>
<p>This function changes the ownership of an existing object.  Ownership is an attribute that affects an object's placement within the object hierarchy as well as impacting on the resource tracking of the object in question. Internally, setting a new owner will cause three things to happen:</p>
<list type="sorted">
<li>The new owner's class will receive notification via the <action>NewChild</action> action.  If the owner rejects the object by sending back an error, SetOwner() will fail immediately.</li>
<li>The object's class will then receive notification via the <action>NewOwner</action> action.</li>
<li>The resource tracking of the new owner will be modified so that the object is accepted as its child.  This means that if and when the owning object is destroyed, the new child object will be destroyed with it.</li>
</list>
<p>If the Object does not support the NewOwner action, or the Owner does not support the NewChild action, then the process will not fail.  It will continue on the assumption that neither party is concerned about ownership management.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="Args">Invalid arguments passed to function.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>SetResource</name>
    <category>System</category>
    <comment>Sets miscellaneous resource identifiers.</comment>
    <prototype>LARGE SetResource(RES Resource, LARGE Value)</prototype>
    <input>
      <param type="RES" name="Resource" lookup="RES">The ID of the resource to be set.</param>
      <param type="LARGE" name="Value">The new value to set for the resource.</param>
    </input>
    <description>
<p>The SetResource() function is used to manipulate miscellaneous system resources.  Currently the following resources are supported:</p>
<types lookup="RES" type="Resource">
<type name="ALLOC_MEM_LIMIT">Adjusts the memory limit imposed on AllocMemory().  The Value specifies the memory limit in bytes.</type>
<type name="LOG_LEVEL">Adjusts the current debug level.  The Value must be between 0 and 9, where 1 is the lowest level of debug output (errors only) and 0 is off.</type>
<type name="PRIVILEGED_USER">If the Value is set to 1, this resource option puts the process in privileged mode (typically this enables full administrator rights).  This feature will only work for Unix processes that are granted admin rights when launched.  Setting the Value to 0 reverts to the user's permission settings.  SetResource() will return an error code indicating the level of success.</type>
</types>
    </description>
    <result type="LARGE">Returns the previous value used for the resource that you have set.  If the resource ID that you provide is invalid, NULL is returned.</result>
  </function>

  <function>
    <name>SetResourcePath</name>
    <category>System</category>
    <comment>Redefines the location of a system resource path.</comment>
    <prototype>ERROR SetResourcePath(RP PathType, CSTRING Path)</prototype>
    <input>
      <param type="RP" name="PathType" lookup="RP">The ID of the resource path to set.</param>
      <param type="CSTRING" name="Path">The new location to set for the resource path.</param>
    </input>
    <description>
<p>The SetResourcePath() function changes the default locations of the Core's resource paths.</p>
<p>To read a resource path, use the <function module="Core">GetSystemState</function> function.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>SetVolume</name>
    <category>Files</category>
    <comment>Adds a new volume name to the system.</comment>
    <prototype>ERROR SetVolume(CSTRING Name, CSTRING Path, CSTRING Icon, CSTRING Label, CSTRING Device, VOLUME Flags)</prototype>
    <input>
      <param type="CSTRING" name="Name">Required.  The name of the volume.</param>
      <param type="CSTRING" name="Path">Required.  The path to be associated with the volume.  If setting multiple paths, separate each path with a semi-colon character.  Each path must terminate with a forward slash to denote a folder.</param>
      <param type="CSTRING" name="Icon">An icon can be associated with the volume so that it has graphical representation when viewed in the UI.  The required icon string format is 'category/name'.</param>
      <param type="CSTRING" name="Label">An optional label or short comment may be applied to the volume.  This may be useful if the volume name has little meaning to the user (e.g. drive1, drive2 ...).</param>
      <param type="CSTRING" name="Device">If the volume references the root of a device, specify a code of 'disk', 'hd', 'cd', 'network' or 'usb'.</param>
      <param type="VOLUME" name="Flags" lookup="VOLUME">Optional flags.</param>
    </input>
    <description>
<p>The SetVolume() function is used to create a volume that is associated with one or more paths.  If the volume already exists, it possible to append more paths or replace them entirely.</p>
<p>Flags that may be passed are as follows:</p>
<types lookup="VOLUME"/>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="LockFailed">Failed to lock a required resource.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>StrBuildArray</name>
    <category>Strings</category>
    <comment>Builds an array of strings from a sequential string list.</comment>
    <prototype>STRING * StrBuildArray(STRING List, LONG Size, LONG Total, SBF Flags)</prototype>
    <input>
      <param type="STRING" name="List">Pointer to a string of sequentially arranged values.</param>
      <param type="LONG" name="Size">The total byte size of the List, not including the terminating byte.</param>
      <param type="LONG" name="Total">The total number of strings specified in the List.</param>
      <param type="SBF" name="Flags" lookup="SBF">Set to SORT to sort the list, NO_DUPLICATES to sort the list and remove duplicated strings, Use CSV if the List is in CSV format, in which case the Size and Total values are ignored (note - the string will be modified if in CSV).</param>
    </input>
    <description>
<p>This function is helpful for converting a buffer of sequential values into a more easily managed string array.  A "sequential list of values" is any number of strings arranged one after the other in a single byte array.  It is similar in arrangement to a CSV file, but null-terminators signal an end to each string value.</p>
<p>To convert such a string list into an array, you need to know the total byte size of the list, as well as the total number of strings in the list. If you don't know this information, you can either alter your routine to make provisions for it, or you can pass the <code>SBF::CSV</code> flag if the List is in CSV format.  CSV mode incurs a performance hit as the string needs to be analysed first.</p>
<p>Once you call this function, it will allocate a memory block to contain the array and string information.  The list will then be converted into the array, which will be terminated with a NULL pointer at its end.  If you have specified the <code>SBF::SORT</code> or <code>SBF::NO_DUPLICATES</code> Flags then the array will be sorted into alphabetical order for your convenience.  The <code>SBF::NO_DUPLICATES</code> flag also removes duplicated strings from the array.</p>
<p>Remember to free the allocated array when it is no longer required.</p>
    </description>
    <result type="STRING *">Returns an array of STRING pointers, or NULL on failure.  The pointer is a memory block that must be freed after use.</result>
  </function>

  <function>
    <name>StrCompare</name>
    <category>Strings</category>
    <comment>Compares strings to see if they are identical.</comment>
    <prototype>ERROR StrCompare(CSTRING String1, CSTRING String2, LONG Length, STR Flags)</prototype>
    <input>
      <param type="CSTRING" name="String1">Pointer to the first string.</param>
      <param type="CSTRING" name="String2">Pointer to the second string.</param>
      <param type="LONG" name="Length">The maximum number of characters to compare.  Does not apply to wildcard comparisons.</param>
      <param type="STR" name="Flags" lookup="STR">Optional flags.</param>
    </input>
    <description>
<p>This function compares two strings against each other.  If the strings match then it returns ERR_Okay, otherwise it returns ERR_False.  By default the function is not case sensitive, but you can turn on case sensitivity by specifying the <code>STR::CASE</code> flag.</p>
<p>If you set the Length to 0, the function will compare both strings for differences until a string terminates.  If all characters matched up until the termination, ERR_Okay will be returned regardless of whether or not one of the strings happened to be longer than the other.</p>
<p>If the Length is not 0, then the comparison will stop once the specified number of characters to match has been reached.  If one of the strings terminates before the specified Length is matched, ERR_False will be returned.</p>
<p>If the <code>STR::MATCH_LEN</code> flag is specified, you can force the function into returning an ERR_Okay code only on the condition that both strings are of matching lengths.  This flag is typically specified if the Length argument has been set to 0.</p>
<p>If the <code>STR::WILDCARD</code> flag is set, the first string that is passed may contain wild card characters, which gives special meaning to the asterisk and question mark characters.  This allows you to make abstract comparisons, for instance <code>ABC*</code> would match to <code>ABCDEF</code> and <code>1?3</code> would match to <code>1x3</code>.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="False">The result is false.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>StrDatatype</name>
    <category>Strings</category>
    <comment>Determines the data type of a string.</comment>
    <prototype>STT StrDatatype(CSTRING String)</prototype>
    <input>
      <param type="CSTRING" name="String">The string that you want to analyse.</param>
    </input>
    <description>
<p>This function analyses a string and returns its data type.  Valid return values are <code>STT::FLOAT</code> for floating point numbers, <code>STT::NUMBER</code> for whole numbers, <code>STT::HEX</code> for hexadecimal (e.g. 0x1) and <code>STT::STRING</code> for any other string type. In order for the string to be recognised as one of the number types, it must be limited to numbers and qualification characters, such as a decimal point or negative sign.</p>
<p>Any white-space at the start of the string will be skipped.</p>
    </description>
    <result type="STT" lookup="STT">Returns FLOAT, NUMBER, HEX or STRING.</result>
  </function>

  <function>
    <name>StrHash</name>
    <category>Strings</category>
    <comment>Convert a string into a 32-bit hash.</comment>
    <prototype>ULONG StrHash(CSTRING String, LONG CaseSensitive)</prototype>
    <input>
      <param type="CSTRING" name="String">Reference to a string that will be processed.</param>
      <param type="LONG" name="CaseSensitive">Set to TRUE to enable case sensitivity.</param>
    </input>
    <description>
<p>This function will convert a string into a 32-bit hash.  The hashing algorithm is consistent throughout our platform and is therefore guaranteed to be compatible with all areas that make use of hashed values.</p>
<p>Hashing is case insensitive by default.  If case sensitive hashing is desired, please set CaseSensitive to TRUE when calling this function.  Please keep in mind that a case sensitive hash value will not be interchangeable with a case insensitive hash of the same string.</p>
    </description>
    <result type="ULONG">The 32-bit hash is returned.</result>
  </function>

  <function>
    <name>StrReadLocale</name>
    <category>Strings</category>
    <comment>Read system locale information.</comment>
    <prototype>ERROR StrReadLocale(CSTRING Key, CSTRING * Value)</prototype>
    <input>
      <param type="CSTRING" name="Key">The name of a locale value to read.</param>
      <param type="CSTRING *" name="Value">A pointer to the retrieved string value will be returned in this parameter.</param>
    </input>
    <description>
<p>Use this function to read system-wide locale information.  Settings are usually preset according to the user's location, but the user also has the power to override individual key value.  The internal nature of this function varies by host system.  If locale information is not readily available then the locale values will be derived from <code>user:config/locale.cfg</code>.</p>
<p>Available key values are as follows:</p>
<types>
<type name="Language">Three letter ISO code indicating the user's preferred language, e.g. 'eng'</type>
<type name="ShortDate">Short date format, e.g. 'dd/mm/yyyy'</type>
<type name="LongDate">Long date format, e.g. 'Dddd, d Mmm yyyy'</type>
<type name="FileDate">File date format, e.g. 'dd-mm-yy hh:nn'</type>
<type name="Time">Basic time format, e.g. hh:nn</type>
<type name="CurrencySymbol">Currency symbol, e.g. '$'</type>
<type name="Decimal">Decimal place symbol, e.g. '.'</type>
<type name="Thousands">Thousands symbol, e.g. ','</type>
<type name="Positive">Positive symbol - typically blank or '+'</type>
<type name="Negative">Negative symbol, e.g. '-'</type>
</types>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="Search">A search routine in this function failed.</error>
      <error code="NoData">No data is available for use.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>SubscribeAction</name>
    <category>Objects</category>
    <comment>Monitor action calls made against an object.</comment>
    <prototype>ERROR SubscribeAction(OBJECTPTR Object, LONG Action, FUNCTION * Callback)</prototype>
    <input>
      <param type="OBJECTPTR" name="Object">The target object.</param>
      <param type="LONG" name="Action">The ID of the action that will be monitored.  Methods are not supported.</param>
      <param type="FUNCTION *" name="Callback">A C/C++ function to callback when the action is triggered.</param>
    </input>
    <description>
<p>The SubscribeAction() function allows a client to receive a callback each time that an action is executed on an object.  This technique is referred to as "action monitoring" and is often used for responding to UI events and the termination of objects.</p>
<p>Subscriptions are context sensitive, so the Callback will execute in the space attributed to to the caller.</p>
<p>The following example illustrates how to listen to a Surface object's Redimension action and respond to resize events:</p>
<pre>auto callback = make_function_stdc(notify_resize);
SubscribeAction(surface, AC_Redimension, &amp;callback);
</pre>
<p>The template below illustrates how the Callback function should be constructed:</p>
<pre>void notify_resize(OBJECTPTR Object, ACTIONID Action, ERROR Result, APTR Parameters)
{
   auto Self = (objClassType *)CurrentContext();

   // Code here...
   if ((Result == ERR_Okay) and (Parameters)) {
      auto resize = (struct acRedimension *)Parameters;
   }
}
</pre>
<p>The Object is the original subscription target, as-is the Action ID.  The Result is the error code that was generated at the end of the action call.  If this is not set to <code>ERR_Okay</code>, assume that the action did not have an effect on state.  The Parameters are the original arguments provided by the client - be aware that these can legitimately be NULL even if an action specifies a required parameter structure.  Notice that because subscriptions are context sensitive, we can use <function module="Core">CurrentContext</function> to get a reference to the object that initiated the subscription.</p>
<p>To terminate an action subscription, use the <function module="Core">UnsubscribeAction</function> function.  Subscriptions are not resource tracked, so it is critical to match the original call with an unsubscription.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="Args">Invalid arguments passed to function.</error>
      <error code="OutOfRange">A specified number is outside of the valid range.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>SubscribeEvent</name>
    <category>Events</category>
    <comment>Subscribe to a system event.</comment>
    <prototype>ERROR SubscribeEvent(LARGE Event, FUNCTION * Callback, APTR Custom, APTR * Handle)</prototype>
    <input>
      <param type="LARGE" name="Event">An event identifier.</param>
      <param type="FUNCTION *" name="Callback">The function that will be subscribed to the event.</param>
      <param type="APTR" name="Custom">A custom pointer that will be sent to the callback function, set to NULL if not required.</param>
      <param type="APTR *" name="Handle">Pointer to an address that will receive the event handle.</param>
    </input>
    <description>
<p>Use the SubscribeEvent() function to listen for system events.  An EventID (obtainable from <function module="Core">GetEventID</function>) must be provided, as well as a reference to a function that will be called each time that the event is broadcast.</p>
<p>An event handle will be returned in the Handle parameter to identify the subscription.  This must be retained to later unsubscribe from the event with the <function module="Core">UnsubscribeEvent</function> function.</p>
<p>The format for the Callback function is <code>Function(APTR Custom, APTR Event, LONG Size)</code>, where 'Event' is the event structure that matches to the subscribed EventID.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="AllocMemory">A call to AllocMemory() failed to create a new memory block.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>SubscribeTimer</name>
    <category>System</category>
    <comment>Subscribes an object or function to the timer service.</comment>
    <prototype>ERROR SubscribeTimer(DOUBLE Interval, FUNCTION * Callback, APTR * Subscription)</prototype>
    <input>
      <param type="DOUBLE" name="Interval">The total number of seconds to wait between timer calls.</param>
      <param type="FUNCTION *" name="Callback">A callback function is required that will be called on each time cycle.</param>
      <param type="APTR *" name="Subscription">Optional.  The subscription will be assigned an identifier that is returned in this parameter.</param>
    </input>
    <description>
<p>This function creates a new timer subscription that will be called at regular intervals for the calling object.</p>
<p>A callback function must be provided that follows this prototype: <code>ERROR Function(OBJECTPTR Subscriber, LARGE Elapsed, LARGE CurrentTime)</code></p>
<p>The Elapsed parameter is the total number of microseconds that have elapsed since the last call.  The CurrentTime parameter is set to the <function module="Core">PreciseTime</function> value just prior to the Callback being called.  The callback function can return <code>ERR_Terminate</code> at any time to cancel the subscription.  All other error codes are ignored.  Fluid callbacks should call <code>check(ERR_Terminate)</code> to perform the equivalent of this behaviour.</p>
<p>To change the interval, call <function module="Core">UpdateTimer</function> with the new value.  To release a timer subscription, call <function module="Core">UpdateTimer</function> with the resulting SubscriptionID and an Interval of zero.</p>
<p>Timer management is provisioned by the <function module="Core">ProcessMessages</function> function.  Failure to regularly process incoming messages will lead to unreliable timer cycles.  It should be noted that the smaller the Interval that has been used, the more imperative regular message checking becomes.  Prolonged processing inside a timer routine can also impact on other timer subscriptions that are waiting to be processed.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="Args">Invalid arguments passed to function.</error>
      <error code="ArrayFull">Array has reached capacity and cannot be expanded.</error>
      <error code="SystemLocked">Part of the system is unreachable due to a persistent lock.</error>
      <error code="InvalidState">Object was in an incorrect state for the operation.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>UTF8CharLength</name>
    <category>Unicode</category>
    <comment>Returns the number of bytes used to define a single UTF-8 character.</comment>
    <prototype>LONG UTF8CharLength(CSTRING String)</prototype>
    <input>
      <param type="CSTRING" name="String">Pointer to a UTF-8 string.</param>
    </input>
    <description>
<p>This function will return the total number of bytes used to create a single UTF-8 character.  A pointer to the start of the character string that is to be analysed is required.</p>
    </description>
    <result type="LONG">Returns the number of bytes used to create the UTF-8 character referred to by the String argument.</result>
  </function>

  <function>
    <name>UTF8CharOffset</name>
    <category>Unicode</category>
    <comment>Retrieves the byte position of a character in a UTF-8 string.</comment>
    <prototype>LONG UTF8CharOffset(CSTRING String, LONG Offset)</prototype>
    <input>
      <param type="CSTRING" name="String">A null-terminated UTF-8 string.</param>
      <param type="LONG" name="Offset">The character number to translate to a byte offset.</param>
    </input>
    <description>
<p>Determines the true byte position of a character within a UTF-8 string, where Offset is a column number.</p>
    </description>
    <result type="LONG">Returns the byte offset of the character.</result>
  </function>

  <function>
    <name>UTF8Copy</name>
    <category>Unicode</category>
    <comment>Copies the characters of one string to another (UTF8).</comment>
    <prototype>LONG UTF8Copy(CSTRING Src, STRING Dest, LONG Chars, LONG Size)</prototype>
    <input>
      <param type="CSTRING" name="Src">Pointer to the source string.</param>
      <param type="STRING" name="Dest">Pointer to the destination buffer.</param>
      <param type="LONG" name="Chars">The maximum number of UTF8 characters to copy.  Can be set to COPY_ALL to copy up to the null terminator of the Src.</param>
      <param type="LONG" name="Size">Byte size of the destination buffer.</param>
    </input>
    <description>
<p>This function copies part of one string over to another.  If the Chars value is <code>COPY_ALL</code> then this function will copy the entire Src string to Dest.  If this function encounters the end of the Src string (null byte) while copying, it will terminate the output string at the same point and return.</p>
<p>Please note that the Dest string will <i>always</i> be null-terminated by this function regardless of the Chars valuae. For example, if <code>123</code> is copied into the middle of string <code>ABCDEFGHI</code> then the result would be <code>ABC123</code> and the <code>GHI</code> part of the string would be lost.</p>
    </description>
    <result type="LONG">Returns the total amount of &lt;i&gt;bytes&lt;/i&gt; that were copied, not including the null byte at the end.</result>
  </function>

  <function>
    <name>UTF8Length</name>
    <category>Unicode</category>
    <comment>Returns the total number of characters in a UTF-8 string.</comment>
    <prototype>LONG UTF8Length(CSTRING String)</prototype>
    <input>
      <param type="CSTRING" name="String">Pointer to a UTF-8 string.</param>
    </input>
    <description>
<p>This function will return the total number of decoded unicode characters in a UTF-8 string.</p>
    </description>
    <result type="LONG">Returns the total number of characters used in the supplied UTF-8 string.</result>
  </function>

  <function>
    <name>UTF8OffsetToChar</name>
    <category>Unicode</category>
    <comment>Converts a byte offset into a character position.</comment>
    <prototype>LONG UTF8OffsetToChar(CSTRING String, LONG Offset)</prototype>
    <input>
      <param type="CSTRING" name="String">A null-terminated UTF-8 string.</param>
      <param type="LONG" name="Offset">The byte offset that you need a character number for.</param>
    </input>
    <description>
<p>This function will convert a byte position in a UTF-8 string to its character column number.</p>
    </description>
    <result type="LONG">Returns the number of the character at the given byte position.</result>
  </function>

  <function>
    <name>UTF8PrevLength</name>
    <category>Unicode</category>
    <comment>Gets the byte length of the previous character at a specific position in a UTF-8 string.</comment>
    <prototype>LONG UTF8PrevLength(CSTRING String, LONG Offset)</prototype>
    <input>
      <param type="CSTRING" name="String">Pointer to a UTF-8 string.</param>
      <param type="LONG" name="Offset">The byte index from which the size of the previous character should be calculated.</param>
    </input>
    <description>
<p>This function calculates the byte-length of the previous character in a string, from an initial position given by Offset.</p>
    </description>
    <result type="LONG">Returns the byte-length of the previous character.</result>
  </function>

  <function>
    <name>UTF8ReadValue</name>
    <category>Unicode</category>
    <comment>Converts UTF-8 characters into 32-bit unicode values.</comment>
    <prototype>ULONG UTF8ReadValue(CSTRING String, LONG * Length)</prototype>
    <input>
      <param type="CSTRING" name="String">Pointer to a character in a UTF-8 string that you want to convert.</param>
      <param type="LONG *" name="Length">Optional argument that will store the resulting number of bytes that make up the UTF-8 character.</param>
    </input>
    <description>
<p>This function converts UTF-8 character strings into 32-bit unicode values.  To determine how many bytes were used in making up the UTF-8 character, set the Length argument so that the function can return the total number of bytes.</p>
    </description>
    <result type="ULONG">Returns the extracted unicode value.  If a failure occurs (the encoding is invalid) then a value of zero is returned. Zero can also be returned if the String parameter is NULL or begins with a null character.</result>
  </function>

  <function>
    <name>UTF8ValidEncoding</name>
    <category>Unicode</category>
    <comment>Corrects invalid UTF-8 encodings and converts string encodings to UTF-8.</comment>
    <prototype>CSTRING UTF8ValidEncoding(CSTRING String, CSTRING Encoding)</prototype>
    <input>
      <param type="CSTRING" name="String">The string to be validated.</param>
      <param type="CSTRING" name="Encoding">The encoding that should be tried for invalid UTF-8 characters.  Set to zero if the encoding is unknown (the system default will be used if the encoding cannot be determined).</param>
    </input>
    <description>
<p>This function recovers strings that should be in UTF-8 format but could contain characters from another type of character encoding.  Such uncertainty can occur - for example - when file names in a filesystem are expected to be in UTF-8 format by default, but there is no absolute guarantee that this rule has been followed by the user or the installed programs.</p>
<p>When processing the String, any non-UTF8 characters are converted from the given Encoding into UTF-8 format.  Any invalid characters will be converted to a unicode value of 0xfffd.</p>
<p>Conversion support is provided by the iconv library.  The following encodings are supported:</p>
<types>
<type name="European">ASCII, ISO-8859-{1,2,3,4,5,7,9,10,13,14,15,16}, KOI8-R, KOI8-U, KOI8-RU, CP{1250,1251,1252,1253,1254,1257}, CP{850,866}, Mac{Roman,CentralEurope,Iceland,Croatian,Romania}, Mac{Cyrillic,Ukraine,Greek,Turkish}, Macintosh, CP{437,737,775,852,853,855,857,858,860,861,863,865,869,1125}</type>
<type name="Semitic">ISO-8859-{6,8}, CP{1255,1256}, CP862, Mac{Hebrew,Arabic}, CP864</type>
<type name="Japanese">EUC-JP, SHIFT_JIS, CP932, ISO-2022-JP, ISO-2022-JP-2, ISO-2022-JP-1, EUC-JISX0213, Shift_JISX0213, ISO-2022-JP-3</type>
<type name="Chinese">EUC-CN, HZ, GBK, GB18030, EUC-TW, BIG5, CP950, BIG5-HKSCS, ISO-2022-CN, ISO-2022-CN-EXT</type>
<type name="Korean">EUC-KR, CP949, ISO-2022-KR, JOHAB</type>
<type name="Armenian">ARMSCII-8</type>
<type name="Georgian">Georgian-Academy, Georgian-PS</type>
<type name="Tajik">KOI8-T</type>
<type name="Thai">TIS-620, CP874, MacThai</type>
<type name="Laotian">MuleLao-1, CP1133</type>
<type name="Vietnamese">VISCII, TCVN, CP1258</type>
<type name="Platform specifics">HP-ROMAN8, NEXTSTEP</type>
<type name="Full Unicode">UTF-8 UCS-2, UCS-2BE, UCS-2LE UCS-4, UCS-4BE, UCS-4LE, UTF-16, UTF-16BE, UTF-16LE, UTF-32, UTF-32BE, UTF-32LE, UTF-7, C99, JAVA, UCS-2-INTERNAL, UCS-4-INTERNAL</type>
<type name="Locale Dependent">char, wchar_t</type>
<type name="Turkmen">TDS565</type>
</types>
    </description>
    <result type="CSTRING">Returns the original string pointer if it is already valid, otherwise a converted string is returned.  The converted string remains valid up until the next call to UTF8ValidEncoding().  A return of NULL is possible if an internal error occurs during the conversion process (e.g. invalid encoding type).</result>
  </function>

  <function>
    <name>UTF8WriteValue</name>
    <category>Unicode</category>
    <comment>Writes a 32-bit unicode value into a UTF-8 character buffer.</comment>
    <prototype>LONG UTF8WriteValue(LONG Value, STRING Buffer, LONG Size)</prototype>
    <input>
      <param type="LONG" name="Value">A 32-bit unicode value.</param>
      <param type="STRING" name="Buffer">Pointer to a string buffer that will hold the UTF-8 characters.</param>
      <param type="LONG" name="Size">The size of the destination string buffer (does not need to be any larger than 6 bytes).</param>
    </input>
    <description>
<p>This function is used to write out unicode values in UTF-8 string format.  You need to provide a string buffer, keeping in mind that anything from 1 to 6 bytes may be written to the buffer, depending on the size of the unicode value.</p>
<p>If the buffer is not large enough to hold the UTF-8 string then the function will do nothing and return a value of zero.  Otherwise, the character will be written and the total number of bytes used will be returned.</p>
<p>This function will not add a null terminator to the end of the UTF-8 string.</p>
    </description>
    <result type="LONG">Returns the total amount of characters written to the string buffer.</result>
  </function>

  <function>
    <name>UnloadFile</name>
    <category>Files</category>
    <comment>Unloads files from the file cache.</comment>
    <prototype>void UnloadFile(struct CacheFile * Cache)</prototype>
    <input>
      <param type="struct CacheFile *" name="Cache">A pointer to a CacheFile structure returned from LoadFile().</param>
    </input>
    <description>
<p>This function unloads cached files that have been previously loaded with the <function module="Core">LoadFile</function> function.</p>
    </description>
  </function>

  <function>
    <name>UnlockMutex</name>
    <category>Locks</category>
    <comment>Release a locked mutex.</comment>
    <prototype>void UnlockMutex(APTR Mutex)</prototype>
    <input>
      <param type="APTR" name="Mutex">Reference to a locked mutex.</param>
    </input>
    <description>
<p>This function will unlock any mutex that has been locked with the <function module="Core">LockMutex</function> function.  If the mutex is nested, this function must be called enough times to match the calls to <function module="Core">LockMutex</function> before it will be released to other processes.</p>
<p>If the target mutex has no lock, or if the lock belongs to another thread, the resulting behaviour is undefined and may result in an exception.</p>
    </description>
  </function>

  <function>
    <name>UnlockSharedMutex</name>
    <category>Locks</category>
    <comment>Release a locked mutex.</comment>
    <prototype>void UnlockSharedMutex(APTR Mutex)</prototype>
    <input>
      <param type="APTR" name="Mutex">Reference to a locked mutex.</param>
    </input>
    <description>
<p>This function will unlock any mutex that has been locked with the <function module="Core">LockSharedMutex</function> function.  As shared mutexes are nested, this function must be called enough times to match the calls to <function module="Core">LockSharedMutex</function> before it will be released to other processes.</p>
<p>If the target mutex has no lock, or if the lock belongs to another thread, the resulting behaviour is undefined and may result in an exception.</p>
    </description>
  </function>

  <function>
    <name>UnsubscribeAction</name>
    <category>Objects</category>
    <comment>Terminates action subscriptions.</comment>
    <prototype>ERROR UnsubscribeAction(OBJECTPTR Object, LONG Action)</prototype>
    <input>
      <param type="OBJECTPTR" name="Object">The object that you are unsubscribing from.</param>
      <param type="LONG" name="Action" lookup="AC">The ID of the action that will be unsubscribed, or zero for all actions.</param>
    </input>
    <description>
<p>The UnsubscribeAction() function will terminate subscriptions made by <function module="Core">SubscribeAction</function>.</p>
<p>To terminate multiple subscriptions in a single call, set the Action parameter to zero.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="Args">Invalid arguments passed to function.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>UnsubscribeEvent</name>
    <category>Events</category>
    <comment>Removes an event subscription.</comment>
    <prototype>void UnsubscribeEvent(APTR Event)</prototype>
    <input>
      <param type="APTR" name="Event">An event handle returned from SubscribeEvent()</param>
    </input>
    <description>
<p>Use UnsubscribeEvent() to remove an existing event subscription.  A valid handle returned from the <function module="Core">SubscribeEvent</function> function must be provided.</p>
    </description>
  </function>

  <function>
    <name>UpdateMessage</name>
    <category>Messages</category>
    <comment>Updates the data of any message that is queued.</comment>
    <prototype>ERROR UpdateMessage(APTR Queue, LONG Message, LONG Type, APTR Data, LONG Size)</prototype>
    <input>
      <param type="APTR" name="Queue">Must refer to the target message queue.</param>
      <param type="LONG" name="Message">The ID of the message that will be updated.</param>
      <param type="LONG" name="Type">Defines the type of the message.  If set to -1, the message will be deleted.</param>
      <param type="APTR" name="Data">Pointer to a buffer that contains the new data for the message.</param>
      <param type="LONG" name="Size">The byte-size of the buffer that has been supplied.  It must not exceed the size of the message that is being updated.</param>
    </input>
    <description>
<p>The UpdateMessage() function provides a facility for updating the content of existing messages on a queue.  You are required to know the ID of the message that will be updated and need to provide the new message Type and/or Data to set against the message.</p>
<p>Messages can be deleted from the queue by setting the Type to -1.  There is no need to provide buffer information when deleting a message.</p>
<p>If you supply a data buffer, then its size should equal that of the data already set against the message.  The size will be trimmed if it exceeds that of the existing message, as this function cannot expand the size of the queue.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="Search">A search routine in this function failed.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>UpdateTimer</name>
    <category>System</category>
    <comment>Modify or remove a subscription created by SubscribeTimer().</comment>
    <prototype>ERROR UpdateTimer(APTR Subscription, DOUBLE Interval)</prototype>
    <input>
      <param type="APTR" name="Subscription">The timer subscription to modify.</param>
      <param type="DOUBLE" name="Interval">The new interval for the timer (measured in seconds), or zero to remove.</param>
    </input>
    <description>
<p>This function complements <function module="Core">SubscribeTimer</function>.  It can change the interval for an existing timer subscription, or remove it if the Interval is set to zero.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="Search">A search routine in this function failed.</error>
      <error code="SystemLocked">Part of the system is unreachable due to a persistent lock.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>WaitForObjects</name>
    <category>Messages</category>
    <comment>Process incoming messages while waiting on objects to complete their activities.</comment>
    <prototype>ERROR WaitForObjects(PMF Flags, LONG TimeOut, struct ObjectSignal * ObjectSignals)</prototype>
    <input>
      <param type="PMF" name="Flags" lookup="PMF">Optional flags are specified here (clients should set a value of zero).</param>
      <param type="LONG" name="TimeOut">A time-out value measured in milliseconds.  If this value is negative then no time-out applies and the function will not return until an incoming message or signal breaks it.</param>
      <param type="struct ObjectSignal *" name="ObjectSignals">A null-terminated array of objects to monitor for signals.</param>
    </input>
    <description>
<p>The WaitForObjects() function acts as a front-end to <function module="Core">ProcessMessages</function>, with the capability of being able to wait for a series of objects that must signal an end to their activities.  An object can be signalled via the Signal() action. Termination of a monitored object is also treated as a signal.  The function will return once ALL of the objects are signalled or a time-out occurs.</p>
<p>Note that if an object has been signalled prior to entry to this function, its signal flag will be cleared and the object will not be monitored.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="Failed">General failure.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
      <error code="Recursion">Detected a recursive function call.</error>
      <error code="OutsideMainThread">An operation has been attempted that is only possible from within the main thread.</error>
    </result>
  </function>

  <function>
    <name>WaitTime</name>
    <category>System</category>
    <comment>Waits for a specified amount of seconds and/or microseconds.</comment>
    <prototype>void WaitTime(LONG Seconds, LONG MicroSeconds)</prototype>
    <input>
      <param type="LONG" name="Seconds">The number of seconds to wait for.</param>
      <param type="LONG" name="MicroSeconds">The number of microseconds to wait for.  Please note that a microsecond is one-millionth of a second - 1/1000000.  The value cannot exceed 999999.</param>
    </input>
    <description>
<p>This function waits for a period of time as specified by the Seconds and MicroSeconds arguments.  While waiting, your task will continue to process incoming messages in order to prevent the process' message queue from developing a back-log.</p>
<p>WaitTime() can return earlier than the indicated timeout if a message handler returns <code>ERR_Terminate</code>, or if a <code>MSGID_QUIT</code> message is sent to the task's message queue.</p>
    </description>
  </function>

  <types>
    <constants lookup="AC" comment="Action identifiers.">
      <const name="Activate"/>
      <const name="Clear"/>
      <const name="Clipboard"/>
      <const name="CopyData"/>
      <const name="Custom"/>
      <const name="DataFeed"/>
      <const name="Deactivate"/>
      <const name="Disable"/>
      <const name="DragDrop"/>
      <const name="Draw"/>
      <const name="END"/>
      <const name="Enable"/>
      <const name="Flush"/>
      <const name="Focus"/>
      <const name="Free"/>
      <const name="FreeWarning"/>
      <const name="GetVar"/>
      <const name="Hide"/>
      <const name="Init"/>
      <const name="Lock"/>
      <const name="LostFocus"/>
      <const name="Move"/>
      <const name="MoveToBack"/>
      <const name="MoveToFront"/>
      <const name="MoveToPoint"/>
      <const name="NewChild"/>
      <const name="NewObject"/>
      <const name="NewOwner"/>
      <const name="Next"/>
      <const name="Prev"/>
      <const name="Query"/>
      <const name="Read"/>
      <const name="Redimension"/>
      <const name="Redo"/>
      <const name="Refresh"/>
      <const name="Rename"/>
      <const name="Reset"/>
      <const name="Resize"/>
      <const name="SaveImage"/>
      <const name="SaveSettings"/>
      <const name="SaveToObject"/>
      <const name="Scroll"/>
      <const name="ScrollToPoint"/>
      <const name="Seek"/>
      <const name="SelectArea"/>
      <const name="SetField"/>
      <const name="SetVar"/>
      <const name="Show"/>
      <const name="Signal"/>
      <const name="Sort"/>
      <const name="Undo"/>
      <const name="Unlock"/>
      <const name="Write"/>
    </constants>

    <constants lookup="ALF">
      <const name="RECURSIVE">Set if support for recursive locking within the same thread is required.</const>
      <const name="SHARED">The lock will be shared between foreign processes.</const>
    </constants>

    <constants lookup="ALIGN" comment="Universal values for alignment of graphics and text">
      <const name="BOTTOM">Align to bottom</const>
      <const name="CENTER">Synonym for HORIZONTAL | VERTICAL</const>
      <const name="HORIZONTAL">Align to horizontal center</const>
      <const name="LEFT">Align to left</const>
      <const name="MIDDLE">Synonym for HORIZONTAL | VERTICAL</const>
      <const name="RIGHT">Align to right</const>
      <const name="TOP">Align to top</const>
      <const name="VERTICAL">Align to vertical center</const>
    </constants>

    <constants lookup="CCF" comment="Class categories">
      <const name="AUDIO">Audio classes interface with audio hardware and drivers for audio playback and recording purposes.</const>
      <const name="COMMAND">Command classes perform specific procedures, like copying or moving a file, managing volumes or executing a program.</const>
      <const name="DATA">Data classes parse, query and manipulate data.</const>
      <const name="DRAWABLE">Drawable classes provide graphical areas that are designed to be drawn to.</const>
      <const name="EFFECT">Effect classes draw graphics and/or play audio for non-productive demonstration purposes.</const>
      <const name="FILESYSTEM">FileSystem classes are based on file management and interaction with file based data.</const>
      <const name="GRAPHICS">Graphics classes provide graphical manipulation and drawing services to developers.</const>
      <const name="GUI">GUI classes are used in the development of graphical user interfaces.</const>
      <const name="IO">IO classes manage hardware and software based input and output.</const>
      <const name="MISC">Miscellaneous classes do not fit into any of the other available categories.</const>
      <const name="MULTIMEDIA"/>
      <const name="NETWORK">Network classes interface with network drivers to simplify network communications for the developer.</const>
      <const name="SYSTEM">System classes are designed to provide low-level services related to system management.</const>
      <const name="TOOL">Tool classes are focussed on providing interactive services to the user.</const>
    </constants>

    <constants lookup="CF" comment="Compression stream formats">
      <const name="DEFLATE">The 'deflate' format</const>
      <const name="GZIP">The 'gzip' format</const>
      <const name="ZLIB">The 'zlib' format</const>
    </constants>

    <constants lookup="CLF" comment="Flags for the MetaClass.">
      <const name="NO_OWNERSHIP">Objects created will not be tracked to the creating process, nor any parent object (SetOwner() will not work either).</const>
      <const name="PROMOTE_INTEGRAL">Promote class support for any integral object defined in the class definition structure.</const>
    </constants>

    <constants lookup="CLIPMODE" comment="Clipboard modes">
      <const name="COPY">Copy from the clipboard.</const>
      <const name="CUT">Cut from the clipboard.</const>
      <const name="PASTE">Paste from the clipboard.</const>
    </constants>

    <constants lookup="CMF" comment="Compression flags">
      <const name="APPLY_SECURITY">When decompressing, apply individual file permissions if they are available in the compression file.</const>
      <const name="CREATE_FILE">Create a new archive only if the source file does not already exist.</const>
      <const name="NEW">Force the creation of a new file archive.  Any existing file data at the target location will be destroyed.</const>
      <const name="NO_LINKS">Treat symbolic links as normal files/folders.</const>
      <const name="PASSWORD">A password has been set on the object.</const>
      <const name="READ_ONLY">Forces read-only access, which is strongly recommended if an existing archive is being opened with no modifications intended.  If this flag is not set, initialisation can fail if the user does not have write access to the source file.</const>
    </constants>

    <constants lookup="CNF" comment="Flags for the Config class.">
      <const name="AUTO_SAVE">When the configuration object is freed, automatically save the configuration data back to the original file source.</const>
      <const name="NEW">On initialisation, do not load any data from the referenced configuration file.</const>
      <const name="OPTIONAL_FILES">Files are optional (do not fail if a requested file does not exist).</const>
      <const name="STRIP_QUOTES">Removes quotes from key values that are quote-encapsulated.</const>
    </constants>

    <constants lookup="DATA" comment="Data codes">
      <const name="AUDIO">Audio file data, recognised by the Sound class</const>
      <const name="CONTENT">Document content (between XML tags) - sent by document objects only</const>
      <const name="DEVICE_INPUT">Device activity</const>
      <const name="FILE">File location (the data will reflect the complete file path)</const>
      <const name="IMAGE">Image file data, recognised by the Image class</const>
      <const name="INPUT_READY">Device input that has been transformed into user input</const>
      <const name="RAW">Raw unprocessed data</const>
      <const name="RECEIPT">Receipt for item data, in response to an earlier request</const>
      <const name="RECORD">Database record</const>
      <const name="REQUEST">Make a request for item data</const>
      <const name="TEXT">Standard ASCII text</const>
      <const name="XML">Markup based text data.  NOTE - For clipboard data, the top-level encapsulating tag must declare the type of XML, e.g. 'html', 'ripple'.  For plain XML, use 'xml'</const>
    </constants>

    <constants lookup="DEVICE">
      <const name="COMPACT_DISC">Compact disc style device</const>
      <const name="FLOPPY_DISK">Floppy disk style device</const>
      <const name="HARD_DISK">Hard disk style device</const>
      <const name="MEMORY">Device is RAM, ROM, WORM, NVRAM, flashdisk or other form of memory.  Does not guarantee a fast connection as it could be over a slow USB 1.1 connection for example</const>
      <const name="MODEM">Device is a modem.</const>
      <const name="NETWORK">Device represents a network link</const>
      <const name="PRINTER">Device is a paper-based printer.</const>
      <const name="PRINTER_3D">Device is a three dimensional printer.</const>
      <const name="READ">Device is readable</const>
      <const name="REMOVABLE">Device media is removable from the hardware</const>
      <const name="REMOVEABLE">Device media is removable from the hardware</const>
      <const name="SCANNER">Device is a two dimensional scanner.</const>
      <const name="SCANNER_3D">Device is a three dimensional scanner.</const>
      <const name="SOFTWARE">Device is virtual/software defined</const>
      <const name="TAPE">Tape/Stream style device</const>
      <const name="TEMPORARY">All storage is temporary</const>
      <const name="USB">Removable USB storage device.  May be further qualified by DEVICE_HARDDISK, DEVICE_FLOPPYDISK etc</const>
      <const name="WRITE">Device is writeable</const>
    </constants>

    <constants lookup="DMF">
      <const name="FIXED_CENTER_X">The CenterX field is a fixed size.</const>
      <const name="FIXED_CENTER_Y">The CenterY field is a fixed size.</const>
      <const name="FIXED_DEPTH">The Depth field is a fixed size.</const>
      <const name="FIXED_HEIGHT">The Height field is a fixed size.</const>
      <const name="FIXED_RADIUS">Synonym for FIXED_RADIUS_X | FIXED_RADIUS_Y</const>
      <const name="FIXED_RADIUS_X">The RadiusX field is a fixed size.</const>
      <const name="FIXED_RADIUS_Y">The RadiusY field is a fixed size.</const>
      <const name="FIXED_WIDTH">The Width field is a fixed suze.</const>
      <const name="FIXED_X">The X field is a fixed coordinate.</const>
      <const name="FIXED_X_OFFSET">The XOffset field is a fixed coordinate.</const>
      <const name="FIXED_Y">The Y field is a fixed coordinate.</const>
      <const name="FIXED_Y_OFFSET">The YOffset field is a fixed coordinate.</const>
      <const name="FIXED_Z">The Z field is a fixed coordinate.</const>
      <const name="HEIGHT">Synonym for FIXED_HEIGHT | RELATIVE_HEIGHT</const>
      <const name="HEIGHT_FLAGS">Synonym for FIXED_HEIGHT | RELATIVE_HEIGHT | FIXED_Y_OFFSET | RELATIVE_Y_OFFSET</const>
      <const name="HORIZONTAL_FLAGS">Synonym for FIXED_WIDTH | RELATIVE_WIDTH | FIXED_X_OFFSET | RELATIVE_X_OFFSET | FIXED_X | RELATIVE_X</const>
      <const name="RELATIVE_CENTER_X">The CenterX field is a relative size to this object's parent.</const>
      <const name="RELATIVE_CENTER_Y">The CenterY field is a relative size to this object's parent.</const>
      <const name="RELATIVE_DEPTH">The Depth field is a relative size to this object's parent.</const>
      <const name="RELATIVE_HEIGHT">The Height field is relative to this object's parent.</const>
      <const name="RELATIVE_RADIUS">Synonym for RELATIVE_RADIUS_X | RELATIVE_RADIUS_Y</const>
      <const name="RELATIVE_RADIUS_X">The RadiusX field is a relative size to this object's parent.</const>
      <const name="RELATIVE_RADIUS_Y">The RadiusY field is a relative size to this object's parent.</const>
      <const name="RELATIVE_WIDTH">The Width field is relative to this object's parent.</const>
      <const name="RELATIVE_X">The X field is relative to this object's parent.</const>
      <const name="RELATIVE_X_OFFSET">The XOffset field is relative to this object's parent.</const>
      <const name="RELATIVE_Y">The Y field is relative to this object's parent.</const>
      <const name="RELATIVE_Y_OFFSET">The YOffset field is relative to this object's parent.</const>
      <const name="RELATIVE_Z">The Z field is a relative coordinate to this object's parent.</const>
      <const name="STATUS_CHANGE">Synonym for STATUS_CHANGE_H | STATUS_CHANGE_V</const>
      <const name="STATUS_CHANGE_H"/>
      <const name="STATUS_CHANGE_V"/>
      <const name="VERTICAL_FLAGS">Synonym for FIXED_HEIGHT | RELATIVE_HEIGHT | FIXED_Y_OFFSET | RELATIVE_Y_OFFSET | FIXED_Y | RELATIVE_Y</const>
      <const name="WIDTH">Synonym for FIXED_WIDTH | RELATIVE_WIDTH</const>
      <const name="WIDTH_FLAGS">Synonym for FIXED_WIDTH | RELATIVE_WIDTH | FIXED_X_OFFSET | RELATIVE_X_OFFSET</const>
      <const name="X">Synonym for FIXED_X | RELATIVE_X</const>
      <const name="X_OFFSET">Synonym for FIXED_X_OFFSET | RELATIVE_X_OFFSET</const>
      <const name="Y">Synonym for FIXED_Y | RELATIVE_Y</const>
      <const name="Y_OFFSET">Synonym for FIXED_Y_OFFSET | RELATIVE_Y_OFFSET</const>
    </constants>

    <constants lookup="DRL" comment="Compass directions.">
      <const name="EAST"/>
      <const name="NORTH"/>
      <const name="NORTH_EAST"/>
      <const name="NORTH_WEST"/>
      <const name="SOUTH"/>
      <const name="SOUTH_EAST"/>
      <const name="SOUTH_WEST"/>
      <const name="WEST"/>
    </constants>

    <constants lookup="EDGE" comment="Edge flags">
      <const name="ALL"/>
      <const name="BOTTOM"/>
      <const name="BOTTOM_LEFT"/>
      <const name="BOTTOM_RIGHT"/>
      <const name="LEFT"/>
      <const name="RIGHT"/>
      <const name="TOP"/>
      <const name="TOP_LEFT"/>
      <const name="TOP_RIGHT"/>
    </constants>

    <constants lookup="EVG" comment="Event categories.">
      <const name="ANDROID">Android specific events that do not already fit existing categories.</const>
      <const name="APP">Custom event dispatched from an application</const>
      <const name="AUDIO">Audio system events.</const>
      <const name="CLASS">Custom event dispatched from a class that doesn't fit within the rest of the event framework</const>
      <const name="DISPLAY">Video display events.</const>
      <const name="FILESYSTEM">File system events.</const>
      <const name="GUI">Events generated by the Graphical User Interface.</const>
      <const name="HARDWARE">Hardware device events that are not covered by other types.</const>
      <const name="IO">Input/Output events.</const>
      <const name="NETWORK">Network events.</const>
      <const name="POWER">Power Management - can also include app-specific events relating to resource management.</const>
      <const name="SYSTEM">System-wide events</const>
      <const name="USER">User activity events (such as user login).</const>
    </constants>

    <constants lookup="FBK" comment="Flags for file feedback.">
      <const name="COPY_FILE">A file is to be, or has been copied.</const>
      <const name="DELETE_FILE">A file is to be, or has been deleted.</const>
      <const name="MOVE_FILE">A file is to be, or has been moved.</const>
    </constants>

    <constants lookup="FD" comment="Field descriptors.">
      <const name="ALLOC">CLASSDEF Indicates the returned value is a dynamic allocation that needs to be manually freed (by default is a memory pointer, can be an object if combined with FD_OBJECT)</const>
      <const name="ARRAY">Indicates an array of values.  Follow with ARRAYSIZE if used in a function.</const>
      <const name="ARRAYSIZE">FUNCDEF Overrides FD_LOOKUP.  Pair with ARRAY to indicate total elements in the array.  It is preferred that any null terminator is not counted.  If ARRAYSIZE not specified, ARRAY must be null-terminated.</const>
      <const name="BUFFER">FUNCDEF Overrides FD_WRITE.  Indicates a buffer that can be filled with data by the function if paired with RESULT; must be paired with BUFSIZE in second argument.</const>
      <const name="BUFSIZE">FUNCDEF Overrides FD_LOOKUP.  Pair with BUFFER to indicate the byte size of the buffer memory.</const>
      <const name="BYTE">8 bit integer.</const>
      <const name="CPP">Use the C++ variant of the indicated type, e.g. ARRAY is a std::vector.</const>
      <const name="CUSTOM"/>
      <const name="DOUBLE">64 bit float.</const>
      <const name="DOUBLERESULT">For actions and methods</const>
      <const name="ERROR">FUNCDEF</const>
      <const name="FLAGS">CLASSDEF</const>
      <const name="FLOAT">32 bit float.  Not valid for use in class definitions.</const>
      <const name="FUNCTION">Intended for callbacks, uses the rkFunction structure.</const>
      <const name="FUNCTIONPTR">Synonym for PTR | FUNCTION</const>
      <const name="I">Synonym for INIT</const>
      <const name="INIT">CLASSDEF</const>
      <const name="INTEGRAL">CLASSDEF Pointer to an object that is integral to the class</const>
      <const name="LARGE">64 bit integer.</const>
      <const name="LARGERESULT">For actions and methods</const>
      <const name="LONG">32 bit integer.</const>
      <const name="LONGRESULT">For actions and methods</const>
      <const name="LOOKUP">CLASSDEF</const>
      <const name="OBJECT">Supplementary, can be used with longs (for IDs) or pointers</const>
      <const name="OBJECTID">Synonym for LONG | OBJECT</const>
      <const name="OBJECTPTR">Synonym for PTR | OBJECT</const>
      <const name="PERCENTAGE">Supplementary, indicates integer or float value is a percentage.</const>
      <const name="POINTER">Pointer (32 or 64 bit).</const>
      <const name="PRIVATE">Synonym for SYSTEM</const>
      <const name="PTR">Synonym for POINTER</const>
      <const name="PTRBUFFER">The next argument should be LONG|BUFSIZE</const>
      <const name="PTRRESULT">Use for pointer-based value results only</const>
      <const name="PTRSIZE">Synonym for BUFSIZE</const>
      <const name="PTR_DOUBLERESULT">Use for pointer-based value results only.</const>
      <const name="PTR_LARGERESULT">Use for pointer-based value results only.</const>
      <const name="PTR_LONGRESULT">Use for pointer-based value results only.</const>
      <const name="R">Synonym for READ</const>
      <const name="READ">CLASSDEF</const>
      <const name="REQUIRED">CLASSDEF The field must be defined by the client prior to object initialisation.</const>
      <const name="RESOURCE">The referenced struct or pointer is a special resource.  Changes some behaviours, e.g. a resourced struct will use direct value references rather than being copied in Fluid.</const>
      <const name="RESULT">FUNCDEF Overrides FD_READ</const>
      <const name="RGB">Supplementary, if a long type then format is 0xAARRGGBB, if pointer then refers to an RGB structure.</const>
      <const name="RI">Synonym for READ | INIT</const>
      <const name="RW">Synonym for READ | WRITE</const>
      <const name="STR">Synonym for STRING</const>
      <const name="STRING">Pointer to a string.</const>
      <const name="STRRESULT">Synonym for STR | RESULT</const>
      <const name="STRUCT">Supplementary, defines the field as a structure reference.  MUST be combined with FD_POINTER.  If used in a class, it is possible to name the structure definition in field-&gt;Arg</const>
      <const name="SYNONYM">CLASSDEF Use to declare fields that duplicate the functionality of another field.</const>
      <const name="SYSTEM">CLASSDEF System, internal and private fields.</const>
      <const name="TAGS">FUNCDEF Overrides FD_INIT</const>
      <const name="UNSIGNED">Supplementary, integer value is unsigned.</const>
      <const name="VARIABLE">Supports multiple primitive types (long, double, large or pointer).</const>
      <const name="VARTAGS">FUNCDEF Overrides FD_FLAGS.  Use for 64-bit taglists that require value definitions, e.g. TDOUBLE, TLONG etc.</const>
      <const name="VIRTUAL">CLASSDEF Ensures that the field has no physical representation in the structure.</const>
      <const name="VOID"/>
      <const name="VOLATILE">[Not yet allocated a bit]  Used on result pointers, usually strings, to indicate that the consecutive reads will overwrite the content of previous return values.  This indicates to scripting languages to make a copy of the data before the next interaction with the object.</const>
      <const name="W">Synonym for WRITE</const>
      <const name="WORD">16 bit integer.</const>
      <const name="WRITE">CLASSDEF</const>
    </constants>

    <constants lookup="FDB" comment="Feedback event indicators.">
      <const name="COMPRESS_FILE"/>
      <const name="DECOMPRESS_FILE"/>
      <const name="DECOMPRESS_OBJECT"/>
      <const name="REMOVE_FILE"/>
    </constants>

    <constants lookup="FDL" comment="Options for the File Delete() method.">
      <const name="FEEDBACK">Automatically manage user feedback for deleting files by presenting dialog boxes.</const>
    </constants>

    <constants lookup="FDT" comment="Flags for the SetDate() file method.">
      <const name="ACCESSED">The date on which the file was last accessed by a user or application.</const>
      <const name="ARCHIVED">The date on which the file was most recently archived.  Not supported by most filesystems.</const>
      <const name="CREATED">The date on which the file was created.  On some host platforms this datestamp may be read-only.</const>
      <const name="MODIFIED">The date on which the file was last modified.</const>
    </constants>

    <constants lookup="FFR" comment="Return codes available to the feedback routine">
      <const name="ABORT">Abort the entire operation.</const>
      <const name="OKAY">Continue processing uninterrupted.</const>
      <const name="SKIP">Skip processing of this entity.</const>
    </constants>

    <constants lookup="FL" comment="File flags">
      <const name="APPROXIMATE">Allows fuzzy matching of the file path when opening an existing file.  This means that the file extension will be ignored; for instance attempting to open a file of 'screenshot.png' when only a file name of 'screenshot.jpg' exists in the same folder, the 'screenshot.jpg' file will be opened instead.  If multiple files could potentially match to the file name, the file object will select the first match that is encountered.</const>
      <const name="BUFFER">Activates a special mode in which the file data is stored in a memory buffer rather than a disk file.  Set the Size field to a value of at least 1 so that the initial buffer size is configured.  In this mode many of the available file operations are meaningless except for the Read, Write and Seek actions.</const>
      <const name="DEVICE">The file is a system device (must set if opening a device for read/write operations)</const>
      <const name="DIRECTORY">The file object represents a folder.</const>
      <const name="EXCLUDE_FILES">Exclude files when scanning this folder.</const>
      <const name="EXCLUDE_FOLDERS">Exclude folders when scanning this folder.</const>
      <const name="FILE">Explicitly declares the file object as an entity that stores content (as opposed to a device or folder for example).</const>
      <const name="FOLDER">The file object represents a folder.</const>
      <const name="LINK">Read-Only.  Indicates that the file is a symbolic link or shortcut to another file.</const>
      <const name="LOOP">In loop mode, the file object's position marker for read/write operations is allowed to extend past the actual file size.  Any read/write operation beyond the file size will loop back to the file at a corrected offset - for example, reading position 330 of a 100 byte file will start the operation from the 30th byte.  Loop mode does not affect any other area besides the read, write and seek operations.  The loop feature is typically used to create multimedia data streams with minimal effort.</const>
      <const name="NEW">Required when creating a new file.  If a file with the same name exists, its contents will be destroyed. If however the existing file is locked, the initalisation process will fail.</const>
      <const name="READ">Required if the file needs to be opened for read access.</const>
      <const name="RESET_DATE">For internal use only</const>
      <const name="STREAM">File data is streamed (e.g. PIPE, FIFO, socket) and may be accessed locally or via a network.</const>
      <const name="WRITE">Prepares a file for writing data, starting at byte position 0.  To start writing from the end of a file, use the Seek action after the file has been initialised.</const>
    </constants>

    <constants lookup="FOF" comment="Flags that can be passed to FindObject()">
      <const name="SMART_NAMES">Parse numeric object names as ID references and support use of the 'Owner' reserved keyword.</const>
    </constants>

    <constants lookup="IDTYPE" comment="Types for AllocateID()">
      <const name="FUNCTION">Function ID's are used to track FUNCTION types and are assigned to the function ID field.</const>
      <const name="GLOBAL">Global ID's have no specific association with anything.</const>
      <const name="MESSAGE">Message ID's are allocated for the purpose of sending uniquely identifiable messages between tasks.</const>
    </constants>

    <constants lookup="JET" comment="JET constants are documented in GetInputEvent()">
      <const name="ABS_X">Value is an absolute horizontal coordinate that corresponds to a page area (usually the display or touchpad).</const>
      <const name="ABS_Y">Value is an absolute vertical coordinate that corresponds to a page area (usually the display or touchpad).</const>
      <const name="ANALOG2_X">As for ANALOG_X, this type covers a second analog stick if present.</const>
      <const name="ANALOG2_Y">As for ANALOG_Y, this type covers a second analog stick if present.</const>
      <const name="ANALOG2_Z">As for ANALOG_Z, this type covers a second analog stick if present.</const>
      <const name="ANALOG_X">Horizontal position for the default analog control (on gamepads this is the left analog control).  Analog values range between -1.0 and 1.0.  A value of zero indicates that the control is at rest.</const>
      <const name="ANALOG_Y">Vertical position for the default analog control.</const>
      <const name="ANALOG_Z">3D or yoke position for the default analog control.  A negative value indicates that the control has been pulled out and a positive value indicates that it has been pushed in.</const>
      <const name="BUTTON_1">Left mouse button, XBox A button, PS square button.  Value is pressure sensitive, ranging between 0 - 1.0 (0 is released, 1.0 is fully depressed).</const>
      <const name="BUTTON_10">Non-specific button assignment.</const>
      <const name="BUTTON_2">Right mouse button, XBox X button, PS cross button.</const>
      <const name="BUTTON_3">Middle mouse button, XBox Y button, PS triangle.</const>
      <const name="BUTTON_4">XBox B button, PS circle.</const>
      <const name="BUTTON_5">Left analog stick depressed.</const>
      <const name="BUTTON_6">Right analog stick depressed.</const>
      <const name="BUTTON_7">Non-specific button assignment.</const>
      <const name="BUTTON_8">Non-specific button assignment.</const>
      <const name="BUTTON_9">Non-specific button assignment.</const>
      <const name="BUTTON_SELECT">Gamepad select button - value is 0 or 1.</const>
      <const name="BUTTON_START">Gamepad start button - value is 0 or 1.</const>
      <const name="DEVICE_TILT_X">Controller tilted on the X axis (left/right).  Value indicates angle, -ve = left, +ve = right</const>
      <const name="DEVICE_TILT_Y">Controller tilted on the Y axis (up/down).  Value indicates angle -ve = pull/up, +ve = push/down</const>
      <const name="DEVICE_TILT_Z">Controller is rising or falling.  Value expressed as 'speed',</const>
      <const name="DIGITAL_X">Horizontal digital movement from a relative location.  Value is +/- n, where n is the number of units moved horizontally.  Mouse movement will normally exceed a value of 1, whereas gamepad movement is limited to a value of +/- 1 except in the case of successive presses.</const>
      <const name="DIGITAL_Y">Vertical digital movement from a relative location.</const>
      <const name="DISPLAY_EDGE">Recently supplied input occurred at the edge of the display.</const>
      <const name="ENTERED_SURFACE">This message is sent by the input system when the mouse pointer enters a surface for the first time.  The message value refers to the surface ID, which will be the same as the recipient.</const>
      <const name="LEFT_BUMPER_1">Gamepad left-hand bumper 1 (top) - pressure sensitive value from 0 - 1.0.</const>
      <const name="LEFT_BUMPER_2">Gamepad left-hand bumper 2 (lower) - pressure sensitive value from 0 - 1.0.</const>
      <const name="LEFT_SURFACE">This message is sent by the input system when the mouse pointer leaves a surface.  The message value refers to the ID of the surface that has been left, which will be the same as the recipient.</const>
      <const name="PEN_TILT_HORIZONTAL">For pen-based input, this type indicates the horizontal tilt of the pen device.</const>
      <const name="PEN_TILT_VERTICAL">For pen-based input, this type indicates the vertical tilt of the pen device.  A value of 0 indicates that the pen is laid flat with nib at the bottom, 0.5 is 90 degrees, 1.0 is laid flat with nib at the top.</const>
      <const name="PRESSURE">Amount of pressure applied, ranges from 0 (none) to 1.0 (normal) and possibly higher if user presses hard enough</const>
      <const name="RIGHT_BUMPER_1">Gamepad right-hand bumper 1 (top) - pressure sensitive value from 0 - 1.0.</const>
      <const name="RIGHT_BUMPER_2">Gamepad right-hand bumper 2 (lower) - pressure sensitive value from 0 - 1.0.</const>
      <const name="TRIGGER_LEFT">Gamepad left-hand trigger - value is between 0 - 1.0 (0 is released, 1.0 is fully depressed).</const>
      <const name="TRIGGER_RIGHT">Gamepad right-hand trigger.</const>
      <const name="WHEEL">Mouse wheel rotation - the value generally reflects the number of 'clicks' rotated on the wheel.</const>
      <const name="WHEEL_TILT">Some mouse wheels can be tilted to the left or right.  Ranges from -1.0 to +1.0</const>
    </constants>

    <constants lookup="JTYPE" comment="JTYPE flags are used to categorise input types.">
      <const name="ANALOG">Analog movement (ranging from -1.0 to 1.0)</const>
      <const name="ANCHORED">Cursor has been anchored with LockCursor()</const>
      <const name="BUTTON">Input is a physical button or switch</const>
      <const name="DBL_CLICK">Set by the input system if the Type is a button and the button has been clicked in quick succession so as to be classed as a double-click.</const>
      <const name="DIGITAL">D-Pad or digital joystick source (restricted to +/- 1)</const>
      <const name="DRAGGED">Set if sufficient movement occurred between the original click and its point of release (usually requires a 3 or more pixel difference).</const>
      <const name="DRAG_ITEM">This special flag is set by the input system if the pointer is click-dragging an object at the time of the event.</const>
      <const name="EXT_MOVEMENT">Extended movement information.  This covers all types of movement that are unconnected to coordinate positioning -  mouse wheel movement and pen tilt are two such examples.</const>
      <const name="FEEDBACK">Device feedback - e.g. vibration, tilt</const>
      <const name="MOVEMENT">X/Y coordinate movement only. Movement such as the wheel mouse spinning is not covered by this type as it does not influence the coordinate system.</const>
      <const name="REPEATED">Input is a repeated entry (i.e. user is holding down a button and a repetition timer is being triggered)</const>
      <const name="SECONDARY">Indicates to the receiver of this message that it is not the primary/original recipient</const>
    </constants>

    <constants lookup="K" comment="Raw key codes">
      <const name="A"/>
      <const name="APOSTROPHE"/>
      <const name="AT"/>
      <const name="B"/>
      <const name="BACK"/>
      <const name="BACKSPACE"/>
      <const name="BACK_SLASH"/>
      <const name="BREAK"/>
      <const name="C"/>
      <const name="CALL"/>
      <const name="CAMERA"/>
      <const name="CANCEL"/>
      <const name="CAPS_LOCK"/>
      <const name="CLEAR"/>
      <const name="COMMA"/>
      <const name="D"/>
      <const name="DELETE"/>
      <const name="DOT"/>
      <const name="DOWN"/>
      <const name="E"/>
      <const name="EIGHT"/>
      <const name="END"/>
      <const name="END_CALL"/>
      <const name="ENTER"/>
      <const name="EQUALS"/>
      <const name="ESCAPE"/>
      <const name="EXECUTE"/>
      <const name="F"/>
      <const name="F1"/>
      <const name="F10"/>
      <const name="F11"/>
      <const name="F12"/>
      <const name="F13"/>
      <const name="F14"/>
      <const name="F15"/>
      <const name="F16"/>
      <const name="F17"/>
      <const name="F18"/>
      <const name="F19"/>
      <const name="F2"/>
      <const name="F20"/>
      <const name="F3"/>
      <const name="F4"/>
      <const name="F5"/>
      <const name="F6"/>
      <const name="F7"/>
      <const name="F8"/>
      <const name="F9"/>
      <const name="FIND"/>
      <const name="FIVE"/>
      <const name="FORWARD"/>
      <const name="FOUR"/>
      <const name="G"/>
      <const name="H"/>
      <const name="HELP"/>
      <const name="HOME"/>
      <const name="I"/>
      <const name="INSERT"/>
      <const name="J"/>
      <const name="K"/>
      <const name="L"/>
      <const name="LEFT"/>
      <const name="LENS_FOCUS"/>
      <const name="LESS_GREATER"/>
      <const name="LIST_END"/>
      <const name="L_ALT"/>
      <const name="L_COMMAND"/>
      <const name="L_CONTROL"/>
      <const name="L_SHIFT"/>
      <const name="L_SQUARE"/>
      <const name="M"/>
      <const name="MACRO"/>
      <const name="MENU"/>
      <const name="MINUS"/>
      <const name="MUTE"/>
      <const name="N"/>
      <const name="NEXT"/>
      <const name="NINE"/>
      <const name="NP_0"/>
      <const name="NP_1"/>
      <const name="NP_2"/>
      <const name="NP_3"/>
      <const name="NP_4"/>
      <const name="NP_5"/>
      <const name="NP_6"/>
      <const name="NP_7"/>
      <const name="NP_8"/>
      <const name="NP_9"/>
      <const name="NP_BAR"/>
      <const name="NP_DECIMAL"/>
      <const name="NP_DIVIDE"/>
      <const name="NP_DOT"/>
      <const name="NP_ENTER"/>
      <const name="NP_MINUS"/>
      <const name="NP_MULTIPLY"/>
      <const name="NP_PLUS"/>
      <const name="NP_PLUS_MINUS"/>
      <const name="NP_SEPARATOR"/>
      <const name="NUM_LOCK"/>
      <const name="O"/>
      <const name="ONE"/>
      <const name="P"/>
      <const name="PAGE_DOWN"/>
      <const name="PAGE_UP"/>
      <const name="PAUSE"/>
      <const name="PERIOD"/>
      <const name="PLAY"/>
      <const name="PLUS"/>
      <const name="POUND"/>
      <const name="POWER"/>
      <const name="PREVIOUS"/>
      <const name="PRINT"/>
      <const name="PRT_SCR"/>
      <const name="Q"/>
      <const name="R"/>
      <const name="REDO"/>
      <const name="REVERSE_QUOTE"/>
      <const name="REWIND"/>
      <const name="RIGHT"/>
      <const name="R_ALT"/>
      <const name="R_COMMAND"/>
      <const name="R_CONTROL"/>
      <const name="R_SHIFT"/>
      <const name="R_SQUARE"/>
      <const name="S"/>
      <const name="SCR_LOCK"/>
      <const name="SELECT"/>
      <const name="SEMI_COLON"/>
      <const name="SEVEN"/>
      <const name="SIX"/>
      <const name="SLASH"/>
      <const name="SLEEP"/>
      <const name="SPACE"/>
      <const name="STAR"/>
      <const name="STOP"/>
      <const name="SYSRQ"/>
      <const name="T"/>
      <const name="TAB"/>
      <const name="THREE"/>
      <const name="TWO"/>
      <const name="U"/>
      <const name="UNDO"/>
      <const name="UP"/>
      <const name="V"/>
      <const name="VOLUME_DOWN"/>
      <const name="VOLUME_UP"/>
      <const name="W"/>
      <const name="WAKE"/>
      <const name="WIN_CONTROL"/>
      <const name="X"/>
      <const name="Y"/>
      <const name="Z"/>
      <const name="ZERO"/>
    </constants>

    <constants lookup="KQ" comment="Special qualifier flags">
      <const name="ALT">Synonym for L_ALT | R_ALT</const>
      <const name="ALTGR">Synonym for R_ALT</const>
      <const name="CAPS_LOCK">Caps-Lock is on</const>
      <const name="COMMAND">Synonym for L_COMMAND | R_COMMAND</const>
      <const name="CONTROL">Synonym for L_CONTROL | R_CONTROL</const>
      <const name="CTRL">Synonym for L_CONTROL | R_CONTROL</const>
      <const name="DEAD_KEY">This key will be affected by a previously pressed dead-key</const>
      <const name="INFO">Synonym for REPEAT | RELEASED | PRESSED | NOT_PRINTABLE | CAPS_LOCK</const>
      <const name="INSTRUCTION_KEYS">Synonym for ALT | CONTROL</const>
      <const name="L_ALT">Left Alt is held</const>
      <const name="L_COMMAND">Left Logo/Special</const>
      <const name="L_CONTROL">Control Key is held</const>
      <const name="L_CTRL">Control Key is held</const>
      <const name="L_SHIFT">Left Shift is held</const>
      <const name="NOT_PRINTABLE">The represented key value is not printable</const>
      <const name="NUM_LOCK">NumLock is on</const>
      <const name="NUM_PAD">Identifies numeric keypad keys</const>
      <const name="PRESSED">Key is being held or tapped</const>
      <const name="QUALIFIERS">Synonym for SHIFT | COMMAND | ALT | CONTROL</const>
      <const name="RELEASED">The key is being released</const>
      <const name="REPEAT">This is a repeated key</const>
      <const name="R_ALT">Right Alt is held</const>
      <const name="R_COMMAND">Right Logo/Special</const>
      <const name="R_CONTROL">Control Key is held</const>
      <const name="R_CTRL">Control Key is held</const>
      <const name="R_SHIFT">Right Shift is held</const>
      <const name="SCR_LOCK">Scroll Lock is on</const>
      <const name="SHIFT">Synonym for L_SHIFT | R_SHIFT</const>
    </constants>

    <constants lookup="LAYOUT" comment="Universal values for alignment of graphic layouts in documents.">
      <const name="BACKGROUND">Graphic is placed behind text.  The text will not be wrapped around the object</const>
      <const name="EMBEDDED">Graphic is embedded in the text stream (treated as a character).  The height of the line can be extended to match the height of the graphic in this mode.</const>
      <const name="FOREGROUND">Graphic is placed in front of the text.  The text will not be wrapped around the object</const>
      <const name="IGNORE_CURSOR">The object has a fixed X/Y position, unrelated to the cursor</const>
      <const name="LEFT">The text boundary is extended to the left edge of the page.</const>
      <const name="LOCK">Lock the position of the graphic to the top left of the view and not the scrolling position of the page.</const>
      <const name="RIGHT">The text boundary is extended to the right edge of the page.</const>
      <const name="SQUARE">The default.  Text will clip around the image's border</const>
      <const name="TIGHT">Text wraps to the shape of the image (alpha blended/masked images only)</const>
      <const name="TILE">The graphic will be tiled.  Tiled graphics also meet the LAYOUT_BACKGROUND criteria (no wrapping).</const>
      <const name="WIDE">The text boundary is extended to the left and right edges of the page.</const>
    </constants>

    <constants lookup="LDF" comment="Flags for LoadFile()">
      <const name="CHECK_EXISTS">Limits the routine to checking the file cache for the existence of the file.  If found, the relevant cache entry is returned. The open count is not incremented by this action (it is therefore unnecessary to follow-up with a call to UnloadFile()).  If no up-to-date cache entry is available, ERR_Search is returned.</const>
    </constants>

    <constants lookup="LOC" comment="AnalysePath() values">
      <const name="DIRECTORY">The path refers to a folder.</const>
      <const name="FILE">The path refers to a file.</const>
      <const name="VOLUME">The path refers to a volume name.</const>
    </constants>

    <constants lookup="MAX">
      <const name="NAME_LEN"/>
    </constants>

    <constants lookup="MEM" comment="Memory types used by AllocMemory().  The lower 16 bits are stored with allocated blocks, the upper 16 bits are function-relative only.">
      <const name="AUDIO">The memory space is reserved by an audio device such as a sound card.</const>
      <const name="CALLER">This flag is usable only in routines that are supporting a class method.  It forces the memory allocation to be tracked to the object that made the method call.  This is particularly important in methods that return memory blocks that do not form a part of the object itself.</const>
      <const name="CODE">Set if the memory will contain executable program code.</const>
      <const name="DATA">The default type, MEM_DATA, is used to indicate a standard memory allocation from system RAM.</const>
      <const name="HIDDEN">Hidden blocks are not recorded and are excluded from resource tracking.</const>
      <const name="MANAGED">Enables custom resource management for the memory block.  The start of the block will need to be reserved with a pointer to a ResourceManager structure, which is included as part of the block's declared Size.  The Free() callback will be called when the block is removed.</const>
      <const name="NO_BLOCK">Permanently turn off all accesses to this memory block.  This means that multiple threads can have full read/write access to the memory block at once regardless of other acces flags.</const>
      <const name="NO_BLOCKING">Permanently turn off all accesses to this memory block.  This means that multiple threads can have full read/write access to the memory block at once regardless of other acces flags.</const>
      <const name="NO_CLEAR">Do not clear the memory on allocation (saves time).</const>
      <const name="NO_LOCK">For AllocMemory() only, indicates that the (private) memory block should not be locked on return.</const>
      <const name="NO_POOL">Gives a hint to the allocator to allocate the block outside of the memory pool.</const>
      <const name="READ">The memory is explicitly marked as readable.</const>
      <const name="READ_WRITE">Synonym for READ | WRITE</const>
      <const name="STRING">Identifies the memory content as a null terminated string. Useful for debugging and run-time type identification in scripts.</const>
      <const name="TEXTURE">The memory space is reserved by a video driver for hosting texture graphics.</const>
      <const name="TMP_LOCK">Enables temporary locking restrictions.  Prevents processes from sleeping while holding a lock on the memory block.</const>
      <const name="UNTRACKED">Allocating an untracked memory block will prevent the memory block from being tracked back to the object holding the current context.</const>
      <const name="VIDEO">The memory space is reserved by a video device such as a graphics card for display purposes, e.g. framebuffer.</const>
      <const name="WRITE">The memory is explicitly marked as writeable.</const>
    </constants>

    <constants lookup="MFF" comment="Flags for the File Watch() method.">
      <const name="ATTRIB">File permissions or datestamp changed.</const>
      <const name="CLOSED">An opened file has been closed.</const>
      <const name="CREATE">New file/link created or renamed in folder.</const>
      <const name="DEEP">Receive notifications from sub-folders (Windows only).</const>
      <const name="DELETE">Existing file deleted</const>
      <const name="FILE">File identifier; if passed to Watch() then indicates a preference for file events only.</const>
      <const name="FOLDER">Folder identifier; if passed to Watch() then indicates a preference for folder events only.</const>
      <const name="MODIFY">File modified via write or truncation.</const>
      <const name="MOVED">Existing file moved or renamed.</const>
      <const name="OPENED">Existing file was opened.</const>
      <const name="READ">File was accessed (read).</const>
      <const name="RENAME">Existing file moved or renamed.</const>
      <const name="SELF">Event applies to the monitored folder and not a contained item</const>
      <const name="UNMOUNT">Host filesystem was unmounted.</const>
      <const name="WRITE">File modified via write or truncation.</const>
    </constants>

    <constants lookup="MHF" comment="Internal options for requesting function tables from modules.">
      <const name="DEFAULT">Use structures to group exported functions (Linux, C/C++ standard)</const>
      <const name="STATIC">Keep the module code in memory</const>
      <const name="STRUCTURE">Use structures to group exported functions (Linux, C/C++ standard)</const>
    </constants>

    <constants lookup="MOF" comment="Module flags">
      <const name="LINK_LIBRARY">Module refers to a symbolic link library (e.g. libz DLL or SO)</const>
      <const name="STATIC">This flag prevents the loaded module code from being unloaded when the module object is freed.  This may be needed in cases where a module is designed with the presumption that it will remain in memory after being loaded by the developer.</const>
      <const name="SYSTEM_PROBE">Indicates that the module is being probed.  Do not use outside of the core library.</const>
    </constants>

    <constants lookup="MOVE" comment="Generic flags for controlling movement.">
      <const name="ALL">Synonym for DOWN | UP | LEFT | RIGHT</const>
      <const name="DOWN"/>
      <const name="LEFT"/>
      <const name="RIGHT"/>
      <const name="UP"/>
    </constants>

    <constants lookup="MSF" comment="Message flags.">
      <const name="ADD">The default behaviour - this will add the message to the end of the queue.</const>
      <const name="MESSAGE_ID">The Type parameter refers to a unique message ID rather than a message type for this call.</const>
      <const name="NO_DUPLICATE">If the Type parameter matches a message already inside the queue, the new message will not be added and the function will immediately return with ERR_Okay.</const>
      <const name="UPDATE">If the Type parameter matches a message already inside the queue, the data for that message will be deleted, then the new message will be added to the end of the queue.</const>
      <const name="WAIT">Wait before inserting the message if the queue is at maximum capacity.</const>
    </constants>

    <constants lookup="MSGID" comment="Reserved message ID's that are handled internally.">
      <const name="ACTION"/>
      <const name="BREAK"/>
      <const name="COMMAND"/>
      <const name="CORE_END"/>
      <const name="DEBUG"/>
      <const name="EVENT"/>
      <const name="FREE"/>
      <const name="QUIT"/>
      <const name="THREAD_ACTION"/>
      <const name="THREAD_CALLBACK"/>
      <const name="VALIDATE_PROCESS"/>
      <const name="WAIT_FOR_OBJECTS"/>
    </constants>

    <constants lookup="MTF" comment="MoveToPoint flags">
      <const name="ANIM"/>
      <const name="RELATIVE"/>
      <const name="X"/>
      <const name="Y"/>
      <const name="Z"/>
    </constants>

    <constants lookup="NETMSG">
      <const name="END"/>
      <const name="START"/>
    </constants>

    <constants lookup="NF" comment="Flags that can be passed to NewObject().  If a flag needs to be stored with the object, it must be specified in the lower word.">
      <const name="COLLECT">Marked for garbage collection.</const>
      <const name="FREE">Read-only indicator for when the object is being freed.</const>
      <const name="INITIALISED">Read-only indicator if the object has been initialised.</const>
      <const name="INTEGRAL">Integral objects can only be allocated by classes that need to adopt the functionality of said object.  Integral objects do not appear in the object tree, effectively making them hidden from view.</const>
      <const name="MESSAGE">Action has been called against the object through the message system (managed by ProcessMessages()).</const>
      <const name="NAME">Use the Name parameter to name the created object.  This flag is not required if using NF_UNIQUE.</const>
      <const name="PRIVATE"/>
      <const name="RECLASSED">The object switched from the base-class to a sub-class during initialisation.</const>
      <const name="SIGNALLED">The object has been signalled and is awaiting processing.</const>
      <const name="TIMER_SUB">The object is subscribed to a timer interval.</const>
      <const name="UNIQUE">Use to allocate an object that has a guaranteed unique name.  This will prevent code from shadowing any object that exists with the same name, which can be imperative when creating shared objects.  If it is discovered that an identically named object exists, NewObject() will return ERR_ObjectExists.  This flag works in conjunction with the Name argument.</const>
      <const name="UNLOCK_FREE">Read-only indicator for when the object is marked for deletion.</const>
      <const name="UNTRACKED">An object created with this flag will not be tracked back to the object that created it.</const>
    </constants>

    <constants lookup="OPF">
      <const name="ARGS"/>
      <const name="COMPILED_AGAINST"/>
      <const name="CORE_VERSION"/>
      <const name="DEPRECATED"/>
      <const name="DETAIL"/>
      <const name="ERROR"/>
      <const name="MAX_DEPTH"/>
      <const name="MODULE_PATH"/>
      <const name="OPTIONS"/>
      <const name="PRIVILEGED"/>
      <const name="ROOT_PATH"/>
      <const name="SCAN_MODULES"/>
      <const name="SHOW_ERRORS"/>
      <const name="SHOW_IO"/>
      <const name="SHOW_MEMORY"/>
      <const name="SYSTEM_PATH"/>
    </constants>

    <constants lookup="PERMIT" comment="Permission flags">
      <const name="ALL_DELETE">Synonym for EVERYONE_DELETE</const>
      <const name="ALL_EXEC">Synonym for EVERYONE_EXEC</const>
      <const name="ALL_READ">Synonym for EVERYONE_READ</const>
      <const name="ALL_WRITE">Synonym for EVERYONE_WRITE</const>
      <const name="ARCHIVE">Marks the file for future backup.  The flag should be cleared after the backup has succeeded.</const>
      <const name="DELETE">Owner can delete.  If the file system does not support this, deletion is enabled via the WRITE flag.</const>
      <const name="EVERYONE_ACCESS">Synonym for EVERYONE_READ | EVERYONE_WRITE | EVERYONE_EXEC | EVERYONE_DELETE</const>
      <const name="EVERYONE_DELETE">Synonym for DELETE | GROUP_DELETE | OTHERS_DELETE</const>
      <const name="EVERYONE_EXEC">Synonym for EXEC | GROUP_EXEC | OTHERS_EXEC</const>
      <const name="EVERYONE_READ">Synonym for READ | GROUP_READ | OTHERS_READ</const>
      <const name="EVERYONE_READWRITE">Synonym for EVERYONE_READ | EVERYONE_WRITE</const>
      <const name="EVERYONE_WRITE">Synonym for WRITE | GROUP_WRITE | OTHERS_WRITE</const>
      <const name="EXEC">User/Owner can execute.</const>
      <const name="GROUP">Synonym for GROUP_READ | GROUP_WRITE | GROUP_EXEC | GROUP_DELETE</const>
      <const name="GROUPID">Allows executables to run with a set group id.</const>
      <const name="GROUP_DELETE">Group members can delete.</const>
      <const name="GROUP_EXEC">Group members can execute.</const>
      <const name="GROUP_READ">Group members can read.</const>
      <const name="GROUP_WRITE">Group members can write.</const>
      <const name="HIDDEN">Recommends that the file is hidden from view by default.</const>
      <const name="INHERIT">Inherit permissions from parent folder and logical OR them with preset permission flags.</const>
      <const name="NETWORK">File is hosted on another machine.</const>
      <const name="OFFLINE">File content for this networked file has not been cached on the local PC.</const>
      <const name="OTHERS">Synonym for OTHERS_READ | OTHERS_WRITE | OTHERS_EXEC | OTHERS_DELETE</const>
      <const name="OTHERS_DELETE">Others can delete.</const>
      <const name="OTHERS_EXEC">Others can execute.</const>
      <const name="OTHERS_READ">Others can read.</const>
      <const name="OTHERS_WRITE">Others can write.</const>
      <const name="PASSWORD">File is password protected.</const>
      <const name="READ">User/Owner has read access.  This will not allow compiled code to be executed.</const>
      <const name="USER">Synonym for READ | WRITE | EXEC | DELETE</const>
      <const name="USERID">Allows executables to run with a set user id.</const>
      <const name="USER_EXEC">Synonym for EXEC</const>
      <const name="USER_READ">Synonym for READ</const>
      <const name="USER_WRITE">Synonym for WRITE</const>
      <const name="WRITE">User/Owner can write.</const>
    </constants>

    <constants lookup="PMF" comment="Flags for ProcessMessages">
    </constants>

    <constants lookup="PTR" comment="Predefined cursor styles">
      <const name="CROSSHAIR">The cross hair is used for targeting specific pixel points (common in paint programs).</const>
      <const name="CUSTOM">Works in conjunction with the SetCustomCursor() function to represent a program defined bitmap.</const>
      <const name="DEFAULT">The default cursor (usually an arrow pointing to the upper left).</const>
      <const name="DRAGGABLE">Used to indicate that a surface or object can be dragged by the user.</const>
      <const name="END"/>
      <const name="HAND">The hand cursor is often used for indicating click-able content (hyper-links, icons etc).</const>
      <const name="HAND_LEFT">Similar to the standard hand cursor, but points to the left.</const>
      <const name="HAND_RIGHT">Similar to the standard hand cursor, but points to the right.</const>
      <const name="INVISIBLE">The cursor graphic is invisible (but will continue to operate as normal in all other respects).</const>
      <const name="MAGNIFIER">Represents a magnifying glass.</const>
      <const name="NO_CHANGE"/>
      <const name="PAINTBRUSH">The paintbrush cursor is typically employed by paint programs.</const>
      <const name="SIZE_BOTTOM">Sizing cursor - for resizing the bottom edge of any rectangular area.</const>
      <const name="SIZE_BOTTOM_LEFT">Sizing cursor - for resizing the bottom left corner of any rectangular area.</const>
      <const name="SIZE_BOTTOM_RIGHT">Sizing cursor - for resizing the bottom right corner of any rectangular area.</const>
      <const name="SIZE_LEFT">Sizing cursor - for resizing the left edge of any rectangular area.</const>
      <const name="SIZE_RIGHT">Sizing cursor - for resizing the right edge of any rectangular area.</const>
      <const name="SIZE_TOP">Sizing cursor - for resizing the top edge of any rectangular area.</const>
      <const name="SIZE_TOP_LEFT">Sizing cursor - for resizing the top left corner of any rectangular area.</const>
      <const name="SIZE_TOP_RIGHT">Sizing cursor - for resizing the top right corner of any rectangular area.</const>
      <const name="SIZING">Multi-directional sizing cursor - for resizing in any direction.</const>
      <const name="SLEEP">The sleep cursor is used to inform the user that the computer is busy.</const>
      <const name="SPLIT_HORIZONTAL">The horizontal split cursor is typically used for splitting rectangles in half, or dragging a horizontal split within a large rectangular space.</const>
      <const name="SPLIT_VERTICAL">The vertical split cursor is typically used for splitting rectangles in half, or dragging a vertical split within a large rectangular space.</const>
      <const name="STOP">The stop cursor is used to inform the user that an operation is not possible (e.g. drag and drop to an unsupported object area).</const>
      <const name="TEXT">The text cursor is popular for the precise positioning of text cursors.</const>
    </constants>

    <constants lookup="RDF" comment="Flags for the OpenDir() function.">
      <const name="ARCHIVE">Feedback only - archive bit is set.</const>
      <const name="DATE">Retrieve the date stamp of each file.</const>
      <const name="FILE">Read all files in the folder.</const>
      <const name="FILES">Read all files in the folder.</const>
      <const name="FOLDER">Read all folders/volumes in the folder.</const>
      <const name="FOLDERS">Read all folders/volumes in the folder.</const>
      <const name="HIDDEN">Feedback only - file/folder is hidden.</const>
      <const name="LINK">Feedback only - file/folder is actually a link to another location.</const>
      <const name="PERMISSIONS">Get permission/security information.</const>
      <const name="QUALIFIED">Return fully qualified folder names (i.e. trailing slash or colon for each name).</const>
      <const name="QUALIFY">Return fully qualified folder names (i.e. trailing slash or colon for each name).</const>
      <const name="READ_ALL">Synonym for SIZE | DATE | PERMISSIONS | FILES | FOLDERS</const>
      <const name="READ_ONLY">Read-only (not permissions related and might indicate read-only media).</const>
      <const name="SIZE">Retrieve the byte size of each file.</const>
      <const name="STREAM">Path is connected via a stream, e.g. network connection.</const>
      <const name="TAGS">Receive additional information for each file, such as comments, author and copyright.  The results are stored in the Tags field of each file.</const>
      <const name="TIME">Retrieve the date stamp of each file.</const>
      <const name="VIRTUAL">Path is to a virtual device.</const>
      <const name="VOLUME">Feedback only - indicates a volume.</const>
    </constants>

    <constants lookup="RES">
      <const name="CORE_IDL">Refers to the Core module's compressed IDL string.</const>
      <const name="CPU_SPEED">The average top-speed of all CPU cores in Mhz.</const>
      <const name="CURRENT_MSG">Returns a Message structure if the program is currently processing a message - otherwise returns NULL.  This resource type is meaningful only during a ProcessMessages call.</const>
      <const name="FREE_MEMORY">The total amount of free memory.</const>
      <const name="FREE_SWAP">The total amount of free swap memory.</const>
      <const name="JNI_ENV">Return the current JNI environment string.</const>
      <const name="KEY_STATE">Maintains the state of key qualifiers such as caps-lock and the shift keys.</const>
      <const name="LOG_DEPTH">The current depth of log messages.</const>
      <const name="LOG_LEVEL">The current level of log detail (larger numbers indicate more detail).</const>
      <const name="MAX_PROCESSES">The maximum number of processes that can be supported at any time.</const>
      <const name="MESSAGE_QUEUE">Use this resource to retrieve the message queue ID of the current task.</const>
      <const name="OPEN_INFO">Pointer to the OpenInfo structure originally used to initialise the system.</const>
      <const name="PARENT_CONTEXT">Read-only pointer to the parent object of the current context.</const>
      <const name="PRIVILEGED">This is set to TRUE if the process has elevated privileges (such as superuser or administrative rights).</const>
      <const name="PRIVILEGED_USER">If this value is set to 1, the process will operate in privileged mode (typically this enables full administrator rights).  This feature will only work for Unix processes that are granted admin rights when launched.  Setting the Value to 0 reverts to the user's permission settings.  SetResource() will return an error code indicating the level of success.</const>
      <const name="PROCESS_STATE">Life-cycle stage of the running process</const>
      <const name="THREAD_ID">Return the ID of the current thread.</const>
      <const name="TOTAL_MEMORY">The total amount of installed memory.</const>
      <const name="TOTAL_SHARED_MEMORY">The total amount of shared memory in use (system wide).</const>
      <const name="TOTAL_SWAP">The total amount of available swap space.</const>
    </constants>

    <constants lookup="RFD" comment="Flags for RegisterFD()">
      <const name="ALWAYS_CALL">Always call this FD's handler prior to the process going to sleep.</const>
      <const name="EXCEPT">Activate the callback if error conditions are pending.</const>
      <const name="READ">Activate the callback if there is data available to read.</const>
      <const name="RECALL">Set if the subscriber needs to manually check for incoming/outgoing data.  This is supported as a one-off check, so the flag will be disabled automatically when the subscriber is called.</const>
      <const name="REMOVE">Stop monitoring this file descriptor.</const>
      <const name="SOCKET">Identifies the file descriptor as a socket (Linux systems only).</const>
      <const name="WRITE">Activate the callback if there is room to write to the FD's buffer.</const>
    </constants>

    <constants lookup="RP" comment="Path types for SetResourcePath()">
      <const name="MODULE_PATH">An alternative path leading to the system modules (normally 'system:modules/').  Introduced for platforms such as Android, where modules are stored in asset folders.</const>
      <const name="ROOT_PATH">Overrides the root path, which defaults to the location at which Parasol is installed.</const>
      <const name="SYSTEM_PATH">The path of the 'system:' volume, which otherwise defaults to '[root]:system/'.</const>
    </constants>

    <constants lookup="RSF" comment="Flags for ResolvePath()">
      <const name="APPROXIMATE">Ignores file extensions for the purpose of file name matching.</const>
      <const name="CASE_SENSITIVE">For use on host systems that use case-insensitive file systems such as Windows; this option checks that the discovered file is a case-sensitive match to the Path.</const>
      <const name="CHECK_VIRTUAL">If the volume referenced by Path is traced to another volume that is reserved by a virtual file system driver, ERR_VirtualVolume is returned. The volume is still resolved as far as possible and the resulting path will be returned by this function.</const>
      <const name="NO_DEEP_SCAN">Do not perform more than one iteration when resolving the source file path.</const>
      <const name="NO_FILE_CHECK">Do not test for the existence of the targeted file or folder during the resolution process.</const>
      <const name="PATH">Use the PATH environment variable to resolve the file name in the Path parameter.</const>
    </constants>

    <constants lookup="SBF" comment="Flags for StrBuildArray()">
      <const name="CASE">Use case-sensitivity when comparing strings in the list.</const>
      <const name="CSV">The list is in CSV format and the Size and Total parameters should be ignored. Note that the source string will be modified in this mode.</const>
      <const name="DESC">Sort in descending order.</const>
      <const name="NO_DUPLICATES">Sort the resulting list and remove duplicated strings.</const>
      <const name="SORT">Sort the resulting list.</const>
    </constants>

    <constants lookup="SCF" comment="Script flags">
      <const name="DEBUG">Enables execution debugging.  More information will be printed to the console in this mode.</const>
      <const name="EXIT_ON_ERROR">The script will automatically terminate its execution process if an error is detected.</const>
    </constants>

    <constants lookup="SEEK" comment="Seek positions">
      <const name="CURRENT">Use an index at the end of the last read/write operation.</const>
      <const name="END">Use an index at the end of the data buffer.</const>
      <const name="RELATIVE">The index is between 0 and 1.0 and relative to the data size.</const>
      <const name="START">Use an index at position zero.</const>
    </constants>

    <constants lookup="SEM">
      <const name="GET_COUNTER">Get the current counter value (affected by AccessSemaphore and ReleaseSemaphore).  Associated tag must be a pointer to a 32-bit integer.</const>
      <const name="GET_DATA_DOUBLE">Get the user customisable data value associated with the semaphore.  The subsequent tag must be a pointer to a 64-bit float point number.</const>
      <const name="GET_DATA_LARGE">Get the user customisable data value associated with the semaphore.  The subsequent tag must be a pointer to a 64-bit integer.</const>
      <const name="GET_DATA_LONG">Get the user customisable data value associated with the semaphore.  The subsequent tag must be a pointer to a 32-bit integer.</const>
      <const name="GET_DATA_PTR">Get the user customisable data value associated with the semaphore.  The subsequent tag must be a pointer to an address pointer.</const>
      <const name="GET_VAL">Get the maximum value for the counter, as originally set in AllocSemaphore.  Associated tag must be a pointer to a 32-bit integer.</const>
      <const name="SET_DATA_DOUBLE">Set the user customisable data value associated with the semaphore.  The subsequent tag must be a 64-bit floating point number.</const>
      <const name="SET_DATA_LARGE">Set the user customisable data value associated with the semaphore.  The subsequent tag must be a 64-bit integer.</const>
      <const name="SET_DATA_LONG">Set the user customisable data value associated with the semaphore.  The subsequent tag must be a 32-bit integer.</const>
      <const name="SET_DATA_PTR">Set the user customisable data value associated with the semaphore.  The subsequent tag must be an address pointer.</const>
    </constants>

    <constants lookup="SMF" comment="Flags for semaphores">
      <const name="EXISTS">When allocating a semaphore, declares that the named semaphore already exists and should not be recreated.</const>
      <const name="NON_BLOCKING">Do not block when locking the semaphore unless its counter has reached zero.</const>
      <const name="NO_BLOCKING">Do not block when locking the semaphore unless its counter has reached zero.</const>
    </constants>

    <constants lookup="STP" comment="ScrollToPoint flags">
      <const name="ANIM"/>
      <const name="X"/>
      <const name="Y"/>
      <const name="Z"/>
    </constants>

    <constants lookup="STR">
      <const name="CASE">Perform a case-sensitive match.</const>
      <const name="MATCH_CASE">Perform a case-sensitive match.</const>
      <const name="MATCH_LEN">The strings must be of equal length to be matched.</const>
      <const name="WILDCARD">Allow the use of wildcard characters '|', '?' and '*'.</const>
    </constants>

    <constants lookup="STT" comment="Types for StrDatatype().">
      <const name="FLOAT">The string represents a floating point number.</const>
      <const name="HEX">The string represents a hexadecimal number.</const>
      <const name="NUMBER">The string represents a whole number.</const>
      <const name="STRING">The string represents plain-text.</const>
    </constants>

    <constants lookup="THF" comment="Thread flags">
      <const name="AUTO_FREE">Automatically destroy the Thread object when the user routine has completed.</const>
    </constants>

    <constants lookup="TOI">
      <const name="ANDROID_ASSETMGR"/>
      <const name="ANDROID_CLASS"/>
      <const name="ANDROID_ENV"/>
      <const name="LOCAL_CACHE"/>
      <const name="LOCAL_STORAGE"/>
    </constants>

    <constants lookup="TSF" comment="Task flags">
      <const name="ATTACHED">Forces new task to be attached to the parent (child will close when parent closes).</const>
      <const name="DEBUG">Additional debug messages will be printed during normal usage of the task class when this flag is set.</const>
      <const name="DETACHED">Forces new task to be detached from the parent.</const>
      <const name="FOREIGN">Set this flag when using the task object to execute a foreign process - that is an executable that does not use the Parasol API.</const>
      <const name="PIPE">Enable the output pipe to the launched process so that it can read data.</const>
      <const name="PRIVILEGED">During a normal execution process, any privileges of the parent process will be dropped so that the child process runs unprivileged.  This behaviour can be reversed if he PRIVILEGED flag is set, in which case the child process has the same privileges as the parent.</const>
      <const name="QUIET">Setting this flag will divert all process output to /dev/null or the nearest equivalent for non-Unix systems.</const>
      <const name="RESET_PATH">If set, the executed process will start in its own folder rather than the folder of the parent process.</const>
      <const name="SHELL">Enables shell mode.  On Unix systems, this means that a shell (usually BASH) will be used to launch the process.</const>
      <const name="WAIT">This flag will cause the parent process to halt when the task is activated.  Control is returned to the parent process once the child process terminates.</const>
    </constants>

    <constants lookup="TSTATE" comment="Indicates the state of a process.">
      <const name="PAUSED">The process is asleep.</const>
      <const name="RUNNING">The process is currently executing code.</const>
      <const name="STOPPING">The process is in its termination phase.</const>
      <const name="TERMINATED">The process has closed.</const>
    </constants>

    <constants lookup="VAS" comment="For use by VirtualVolume()">
      <const name="CASE_SENSITIVE">Set to true if the volume's paths are case-sensitive.</const>
      <const name="CLOSE_DIR"/>
      <const name="CREATE_LINK"/>
      <const name="DELETE"/>
      <const name="DEREGISTER">Remove the virtual volume from the system.</const>
      <const name="DRIVER_SIZE"/>
      <const name="GET_DEVICE_INFO"/>
      <const name="GET_INFO"/>
      <const name="IDENTIFY_FILE"/>
      <const name="IGNORE_FILE"/>
      <const name="MAKE_DIR"/>
      <const name="OPEN_DIR"/>
      <const name="READ_LINK"/>
      <const name="RENAME"/>
      <const name="SAME_FILE"/>
      <const name="SCAN_DIR"/>
      <const name="TEST_PATH"/>
      <const name="WATCH_PATH"/>
    </constants>

    <constants lookup="VLF" comment="VlogF flags">
      <const name="API"/>
      <const name="BRANCH"/>
      <const name="CRITICAL"/>
      <const name="DEBUG"/>
      <const name="ERROR"/>
      <const name="EXTAPI"/>
      <const name="FUNCTION"/>
      <const name="INFO"/>
      <const name="TRACE"/>
      <const name="WARNING"/>
    </constants>

    <constants lookup="VOLUME" comment="Options for SetVolume()">
      <const name="HIDDEN">Hides the volume so that it will not show up when reading the root folder.</const>
      <const name="PRIORITY">If the volume already exists, the path will be inserted at the beginning of the path list so that it has priority over the others.</const>
      <const name="REPLACE">If the volume already exists, all paths that are attached to it will be replaced with the new path setting.</const>
      <const name="SYSTEM">Identifies the volume as being created by the system, is immutable and persistent between sessions.</const>
    </constants>

  </types>
  <structs>
    <struct name="ActionArray">
      <field name="ActionCode" type="LONG">Action identifier</field>
      <field name="Routine" type="APTR">Pointer to the function entry point</field>
    </struct>

    <struct name="ActionTable" comment="Structure for ActionList">
      <field name="Hash" type="ULONG">Hash of the action name.</field>
      <field name="Size" type="LONG">Byte-size of the structure for this action.</field>
      <field name="Name" type="CSTRING">Name of the action.</field>
      <field name="Args" type="const struct FunctionField *">List of fields that are passed to this action.</field>
    </struct>

    <struct name="ChildEntry" comment="Structure for ListChildren() function">
      <field name="ObjectID" type="OBJECTID">Object ID</field>
      <field name="ClassID" type="CLASSID">The class ID of the referenced object.</field>
    </struct>

    <struct name="ClipRectangle" comment="Generic structure for rectangular clipping.">
      <field name="Left" type="LONG">Left-most coordinate</field>
      <field name="Top" type="LONG">Top coordinate</field>
      <field name="Right" type="LONG">Right-most coordinate</field>
      <field name="Bottom" type="LONG">Bottom coordinate</field>
    </struct>

    <struct name="ColourFormat" typeName="COLOURFORMAT">
      <field name="RedShift" type="UBYTE">Right shift value for red (15/16 bit formats only)</field>
      <field name="GreenShift" type="UBYTE">Right shift value for green</field>
      <field name="BlueShift" type="UBYTE">Right shift value for blue</field>
      <field name="AlphaShift" type="UBYTE">Right shift value for alpha</field>
      <field name="RedMask" type="UBYTE">Unshifted mask value for red (ranges from 0x00 to 0xff)</field>
      <field name="GreenMask" type="UBYTE">Unshifted mask value for green</field>
      <field name="BlueMask" type="UBYTE">Unshifted mask value for blue</field>
      <field name="AlphaMask" type="UBYTE">Unshifted mask value for alpha</field>
      <field name="RedPos" type="UBYTE">Left shift/positional value for red</field>
      <field name="GreenPos" type="UBYTE">Left shift/positional value for green</field>
      <field name="BluePos" type="UBYTE">Left shift/positional value for blue</field>
      <field name="AlphaPos" type="UBYTE">Left shift/positional value for alpha</field>
      <field name="BitsPerPixel" type="UBYTE">Number of bits per pixel for this format.</field>
    </struct>

    <struct name="CompressedItem">
      <field name="OriginalSize" type="LARGE">Original size of the file</field>
      <field name="CompressedSize" type="LARGE">Compressed size of the file</field>
      <field name="Next" type="struct CompressedItem *">Used only if this is a linked-list.</field>
      <field name="Path" type="CSTRING">Path to the file (includes folder prefixes).  Archived folders will include the trailing slash.</field>
      <field name="Permissions" type="PERMIT" lookup="PERMIT">Original permissions - see PERMIT flags.</field>
      <field name="UserID" type="LONG">Original user ID</field>
      <field name="GroupID" type="LONG">Original group ID</field>
      <field name="OthersID" type="LONG">Original others ID</field>
      <field name="Flags" type="FL" lookup="FL">FL flags</field>
      <field name="Created" type="struct DateTime">Date and time of the file's creation.</field>
      <field name="Modified" type="struct DateTime">Date and time last modified.</field>
    </struct>

    <struct name="CompressionFeedback">
      <field name="FeedbackID" type="FDB" lookup="FDB">Set to one of the FDB event indicators</field>
      <field name="Index" type="LONG">Index of the current file</field>
      <field name="Path" type="CSTRING">Name of the current file/path in the archive</field>
      <field name="Dest" type="CSTRING">Destination file/path during decompression</field>
      <field name="Progress" type="LARGE">Progress indicator (byte position for the file being de/compressed).</field>
      <field name="OriginalSize" type="LARGE">Original size of the file</field>
      <field name="CompressedSize" type="LARGE">Compressed size of the file</field>
      <field name="Year" type="WORD">Year of the original file's datestamp.</field>
      <field name="Month" type="WORD">Month of the original file's datestamp.</field>
      <field name="Day" type="WORD">Day of the original file's datestamp.</field>
      <field name="Hour" type="WORD">Hour of the original file's datestamp.</field>
      <field name="Minute" type="WORD">Minute of the original file's datestamp.</field>
      <field name="Second" type="WORD">Second of the original file's datestamp.</field>
    </struct>

    <struct name="DateTime" comment="Generic structure for date-time management.">
      <field name="Year" type="LONG">Year</field>
      <field name="Month" type="LONG">Month 1 to 12</field>
      <field name="Day" type="LONG">Day 1 to 31</field>
      <field name="Hour" type="LONG">Hour 0 to 23</field>
      <field name="Minute" type="LONG">Minute 0 to 59</field>
      <field name="Second" type="LONG">Second 0 to 59</field>
      <field name="TimeZone" type="LONG">TimeZone -13 to +13</field>
    </struct>

    <struct name="DirInfo" comment="Used by OpenDir() only">
      <field name="Info" type="struct FileInfo *">Pointer to a FileInfo structure</field>
    </struct>

    <struct name="Edges" comment="Generic structure for declaring edge coordinates.">
      <field name="Left" type="LONG">Left-most coordinate</field>
      <field name="Top" type="LONG">Top coordinate</field>
      <field name="Right" type="LONG">Right-most coordinate</field>
      <field name="Bottom" type="LONG">Bottom coordinate</field>
    </struct>

    <struct name="FRGB" comment="64-bit floating point RGB colour value.">
      <field name="Red" type="FLOAT">Red component value</field>
      <field name="Green" type="FLOAT">Green component value</field>
      <field name="Blue" type="FLOAT">Blue component value</field>
      <field name="Alpha" type="FLOAT">Alpha component value</field>
    </struct>

    <struct name="Field" comment="Used to describe the public fields of a class.">
      <field name="Arg" type="MAXINT">An option to complement the field type.  Can be a pointer or an integer value</field>
      <field name="GetValue" type="FUNCTION *" prototype="ERROR (*GetValue)(APTR, APTR)">A virtual function that will retrieve the value for this field.</field>
      <field name="SetValue" type="APTR">A virtual function that will set the value for this field.</field>
      <field name="WriteValue" type="FUNCTION *" prototype="ERROR (*WriteValue)(OBJECTPTR, struct Field *, LONG, const void *, LONG)">An internal function for writing to this field.</field>
      <field name="Name" type="CSTRING">The English name for the field, e.g. "Width"</field>
      <field name="FieldID" type="ULONG">Provides a fast way of finding fields, e.g. FID_WIDTH</field>
      <field name="Offset" type="UWORD">Field offset within the object</field>
      <field name="Index" type="UWORD">Field array index</field>
      <field name="Flags" type="ULONG">Special flags that describe the field</field>
    </struct>

    <struct name="FieldArray" comment="Used to construct class blueprints for the MetaClass.">
      <field name="Name" type="CSTRING">The name of the field, e.g. "Width"</field>
      <field name="Flags" type="ULONG">Special flags that describe the field</field>
      <field name="Arg" type="MAXINT">Can be a pointer or an integer value</field>
      <field name="GetField" type="APTR">void GetField(*Object, APTR Result);</field>
      <field name="SetField" type="APTR">ERROR SetField(*Object, APTR Value);</field>
    </struct>

    <struct name="FieldDef" comment="Used to define constants for field references.">
      <field name="Name" type="CSTRING">The name of the constant.</field>
      <field name="Value" type="LONG">The value of the constant.</field>
    </struct>

    <struct name="FileFeedback">
      <field name="Size" type="LARGE">Size of the file</field>
      <field name="Position" type="LARGE">Current seek position within the file if moving or copying</field>
      <field name="Path" type="STRING">Path to the file</field>
      <field name="Dest" type="STRING">Destination file/path if moving or copying</field>
      <field name="FeedbackID" type="FBK" lookup="FBK">Set to one of the FBK values</field>
      <field name="Reserved" type="char" size="32">Reserved in case of future expansion</field>
    </struct>

    <struct name="FileInfo" comment="Returned by GetFileInfo()">
      <field name="Size" type="LARGE">The size of the file's content.</field>
      <field name="TimeStamp" type="LARGE">64-bit time stamp - usable only for comparison (e.g. sorting).</field>
      <field name="Next" type="struct FileInfo *">Next structure in the list, or NULL.</field>
      <field name="Name" type="STRING">The name of the file.  This string remains valid until the next call to GetFileInfo().</field>
      <field name="Flags" type="RDF" lookup="RDF">Additional flags to describe the file.</field>
      <field name="Permissions" type="PERMIT" lookup="PERMIT">Standard permission flags.</field>
      <field name="UserID" type="LONG">User  ID (Unix systems only).</field>
      <field name="GroupID" type="LONG">Group ID (Unix systems only).</field>
      <field name="Created" type="struct DateTime">The date/time of the file's creation.</field>
      <field name="Modified" type="struct DateTime">The date/time of the last file modification.</field>
    </struct>

    <struct name="Function" comment="Function list array structure">
      <field name="Address" type="APTR">Pointer to the function entry point</field>
      <field name="Name" type="CSTRING">Name of the function</field>
      <field name="Args" type="const struct FunctionField *">A list of parameters accepted by the function</field>
    </struct>

    <struct name="FunctionField" comment="Used by ActionTable and Function structures to declare lists of parameters.">
      <field name="Name" type="CSTRING">Name of the field</field>
      <field name="Type" type="ULONG">Type of the field</field>
    </struct>

    <struct name="HSV" comment="Colour structure for Hue, Saturation and Value components.">
      <field name="Hue" type="DOUBLE">Between 0 and 359.999</field>
      <field name="Saturation" type="DOUBLE">Between 0 and 1.0</field>
      <field name="Value" type="DOUBLE">Between 0 and 1.0.  Corresponds to Value, Lightness or Brightness</field>
    </struct>

    <struct name="InputEvent">
      <field name="Next" type="const struct InputEvent *">Next event in the chain</field>
      <field name="Value" type="DOUBLE">The value associated with the Type</field>
      <field name="Timestamp" type="LARGE">PreciseTime() of the recorded input</field>
      <field name="RecipientID" type="OBJECTID">Surface that the input message is being conveyed to</field>
      <field name="OverID" type="OBJECTID">Surface that is directly under the mouse pointer at the time of the event</field>
      <field name="AbsX" type="DOUBLE">Absolute horizontal position of mouse cursor</field>
      <field name="AbsY" type="DOUBLE">Absolute vertical position of mouse cursor</field>
      <field name="X" type="DOUBLE">Horizontal position relative to the surface that the pointer is over - unless a mouse button is held or pointer is anchored - then the coordinates are relative to the click-held surface</field>
      <field name="Y" type="DOUBLE">Vertical position relative to the surface that the pointer is over - unless a mouse button is held or pointer is anchored - then the coordinates are relative to the click-held surface</field>
      <field name="DeviceID" type="OBJECTID">The hardware device that this event originated from</field>
      <field name="Type" type="UWORD">JET constant</field>
      <field name="Flags" type="UWORD">Broad descriptors for the given Type (see JTYPE flags).  Automatically set by the system when sent to the pointer object</field>
      <field name="Mask" type="UWORD">Mask to use for checking against subscribers</field>
    </struct>

    <struct name="MemInfo" typeName="MEMINFO">
      <field name="Start" type="APTR">The starting address of the memory block (does not apply to shared blocks).</field>
      <field name="ObjectID" type="OBJECTID">The object that owns the memory block.</field>
      <field name="Size" type="LONG">The size of the memory block.</field>
      <field name="AccessCount" type="WORD">Total number of active locks on this block.</field>
      <field name="Flags" type="WORD">The type of memory.</field>
      <field name="MemoryID" type="MEMORYID">The unique ID for this block.</field>
    </struct>

    <struct name="Message" comment="Messaging structures.  Note: This structure is utilised by NextMsg">
      <field name="Time" type="LARGE">A timestamp acquired from PreciseTime() when the message was first passed to SendMessage().</field>
      <field name="UniqueID" type="LONG">A unique identifier automatically created by SendMessage().</field>
      <field name="Type" type="LONG">A message type identifier as defined by the client.</field>
      <field name="Size" type="LONG">The size of the message data, in bytes.  If there is no data associated with the message, the Size will be set to zero.&lt;/&gt;</field>
    </struct>

    <struct name="ObjectSignal" comment="Required in calls to WaitForObjects().">
      <field name="Object" type="OBJECTPTR"></field>
    </struct>

    <struct name="RGB16" comment="16-bit RGB colour value.">
      <field name="Red" type="UWORD">Red component value</field>
      <field name="Green" type="UWORD">Green component value</field>
      <field name="Blue" type="UWORD">Blue component value</field>
      <field name="Alpha" type="UWORD">Alpha component value</field>
    </struct>

    <struct name="RGB32" comment="32-bit RGB colour value.">
      <field name="Red" type="ULONG">Red component value</field>
      <field name="Green" type="ULONG">Green component value</field>
      <field name="Blue" type="ULONG">Blue component value</field>
      <field name="Alpha" type="ULONG">Alpha component value</field>
    </struct>

    <struct name="RGB8" comment="8-bit RGB colour value." typeName="RGB8">
      <field name="Red" type="UBYTE">Red component value</field>
      <field name="Green" type="UBYTE">Green component value</field>
      <field name="Blue" type="UBYTE">Blue component value</field>
      <field name="Alpha" type="UBYTE">Alpha component value</field>
    </struct>

    <struct name="RGBPalette">
      <field name="AmtColours" type="LONG">Amount of Colours</field>
      <field name="Col" type="struct RGB8" size="256">RGB Palette</field>
    </struct>

    <struct name="SystemState" comment="Returned by the GetSystemState() function.">
      <field name="Platform" type="CSTRING">String-based field indicating the user's platform.  Currently returns 'Native', 'Windows', 'OSX' or 'Linux'.</field>
      <field name="ConsoleFD" type="HOSTHANDLE">Internal</field>
      <field name="CoreVersion" type="LONG">Reflects the Core version number.</field>
      <field name="CoreRevision" type="LONG">Reflects the Core revision number.</field>
      <field name="Stage" type="LONG">The current operating stage.  -1 = Initialising, 0 indicates normal operating status; 1 means that the program is shutting down; 2 indicates a program restart; 3 is for mode switches.</field>
    </struct>

    <struct name="Variable">
      <field name="Type" type="ULONG">Field definition flags</field>
      <field name="Unused" type="LONG">Unused 32-bit value for 64-bit alignment</field>
      <field name="Large" type="LARGE">The value as a 64-bit integer.</field>
      <field name="Double" type="DOUBLE">The value as a 64-bit float-point number.</field>
      <field name="Pointer" type="APTR">The value as an address pointer.</field>
    </struct>

    <struct name="dcAudio" comment="Data feed structure for Audio">
      <field name="Size" type="LONG">Byte size of this structure</field>
      <field name="Format" type="LONG">Format of the audio data</field>
    </struct>

    <struct name="dcDeviceInput">
      <field name="Value" type="DOUBLE">The value associated with the Type</field>
      <field name="Timestamp" type="LARGE">PreciseTime() of the recorded input</field>
      <field name="DeviceID" type="OBJECTID">The hardware device that this event originated from (note: This ID can be to a private/inaccessible object, the point is that the ID is unique)</field>
      <field name="Flags" type="LONG">Broad descriptors for the given Type (see JTYPE flags).  Automatically set by the system when sent to the pointer object</field>
      <field name="Type" type="UWORD">JET constant</field>
      <field name="Unused" type="UWORD">Unused value for 32-bit padding</field>
    </struct>

    <struct name="dcKeyEntry" comment="Data feed structure for Keypress">
      <field name="Flags" type="LONG">Shift/Control/CapsLock...</field>
      <field name="Value" type="LONG">ASCII value of the key A/B/C/D...</field>
      <field name="Timestamp" type="LARGE">PreciseTime() at which the keypress was recorded</field>
      <field name="Unicode" type="LONG">Unicode value for pre-calculated key translations</field>
    </struct>

    <struct name="dcRequest" comment="Data feed item request">
      <field name="Item" type="LONG">Identifier for retrieval from the source</field>
      <field name="Preference" type="char" size="4">Data preferences for the returned item(s)</field>
    </struct>

    <struct name="pfBase64Decode" comment="Private structure for the Base64Decode() function." typeName="BASE64DECODE">
      <field name="Step" type="UBYTE">Internal</field>
      <field name="PlainChar" type="UBYTE">Internal</field>
      <field name="Initialised" type="UBYTE">Internal</field>
    </struct>

    <struct name="pfBase64Encode" comment="Private structure for the Base64Encode() function." typeName="BASE64ENCODE">
      <field name="Step" type="UBYTE">Internal</field>
      <field name="Result" type="UBYTE">Internal</field>
      <field name="StepCount" type="LONG">Internal</field>
    </struct>

  </structs>
</book>
