<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="module.xsl"?>

<book>
  <info>
    <name>Display</name>
    <type>module</type>
    <version>1</version>
    <status>stable</status>
    <prefix>gfx</prefix>
    <copyright>Paul Manias 2003-2024</copyright>
    <classes>
      <class>Bitmap</class>
      <class>Clipboard</class>
      <class>Display</class>
      <class>Pointer</class>
      <class>Surface</class>
    </classes>
    <categories>
      <category>Bitmap</category>
      <category>Cursor</category>
      <category>Display</category>
      <category>Input</category>
      <category>Surfaces</category>
    </categories>
  </info>

  <function>
    <name>AccessPointer</name>
    <category>Cursor</category>
    <comment>Returns a lock on the default pointer object.</comment>
    <prototype>objPointer * gfx::AccessPointer()</prototype>
    <description>
<p>Use AccessPointer() to grab a lock on the default pointer object that is active in the system.  This is typically the first object created from the Pointer class with a name of <code>SystemPointer</code>.</p>
<p>Call <function module="Core">ReleaseObject</function> to free the lock once it is no longer required.</p>
    </description>
    <result type="objPointer *">Returns the address of the default pointer object.</result>
  </function>

  <function>
    <name>CheckIfChild</name>
    <category>Surfaces</category>
    <comment>Check if a surface is the child of another surface.</comment>
    <prototype>ERR gfx::CheckIfChild(OBJECTID Parent, OBJECTID Child)</prototype>
    <input>
      <param type="OBJECTID" name="Parent">The surface that is assumed to be the parent.</param>
      <param type="OBJECTID" name="Child">The child surface to check.</param>
    </input>
    <description>
<p>This function checks if a surface identified by the Child value is the child of the surface identified by the Parent value.  <code>ERR::True</code> is returned if the surface is confirmed as being a child of the parent, or if the Child and Parent values are equal.  All other return codes indicate false or failure.</p>
    </description>
    <result type="ERR">
      <error code="True">The Child surface belongs to the Parent.</error>
      <error code="False">The Child surface is not a child of Parent.</error>
      <error code="Args">Invalid arguments were specified.</error>
      <error code="AccessMemory">Failed to access the internal surface list.</error>
    </result>
  </function>

  <function>
    <name>CopyArea</name>
    <category>Bitmap</category>
    <comment>Copies a rectangular area from one bitmap to another.</comment>
    <prototype>ERR gfx::CopyArea(objBitmap * Bitmap, objBitmap * Dest, BAF Flags, LONG X, LONG Y, LONG Width, LONG Height, LONG XDest, LONG YDest)</prototype>
    <input>
      <param type="objBitmap *" name="Bitmap">The source bitmap.</param>
      <param type="objBitmap *" name="Dest">Pointer to the destination bitmap.</param>
      <param type="BAF" name="Flags" lookup="BAF">Optional flags.</param>
      <param type="LONG" name="X">The horizontal position of the area to be copied.</param>
      <param type="LONG" name="Y">The vertical position of the area to be copied.</param>
      <param type="LONG" name="Width">The width of the area.</param>
      <param type="LONG" name="Height">The height of the area.</param>
      <param type="LONG" name="XDest">The horizontal position to copy the area to.</param>
      <param type="LONG" name="YDest">The vertical position to copy the area to.</param>
    </input>
    <description>
<p>This function copies rectangular areas from one bitmap to another.  It performs a straight region-copy only, using the fastest method available.  Bitmaps may be of a different type (e.g. bit depth), however this will result in performance penalties.  The copy process will respect the clipping region defined in both the source and destination bitmap objects.</p>
<p>If the <code>TRANSPARENT</code> flag is set in the source object, all colours that match the <class name="Bitmap" field="TransIndex">Bitmap.TransIndex</class> field will be ignored in the copy operation.</p>
<p>To enable dithering, pass <code>BAF::DITHER</code> in the Flags parameter.  The drawing algorithm will use dithering if the source needs to be down-sampled to the target bitmap's bit depth.  To enable alpha blending, set <code>BAF::BLEND</code> (the source bitmap will also need to have the <code>BMF::ALPHA_CHANNEL</code> flag set to indicate that an alpha channel is available).</p>
<p>The quality of 32-bit alpha blending can be improved by selecting the <code>BAF::LINEAR</code> flag.  This enables an additional computation whereby each RGB value is converted to linear sRGB colour space before performing the blend.  The discernible value of using this option largely depends on the level of opaqueness of either bitmap.  Note that this option is not usable if either bitmap is already in a linear colourspace (<code>ERR::InvalidState</code> will be returned if that is the case).</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="Mismatch">The destination bitmap is not a close enough match to the source bitmap in order to perform the blit.</error>
      <error code="InvalidState">The <code>LINEAR</code> flag was used when at least one bitmap is using a linear colourspace.</error>
      <error code="NullArgs">The <code>Dest</code> parameter was not specified.</error>
    </result>
  </function>

  <function>
    <name>CopyRawBitmap</name>
    <category>Bitmap</category>
    <comment>Copies graphics data from an arbitrary surface to a bitmap.</comment>
    <prototype>ERR gfx::CopyRawBitmap(struct BitmapSurfaceV2 * Surface, objBitmap * Dest, CSRF Flags, LONG X, LONG Y, LONG Width, LONG Height, LONG XDest, LONG YDest)</prototype>
    <input>
      <param type="struct BitmapSurfaceV2 *" name="Surface">Description of the surface source.</param>
      <param type="objBitmap *" name="Dest">Destination bitmap.</param>
      <param type="CSRF" name="Flags" lookup="CSRF">Optional flags.</param>
      <param type="LONG" name="X">Horizontal source coordinate.</param>
      <param type="LONG" name="Y">Vertical source coordinate.</param>
      <param type="LONG" name="Width">Source width.</param>
      <param type="LONG" name="Height">Source height.</param>
      <param type="LONG" name="XDest">Horizontal destination coordinate.</param>
      <param type="LONG" name="YDest">Vertical destination coordinate.</param>
    </input>
    <description>
<p>This function will copy data from a described surface to a destination bitmap object.  You are required to provide the function with a full description of the source in a <st>BitmapSurface</st> structure.</p>
<p>The <code>X</code>, <code>Y</code>, <code>Width</code> and <code>Height</code> parameters define the area from the source that you wish to copy.  The <code>XDest</code> and <code>YDest</code> parameters define the top left corner that you will blit the graphics to in the destination.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="Args">Invalid arguments passed to function.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>CopySurface</name>
    <category>Surfaces</category>
    <comment>Copies surface graphics data into any bitmap object</comment>
    <prototype>ERR gfx::CopySurface(OBJECTID Surface, objBitmap * Bitmap, BDF Flags, LONG X, LONG Y, LONG Width, LONG Height, LONG XDest, LONG YDest)</prototype>
    <input>
      <param type="OBJECTID" name="Surface">The ID of the surface object to copy from.</param>
      <param type="objBitmap *" name="Bitmap">Must reference a target Bitmap object.</param>
      <param type="BDF" name="Flags" lookup="BDF">Optional flags.</param>
      <param type="LONG" name="X">The horizontal source coordinate.</param>
      <param type="LONG" name="Y">The vertical source coordinate.</param>
      <param type="LONG" name="Width">The width of the graphic that will be copied.</param>
      <param type="LONG" name="Height">The height of the graphic that will be copied.</param>
      <param type="LONG" name="XDest">The horizontal target coordinate.</param>
      <param type="LONG" name="YDest">The vertical target coordinate.</param>
    </input>
    <description>
<p>This function will copy the graphics data from any surface object to a target <class name="Bitmap">Bitmap</class>.  This is the fastest and most convenient way to get graphics information out of any surface.  As surfaces are buffered, it is guaranteed that the result will not be obscured by any overlapping surfaces that are on the display.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="Search">The supplied SurfaceID did not refer to a recognised surface object</error>
      <error code="AccessMemory">Failed to access the internal surfacelist memory structure</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>DrawPixel</name>
    <category>Bitmap</category>
    <comment>Draws a single pixel to a bitmap.</comment>
    <prototype>void gfx::DrawPixel(objBitmap * Bitmap, LONG X, LONG Y, ULONG Colour)</prototype>
    <input>
      <param type="objBitmap *" name="Bitmap">The target bitmap object.</param>
      <param type="LONG" name="X">The horizontal coordinate of the pixel.</param>
      <param type="LONG" name="Y">The vertical coordinate of the pixel.</param>
      <param type="ULONG" name="Colour">The colour value to use for the pixel.</param>
    </input>
    <description>
<p>This function draws a pixel to the coordinates <code>(X, Y)</code> on a bitmap with a colour determined by the <code>Colour</code> index. This function will check the given coordinates to make sure that the pixel is inside the bitmap's clipping area.</p>
    </description>
  </function>

  <function>
    <name>DrawRGBPixel</name>
    <category>Bitmap</category>
    <comment>Draws a 24 bit pixel to a <class name="Bitmap">Bitmap</class>.</comment>
    <prototype>void gfx::DrawRGBPixel(objBitmap * Bitmap, LONG X, LONG Y, struct RGB8 * RGB)</prototype>
    <input>
      <param type="objBitmap *" name="Bitmap">The target bitmap object.</param>
      <param type="LONG" name="X">Horizontal coordinate of the pixel.</param>
      <param type="LONG" name="Y">Vertical coordinate of the pixel.</param>
      <param type="struct RGB8 *" name="RGB">The colour to be drawn, in RGB format.</param>
    </input>
    <description>
<p>This function draws an <st>RGB8</st> colour to the <code>(X, Y)</code> position of a target <class name="Bitmap">Bitmap</class>.  The function will check the given coordinates to ensure that the pixel is inside the bitmap's clipping area.</p>
    </description>
  </function>

  <function>
    <name>DrawRectangle</name>
    <category>Bitmap</category>
    <comment>Draws rectangles, both filled and unfilled.</comment>
    <prototype>void gfx::DrawRectangle(objBitmap * Bitmap, LONG X, LONG Y, LONG Width, LONG Height, ULONG Colour, BAF Flags)</prototype>
    <input>
      <param type="objBitmap *" name="Bitmap">Pointer to the target <class name="Bitmap">Bitmap</class>.</param>
      <param type="LONG" name="X">The left-most coordinate of the rectangle.</param>
      <param type="LONG" name="Y">The top-most coordinate of the rectangle.</param>
      <param type="LONG" name="Width">The width of the rectangle.</param>
      <param type="LONG" name="Height">The height of the rectangle.</param>
      <param type="ULONG" name="Colour">The colour value to use for the rectangle.</param>
      <param type="BAF" name="Flags" lookup="BAF">Use <code>FILL</code> to fill the rectangle.  Use of <code>BLEND</code> will enable blending.</param>
    </input>
    <description>
<p>This function draws both filled and unfilled rectangles.  The rectangle is drawn to the target bitmap at position (X, Y) with dimensions determined by the specified <code>Width</code> and <code>Height</code>.  If the <code>Flags</code> parameter defines <code>BAF::FILL</code> then the rectangle will be filled, otherwise only the outline will be drawn.  The colour of the rectangle is determined by the pixel value in the <code>Colour</code> parameter.  Blending is not enabled unless the <code>BAF::BLEND</code> flag is defined and an alpha value is present in the <code>Colour</code>.</p>
    </description>
  </function>

  <function>
    <name>ExposeSurface</name>
    <category>Surfaces</category>
    <comment>Exposes the content of a surface to the display.</comment>
    <prototype>ERR gfx::ExposeSurface(OBJECTID Surface, LONG X, LONG Y, LONG Width, LONG Height, EXF Flags)</prototype>
    <input>
      <param type="OBJECTID" name="Surface">The ID of the surface object that will be exposed.</param>
      <param type="LONG" name="X">The horizontal coordinate of the area to expose.</param>
      <param type="LONG" name="Y">The vertical coordinate of the area to expose.</param>
      <param type="LONG" name="Width">The width of the expose area.</param>
      <param type="LONG" name="Height">The height of the expose area.</param>
      <param type="EXF" name="Flags" lookup="EXF">Optional flags - using CHILDREN will expose all intersecting child regions.</param>
    </input>
    <description>
<p>This expose routine will expose all content within a defined surface area, copying it to the display.  This will include all child surfaces that intersect with the region being exposed if you set the <code>EXF::CHILDREN</code> flag.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="Search">The SurfaceID does not refer to an existing surface object</error>
      <error code="AccessMemory">The internal surfacelist could not be accessed</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>FlipBitmap</name>
    <category>Bitmap</category>
    <comment>Flips a bitmap around its horizontal or vertical axis.</comment>
    <prototype>void gfx::FlipBitmap(objBitmap * Bitmap, FLIP Orientation)</prototype>
    <input>
      <param type="objBitmap *" name="Bitmap">Pointer to a bitmap object.</param>
      <param type="FLIP" name="Orientation" lookup="FLIP">Set to either <code>HORIZONTAL</code> or <code>VERTICAL</code>.  If set to neither, the function does nothing.</param>
    </input>
    <description>
<p>The FlipBitmap() function is used to flip bitmap images on their horizontal or vertical axis.  The amount of time required to flip a bitmap is dependent on the area of the bitmap you are trying to flip over and its total number of colours.</p>
    </description>
  </function>

  <function>
    <name>GetColourFormat</name>
    <category>Bitmap</category>
    <comment>Generates the values for a <st>ColourFormat</st> structure for a given bit depth.</comment>
    <prototype>void gfx::GetColourFormat(struct ColourFormat * Format, LONG BitsPerPixel, LONG RedMask, LONG GreenMask, LONG BlueMask, LONG AlphaMask)</prototype>
    <input>
      <param type="struct ColourFormat *" name="Format">Pointer to an empty <st>ColourFormat</st> structure.</param>
      <param type="LONG" name="BitsPerPixel">The depth that you would like to generate colour values for.  Ignored if mask values are set.</param>
      <param type="LONG" name="RedMask">Red component bit mask value.  Set this value to zero if the <code>BitsPerPixel</code> parameter is used.</param>
      <param type="LONG" name="GreenMask">Green component bit mask value.</param>
      <param type="LONG" name="BlueMask">Blue component bit mask value.</param>
      <param type="LONG" name="AlphaMask">Alpha component bit mask value.</param>
    </input>
    <description>
<p>This function will generate the values for a <st>ColourFormat</st> structure, for either a given bit depth or customised colour bit values.  The <st>ColourFormat</st> structure is used by internal bitmap routines to pack and unpack bit values to and from bitmap memory.</p>
<p>The <st>ColourFormat</st> structure is supported by the following macros for packing and unpacking colour bit values:</p>
<pre>Colour = CFPackPixel(Format,Red,Green,Blue)
Colour = CFPackPixelA(Format,Red,Green,Blue,Alpha)
Colour = CFPackAlpha(Format,Alpha)
Red    = CFUnpackRed(Format,Colour)
Green  = CFUnpackGreen(Format,Colour)
Blue   = CFUnpackBlue(Format,Colour)
Alpha  = CFUnpackAlpha(Format,Colour)
</pre>
    </description>
  </function>

  <function>
    <name>GetCursorInfo</name>
    <category>Cursor</category>
    <comment>Retrieves graphics information from the active mouse cursor.</comment>
    <prototype>ERR gfx::GetCursorInfo(struct CursorInfo * Info, LONG Size)</prototype>
    <input>
      <param type="struct CursorInfo *" name="Info">Pointer to a CursorInfo structure.</param>
      <param type="LONG" name="Size">The byte-size of the Info structure.</param>
    </input>
    <description>
<p>The GetCursorInfo() function is used to retrieve useful information on the graphics structure of the mouse cursor.  It will return the maximum possible dimensions for custom cursor graphics and indicates the optimal bits-per-pixel setting for the hardware cursor.</p>
<p>If there is no cursor (e.g. this is likely on touch-screen devices) then all field values will be set to zero.</p>
<p>Note: If the hardware cursor is monochrome, the bits-per-pixel setting will be set to 2 on return.  This does not indicate a 4 colour cursor image; rather colour 0 is the mask, 1 is the foreground colour (black), 2 is the background colour (white) and 3 is an XOR pixel.  When creating the bitmap, always set the palette to the RGB values that are wanted.  The mask colour for the bitmap must refer to colour index 0.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="NoSupport">The device does not support a cursor (common for touch screen displays).</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>GetCursorPos</name>
    <category>Cursor</category>
    <comment>Returns the coordinates of the UI pointer.</comment>
    <prototype>ERR gfx::GetCursorPos(DOUBLE * X, DOUBLE * Y)</prototype>
    <input>
      <param type="DOUBLE *" name="X">Variable that will store the pointer's horizontal coordinate.</param>
      <param type="DOUBLE *" name="Y">Variable that will store the pointer's vertical coordinate.</param>
    </input>
    <description>
<p>This function will return the current coordinates of the mouse cursor.  If the device is touch-screen based then the coordinates will reflect the last position that a touch event occurred.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="AccessObject">Failed to access the SystemPointer object.</error>
    </result>
  </function>

  <function>
    <name>GetDisplayInfo</name>
    <category>Display</category>
    <comment>Retrieves display information.</comment>
    <prototype>ERR gfx::GetDisplayInfo(OBJECTID Display, struct DisplayInfoV3 ** Info)</prototype>
    <input>
      <param type="OBJECTID" name="Display">Object ID of the display to be analysed.</param>
      <param type="struct DisplayInfoV3 **" name="Info">This reference will receive a pointer to a DISPLAYINFO structure.</param>
    </input>
    <description>
<p>The GetDisplayInfo() function returns information about a display, which includes information such as its size and bit depth.  If the system is running on a hosted display (e.g. Windows or X11) then GetDisplayInfo() can also be used to retrieve information about the default monitor by using a Display of zero.</p>
<p>The resulting <code>DISPLAYINFO</code> structure values remain good until the next call to this function, at which point they will be overwritten.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="AllocMemory">A call to AllocMemory() failed to create a new memory block.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>GetDisplayType</name>
    <category>Display</category>
    <comment>Returns the type of display supported.</comment>
    <prototype>DT gfx::GetDisplayType()</prototype>
    <description>
<p>This function returns the type of display supported by the loaded Display module.  Current return values are:</p>
<types lookup="DT"/>
    </description>
    <result type="DT" lookup="DT">Returns an integer indicating the display type.</result>
  </function>

  <function>
    <name>GetInputTypeName</name>
    <category>Input</category>
    <comment>Returns the string name for an input type.</comment>
    <prototype>CSTRING gfx::GetInputTypeName(JET Type)</prototype>
    <input>
      <param type="JET" name="Type" lookup="JET">JET type integer.</param>
    </input>
    <description>
<p>This function converts <code>JET</code> integer constants to their string equivalent.</p>
    </description>
    <result type="CSTRING">A string describing the input type is returned or NULL if the Type is invalid.</result>
  </function>

  <function>
    <name>GetModalSurface</name>
    <category>Surfaces</category>
    <comment>Returns the current modal surface (if defined).</comment>
    <prototype>OBJECTID gfx::GetModalSurface()</prototype>
    <description>
<p>This function returns the modal surface for the running process.  Returns zero if no modal surface is active.</p>
    </description>
    <result type="OBJECTID">The UID of the modal surface, or zero.</result>
  </function>

  <function>
    <name>GetRelativeCursorPos</name>
    <category>Cursor</category>
    <comment>Returns the coordinates of the pointer cursor, relative to a surface object.</comment>
    <prototype>ERR gfx::GetRelativeCursorPos(OBJECTID Surface, DOUBLE * X, DOUBLE * Y)</prototype>
    <input>
      <param type="OBJECTID" name="Surface">Unique ID of the surface that the coordinates need to be relative to.</param>
      <param type="DOUBLE *" name="X">Variable that will store the pointer's horizontal coordinate.</param>
      <param type="DOUBLE *" name="Y">Variable that will store the pointer's vertical coordinate.</param>
    </input>
    <description>
<p>This function is used to retrieve the current coordinates of the pointer cursor. The coordinates are relative to the surface object that is specified in the Surface argument.</p>
<p>The X and Y parameters will not be set if a failure occurs.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="AccessObject">Failed to access the SystemPointer object.</error>
    </result>
  </function>

  <function>
    <name>GetSurfaceCoords</name>
    <category>Surfaces</category>
    <comment>Returns the dimensions of a surface.</comment>
    <prototype>ERR gfx::GetSurfaceCoords(OBJECTID Surface, LONG * X, LONG * Y, LONG * AbsX, LONG * AbsY, LONG * Width, LONG * Height)</prototype>
    <input>
      <param type="OBJECTID" name="Surface">The surface to query.  If zero, the top-level display is queried.</param>
      <param type="LONG *" name="X">The X coordinate of the surface is returned here.</param>
      <param type="LONG *" name="Y">The Y coordinate of the surface is returned here.</param>
      <param type="LONG *" name="AbsX">The absolute X coordinate of the surface is returned here.</param>
      <param type="LONG *" name="AbsY">The absolute Y coordinate of the surface is returned here.</param>
      <param type="LONG *" name="Width">The width of the surface is returned here.</param>
      <param type="LONG *" name="Height">The height of the surface is returned here.</param>
    </input>
    <description>
<p>GetSurfaceCoords() retrieves the dimensions that describe a surface object's area as X, Y, Width and Height.  This is the fastest way to retrieve surface dimensions when access to the object structure is not already available.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="Search">The supplied SurfaceID did not refer to a recognised surface object.</error>
      <error code="AccessMemory">Failed to access the internal surfacelist memory structure.</error>
    </result>
  </function>

  <function>
    <name>GetSurfaceFlags</name>
    <category>Surfaces</category>
    <comment>Retrieves the Flags field from a surface.</comment>
    <prototype>ERR gfx::GetSurfaceFlags(OBJECTID Surface, RNF * Flags)</prototype>
    <input>
      <param type="OBJECTID" name="Surface">The surface to query.  If zero, the top-level surface is queried.</param>
      <param type="RNF *" name="Flags" lookup="RNF">The flags value is returned here.</param>
    </input>
    <description>
<p>This function returns the current Flags field from a surface.  It provides the same result as reading the field directly, however it is considered advantageous in circumstances where the overhead of locking a surface object for a read operation is undesirable.</p>
<p>For information on the available flags, please refer to the Flags field of the <class name="Surface">Surface</class> class.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="AccessMemory">Access to a shared memory block was denied.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>GetSurfaceInfo</name>
    <category>Surfaces</category>
    <comment>Retrieves display information for any surface object without having to access it directly.</comment>
    <prototype>ERR gfx::GetSurfaceInfo(OBJECTID Surface, struct SurfaceInfoV2 ** Info)</prototype>
    <input>
      <param type="OBJECTID" name="Surface">The unique ID of a surface to query.  If zero, the root surface is returned.</param>
      <param type="struct SurfaceInfoV2 **" name="Info">This parameter will receive a SurfaceInfo pointer that describes the Surface object.</param>
    </input>
    <description>
<p>GetSurfaceInfo() is used for quickly retrieving basic information from surfaces, allowing the client to bypass the AccessObject() function.  The resulting structure values are good only up until the next call to this function, at which point those values will be overwritten.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="Search">The supplied SurfaceID did not refer to a recognised surface object.</error>
      <error code="Args">Invalid arguments passed to function.</error>
      <error code="AccessMemory">Failed to access the internal surfacelist memory structure.</error>
    </result>
  </function>

  <function>
    <name>GetUserFocus</name>
    <category>Surfaces</category>
    <comment>Returns the ID of the surface that currently has the user's focus.</comment>
    <prototype>OBJECTID gfx::GetUserFocus()</prototype>
    <description>
<p>This function returns the unique ID of the surface that has the user's focus.</p>
    </description>
    <result type="OBJECTID">Returns the ID of the surface object that has the user focus, or zero on failure.</result>
  </function>

  <function>
    <name>GetVisibleArea</name>
    <category>Surfaces</category>
    <comment>Returns the visible region of a surface.</comment>
    <prototype>ERR gfx::GetVisibleArea(OBJECTID Surface, LONG * X, LONG * Y, LONG * AbsX, LONG * AbsY, LONG * Width, LONG * Height)</prototype>
    <input>
      <param type="OBJECTID" name="Surface">The surface to query.  If zero, the top-level display will be queried.</param>
      <param type="LONG *" name="X">The X coordinate of the visible area.</param>
      <param type="LONG *" name="Y">The Y coordinate of the visible area.</param>
      <param type="LONG *" name="AbsX">The absolute X coordinate of the visible area.</param>
      <param type="LONG *" name="AbsY">The absolute Y coordinate of the visible area.</param>
      <param type="LONG *" name="Width">The visible width of the surface.</param>
      <param type="LONG *" name="Height">The visible height of the surface.</param>
    </input>
    <description>
<p>The GetVisibleArea() function returns the visible area of a surface, which is based on its position within its parent surfaces. The resulting coordinates are relative to point <code>0,0</code> of the queried surface. If the surface is not obscured, then the resulting coordinates will be <code>(0,0),(Width,Height)</code>.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="Search">The supplied SurfaceID did not refer to a recognised surface object.</error>
      <error code="AccessMemory">Failed to access the internal surfacelist memory structure.</error>
    </result>
  </function>

  <function>
    <name>LockBitmap</name>
    <category>Surfaces</category>
    <comment>Returns a bitmap that represents the video area covered by the surface object.</comment>
    <prototype>ERR gfx::LockBitmap(OBJECTID Surface, objBitmap ** Bitmap, LVF * Info)</prototype>
    <input>
      <param type="OBJECTID" name="Surface">Object ID of the surface object that you want to lock.</param>
      <param type="objBitmap **" name="Bitmap">The resulting bitmap will be returned in this parameter.</param>
      <param type="LVF *" name="Info" lookup="LVF">Special flags may be returned in this parameter.  If EXPOSE_CHANGES is returned, any changes must be exposed in order for them to be displayed to the user.</param>
    </input>
    <description>
<p>Use the LockBitmap() function to gain direct access to the bitmap information of a surface object. Because the layering buffer will be inaccessible to the UI whilst you retain the lock, you must keep your access time to an absolute minimum or desktop performance may suffer.</p>
<p>Repeated calls to this function will nest.  To release a surface bitmap, call the <function>UnlockBitmap</function> function.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="Args">Invalid arguments passed to function.</error>
    </result>
  </function>

  <function>
    <name>LockCursor</name>
    <category>Cursor</category>
    <comment>Anchors the cursor so that it cannot move without explicit movement signals.</comment>
    <prototype>ERR gfx::LockCursor(OBJECTID Surface)</prototype>
    <input>
      <param type="OBJECTID" name="Surface">Refers to the surface object that the pointer should send movement signals to.</param>
    </input>
    <description>
<p>The LockCursor() function will lock the current pointer position and pass UserMovement signals to the surface referenced in the Surface parameter.  The pointer will not move unless the <function>SetCursorPos</function> function is called. The anchor is granted on a time-limited basis.  It is necessary to reissue the anchor every time that a UserMovement signal is intercepted.  Failure to reissue the anchor will return the pointer to its normal state, typically within 200 microseconds.</p>
<p>The anchor can be released at any time by calling the <function>UnlockCursor</function> function.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="NoSupport">The pointer cannot be locked due to system limitations.</error>
      <error code="AccessObject">Failed to access the pointer object.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>ReadPixel</name>
    <category>Bitmap</category>
    <comment>Reads a pixel's colour from the target bitmap.</comment>
    <prototype>ULONG gfx::ReadPixel(objBitmap * Bitmap, LONG X, LONG Y)</prototype>
    <input>
      <param type="objBitmap *" name="Bitmap">Pointer to a bitmap object.</param>
      <param type="LONG" name="X">The horizontal coordinate of the pixel.</param>
      <param type="LONG" name="Y">The vertical coordinate of the pixel.</param>
    </input>
    <description>
<p>This function reads a pixel from a bitmap area and returns its colour index (if the <class name="Bitmap">Bitmap</class> is indexed with a palette) or its packed pixel value.  Zero is returned if the pixel is out of bounds.</p>
    </description>
    <result type="ULONG">The colour value of the pixel will be returned.  Zero is returned if the pixel is out of bounds.</result>
  </function>

  <function>
    <name>ReadRGBPixel</name>
    <category>Bitmap</category>
    <comment>Reads a pixel's colour from the target bitmap.</comment>
    <prototype>void gfx::ReadRGBPixel(objBitmap * Bitmap, LONG X, LONG Y, struct RGB8 ** RGB)</prototype>
    <input>
      <param type="objBitmap *" name="Bitmap">Pointer to a bitmap object.</param>
      <param type="LONG" name="X">The horizontal coordinate of the pixel.</param>
      <param type="LONG" name="Y">The vertical coordinate of the pixel.</param>
      <param type="struct RGB8 **" name="RGB">The colour values will be stored in this <st>RGB8</st> structure.</param>
    </input>
    <description>
<p>This function reads a pixel from a bitmap surface and returns the value in an <st>RGB8</st> structure that remains good up until the next call to this function.  Zero is returned in the alpha component if the pixel is out of bounds.</p>
<p>This function is thread-safe if the target <class name="Bitmap">Bitmap</class> is locked.</p>
    </description>
  </function>

  <function>
    <name>Resample</name>
    <category>Bitmap</category>
    <comment>Resamples a bitmap by dithering it to a new set of colour masks.</comment>
    <prototype>ERR gfx::Resample(objBitmap * Bitmap, struct ColourFormat * ColourFormat)</prototype>
    <input>
      <param type="objBitmap *" name="Bitmap">The bitmap object to be resampled.</param>
      <param type="struct ColourFormat *" name="ColourFormat">The new colour format to be applied to the bitmap.</param>
    </input>
    <description>
<p>The Resample() function provides a means for resampling a bitmap to a new colour format without changing the actual bit depth of the image. It uses dithering so as to retain the quality of the image when down-sampling.  This function is generally used to 'pre-dither' true colour bitmaps in preparation for copying to bitmaps with lower colour quality.</p>
<p>You are required to supply a <st>ColourFormat</st> structure that describes the colour format that you would like to apply to the bitmap's image data.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>RestoreCursor</name>
    <category>Cursor</category>
    <comment>Returns the pointer image to its original state.</comment>
    <prototype>ERR gfx::RestoreCursor(PTC Cursor, OBJECTID Owner)</prototype>
    <input>
      <param type="PTC" name="Cursor" lookup="PTC">The cursor image that the pointer will be restored to (0 for the default).</param>
      <param type="OBJECTID" name="Owner">The ownership ID that was given in the initial call to SetCursor().</param>
    </input>
    <description>
<p>Use the RestoreCursor() function to undo an earlier call to <function>SetCursor</function>.  It is necessary to provide the same OwnerID that was used in the original call to <function>SetCursor</function>.</p>
<p>To release ownership of the cursor without changing the current cursor image, use a Cursor setting of <code>PTC::NOCHANGE</code>.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="Args">Invalid arguments passed to function.</error>
    </result>
  </function>

  <function>
    <name>ScaleToDPI</name>
    <category>Display</category>
    <comment>Scales a value to the active display's DPI.</comment>
    <prototype>DOUBLE gfx::ScaleToDPI(DOUBLE Value)</prototype>
    <input>
      <param type="DOUBLE" name="Value">The number to be scaled.</param>
    </input>
    <description>
<p>ScaleToDPI() is a convenience function for scaling any value to the active display's current DPI setting.  The value that you provide must be fixed in relation to the system wide default of 96 DPI.  If the display's DPI varies differs to that, your value will be scaled to match.  For instance, an 8 point font at 96 DPI would be scaled to 20 points if the display was 240 DPI.</p>
<p>If the DPI of the display is unknown, your value will be returned unscaled.</p>
    </description>
    <result type="DOUBLE">The scaled value is returned.</result>
  </function>

  <function>
    <name>SetClipRegion</name>
    <category>Bitmap</category>
    <comment>Sets a clipping region for a bitmap object.</comment>
    <prototype>void gfx::SetClipRegion(objBitmap * Bitmap, LONG Number, LONG Left, LONG Top, LONG Right, LONG Bottom, LONG Terminate)</prototype>
    <input>
      <param type="objBitmap *" name="Bitmap">The target bitmap.</param>
      <param type="LONG" name="Number">The number of the clip region to set.</param>
      <param type="LONG" name="Left">The horizontal start of the clip region.</param>
      <param type="LONG" name="Top">The vertical start of the clip region.</param>
      <param type="LONG" name="Right">The right-most edge of the clip region.</param>
      <param type="LONG" name="Bottom">The bottom-most edge of the clip region.</param>
      <param type="LONG" name="Terminate">Set to <code>true</code> if this is the last clip region in the list, otherwise <code>false</code>.</param>
    </input>
    <description>
<p>The SetClipRegion() method is used to manage the clipping regions assigned to a bitmap object.  Each new bitmap that is created has at least one clip region assigned to it, but by using SetClipRegion() you can also define multiple clipping areas, which is useful for complex graphics management.</p>
<p>Each clipping region that you set is assigned a Number, starting from zero which is the default.  Each time that you set a new clip region you must specify the number of the region that you wish to set.  If you attempt to 'skip' regions - for instance, if you set regions 0, 1, 2 and 3, then skip 4 and set 5, the routine will set region 4 instead. If you have specified multiple clip regions and want to lower the count or reset the list, set the number of the last region that you want in your list and set the <code>Terminate</code> parameter to <code>true</code> to kill the regions specified beyond it.</p>
<p>The <code>ClipLeft</code>, <code>ClipTop</code>, <code>ClipRight</code> and <code>ClipBottom</code> fields in the target <code>Bitmap</code> will be updated to reflect the overall area that is covered by the clipping regions that have been set.</p>
    </description>
  </function>

  <function>
    <name>SetCursor</name>
    <category>Cursor</category>
    <comment>Sets the cursor image and can anchor the pointer to any surface.</comment>
    <prototype>ERR gfx::SetCursor(OBJECTID Surface, CRF Flags, PTC Cursor, CSTRING Name, OBJECTID Owner)</prototype>
    <input>
      <param type="OBJECTID" name="Surface">Refers to the surface object that the pointer should anchor itself to, if the RESTRICT flag is used.  Otherwise, this parameter can be set to a surface that the new cursor image should be limited to.  The object referred to here must be publicly accessible to all tasks.</param>
      <param type="CRF" name="Flags" lookup="CRF">Optional flags that affect the cursor.</param>
      <param type="PTC" name="Cursor" lookup="PTC">The ID of the cursor image that is to be set.</param>
      <param type="CSTRING" name="Name">The name of the cursor image that is to be set (if Cursor is zero).</param>
      <param type="OBJECTID" name="Owner">The object nominated as the owner of the anchor, and/or owner of the cursor image setting.</param>
    </input>
    <description>
<p>Use the SetCursor() function to change the pointer image and/or restrict the movement of the pointer to a surface area.</p>
<p>To change the cursor image, set the Cursor or Name parameters to define the new image.  Valid cursor ID's and their equivalent names are listed in the documentation for the Cursor field.  If the ObjectID field is set to a valid surface, then the cursor image will switch back to the default setting once the pointer moves outside of its region.  If both the Cursor and Name parameters are NULL, the cursor image will remain unchanged from its current image.</p>
<p>The SetCursor() function accepts the following flags in the Flags parameter:</p>
<types lookup="CRF"/>
<p>The Owner parameter is used as a locking mechanism to prevent the cursor from being changed whilst it is locked.  We recommend that it is set to an object ID such as the program's task ID.  As the owner, the cursor remains under your program's control until <function>RestoreCursor</function> is called.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="Args">Invalid arguments passed to function.</error>
      <error code="NoSupport">The pointer cannot be set due to system limitations.</error>
      <error code="OutOfRange">The cursor ID is outside of acceptable range.</error>
      <error code="AccessObject">Failed to access the internally maintained image object.</error>
    </result>
  </function>

  <function>
    <name>SetCursorPos</name>
    <category>Cursor</category>
    <comment>Changes the position of the pointer cursor.</comment>
    <prototype>ERR gfx::SetCursorPos(DOUBLE X, DOUBLE Y)</prototype>
    <input>
      <param type="DOUBLE" name="X">The new horizontal coordinate for the pointer.</param>
      <param type="DOUBLE" name="Y">The new vertical coordinate for the pointer.</param>
    </input>
    <description>
<p>Changes the position of the pointer cursor using coordinates relative to the entire display.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="AccessObject">Failed to access the SystemPointer object.</error>
    </result>
  </function>

  <function>
    <name>SetCustomCursor</name>
    <category>Cursor</category>
    <comment>Sets the cursor to a customised bitmap image.</comment>
    <prototype>ERR gfx::SetCustomCursor(OBJECTID Surface, CRF Flags, objBitmap * Bitmap, LONG HotX, LONG HotY, OBJECTID Owner)</prototype>
    <input>
      <param type="OBJECTID" name="Surface">Refers to the surface object that the pointer should restrict itself to, if the RESTRICT flag is used.  Otherwise, this parameter can be set to a surface that the new cursor image should be limited to.  The object referred to here must be publicly accessible to all tasks.</param>
      <param type="CRF" name="Flags" lookup="CRF">Optional flags affecting the cursor are set here.</param>
      <param type="objBitmap *" name="Bitmap">The bitmap to set for the mouse cursor.</param>
      <param type="LONG" name="HotX">The horizontal position of the cursor hot-spot.</param>
      <param type="LONG" name="HotY">The vertical position of the cursor hot-spot.</param>
      <param type="OBJECTID" name="Owner">The object nominated as the owner of the anchor.</param>
    </input>
    <description>
<p>Use the SetCustomCursor() function to change the pointer image and/or anchor the position of the pointer so that it cannot move without permission.  The functionality provided is identical to that of the SetCursor() function with some minor adjustments to allow custom images to be set.</p>
<p>The Bitmap that is provided should be within the width, height and bits-per-pixel settings that are returned by the GetCursorInfo() function.  If the basic settings are outside the allowable parameters, the Bitmap will be trimmed or resampled appropriately when the cursor is downloaded to the video card.</p>
<p>It may be possible to speed up the creation of custom cursors by drawing directly to the pointer's internal bitmap buffer rather than supplying a fresh bitmap.  To do this, the Bitmap parameter must be NULL and it is necessary to draw to the pointer's bitmap before calling SetCustomCursor().  Note that the bitmap is always returned as a 32-bit, alpha-enabled graphics area.  The following code illustrates this process:</p>
<pre>if (auto pointer = gfx::AccessPointer()) {
   objBitmap *bitmap;
   if (!AccessObject(pointer-&gt;BitmapID, 3000, &amp;bitmap)) {
      // Adjust clipping to match the cursor size.
      buffer-&gt;Clip.Right  = CursorWidth;
      buffer-&gt;Clip.Bottom = CursorHeight;
      if (buffer-&gt;Clip.Right &gt; buffer-&gt;Width) buffer-&gt;Clip.Right = buffer-&gt;Width;
      if (buffer-&gt;Clip.Bottom &gt; buffer-&gt;Height) buffer-&gt;Clip.Bottom = buffer-&gt;Height;

      // Draw to the bitmap here.
      ...

      gfx::SetCustomCursor(ObjectID, NULL, NULL, 1, 1, glTaskID, NULL);
      ReleaseObject(bitmap);
   }
   gfx::ReleasePointer(pointer);
}
</pre>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="Args">Invalid arguments passed to function.</error>
      <error code="NoSupport">This request is not supported.</error>
      <error code="AccessObject">Failed to access the internally maintained image object.</error>
    </result>
  </function>

  <function>
    <name>SetHostOption</name>
    <category>Display</category>
    <comment>Alter options associated with the host display system.</comment>
    <prototype>ERR gfx::SetHostOption(HOST Option, LARGE Value)</prototype>
    <input>
      <param type="HOST" name="Option" lookup="HOST">One of TRAY_ICON, TASKBAR or STICK_TO_FRONT.</param>
      <param type="LARGE" name="Value">The value to be applied to the option.</param>
    </input>
    <description>
<p>For internal usage only.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
    </result>
  </function>

  <function>
    <name>SetModalSurface</name>
    <category>Surfaces</category>
    <comment>Enables a modal surface for the current task.</comment>
    <prototype>OBJECTID gfx::SetModalSurface(OBJECTID Surface)</prototype>
    <input>
      <param type="OBJECTID" name="Surface">The surface to enable as modal.</param>
    </input>
    <description>
<p>Any surface that is created by a task can be enabled as a modal surface.  A surface that has been enabled as modal becomes the central point for all GUI interaction with the task.  All other I/O between the user and surfaces maintained by the task will be ignored for as long as the target surface remains modal.</p>
<p>A task can switch off the current modal surface by calling this function with a Surface parameter of zero.</p>
<p>If a surface is modal at the time that this function is called, it is not possible to switch to a new modal surface until the current modal state is dropped.</p>
    </description>
    <result type="OBJECTID">The object ID of the previous modal surface is returned (zero if there was no currently modal surface).</result>
  </function>

  <function>
    <name>StartCursorDrag</name>
    <category>Cursor</category>
    <comment>Attaches an item to the cursor for the purpose of drag and drop.</comment>
    <prototype>ERR gfx::StartCursorDrag(OBJECTID Source, LONG Item, CSTRING Datatypes, OBJECTID Surface)</prototype>
    <input>
      <param type="OBJECTID" name="Source">Refers to an object that is managing the source data.</param>
      <param type="LONG" name="Item">A custom number that represents the item being dragged from the source.</param>
      <param type="CSTRING" name="Datatypes">A null terminated byte array that lists the datatypes supported by the source item, in order of conversion preference.</param>
      <param type="OBJECTID" name="Surface">A 32-bit composite surface that represents the item being dragged.</param>
    </input>
    <description>
<p>This function starts a drag and drop operation with the mouse cursor.  The user must be holding the primary mouse button to initiate the drag and drop operation.</p>
<p>A Source object ID is required that indicates the origin of the item being dragged and will be used to retrieve the data on completion of the drag and drop operation. An Item number, which is optional, identifies the item being dragged from the Source object.</p>
<p>The type of data represented by the source item and all other supportable data types are specified in the Datatypes parameter as a null terminated array.  The array is arranged in order of preference, starting with the item's native data type.  Acceptable data type values are listed in the documentation for the DataFeed action.</p>
<p>The Surface argument allows for a composite surface to be dragged by the mouse cursor as a graphical representation of the source item.  It is recommended that the graphic be 32x32 pixels in size and no bigger than 64x64 pixels.  The Surface will be hidden on completion of the drag and drop operation.</p>
<p>If the call to StartCursorDrag() is successful, the mouse cursor will operate in drag and drop mode.  The UserMovement and UserClickRelease actions normally reported from the SystemPointer will now include the <code>JD_DRAGITEM</code> flag in the ButtonFlags parameter.  When the user releases the primary mouse button, the drag and drop operation will stop and the DragDrop action will be passed to the surface immediately underneath the mouse cursor.  Objects that are monitoring for the DragDrop action on that surface can then contact the Source object with a DataFeed DragDropRequest.  The resulting data is then passed to the requesting object with a DragDropResult on the DataFeed.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="InUse">A drag and drop operation has already been started.</error>
      <error code="Failed">The left mouse button is not held by the user.</error>
      <error code="AccessObject">An attempt to gain exclusive access to a shared object failed.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>SubscribeInput</name>
    <category>Input</category>
    <comment>Subscribe to incoming input messages for any active surface object.</comment>
    <prototype>ERR gfx::SubscribeInput(FUNCTION * Callback, OBJECTID SurfaceFilter, JTYPE Mask, OBJECTID DeviceFilter, LONG * Handle)</prototype>
    <input>
      <param type="FUNCTION *" name="Callback">Reference to a callback function that will receive input messages.</param>
      <param type="OBJECTID" name="SurfaceFilter">Optional.  Only the input messages that match the given surface ID will be received.</param>
      <param type="JTYPE" name="Mask" lookup="JTYPE">Combine JTYPE flags to define the input messages required by the client.  Set to 0xffffffff if all messages are desirable.</param>
      <param type="OBJECTID" name="DeviceFilter">Optional.  Only the input messages that match the given device ID will be received.  NOTE - Support not yet implemented, set to zero.</param>
      <param type="LONG *" name="Handle">A handle for the subscription is returned here.</param>
    </input>
    <description>
<p>The SubscribeInput() function provides a systematic way of receiving input events as they occur.  Coverage is limited to device events that are linked to the display (i.e. events from track pads, mouse pointers, graphics tablets and touch screens).  Keyboard devices are not included.</p>
<p>The client is required to remove the subscription with <function>UnsubscribeInput</function> once tracking is no longer required.</p>
<p>Input events can be filtered so that they are received in relation to surfaces and devices.  An input mask can also be applied so that only certain types of events are received.</p>
<p>A callback is required for receiving the input events.  The following C++ code illustrates a method for processing events in the callback:</p>
<pre>ERR consume_input_events(const InputEvent *Events, LONG Handle)
{
   for (auto e=Events; e; e=e-&gt;Next) {
      if (((e-&gt;Flags &amp; JTYPE::BUTTON) != JTYPE::NIL) and (e-&gt;Value &gt; 0)) {
         process_click(Self, e-&gt;RecipientID, e-&gt;X, e-&gt;Y);
      }
   }

   return ERR::Okay;
}
</pre>
<p>All processable events are referenced in the InputEvent structure in the Events parameter.</p>
<p>
<code>JET</code> constants are as follows and take note of <code>CROSSED_IN</code> and <code>CROSSED_OUT</code> which are software generated and not a device event:</p>
<types lookup="JET"/>
<p>The <code>JTYPE</code> values for the Flags field are as follows.  Note that these flags also serve as input masks for the SubscribeInput() function, so to receive a message of the given type the appropriate <code>JTYPE</code> flag must have been set in the original subscription call.</p>
<types lookup="JTYPE"/>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>Sync</name>
    <category>Bitmap</category>
    <comment>Waits for the completion of all active bitmap operations.</comment>
    <prototype>void gfx::Sync(objBitmap * Bitmap)</prototype>
    <input>
      <param type="objBitmap *" name="Bitmap">Pointer to the bitmap that you want to synchronise or <code>NULL</code> to sleep on the graphics accelerator.</param>
    </input>
    <description>
<p>The Sync() function will wait for all current video operations to complete before it returns.  This ensures that it is safe to write to video memory with the CPU, preventing any possibility of clashes with the onboard graphics chip.</p>
    </description>
  </function>

  <function>
    <name>UnlockBitmap</name>
    <category>Surfaces</category>
    <comment>Unlocks any earlier call to gfx::LockBitmap().</comment>
    <prototype>ERR gfx::UnlockBitmap(OBJECTID Surface, objBitmap * Bitmap)</prototype>
    <input>
      <param type="OBJECTID" name="Surface">The ID of the surface object that you are releasing.</param>
      <param type="objBitmap *" name="Bitmap">Pointer to the bitmap structure returned earlier by LockBitmap().</param>
    </input>
    <description>
<p>Call the UnlockBitmap() function to release a surface object from earlier calls to <function>LockBitmap</function>.</p>
    </description>
    <result type="ERR">
      <error code="Okay">The bitmap has been unlocked successfully.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>UnlockCursor</name>
    <category>Cursor</category>
    <comment>Undoes an earlier call to LockCursor()</comment>
    <prototype>ERR gfx::UnlockCursor(OBJECTID Surface)</prototype>
    <input>
      <param type="OBJECTID" name="Surface">Refers to the surface object used for calling LockCursor().</param>
    </input>
    <description>
<p>Call this function to undo any earlier calls to LockCursor() and return the mouse pointer to its regular state.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="NotLocked">A lock is not present, or the lock belongs to another surface.</error>
      <error code="AccessObject">Failed to access the pointer object.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>UnsubscribeInput</name>
    <category>Input</category>
    <comment>Removes an input subscription.</comment>
    <prototype>ERR gfx::UnsubscribeInput(LONG Handle)</prototype>
    <input>
      <param type="LONG" name="Handle">Reference to a handle returned by SubscribeInput().</param>
    </input>
    <description>
<p>This function removes an input subscription that has been created with <function>SubscribeInput</function>.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="NotFound">A search routine in this function failed.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>WindowHook</name>
    <category>Surfaces</category>
    <comment>Adds a function hook for receiving window messages from a host desktop.</comment>
    <prototype>ERR gfx::WindowHook(OBJECTID SurfaceID, WH Event, FUNCTION * Callback)</prototype>
    <input>
      <param type="OBJECTID" name="SurfaceID">A hosted surface to be monitored.</param>
      <param type="WH" name="Event" lookup="WH">A window hook event.</param>
      <param type="FUNCTION *" name="Callback">A function to callback when the event is triggered.</param>
    </input>
    <description>
<p>Adds a function hook for receiving window events from a host desktop.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <types>
    <constants lookup="ACF" comment="Acceleration flags for GetDisplayInfo().">
      <const name="SOFTWARE_BLIT">Software blitting is used (or forced) for this display.</const>
      <const name="VIDEO_BLIT">Video blitting is supported for this display.</const>
    </constants>

    <constants lookup="ALIGN" comment="Universal values for alignment of graphics and text">
      <const name="BOTTOM">Align to bottom</const>
      <const name="CENTER">Synonym for <code>HORIZONTAL | VERTICAL</code></const>
      <const name="HORIZONTAL">Align to horizontal center</const>
      <const name="LEFT">Align to left</const>
      <const name="MIDDLE">Synonym for <code>HORIZONTAL | VERTICAL</code></const>
      <const name="RIGHT">Align to right</const>
      <const name="TOP">Align to top</const>
      <const name="VERTICAL">Align to vertical center</const>
    </constants>

    <constants lookup="BAF" comment="Instructions for basic graphics operations.">
      <const name="BLEND">Enable alpha blending to the destination if the source supports an alpha channel.</const>
      <const name="COPY">Special <function module="Display">CopyArea</function> option that avoids blending when the destination pixel is empty.</const>
      <const name="DITHER">Perform dithering if the colour formats differ between the source and destination.</const>
      <const name="FILL">For primitive operations such as <function module="Display">DrawRectangle</function>, this will fill the shape with a solid colour or texture.</const>
      <const name="LINEAR">Use linear interpolation to improve the quality of alpha blending.</const>
    </constants>

    <constants lookup="BDF" comment="CopySurface() flags">
      <const name="DITHER">Allow the use of dithering to improve image quality at a cost of speed.</const>
      <const name="REDRAW">Redraw the surface before performing the copy operation.</const>
    </constants>

    <constants lookup="BMF" comment="Bitmap flags">
      <const name="ACCELERATED_2D">2D video acceleration is available.</const>
      <const name="ACCELERATED_3D">3D video acceleration is available.</const>
      <const name="ALPHA_CHANNEL">For 32-bit images, indicates that an alpha channel is present.</const>
      <const name="BLANK_PALETTE">Forces a blank/black palette on initialisation.</const>
      <const name="CLEAR">Clear graphics on initialisation and when resizing.</const>
      <const name="COMPRESSED">The bitmap data is compressed.</const>
      <const name="FIXED_DEPTH">Prevent changing of bitmap depth after initialisation (e.g. via <code>Resize()</code>).</const>
      <const name="INVERSE_ALPHA">Indicates reverse alpha blending, higher values are transparent.</const>
      <const name="MASK">Declare the <class name="Bitmap">Bitmap</class> as a 1 or 8 bit mask.  Must be set in conjunction with the <class name="Bitmap" field="BitsPerPixel">Bitmap.BitsPerPixel</class> field on initialisation.</const>
      <const name="NEVER_SHRINK">Ignore resize requests that would shrink the size of the bitmap.</const>
      <const name="NO_BLEND">Drawing routines that support this flag will not blend pixels.</const>
      <const name="NO_DATA">Do not allocate memory in the Data field on initialisation.</const>
      <const name="PREMUL">The RGB values are premultiplied (32-bit only).</const>
      <const name="QUERIED">Automatically set after a <code>Query()</code> on the bitmap.</const>
      <const name="TRANSPARENT">Indicates that the bitmap utilises a transparent colour.  This is automatically set if the <class name="Bitmap" field="TransIndex">Bitmap.TransIndex</class> or <class name="Bitmap" field="TransColour">Bitmap.TransColour</class> is defined, and support exists in functions such as <function module="Display">CopyArea</function>.</const>
      <const name="USER">This user flag can be used to tag bitmaps with special meaning.  Not used internally.</const>
    </constants>

    <constants lookup="BMP" comment="Bitmap types">
      <const name="CHUNKY">Chunky pixel mode (default).</const>
      <const name="PLANAR">Planar pixel mode separates pixel bits across multiple planes.  Commonly used for single bit bitmap masks.</const>
    </constants>

    <constants lookup="CEF">
      <const name="DELETE">Requests that the original file source is deleted if a successful paste operation takes place.</const>
      <const name="EXTEND">Instead of replacing existing clipboard data, add the new data to the group.</const>
    </constants>

    <constants lookup="CLIPTYPE" comment="Clipboard types">
      <const name="AUDIO">An audio clip that is recognised by the Sound class (such as wav's and mp3's).</const>
      <const name="DATA">Raw information that is uncategorised can be defined as a data clip.</const>
      <const name="FILE">Pure file references are stored as file clips.  This type is typically used by file managers for moving and copying files.</const>
      <const name="IMAGE">Images that are recognised by the Picture class may be stored as this type (such as jpeg's and png files).</const>
      <const name="OBJECT">An object that has been deserialised into binary form.</const>
      <const name="TEXT">Plain text files such as ASCII and UTF-8 must be identified through this clip type.</const>
    </constants>

    <constants lookup="CPF" comment="Clipboard flags">
      <const name="DRAG_DROP">Enables drag and drop mode.  The clipboard content will be private and not share data with the host system in this mode.</const>
      <const name="HISTORY_BUFFER">Enables the history buffer.  Note that this results in active clipboard monitoring and the program will make copies of all potential clipboard content - whether it is used or not.</const>
      <const name="HOST">This indicator is automatically set when a clipboard was created due to incoming content from the host system.</const>
    </constants>

    <constants lookup="CRF" comment="Flags for the SetCursor() function.">
      <const name="BUFFER">Use of the <code>BUFFER</code> option allows the cursor request to be buffered in the event that the cursor is locked at the time of calling the <function module="Display">SetCursor</function> function.  Use of this flag is highly recommended in most circumstances, but may not be used in conjunction with the <code>ANCHOR</code> option.</const>
      <const name="LMB">Release the cursor after the left mouse button is held and released.</const>
      <const name="MMB">Release the cursor after the middle mouse button is held and released.</const>
      <const name="NO_BUTTONS">Set the cursor only on the condition that the user is not holding down any buttons.  <code>ERR::NothingDone</code> is returned if the user has a button held down.</const>
      <const name="RESTRICT">Similar to the anchor option, but allows the pointer to move within the surface referred to by ObjectID.</const>
      <const name="RMB">Release the cursor after the right mouse button is held and released.</const>
    </constants>

    <constants lookup="CS" comment="Colour space options.">
      <const name="CIE_LAB">Cartesian L*a*b* colour space defined by CIE 15.</const>
      <const name="CIE_LCH">Polar L*CHab colour space defined by CIE 15.</const>
      <const name="LINEAR_RGB">Linear RGB is used to improve colour balance in blending operations.</const>
      <const name="SRGB">The default colour-space is sRGB.</const>
    </constants>

    <constants lookup="CSRF" comment="Flags for CopySurface().">
      <const name="ALPHA">Enable alpha blending if the source is in 32-bit colour format with an alpha channel.</const>
      <const name="CLIP">Enable clipping of the source coordinates.</const>
      <const name="DEFAULT_FORMAT">Ignore the colour format defined in the source surface (if any) and generate a default format based on the <code>BitsPerPixel</code> value.</const>
      <const name="OFFSET">Adjust X and Y coordinates by the offset values defined in the <class name="Surface" field="XOffset">Surface.XOffset</class> and <class name="Surface" field="YOffset">Surface.YOffset</class> fields.</const>
      <const name="TRANSLUCENT">Perform a translucent copy operation, using the strength value specified in the <class name="Surface" field="Opacity">Surface.Opacity</class> field.</const>
      <const name="TRANSPARENT">Enable transparent copying, whereby colours matching the source's <code>Colour</code> field will be ignored.</const>
    </constants>

    <constants lookup="CT">
      <const name="AUDIO"/>
      <const name="DATA"/>
      <const name="END"/>
      <const name="FILE"/>
      <const name="IMAGE"/>
      <const name="OBJECT"/>
      <const name="TEXT"/>
    </constants>

    <constants lookup="DMF">
      <const name="FIXED_CENTER_X">The CenterX field is a fixed size.</const>
      <const name="FIXED_CENTER_Y">The CenterY field is a fixed size.</const>
      <const name="FIXED_DEPTH">The Depth field is a fixed size.</const>
      <const name="FIXED_HEIGHT">The Height field is a fixed size.</const>
      <const name="FIXED_RADIUS">Synonym for <code>FIXED_RADIUS_X | FIXED_RADIUS_Y</code></const>
      <const name="FIXED_RADIUS_X">The RadiusX field is a fixed size.</const>
      <const name="FIXED_RADIUS_Y">The RadiusY field is a fixed size.</const>
      <const name="FIXED_WIDTH">The Width field is a fixed suze.</const>
      <const name="FIXED_X">The X field is a fixed coordinate.</const>
      <const name="FIXED_X_OFFSET">The XOffset field is a fixed coordinate.</const>
      <const name="FIXED_Y">The Y field is a fixed coordinate.</const>
      <const name="FIXED_Y_OFFSET">The YOffset field is a fixed coordinate.</const>
      <const name="FIXED_Z">The Z field is a fixed coordinate.</const>
      <const name="HEIGHT">Synonym for <code>FIXED_HEIGHT | SCALED_HEIGHT</code></const>
      <const name="HEIGHT_FLAGS">Synonym for <code>FIXED_HEIGHT | SCALED_HEIGHT | FIXED_Y_OFFSET | SCALED_Y_OFFSET</code></const>
      <const name="HORIZONTAL_FLAGS">Synonym for <code>FIXED_WIDTH | SCALED_WIDTH | FIXED_X_OFFSET | SCALED_X_OFFSET | FIXED_X | SCALED_X</code></const>
      <const name="SCALED_CENTER_X">The CenterX field is scaled to this object's parent.</const>
      <const name="SCALED_CENTER_Y">The CenterY field is scaled to this object's parent.</const>
      <const name="SCALED_DEPTH">The Depth field is scaled to this object's parent.</const>
      <const name="SCALED_HEIGHT">The Height field is scaled to this object's parent.</const>
      <const name="SCALED_RADIUS">Synonym for <code>SCALED_RADIUS_X | SCALED_RADIUS_Y</code></const>
      <const name="SCALED_RADIUS_X">The RadiusX field is scaled to this object's parent.</const>
      <const name="SCALED_RADIUS_Y">The RadiusY field is a scaled size to this object's parent.</const>
      <const name="SCALED_WIDTH">The Width field is scaled to this object's parent.</const>
      <const name="SCALED_X">The X field is scaled to this object's parent.</const>
      <const name="SCALED_X_OFFSET">The XOffset field is scaled to this object's parent.</const>
      <const name="SCALED_Y">The Y field is scaled to this object's parent.</const>
      <const name="SCALED_Y_OFFSET">The YOffset field is scaled to this object's parent.</const>
      <const name="SCALED_Z">The Z field is a scaled coordinate to this object's parent.</const>
      <const name="STATUS_CHANGE">Synonym for <code>STATUS_CHANGE_H | STATUS_CHANGE_V</code></const>
      <const name="STATUS_CHANGE_H"/>
      <const name="STATUS_CHANGE_V"/>
      <const name="VERTICAL_FLAGS">Synonym for <code>FIXED_HEIGHT | SCALED_HEIGHT | FIXED_Y_OFFSET | SCALED_Y_OFFSET | FIXED_Y | SCALED_Y</code></const>
      <const name="WIDTH">Synonym for <code>FIXED_WIDTH | SCALED_WIDTH</code></const>
      <const name="WIDTH_FLAGS">Synonym for <code>FIXED_WIDTH | SCALED_WIDTH | FIXED_X_OFFSET | SCALED_X_OFFSET</code></const>
      <const name="X">Synonym for <code>FIXED_X | SCALED_X</code></const>
      <const name="X_OFFSET">Synonym for <code>FIXED_X_OFFSET | SCALED_X_OFFSET</code></const>
      <const name="Y">Synonym for <code>FIXED_Y | SCALED_Y</code></const>
      <const name="Y_OFFSET">Synonym for <code>FIXED_Y_OFFSET | SCALED_Y_OFFSET</code></const>
    </constants>

    <constants lookup="DPMS" comment="Possible modes for the Display class' PowerMode field.">
      <const name="DEFAULT">Use the default DPMS mode as defined by the display driver.</const>
      <const name="OFF">Stop sending power to the display in order to turn it off (it may not be possible to restart the display without the user's intervention).</const>
      <const name="STANDBY">Puts the display into standby (reduced power) mode.</const>
      <const name="SUSPEND">Puts the display into suspend mode (blanks the display output while maintaining normal power levels).</const>
    </constants>

    <constants lookup="DRAG">
      <const name="ANCHOR">The surface is being dragged and the mouse pointer is anchored to the surface.</const>
      <const name="NONE">The surface is not being dragged.</const>
      <const name="NORMAL">The surface is being dragged.</const>
    </constants>

    <constants lookup="DSF">
      <const name="NO_DRAW">Drawing and exposures are disabled</const>
      <const name="NO_EXPOSE">Drawing is enabled, exposures are disabled</const>
    </constants>

    <constants lookup="DT" comment="Flags for GetDisplayType().">
      <const name="GLES">The display is driven by OpenGLES.</const>
      <const name="NATIVE">The display is native (supported by internal drivers).</const>
      <const name="WINGDI">The display is driven by Microsoft Windows drivers.</const>
      <const name="X11">The display is driven by the X Window System (X11, X.Org, XFree86)</const>
    </constants>

    <constants lookup="EXF" comment="Optional flags for the ExposeSurface() function.">
      <const name="ABSOLUTE">The supplied coordinates for exposure are absolute (relative to the display).</const>
      <const name="ABSOLUTE_COORDS">The supplied coordinates for exposure are absolute (relative to the display).</const>
      <const name="CHILDREN">If set, all child surfaces that intersect with exposed region will be included in the expose operation.</const>
      <const name="REDRAW_VOLATILE">Redraw every volatile object that intersects with the expose region, including internal volatile children.</const>
      <const name="REDRAW_VOLATILE_OVERLAP">Only redraw volatile objects that obscure the expose region from a position outside of the target surface and its children.  Useful if no redrawing has occurred in the surface, but the surface has moved to a new position and the parents need to be redrawn.</const>
    </constants>

    <constants lookup="FLIP" comment="Flags for the bitmap Flip method.">
      <const name="HORIZONTAL">Flip the bitmap from top to bottom.</const>
      <const name="VERTICAL">Flip the bitmap from left to right.</const>
    </constants>

    <constants lookup="GMF" comment="Flags for gamma operations.">
      <const name="SAVE">Save the provided settings permanently.</const>
    </constants>

    <constants lookup="HOST">
      <const name="STICK_TO_FRONT">The hosted display sticks to the front.</const>
      <const name="TASKBAR">The hosted display is given a taskbar button.</const>
      <const name="TRANSLUCENCE">Change the alpha channel level for the entire window.</const>
      <const name="TRANSPARENT">Defines an RGB colour that is to be used as transparent.</const>
      <const name="TRAY_ICON">All new displays are represented in the system tray when this option is active.</const>
    </constants>

    <constants lookup="IRF" comment="Flags for RedrawSurface().">
      <const name="FORCE_DRAW">Forces redrawing to the surface buffer (overrides visibility checks).</const>
      <const name="IGNORE_CHILDREN">Do not draw child surfaces (this includes volatile children).</const>
      <const name="IGNORE_NV_CHILDREN">Do not draw child surfaces unless they are volatile.</const>
      <const name="RELATIVE">Coordinate parameters are expressed in relative format.  Right and Bottom reflect Width and Height respectively.</const>
      <const name="SINGLE_BITMAP">Only draw children and/or siblings when they share our bitmap space.</const>
    </constants>

    <constants lookup="LVF" comment="drwLockBitmap() result flags">
      <const name="EXPOSE_CHANGES"/>
    </constants>

    <constants lookup="MON" comment="Flags for the Display class SetMonitor() method.">
      <const name="AUTO_DETECT">Monitor settings to be auto-detected on startup.</const>
      <const name="BIT_6">The device is limited to 6-bit colour production in real terms.</const>
    </constants>

    <constants lookup="PF" comment="Flags for the Pointer class.">
      <const name="ANCHOR">Allow the pointer to be anchored.</const>
      <const name="UNUSED"/>
      <const name="VISIBLE">Indicates that the pointer is currently visible.  Read-only.</const>
    </constants>

    <constants lookup="PTC" comment="Predefined cursor styles">
      <const name="CROSSHAIR">The cross hair is used for targeting specific pixel points (common in paint programs).</const>
      <const name="CUSTOM">Works in conjunction with the SetCustomCursor() function to represent a program defined bitmap.</const>
      <const name="DEFAULT">The default cursor (usually an arrow pointing to the upper left).</const>
      <const name="DRAGGABLE">Used to indicate that a surface or object can be dragged by the user.</const>
      <const name="END"/>
      <const name="HAND">The hand cursor is often used for indicating click-able content (hyper-links, icons etc).</const>
      <const name="HAND_LEFT">Similar to the standard hand cursor, but points to the left.</const>
      <const name="HAND_RIGHT">Similar to the standard hand cursor, but points to the right.</const>
      <const name="INVISIBLE">The cursor graphic is invisible (but will continue to operate as normal in all other respects).</const>
      <const name="MAGNIFIER">Represents a magnifying glass.</const>
      <const name="NO_CHANGE"/>
      <const name="PAINTBRUSH">The paintbrush cursor is typically employed by paint programs.</const>
      <const name="SIZE_BOTTOM">Sizing cursor - for resizing the bottom edge of any rectangular area.</const>
      <const name="SIZE_BOTTOM_LEFT">Sizing cursor - for resizing the bottom left corner of any rectangular area.</const>
      <const name="SIZE_BOTTOM_RIGHT">Sizing cursor - for resizing the bottom right corner of any rectangular area.</const>
      <const name="SIZE_LEFT">Sizing cursor - for resizing the left edge of any rectangular area.</const>
      <const name="SIZE_RIGHT">Sizing cursor - for resizing the right edge of any rectangular area.</const>
      <const name="SIZE_TOP">Sizing cursor - for resizing the top edge of any rectangular area.</const>
      <const name="SIZE_TOP_LEFT">Sizing cursor - for resizing the top left corner of any rectangular area.</const>
      <const name="SIZE_TOP_RIGHT">Sizing cursor - for resizing the top right corner of any rectangular area.</const>
      <const name="SIZING">Multi-directional sizing cursor - for resizing in any direction.</const>
      <const name="SLEEP">The sleep cursor is used to inform the user that the computer is busy.</const>
      <const name="SPLIT_HORIZONTAL">The horizontal split cursor is typically used for splitting rectangles in half, or dragging a horizontal split within a large rectangular space.</const>
      <const name="SPLIT_VERTICAL">The vertical split cursor is typically used for splitting rectangles in half, or dragging a vertical split within a large rectangular space.</const>
      <const name="STOP">The stop cursor is used to inform the user that an operation is not possible (e.g. drag and drop to an unsupported object area).</const>
      <const name="TEXT">The text cursor is popular for the precise positioning of text cursors.</const>
    </constants>

    <constants lookup="RNF" comment="Switches for the Surface class' Flags field.">
      <const name="AFTER_COPY">Read-only.  Indicates that after-copy mode has been enabled.</const>
      <const name="ASPECT_RATIO">When resizing, enforce the aspect ratio as defined by <class name="Surface" field="MinWidth">Surface.MinWidth</class> and <class name="Surface" field="MinHeight">Surface.MinHeight</class>.</const>
      <const name="AUTO_QUIT">The surface object will send a quit message to its supporting process when and if the Close method is called.  This flag is typically used when a surface object represents a core window for an application.</const>
      <const name="COMPOSITE">Do not copy background information into the surface buffer - composite on the fly instead</const>
      <const name="DISABLED">This flag is set if the Disable action has been called on a surface object.  Calling the Enable action will turn off the flag setting.</const>
      <const name="FIXED_BUFFER">Passes the <code>NEVER_SHRINK</code> option to the surface bitmap</const>
      <const name="FIXED_DEPTH">The target buffer always remains at the same depth</const>
      <const name="FULL_SCREEN">Allow the surface to open as a new screen display</const>
      <const name="GRAB_FOCUS">Helps application windows manage the user's focus within the window</const>
      <const name="HAS_FOCUS">Read-only.  If set, this flag indicates that the surface object currently has the focus.</const>
      <const name="HOST">Define host on initialisation to create a container that can host surfaces from other processes.</const>
      <const name="IGNORE_FOCUS">Focus is diverted directly to the parent</const>
      <const name="INIT_ONLY">Synonym for <code>HOST | TRANSPARENT | DISABLED | PRECOPY | VIDEO | FIXED_BUFFER | PERVASIVE_COPY | FIXED_DEPTH | FULL_SCREEN | IGNORE_FOCUS</code></const>
      <const name="NO_FOCUS">Prevents any kind of focussing on this object; no circumvention is possible</const>
      <const name="NO_HORIZONTAL">Turns off all horizontal movement (applies to the <code>Move()</code> action only).</const>
      <const name="NO_PRECOMPOSITE">Do not copy background information into the surface buffer - composite on the fly instead</const>
      <const name="NO_VERTICAL">Turns off all vertical movement (applies to the <code>Move()</code> action only).</const>
      <const name="PERVASIVE_COPY">This flag can be set in conjunction with after-copy mode.  It forces the after-copy support routine to copy graphics over the entire surface area, rather than avoiding the graphics of child surfaces.</const>
      <const name="POST_COMPOSITE">Do not copy background information into the surface buffer - composite on the fly instead</const>
      <const name="PRECOPY">Enables pre-copy mode, which means that all graphics behind the surface object are copied into the bitmap buffer prior to any redraw.  This mode can have a noticable impact on CPU time when drawing.</const>
      <const name="READ_ONLY">Synonym for <code>HAS_FOCUS | CURSOR | AFTER_COPY</code></const>
      <const name="STICKY">Prevents any response to the Move action.  It can be circumvented by writing to coordinate fields directly.</const>
      <const name="STICK_TO_BACK">Enable if the surface object must stick to the back of its container.</const>
      <const name="STICK_TO_FRONT">Enable if the surface object must stick to the front of its container.</const>
      <const name="TOTAL_REDRAW">Perform a total redraw of the entire surface when drawing - no partial draws</const>
      <const name="TRANSPARENT">Enables transparency, which means that the internal graphics routines will ignore this surface during redraws.  It is typically used when creating containers that will host other surfaces.</const>
      <const name="VIDEO">Set this flag if you would like the surface object's data to be managed in video memory only.  While this can give some speed advantages, be warned that video based surfaces are limited to write-only operations.</const>
      <const name="VISIBLE">If a surface object is visible to the user, the <code>VISIBLE</code> flag will be set.  If the flag is not set, the surface object is hidden.</const>
      <const name="VOLATILE">Synonym for <code>PRECOPY | AFTER_COPY | CURSOR</code></const>
      <const name="WRITE_ONLY">Set this flag if you would like the surface object's data to be managed in video memory only.  While this can give some speed advantages, be warned that video based surfaces are limited to write-only operations.</const>
    </constants>

    <constants lookup="RT">
      <const name="ROOT">Can be used by window surfaces to identify themselves as a root layer.</const>
    </constants>

    <constants lookup="SCR" comment="Display flags.">
      <const name="ALPHA_BLEND">Enables alpha channel blending (if display is hosted and 32-bit).</const>
      <const name="AUTO_SAVE">Saves settings to the global display state when the object is freed.</const>
      <const name="BIT_6">Display is limited to 6-bit output per colour gun.</const>
      <const name="BORDERLESS">If display is hosted, create it as a popup / borderless window.</const>
      <const name="BUFFER">Set if you would like a complementing buffer in video RAM.</const>
      <const name="COMPOSITE">Enables alpha channel blending (if display is hosted and 32-bit).</const>
      <const name="CUSTOM_WINDOW">The display has been created with a custom window reference.</const>
      <const name="DPMS_ENABLED">Power saving through DPMS is supported.</const>
      <const name="FLIPPABLE">If <code>SCR::BUFFER</code> is used, this flag may be set by the display manager if it is possible to flip the buffer.</const>
      <const name="GTF_ENABLED">GTF frequency timings are supported.</const>
      <const name="HOSTED">The display is a desktop hosted window.</const>
      <const name="MAXIMISE">Special win32 flag.</const>
      <const name="MAXSIZE">For <function module="Display">GetDisplayInfo</function> only, indicates that the width and height values indicate the display's maximum size.</const>
      <const name="NO_ACCELERATION">2D graphics card acceleration is not available.</const>
      <const name="POWERSAVE">Power saving is active (read-only).</const>
      <const name="READ_ONLY">Synonym for <code>MAXIMISE | CUSTOM_WINDOW | FLIPPABLE | GTF_ENABLED | DPMS_ENABLED | POWERSAVE | HOSTED | MAXSIZE | REFRESH | BIT_6 | VISIBLE | NO_ACCELERATION</code></const>
      <const name="REFRESH">For <function module="Display">GetDisplayInfo</function> only, used to indicate that a display change has recently occurred and cache refresh is required.</const>
      <const name="VISIBLE">Set if the screen is on display.</const>
    </constants>

    <constants lookup="SWIN" comment="Options for the Surface WindowType field.">
      <const name="HOST">Default to the standard hosted window mode with full titlebar, borders and taskbar representation.</const>
      <const name="ICON_TRAY">Create a borderless (custom) window with icon tray representation.</const>
      <const name="NONE">Create a borderless (custom) window with no UI representation.</const>
      <const name="TASKBAR">Create a borderless (custom) window with taskbar representation.</const>
    </constants>

    <constants lookup="WH" comment="Events for WindowHook()">
      <const name="CLOSE"/>
    </constants>

  </types>
  <structs>
    <struct name="BitmapSurface" typeName="BITMAPSURFACE">
      <field name="Data" type="APTR">Pointer to the bitmap graphics data.</field>
      <field name="Width" type="WORD">Pixel width of the bitmap.</field>
      <field name="Height" type="WORD">Pixel height of the bitmap.</field>
      <field name="LineWidth" type="LONG">The distance between bitmap lines, measured in bytes.</field>
      <field name="BitsPerPixel" type="UBYTE">The number of bits per pixel (8, 15, 16, 24, 32).</field>
      <field name="BytesPerPixel" type="UBYTE">The number of bytes per pixel (1, 2, 3, 4).</field>
      <field name="Opacity" type="UBYTE">Opacity level of the source if <code>CSRF::TRANSLUCENT</code> is used.</field>
      <field name="Version" type="UBYTE">Version of this structure.</field>
      <field name="Colour" type="LONG">Colour index to use if <code>CSRF::TRANSPARENT</code> is used.</field>
      <field name="Clip" type="struct ClipRectangle">A clipping rectangle will restrict drawing operations to this region if <code>CSRF::CLIP</code> is used.</field>
      <field name="XOffset" type="WORD">Offset all X coordinate references by the given value.</field>
      <field name="YOffset" type="WORD">Offset all Y coordinate references by the given value.</field>
      <field name="Format" type="struct ColourFormat">The colour format of this bitmap's pixels, or alternatively use <code>CSRF::DEFAULT_FORMAT</code>.</field>
    </struct>

    <struct name="ColourFormat" typeName="COLOURFORMAT">
      <field name="RedShift" type="UBYTE">Right shift value for red (15/16 bit formats only)</field>
      <field name="GreenShift" type="UBYTE">Right shift value for green</field>
      <field name="BlueShift" type="UBYTE">Right shift value for blue</field>
      <field name="AlphaShift" type="UBYTE">Right shift value for alpha</field>
      <field name="RedMask" type="UBYTE">Unshifted mask value for red (ranges from 0x00 to 0xff)</field>
      <field name="GreenMask" type="UBYTE">Unshifted mask value for green</field>
      <field name="BlueMask" type="UBYTE">Unshifted mask value for blue</field>
      <field name="AlphaMask" type="UBYTE">Unshifted mask value for alpha</field>
      <field name="RedPos" type="UBYTE">Left shift/positional value for red</field>
      <field name="GreenPos" type="UBYTE">Left shift/positional value for green</field>
      <field name="BluePos" type="UBYTE">Left shift/positional value for blue</field>
      <field name="AlphaPos" type="UBYTE">Left shift/positional value for alpha</field>
      <field name="BitsPerPixel" type="UBYTE">Number of bits per pixel for this format.</field>
    </struct>

    <struct name="CursorInfo">
      <field name="Width" type="LONG">Maximum cursor width for custom cursors</field>
      <field name="Height" type="LONG">Maximum cursor height for custom cursors</field>
      <field name="Flags" type="LONG">Currently unused</field>
      <field name="BitsPerPixel" type="WORD">Preferred bits-per-pixel setting for custom cursors</field>
    </struct>

    <struct name="DisplayInfo" typeName="DISPLAYINFO">
      <field name="Display" type="OBJECTID">Object ID related to the display</field>
      <field name="Flags" type="SCR" lookup="SCR">Display flags</field>
      <field name="Width" type="WORD">Pixel width of the display</field>
      <field name="Height" type="WORD">Pixel height of the display</field>
      <field name="BitsPerPixel" type="WORD">Bits per pixel</field>
      <field name="BytesPerPixel" type="WORD">Bytes per pixel</field>
      <field name="AccelFlags" type="ACF" lookup="ACF">Flags describing supported hardware features.</field>
      <field name="AmtColours" type="LONG">Total number of supported colours.</field>
      <field name="PixelFormat" type="struct PixelFormat">The colour format to use for each pixel.</field>
      <field name="MinRefresh" type="FLOAT">Minimum refresh rate</field>
      <field name="MaxRefresh" type="FLOAT">Maximum refresh rate</field>
      <field name="RefreshRate" type="FLOAT">Recommended refresh rate</field>
      <field name="Index" type="LONG">Display mode ID (internal)</field>
      <field name="HDensity" type="LONG">Horizontal pixel density per inch.</field>
      <field name="VDensity" type="LONG">Vertical pixel density per inch.</field>
    </struct>

    <struct name="PixelFormat" comment="Carries instructions to pack or unpack RGBA colours." typeName="PIXELFORMAT">
      <field name="RedShift" type="UBYTE">Right shift value</field>
      <field name="GreenShift" type="UBYTE">Green shift value</field>
      <field name="BlueShift" type="UBYTE">Blue shift value</field>
      <field name="AlphaShift" type="UBYTE">Alpha shift value</field>
      <field name="RedMask" type="UBYTE">The unshifted red mask value (ranges from 0x00 to 0xff)</field>
      <field name="GreenMask" type="UBYTE">The unshifted green mask value (ranges from 0x00 to 0xff)</field>
      <field name="BlueMask" type="UBYTE">The unshifted blue mask value (ranges from 0x00 to 0xff)</field>
      <field name="AlphaMask" type="UBYTE">The unshifted alpha mask value (ranges from 0x00 to 0xff)</field>
      <field name="RedPos" type="UBYTE">Left shift/positional value for red</field>
      <field name="GreenPos" type="UBYTE">Left shift/positional value for green</field>
      <field name="BluePos" type="UBYTE">Left shift/positional value for blue</field>
      <field name="AlphaPos" type="UBYTE">Left shift/positional value for alpha</field>
    </struct>

    <struct name="SurfaceCoords">
      <field name="X" type="LONG">Horizontal coordinate</field>
      <field name="Y" type="LONG">Vertical coordinate</field>
      <field name="Width" type="LONG">Width</field>
      <field name="Height" type="LONG">Height</field>
      <field name="AbsX" type="LONG">Absolute X</field>
      <field name="AbsY" type="LONG">Absolute Y</field>
    </struct>

    <struct name="SurfaceInfo" typeName="SURFACEINFO">
      <field name="Data" type="APTR">Bitmap data memory ID</field>
      <field name="ParentID" type="OBJECTID">Object that contains the surface area</field>
      <field name="BitmapID" type="OBJECTID">Surface bitmap buffer</field>
      <field name="DisplayID" type="OBJECTID">Refers to the display if this object is at root level</field>
      <field name="Flags" type="RNF" lookup="RNF">Surface flags</field>
      <field name="X" type="LONG">Horizontal coordinate</field>
      <field name="Y" type="LONG">Vertical coordinate</field>
      <field name="Width" type="LONG">Width of the surface area</field>
      <field name="Height" type="LONG">Height of the surface area</field>
      <field name="AbsX" type="LONG">Absolute X coordinate</field>
      <field name="AbsY" type="LONG">Absolute Y coordinate</field>
      <field name="Level" type="WORD">Branch level within the tree</field>
      <field name="BitsPerPixel" type="BYTE">Bits per pixel of the bitmap</field>
      <field name="BytesPerPixel" type="BYTE">Bytes per pixel of the bitmap</field>
      <field name="LineWidth" type="LONG">Line width of the bitmap, in bytes</field>
    </struct>

    <struct name="xrMode" comment="Display mode.">
      <field name="Width" type="LONG">Horizontal</field>
      <field name="Height" type="LONG">Vertical</field>
      <field name="Depth" type="LONG">bit depth</field>
    </struct>

  </structs>
</book>
