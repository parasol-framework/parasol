<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="module.xsl"?>

<book>
  <info>
    <name>Regex</name>
    <type>module</type>
    <comment>Provides support for regular expression pattern matching and text processing.</comment>
    <version>1</version>
    <copyright>Paul Manias Â© 2025</copyright>
    <description>
<p>The Regex module provides ECMAScript-compatible regex functionality with Unicode support. It offers efficient pattern compilation, flexible matching modes, and text manipulation capabilities including search, replace, and split operations.</p>
<p>Key features include:</p>
<list type="bullet">
<li>ECMAScript (JavaScript) regex syntax with optional AWK and GREP modes.</li>
<li>Full Unicode support including character classes and properties.</li>
<li>Case-insensitive and multiline matching options.</li>
<li>Reusable compiled patterns for optimal performance.</li>
<li>Callback-based result processing for custom handling.</li>
</list></description>
  </info>

  <function>
    <name>Compile</name>
    <comment>Compiles a regex pattern and returns a regex object.</comment>
    <prototype>ERR rx::Compile(const std::string_view &amp; Pattern, REGEX Flags, std::string * ErrorMsg, struct Regex ** Result)</prototype>
    <input>
      <param type="const std::string_view &amp;" name="Pattern">A regex pattern string.</param>
      <param type="REGEX" name="Flags" lookup="REGEX">Optional flags.</param>
      <param type="std::string *" name="ErrorMsg">Optional reference for storing custom error messages.</param>
      <param type="struct Regex **" name="Result">Pointer to store the created regex object.</param>
    </input>
    <description>
<p>Use Compile() to compile a regex pattern into a regex object that can be used for matching and searching.  The compiled regex object can be reused for multiple match or search operations, improving performance.  It must be removed with ~Core:FreeResource() when no longer needed to avoid memory leaks.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Operation successful.</error>
      <error code="AllocMemory">AllocMemory() failed to create a new memory block.</error>
      <error code="Syntax">Invalid syntax detected.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>Match</name>
    <comment>Performs a single anchored regex match.</comment>
    <prototype>ERR rx::Match(struct Regex * Regex, const std::string_view &amp; Text, RMATCH Flags, FUNCTION * Callback)</prototype>
    <input>
      <param type="struct Regex *" name="Regex">The compiled regex object.</param>
      <param type="const std::string_view &amp;" name="Text">The input text to perform matching on.</param>
      <param type="RMATCH" name="Flags" lookup="RMATCH">Optional.  Flags to modify the matching behavior.</param>
      <param type="FUNCTION *" name="Callback">Optional.  Receives the match results.</param>
    </input>
    <description>
<p>Use Match() to perform a singular anchored regex match (no searching) on a given text. The function takes a compiled Regex  object, the input Text, optional Flags to modify the matching behavior, and an optional Callback function to process the match results.</p>
<p>The C++ prototype for the Callback function is:</p>
<pre>ERR callback(std::vector&lt;std::string_view&gt; &amp;Capture, std::string_view Prefix, std::string_view Suffix, APTR Meta);
</pre>
<p>For more sophisticated matching needs, consider using <function>Search</function> instead.</p>
    </description>
    <result type="ERR">
      <error code="Okay">A match was found and processed.</error>
      <error code="Search">No match was found.</error>
      <error code="NullArgs">One or more required input arguments were null.</error>
    </result>
  </function>

  <function>
    <name>Replace</name>
    <comment>Replaces occurrences of the regex pattern in the input text with a specified replacement string.</comment>
    <prototype>ERR rx::Replace(struct Regex * Regex, const std::string_view &amp; Text, const std::string_view &amp; Replacement, std::string * Output, RMATCH Flags)</prototype>
    <input>
      <param type="struct Regex *" name="Regex">The compiled regex object.</param>
      <param type="const std::string_view &amp;" name="Text">The input text to perform replacements on.</param>
      <param type="const std::string_view &amp;" name="Replacement">The replacement string, which can include back-references like <code>\1</code>, <code>\2</code>, etc.</param>
      <param type="std::string *" name="Output">Receives the resulting string after replacements.</param>
      <param type="RMATCH" name="Flags" lookup="RMATCH">Optional flags to modify the replacement behavior.</param>
    </input>
    <description>
<p>Call Replace() to perform regex-based replacements in a given text. The function takes a compiled regex object, the input text, a replacement string, and optional flags to modify the replacement behavior. The replacement string can include back-references like <code>\1</code>, <code>\2</code>, etc., to refer to captured groups from the regex match.</p>
    </description>
    <result type="ERR">
      <error code="Okay">Successful execution, does not necessarily mean replacements were made.</error>
      <error code="NullArgs">One or more required input arguments were null.</error>
    </result>
  </function>

  <function>
    <name>Search</name>
    <comment>Performs regex matching.</comment>
    <prototype>ERR rx::Search(struct Regex * Regex, const std::string_view &amp; Text, RMATCH Flags, FUNCTION * Callback)</prototype>
    <input>
      <param type="struct Regex *" name="Regex">The compiled regex object.</param>
      <param type="const std::string_view &amp;" name="Text">The input text to perform matching on.</param>
      <param type="RMATCH" name="Flags" lookup="RMATCH">Optional flags to modify the matching behavior.</param>
      <param type="FUNCTION *" name="Callback">Receives the match results.</param>
    </input>
    <description>
<p>Call Search() to search for a regex pattern in a given text. The function takes a compiled regex object, the input text, optional flags to modify the matching behavior, and a callback function to process the match results. For each match that is found, the callback function is invoked with details about the match.</p>
<p>The C++ prototype for the Callback function is:</p>
<pre>ERR callback(int Index, std::vector&lt;std::string_view&gt; &amp;Capture, std::string_view Prefix, std::string_view Suffix, APTR Meta);
</pre>
<p>Note the inclusion of the <code>Index</code> parameter, which indicates the match number (starting from 0).</p>
    </description>
    <result type="ERR">
      <error code="Okay">At least one match was found and processed.</error>
      <error code="Search">No matches were found.</error>
      <error code="NullArgs">One or more required input arguments were null.</error>
    </result>
  </function>

  <function>
    <name>Split</name>
    <comment>Split a string into tokens, using a regex pattern to denote the delimiter.</comment>
    <prototype>ERR rx::Split(struct Regex * Regex, const std::string_view &amp; Text, pf::vector&lt;std::string&gt; * Output, RMATCH Flags)</prototype>
    <input>
      <param type="struct Regex *" name="Regex">The compiled regex object.</param>
      <param type="const std::string_view &amp;" name="Text">The input text to split.</param>
      <param type="pf::vector&lt;std::string&gt; *" name="Output">Receives the resulting string tokens.</param>
      <param type="RMATCH" name="Flags" lookup="RMATCH">Optional flags to modify the splitting behavior.</param>
    </input>
    <description>
<p>Call Split() to divide a string into multiple tokens based on a regex pattern that defines the delimiters. The function takes a compiled regex object, the input text, and optional flags to modify the splitting behavior.</p>
<p>The resulting tokens are stored in the provided output array.</p>
<p>If no matches are found, the entire input text is returned as a single token.</p>
    </description>
    <result type="ERR">
      <error code="Okay">The string was successfully split into tokens. If no matches are found, the entire input text is returned as a single token.</error>
      <error code="NullArgs">One or more required input arguments were null.</error>
    </result>
  </function>

  <types>
    <constants lookup="REGEX" comment="Optional flags for the Regex functions.">
      <const name="AWK">AWK syntax.</const>
      <const name="DOT_ALL"><code>.</code> matches newlines.</const>
      <const name="EXTENDED">Allow whitespace and comments.</const>
      <const name="GREP">GREP syntax.</const>
      <const name="ICASE">Ignore case.</const>
      <const name="MULTILINE"><code>^</code> and <code>$</code> match line boundaries.</const>
    </constants>

    <constants lookup="RMATCH">
      <const name="CONTINUOUS">Requires the match to start at the beginning of the sequence (anchored matching).</const>
      <const name="NOT_BEGIN_OF_LINE">Treats the first character in the sequence as NOT being at the beginning of a line, preventing <code>^</code> from matching at that position.</const>
      <const name="NOT_BEGIN_OF_WORD">Treats the first character in the sequence as NOT being at the beginning of a word, affecting <code>\b</code> word boundary matching.</const>
      <const name="NOT_END_OF_LINE">Treats the last character in the sequence as NOT being at the end of a line, preventing <code>$</code> from matching at that position.</const>
      <const name="NOT_END_OF_WORD">Treats the last character in the sequence as NOT being at the end of a word, affecting <code>\b</code> word boundary matching.</const>
      <const name="NOT_NULL">Prevents the regex engine from matching zero-length (empty) sequences.</const>
      <const name="PREV_AVAILABLE">Indicates that a valid character exists before the first position in the sequence, enabling proper look-behind and boundary assertions.</const>
      <const name="REPLACE_FIRST_ONLY">In Replace(), replaces only the first match and leaves subsequent matches unchanged.</const>
      <const name="REPLACE_NO_COPY">In Replace(), prevents copying non-matched portions of the input to the output.</const>
    </constants>

  </types>
  <structs>
    <struct name="Regex" comment="Compiled regex structure.">
      <field name="pattern" type="std::string">Original pattern string</field>
      <field name="error_msg" type="std::string">Error message if compilation failed</field>
      <field name="flags" type="REGEX" lookup="REGEX">Compilation flags</field>
    </struct>

  </structs>
</book>
