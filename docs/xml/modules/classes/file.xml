<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="class.xsl"?>

<book>
  <info>
    <name>File</name>
    <type>class</type>
    <module>Core</module>
    <comment>Enables access to the file system.</comment>
    <version>1.2</version>
    <id>7c96cb25</id>
    <idstring>FILE</idstring>
    <category>System</category>
    <copyright>Paul Manias 1996-2025</copyright>
    <description>
<p>The File class provides extensive support for file management and I/O.  The class supports the notion of individual file compression and file finding capabilities.  Since all File objects are tracked, there is no chance of the system leaving locked files behind after a program exits.  Folder management is also integrated into this class to ease the management of both file types.</p>
<p>To read or write to a file, set the <fl>Path</fl> of the file as well as the correct I/O file flags before initialisation. See the <fl>Flags</fl> field for information on the available I/O flags.  Functionality for read and write operations is provided through the <action>Read</action> and <action>Write</action> actions.  The <action>Seek</action> action can be used to change the read/write position in a file.</p></description>
    <source>
      <file path="../classes/">class_file.cpp</file>
    </source>
  </info>

  <actions>
    <action>
      <name>Activate</name>
      <comment>Opens the file.  Performed automatically if <code>NEW</code>, <code>READ</code> or <code>WRITE</code> flags were specified on initialisation.</comment>
      <prototype>ERR acActivate(*Object)</prototype>
    </action>

    <action>
      <name>DataFeed</name>
      <comment>Data can be streamed to any file as a method of writing content.</comment>
      <prototype>ERR acDataFeed(*Object, OBJECTID Object, DATA Datatype, APTR Buffer, INT Size)</prototype>
      <input>
        <param type="OBJECTID" name="Object">Must refer to the unique ID of the object that you represent. If you do not represent an object, set this parameter to the current task ID.</param>
        <param type="DATA" name="Datatype" lookup="DATA">The type of data being sent.</param>
        <param type="APTR" name="Buffer">The data being sent to the target object.</param>
        <param type="INT" name="Size">The size of the data in Buffer.</param>
      </input>
      <description>
<p>Streaming data of any type to a file will result in the content being written to the file at the current seek <fl>Position</fl>.</p>
      </description>
    </action>

    <action>
      <name>Init</name>
      <comment>Initialises a file.</comment>
      <prototype>ERR InitObject(*Object)</prototype>
      <description>
<p>This action will prepare a file or folder at the given <fl>Path</fl> for use.</p>
<p>To create a new file from scratch, specify the <code>NEW</code> flag.  This will overwrite any file that exists at the target path.</p>
<p>To read and write data to the file, specify the <code>READ</code> and/or <code>WRITE</code> modes in the <fl>Flags</fl> field prior to initialisation. If a file is read-only and the <code>WRITE</code> and <code>READ</code> flags are set in combination, the <code>WRITE</code> flag will be dropped and initialisation will continue as normal.</p>
<p>If neither of the <code>NEW</code>, <code>READ</code> or <code>WRITE</code> flags are specified, the file object is prepared and queried from disk (if it exists), but will not be opened.  It will be necessary to <action>Activate</action> the file in order to open it.</p>
<p>The File class supports RAM based file buffering - this is activated by using the <code>BUFFER</code> flag and setting the Size field to the desired buffer size.  A file path is not required unless the buffer needs to be filled with content on initialisation.  Because buffered files exist virtually, their functionality is restricted to read/write access.</p>
<p>Strings can also be loaded into file buffers for read/write access.  This is achieved by specifying the <fl>Path</fl> <code>string:Data\0</code>, where <code>Data</code> is a sequence of characters to be loaded into a virtual memory space.</p>
      </description>
      <result>
        <error code="Okay">Operation successful.</error>
        <error code="Search">The file could not be found.</error>
        <error code="FileNotFound">File not found.</error>
        <error code="NoPermission">Permission was denied when accessing or creating the file.</error>
        <error code="SetField">An error occurred while updating the <fl>Path</fl> field.</error>
        <error code="MissingPath">The object is missing a setting in the Path or Location field.</error>
        <error code="ResolvePath">A volume could not be resolved.</error>
      </result>
    </action>

    <action>
      <name>Query</name>
      <comment>Read a file's meta information from source.</comment>
      <prototype>ERR acQuery(*Object)</prototype>
    </action>

    <action>
      <name>Read</name>
      <comment>Reads data from a file.</comment>
      <prototype>ERR acRead(*Object, APTR Buffer, INT Length, INT *Result)</prototype>
      <input>
        <param type="APTR" name="Buffer">Points a buffer that will receive the data.</param>
        <param type="INT" name="Length">The total number of bytes to read from the object.  This value cannot exceed the size of the Buffer.</param>
        <param type="INT" name="Result">The Read action will write this parameter with the total number of bytes read into the Buffer.</param>
      </input>
      <description>
<p>Reads data from a file into the given buffer.  Increases the value in the <fl>Position</fl> field by the amount of bytes read from the file data.  The <code>FL::READ</code> bit in the <fl>Flags</fl> field must have been set on file initialisation, or the call will fail.</p>
<p>It is normal behaviour for this call to report success in the event that no data has been read from the file, e.g. if the end of the file has been reached.  The <code>Result</code> parameter will be returned as zero in such cases.  Check the current <fl>Position</fl> against the <fl>Size</fl> to confirm that the end has been reached.</p>
      </description>
      <result>
        <error code="Okay">The file information was read into the buffer.</error>
        <error code="Failed">The file object refers to a folder, or the object is corrupt.</error>
        <error code="Args">Invalid arguments passed to function.</error>
        <error code="OutOfRange">Invalid <code>Length</code> parameter.</error>
        <error code="FileReadFlag">The <code>FL::READ</code> flag was not specified on initialisation.</error>
        <error code="NotInitialised">The object has not been initialised.</error>
        <error code="NullArgs">Function call missing argument value(s)</error>
        <error code="ExpectedFolder">The file object refers to a folder.</error>
      </result>
    </action>

    <action>
      <name>Rename</name>
      <comment>Changes the name of a file.</comment>
      <prototype>ERR acRename(*Object, CSTRING Name)</prototype>
      <input>
        <param type="CSTRING" name="Name">The new name for the object.</param>
      </input>
    </action>

    <action>
      <name>Reset</name>
      <comment>If the file represents a folder, the file list index is reset by this action.</comment>
      <prototype>ERR acRefresh(*Object)</prototype>
    </action>

    <action>
      <name>Seek</name>
      <comment>Seeks to a new read/write position within a file.</comment>
      <prototype>ERR acSeek(*Object, DOUBLE Offset, INT Position)</prototype>
      <input>
        <param type="DOUBLE" name="Offset">The desired offset to seek to, relative to the Position parameter.</param>
        <param type="POS" name="Position">The position that defines the starting point for Offset.</param>
      </input>
    </action>

    <action>
      <name>Write</name>
      <comment>Writes data to a file.</comment>
      <prototype>ERR acWrite(*Object, APTR Buffer, INT Length, INT Result)</prototype>
      <input>
        <param type="APTR" name="Buffer">A buffer containing the data that will be written to the object.</param>
        <param type="INT" name="Length">The total number of bytes to write to the object.</param>
        <param type="INT" name="Result">This parameter with be updated with the total number of bytes written from the Buffer.</param>
      </input>
      <description>
<p>Writes data from the provided buffer into the file, then updates the <fl>Position</fl> field to reflect the new read/write position.  You must have set the <code>FL::WRITE</code> bit in the <fl>Flags</fl> field when you initialised the file, or the call will fail.</p>
      </description>
      <result>
        <error code="Okay">All of the data was written to the file.</error>
        <error code="LimitedSuccess">Only some of the data was written to the file.  Check the Result parameter to see how much data was written.</error>
        <error code="Args">Invalid arguments passed to function.</error>
        <error code="FileWriteFlag">The <code>FL::WRITE</code> flag was not specified when initialising the file.</error>
        <error code="ObjectCorrupt">The object structure is corrupt or has not been initialised.</error>
        <error code="ReallocMemory">The reallocation of a memory block failed.</error>
        <error code="ExpectedFile">The operation expected a path to a file.</error>
        <error code="NullArgs">Function call missing argument value(s)</error>
      </result>
    </action>

  </actions>

  <methods>
    <method>
      <name>BufferContent</name>
      <comment>Reads all file content into a local memory buffer.</comment>
      <prototype>ERR fl::BufferContent(OBJECTPTR Object)</prototype>
      <description>
<p>File content may be buffered at any time by calling the BufferContent method.  This will allocate a buffer that matches the current file size and the file's content will be read into that buffer.  The <code>BUFFER</code> flag is set in the file object and a pointer to the content is referenced in the file's <fl>Buffer</fl> field.  Standard file operations such as read, write and seek have the same effect when a file is in buffer mode.</p>
<p>Once a file has been buffered, the original file handle and any locks on that file are returned to the system. Physical operations on the file object such as delete, rename and attribute settings no longer have meaning when applied to a buffered file.  It is not possible to drop the buffer and return the file object to its original state once buffering has been enabled.</p>
      </description>
      <result>
        <error code="Okay">The file content was successfully buffered.</error>
        <error code="Read">Failed to read the file content.</error>
        <error code="AllocMemory">AllocMemory() failed to create a new memory block.</error>
      </result>
    </method>

    <method>
      <name>Copy</name>
      <comment>Copies the data of a file to another location.</comment>
      <prototype>ERR fl::Copy(OBJECTPTR Object, CSTRING Dest, FUNCTION * Callback)</prototype>
      <input>
        <param type="CSTRING" name="Dest">The destination file path for the copy operation.</param>
        <param type="FUNCTION *" name="Callback">Optional callback for receiving feedback during the operation.</param>
      </input>
      <description>
<p>This method is used to copy the data of a file object to another location.  All of the data will be copied, effectively creating a clone of the original file information.  The file object must have been initialised with the <code>FL::READ</code> flag, or the copy operation will not work (this restriction does not apply to directories).  If a matching file name already exists at the destination path, it will be over-written with the new data.</p>
<p>The <fl>Position</fl> field will be reset as a result of calling this method.</p>
<p>When copying directories with this method, the entire folder structure (i.e. all of the folder contents) will be copied to the new location.  If an error occurs when copying a sub-folder or file, the procedure will be aborted and an error code will be returned.</p>
      </description>
      <result>
        <error code="Okay">The file data was copied successfully.</error>
        <error code="Failed">General failure.</error>
        <error code="Args">Invalid arguments passed to function.</error>
        <error code="Read">Data could not be read from the source path.</error>
        <error code="Write">Data could not be written to the destination path.</error>
        <error code="FieldNotSet">The <fl>Path</fl> field has not been set in the file object.</error>
        <error code="AllocMemory">AllocMemory() failed to create a new memory block.</error>
        <error code="Loop">Performing the copy would cause infinite recursion.</error>
        <error code="ResolvePath">A volume could not be resolved.</error>
        <error code="NullArgs">Function call missing argument value(s)</error>
      </result>
    </method>

    <method>
      <name>Delete</name>
      <comment>Deletes a file from its source location.</comment>
      <prototype>ERR fl::Delete(OBJECTPTR Object, FUNCTION * Callback)</prototype>
      <input>
        <param type="FUNCTION *" name="Callback">Optional callback for receiving feedback during the operation.</param>
      </input>
      <description>
<p>This method is used to delete files from their source location.  If used on a folder, all of the folder's contents will be deleted in the call.   Once a file is deleted, the object effectively becomes unusable.  For this reason, file deletion should normally be followed up with a call to the Free action.</p>
      </description>
      <result>
        <error code="Okay">File deleted successfully.</error>
        <error code="Failed">The deletion attempt failed (specific condition not available).</error>
        <error code="NoPermission">The user does not have the necessary permissions to delete the file.</error>
        <error code="MissingPath">The object is missing a setting in the Path or Location field.</error>
        <error code="BufferOverflow">The file path string is too long.</error>
        <error code="ResolvePath">A volume could not be resolved.</error>
        <error code="ReadOnly">The file is on a read-only filesystem.</error>
        <error code="Locked">The file is in use.</error>
      </result>
    </method>

    <method>
      <name>Move</name>
      <comment>Moves a file to a new location.</comment>
      <prototype>ERR fl::Move(OBJECTPTR Object, CSTRING Dest, FUNCTION * Callback)</prototype>
      <input>
        <param type="CSTRING" name="Dest">The desired path for the file.</param>
        <param type="FUNCTION *" name="Callback">Optional callback for receiving feedback during the operation.</param>
      </input>
      <description>
<p>This method is used to move the data of a file to another location.  If the file object represents a folder, then the folder and all of its contents will be moved.  The file object must have been initialised with the <code>FL::READ</code> flag, or the move operation will not work (this restriction does not apply to directories).  If a file already exists at the destination path then it will be over-written with the new data.</p>
<p>The <fl>Position</fl> field will be reset as a result of calling this method.</p>
      </description>
      <result>
        <error code="Okay">The File was moved successfully.</error>
        <error code="Failed">General failure.</error>
        <error code="Args">Invalid arguments passed to function.</error>
        <error code="FieldNotSet">The <fl>Path</fl> field has not been set in the file object.</error>
        <error code="NullArgs">Function call missing argument value(s)</error>
      </result>
    </method>

    <method>
      <name>Next</name>
      <comment>Retrieve meta information describing the next indexed file in the folder list.</comment>
      <prototype>ERR fl::Next(OBJECTPTR Object, objFile ** File)</prototype>
      <input>
        <param type="objFile **" name="File">A pointer to a new File object will be returned in this parameter if the call is successful.</param>
      </input>
      <description>
<p>If a file object represents a folder, calling the Next() method will retrieve meta information about the next file in the folder's index.  This information will be returned as a new File object that is partially initialised (the file will not be opened, but information such as size, timestamps and permissions will be retrievable).</p>
<p>If desired, the resulting file object can be opened by setting the <code>READ</code> or <code>WRITE</code> bits in <fl>Flags</fl> and then calling the <action>Activate</action> action.</p>
<p>It is the responsibility of the caller to free the resulting File object once it is no longer required.</p>
<p>The file index can be reset by calling the <action>Reset</action> action.</p>
      </description>
      <result>
        <error code="Okay">Operation successful.</error>
        <error code="DirEmpty">The index has reached the end of the file list.</error>
        <error code="Args">Invalid arguments passed to function.</error>
        <error code="NullArgs">Function call missing argument value(s)</error>
      </result>
    </method>

    <method>
      <name>ReadLine</name>
      <comment>Reads the next line from the file.</comment>
      <prototype>ERR fl::ReadLine(OBJECTPTR Object, STRING * Result)</prototype>
      <input>
        <param type="STRING *" name="Result">The resulting string is returned in this parameter.</param>
      </input>
      <description>
<p>Reads one line from the file into an internal buffer, which is returned in the Result argument.  Reading a line will increase the <fl>Position</fl> field by the amount of bytes read from the file.  You must have set the <code>FL::READ</code> bit in the <fl>Flags</fl> field when you initialised the file, or the call will fail.</p>
<p>The line buffer is managed internally, so there is no need to free the <code>Result</code> string.  <code>ERR::NoData</code> is returned once all lines have been read.</p>
      </description>
      <result>
        <error code="Okay">The file information was read into the buffer.</error>
        <error code="Failed">The file object refers to a folder.</error>
        <error code="Args">Invalid arguments passed to function.</error>
        <error code="NoData">There is no more data left to read.</error>
        <error code="FileReadFlag">The <code>FL::READ</code> flag was not specified on initialisation.</error>
        <error code="ObjectCorrupt">The internal file handle is missing.</error>
        <error code="BufferOverflow">The line is too long for the read routine (4096 byte limit).</error>
      </result>
    </method>

    <method>
      <name>SetDate</name>
      <comment>Sets the date on a file.</comment>
      <prototype>ERR fl::SetDate(OBJECTPTR Object, INT Year, INT Month, INT Day, INT Hour, INT Minute, INT Second, FDT Type)</prototype>
      <input>
        <param type="INT" name="Year">Year (-ve for BC, +ve for AD).</param>
        <param type="INT" name="Month">Month (1 - 12)</param>
        <param type="INT" name="Day">Day (1 - 31)</param>
        <param type="INT" name="Hour">Hour (0 - 23</param>
        <param type="INT" name="Minute">Minute (0 - 59)</param>
        <param type="INT" name="Second">Second (0 - 59)</param>
        <param type="FDT" name="Type" lookup="FDT">The type of date to set (filesystem dependent).</param>
      </input>
      <description>
<p>The SetDate method provides a convenient way to set the date and time information for a file object.  Date information is set in a human readable year, month, day, hour, minute and second format for your convenience.</p>
<p>Depending on the filesystem type, multiple forms of datestamp may be supported.  The default datestamp, <code>FDT::MODIFIED</code> defines the time at which the file data was last altered.  Other types include the date on which the file was created and the date it was last archived (backed up).  The following types are supported by the Type argument:</p>
<types lookup="FDT"/>
<p>If the specified datestamp is not supported by the filesystem, <code>ERR::NoSupport</code> is returned by this method.</p>
      </description>
      <result>
        <error code="Okay">Operation successful.</error>
        <error code="NoSupport">The platform does not support file date setting.</error>
        <error code="ResolvePath">A volume could not be resolved.</error>
        <error code="SystemCall">A call to the host system has failed.</error>
        <error code="NullArgs">Function call missing argument value(s)</error>
      </result>
    </method>

    <method>
      <name>StartStream</name>
      <comment>Starts streaming data from a file source.</comment>
      <prototype>ERR fl::StartStream(OBJECTPTR Object, OBJECTID Subscriber, FL Flags, INT Length)</prototype>
      <input>
        <param type="OBJECTID" name="Subscriber">Reference to an object that will receive streamed data notifications.</param>
        <param type="FL" name="Flags" lookup="FL">Use <code>READ</code> for incoming data, <code>WRITE</code> for outgoing data.</param>
        <param type="INT" name="Length">Limits the total amount of data to be streamed.</param>
      </input>
      <description>
<p>If a file object is a stream (indicated by the <code>STREAM</code> flag), the StartStream method should be used for reading or writing data to the file object.  Although it is possible to call the Read and Write actions on streamed files, they will be limited to returning only the amount of data that is cached locally (if any), or writing as much as buffers will allow in software.</p>
<p>A single file object can support read or write streams (pass <code>FL::READ</code> or <code>FL::WRITE</code> in the <code>Flags</code> parameter). However, only one of the two can be active at any time.  To switch between read and write modes, the stream must be stopped with the <method>StopStream</method> method and then restarted with StartStream.</p>
<p>A stream can be limited by setting the Length parameter to a non-zero value.</p>
<p>If the StartStream request is successful, the file object will return action notifications to the Subscriber to indicate activity on the file stream.  When reading from a stream, <code>AC::Write</code> notifications will be received to indicate that new data has been written to the file cache.  The Buffer parameter of the reported acWrite structure may refer to a private address that contains the data that was received from the stream and the Result indicates the amount of new data available.</p>
<p>When writing to a stream, <code>AC::Read</code> notifications will be received to indicate that the stream is ready to accept more data.  The Result parameter will indicate the maximum amount of data that should be written to the stream using the <action>Write</action> action.</p>
<p>A stream can be cancelled at any time by calling <method>StopStream</method>.</p>
      </description>
      <result>
        <error code="Okay">Operation successful.</error>
        <error code="Args">Invalid arguments passed to function.</error>
        <error code="NoSupport">The file is not streamed.</error>
      </result>
    </method>

    <method>
      <name>StopStream</name>
      <comment>Stops streaming data from a file source.</comment>
      <prototype>ERR fl::StopStream(OBJECTPTR Object)</prototype>
      <description>
<p>This method terminates data streaming from a file (instantiated by the <method>StartStream</method> method).  Any resources related to the streaming process will be deallocated.</p>
      </description>
      <result>
        <error code="Okay">Operation successful.</error>
        <error code="Args">Invalid arguments passed to function.</error>
        <error code="NoSupport">The file is not streamed.</error>
      </result>
    </method>

    <method>
      <name>Watch</name>
      <comment>Monitors files and folders for file system events.</comment>
      <prototype>ERR fl::Watch(OBJECTPTR Object, FUNCTION * Callback, INT64 Custom, MFF Flags)</prototype>
      <input>
        <param type="FUNCTION *" name="Callback">The routine that will be called when a file change is triggered by the system.</param>
        <param type="INT64" name="Custom">A custom 64-bit value that will passed to the Callback routine as a parameter.</param>
        <param type="MFF" name="Flags" lookup="MFF">Filter events to those indicated in these flags.</param>
      </input>
      <description>
<p>The Watch() method configures event based reporting for changes to any file or folder in the file system. The capabilities of this method are dependent on the host platform, with Windows and Linux systems being able to support most of the current feature set.</p>
<p>The path that will be monitored is determined by the File object's <fl>Path</fl> field.  Both files and folders are supported as targets.</p>
<p>The optional <lk>MFF</lk> Flags are used to filter events to those that are desired for monitoring.</p>
<p>The client must provide a <code>Callback</code> that will be triggered when a monitored event is triggered.  The <code>Callback</code> must follow the format <code>ERR Routine(*File, STRING Path, INT64 Custom, INT Flags)</code></p>
<p>Each event will be delivered in the sequence that they are originally raised.  The <code>Flags</code> parameter will reflect the specific event that has occurred.  The <code>Custom</code> parameter is identical to the <code>Custom</code> argument originally passed to this method.  The <code>Path</code> is a string that is relative to the File's <fl>Path</fl> field.</p>
<p>If the callback routine returns <code>ERR::Terminate</code>, the watch will be disabled.  It is also possible to disable an existing watch by calling this method with no parameters, or by setting the <code>Flags</code> parameter to <code>0</code>.</p>
      </description>
      <result>
        <error code="Okay">Operation successful.</error>
        <error code="Args">Invalid arguments passed to function.</error>
        <error code="NullArgs">Function call missing argument value(s)</error>
      </result>
    </method>

  </methods>

  <fields>
    <field>
      <name>Buffer</name>
      <comment>Points to the internal data buffer if the file content is held in memory.</comment>
      <access read="G">Get</access>
      <type>INT8 *</type>
      <description>
<p>If a file has been created with an internal buffer (by setting the <code>BUFFER</code> flag on creation), this field will point to the address of that buffer.  The size of the buffer will match the <fl>Size</fl> field.</p>
      </description>
    </field>

    <field>
      <name>Created</name>
      <comment>The creation date stamp for the file.</comment>
      <access read="G" write="W">Get/Write</access>
      <type>APTR</type>
      <description>
<p>The Created field returns the time at which the file was first created, if supported by the filesystem.  If not supported directly, the most recent 'modification date' is normally returned.</p>
<p>To simplify time management, information is read and set via a <st>DateTime</st> structure.</p>
      </description>
    </field>

    <field>
      <name>Date</name>
      <comment>The 'last modified' date stamp on the file.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>APTR</type>
      <description>
<p>The Date field reflects the time at which the file was last modified.  It can also be used to set a new modification date.  Please note that if the file is open for writing, then date-stamped, then modified; the file system driver will overwrite the previously defined date stamp with the time at which the file was last written.</p>
<p>Information is read and set using a standard <st>DateTime</st> structure.</p>
      </description>
    </field>

    <field>
      <name>Flags</name>
      <comment>File flags and options.</comment>
      <access read="R" write="S">Read/Set</access>
      <type lookup="FL">FL</type>
      <description>
<p>Note: If setting flags post-initialisation, the following restrictions apply: 1. The file must not have been activated (opened) yet; 2. Only the <code>NEW</code>, <code>READ</code> and <code>WRITE</code> flags can be utilised.</p>
<types lookup="FL"/>
      </description>
    </field>

    <field>
      <name>Group</name>
      <comment>Retrieve or change the group ID of a file.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>INT</type>
      <description>
<p>The group ID assigned to a file can be read from this field.  The ID is retrieved from the file system in real time in case the ID has been changed after initialisation of the file object.</p>
<p>You can also change the group ID of a file by writing an integer value to this field.</p>
<p>If the file system does not support group ID's, <code>ERR::NoSupport</code> is returned.</p>
      </description>
    </field>

    <field>
      <name>Handle</name>
      <comment>The native system handle for the file opened by the file object.</comment>
      <access read="G">Get</access>
      <type>INT64</type>
      <description>
<p>This field returns the native file system handle for the file opened by the file object.  The native handle may be an integer or pointer value in 32 or 64-bit format.  In order to manage this issue in a multi-platform manner, the value is returned as a 64-bit integer.</p>
      </description>
    </field>

    <field>
      <name>Icon</name>
      <comment>Returns an icon reference that is suitable for this file in the UI.</comment>
      <access read="G">Get</access>
      <type>STRING</type>
      <description>
<p>This field returns the name of the best icon to use when representing the file to the user, for instance in a file list.  The icon style is determined by analysing the File's <fl>Path</fl>.</p>
<p>The resulting string is returned in the format <code>icons:category/name</code> and will refer to an SVG file.</p>
      </description>
    </field>

    <field>
      <name>Link</name>
      <comment>Returns the link path for symbolically linked files.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>STRING</type>
      <description>
<p>If a file represents a symbolic link (indicated by the <code>SYMLINK</code> flag setting) then reading the Link field will return the link path.  No assurance is made as to the validity of the path.  If the path is not absolute, then the parent folder containing the link will need to be taken into consideration when calculating the path that the link refers to.</p>
      </description>
    </field>

    <field>
      <name>Path</name>
      <comment>Specifies the location of a file or folder.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>STRING</type>
      <description>
<p>This field is required for initialisation and must either be in the format of a universal path string, or a path that is compatible with the host system.  The standard format for a universal path is <code>volume:folder/file</code>, for instance <code>parasol:system/classes.bin</code>.</p>
<p>To reference a folder in a way that is distinct from a file, use a trailing slash as in <code>volume:folder/</code>.</p>
<p>Referencing a <code>volume:</code> is optional.  In the event that a volume is not defined, the current working path is used as the point of origin.</p>
<p>The accepted method for referencing parent folders is <code>../</code>, which can be repeated for as many parent folders as needed to traverse the folder hierarchy.</p>
      </description>
    </field>

    <field>
      <name>Permissions</name>
      <comment>Manages the permissions of a file.</comment>
      <access read="G" write="S">Get/Set</access>
      <type lookup="PERMIT">INT</type>
      <description>
<types lookup="PERMIT"/>
      </description>
    </field>

    <field>
      <name>Position</name>
      <comment>The current read/write byte position in a file.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>INT64</type>
      <description>
<p>This field indicates the current byte position of an open file (this affects read and write operations).  Writing to this field performs a <action>Seek</action> operation.</p>
<p>The Position will always remain at zero if the file object represents a folder.</p>
      </description>
    </field>

    <field>
      <name>ResolvedPath</name>
      <comment>Returns a resolved copy of the Path string.</comment>
      <access read="G">Get</access>
      <type>STRING</type>
      <description>
<p>The ResolvedPath will return a resolved copy of the <fl>Path</fl> string.  The resolved path will be in a format that is native to the host platform.  Please refer to the <function>ResolvePath</function> function for further information.</p>
      </description>
    </field>

    <field>
      <name>Size</name>
      <comment>The byte size of a file.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>INT64</type>
      <description>
<p>The current byte size of a file is indicated by this field.  If the file object represents a folder, the Size value will be zero.  You can also truncate a file by setting the Size; this will result in the current read/write position being set to the end of the file.</p>
      </description>
    </field>

    <field>
      <name>Static</name>
      <comment>Set to <code>true</code> if a file object should be static.</comment>
      <access read="R" write="I">Read/Init</access>
      <type>INT</type>
      <description>
<p>This field applies when a file object has been created in an object script.  By default, a file object will auto-terminate when a closing tag is received.  If the object must remain live, set this field to <code>true</code>.</p>
      </description>
    </field>

    <field>
      <name>Target</name>
      <comment>Specifies a surface ID to target for user feedback and dialog boxes.</comment>
      <access read="R" write="W">Read/Write</access>
      <type>OBJECTID</type>
      <description>
<p>User feedback can be enabled for certain file operations by setting the Target field to a valid surface ID, or zero for the default target for new windows.  This field is set to <code>-1</code> by default, in order to disable this feature.</p>
<p>If set correctly, operations such as file deletion or copying will pop-up a progress box after a certain amount of time has elapsed during the operation.  The dialog box will also provide the user with a cancel option to terminate the process early.</p>
      </description>
    </field>

    <field>
      <name>TimeStamp</name>
      <comment>The last modification time set on a file, represented as a 64-bit integer.</comment>
      <access read="G">Get</access>
      <type>INT64</type>
      <description>
<p>The TimeStamp field is a 64-bit representation of the last modification date/time set on a file.  It is not guaranteed that the value represents seconds from the epoch, so it should only be used for purposes such as sorting, or for comparison to the time stamps of other files.  For a parsed time structure, refer to the <fl>Date</fl> field.</p>
      </description>
    </field>

    <field>
      <name>User</name>
      <comment>Retrieve or change the user ID of a file.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>INT</type>
      <description>
<p>The user ID assigned to a file can be read from this field.  The ID is retrieved from the file system in real time in case the ID has been changed after initialisation of the file object.</p>
<p>You can also change the user ID of a file by writing an integer value to this field.  This can only be done post-initialisation or an error code will be returned.</p>
<p>If the filesystem does not support user ID's, <code>ERR::NoSupport</code> is returned.</p>
      </description>
    </field>

  </fields>
  <types>
    <constants lookup="FDT" comment="Flags for the SetDate() file method.">
      <const name="ACCESSED">The date on which the file was last accessed by a user or application.</const>
      <const name="ARCHIVED">The date on which the file was most recently archived.  Not supported by most filesystems.</const>
      <const name="CREATED">The date on which the file was created.  On some host platforms this datestamp may be read-only.</const>
      <const name="MODIFIED">The date on which the file was last modified.</const>
    </constants>

    <constants lookup="FL" comment="File flags">
      <const name="APPROXIMATE">Allows fuzzy matching of the file path when opening an existing file.  This means that the file extension will be ignored; for instance attempting to open a file of 'screenshot.png' when only a file name of 'screenshot.jpg' exists in the same folder, the 'screenshot.jpg' file will be opened instead.  If multiple files could potentially match to the file name, the file object will select the first match that is encountered.</const>
      <const name="BUFFER">Activates a special mode in which the file data is stored in a memory buffer rather than a disk file.  Set the Size field to a value of at least 1 so that the initial buffer size is configured.  In this mode many of the available file operations are meaningless except for the Read, Write and Seek actions.</const>
      <const name="DEVICE">The file is a system device (must set if opening a device for read/write operations)</const>
      <const name="DIRECTORY">The file object represents a folder.</const>
      <const name="EXCLUDE_FILES">Exclude files when scanning this folder.</const>
      <const name="EXCLUDE_FOLDERS">Exclude folders when scanning this folder.</const>
      <const name="FILE">Explicitly declares the file object as an entity that stores content (as opposed to a device or folder for example).</const>
      <const name="FOLDER">The file object represents a folder.</const>
      <const name="LINK">Read-Only.  Indicates that the file is a symbolic link or shortcut to another file.</const>
      <const name="LOOP">In loop mode, the file object's position marker for read/write operations is allowed to extend past the actual file size.  Any read/write operation beyond the file size will loop back to the file at a corrected offset - for example, reading position 330 of a 100 byte file will start the operation from the 30th byte.  Loop mode does not affect any other area besides the read, write and seek operations.  The loop feature is typically used to create multimedia data streams with minimal effort.</const>
      <const name="NEW">Required when creating a new file.  If a file with the same name exists, its contents will be destroyed. If however the existing file is locked, the initalisation process will fail.</const>
      <const name="READ">Required if the file needs to be opened for read access.</const>
      <const name="RESET_DATE">For internal use only</const>
      <const name="STREAM">File data is streamed (e.g. PIPE, FIFO, socket) and may be accessed locally or via a network.</const>
      <const name="WRITE">Prepares a file for writing data, starting at byte position 0.  To start writing from the end of a file, use the Seek action after the file has been initialised.</const>
    </constants>

    <constants lookup="MFF" comment="Flags for the File Watch() method.">
      <const name="ATTRIB">File permissions or datestamp changed.</const>
      <const name="CLOSED">An opened file has been closed.</const>
      <const name="CREATE">New file/link created or renamed in folder.</const>
      <const name="DEEP">Receive notifications from sub-folders (Windows only).</const>
      <const name="DELETE">Existing file deleted</const>
      <const name="FILE">File identifier; if passed to <class name="File" method="Watch">File.Watch()</class> then indicates a preference for file events only.</const>
      <const name="FOLDER">Folder identifier; if passed to <class name="File" method="Watch">File.Watch()</class> then indicates a preference for folder events only.</const>
      <const name="MODIFY">File modified via write or truncation.</const>
      <const name="MOVED">Existing file moved or renamed.</const>
      <const name="OPENED">Existing file was opened.</const>
      <const name="READ">File was accessed (read).</const>
      <const name="RENAME">Existing file moved or renamed.</const>
      <const name="SELF">Event applies to the monitored folder and not a contained item</const>
      <const name="UNMOUNT">Host filesystem was unmounted.</const>
      <const name="WRITE">File modified via write or truncation.</const>
    </constants>

    <constants lookup="PERMIT" comment="Permission flags">
      <const name="ALL_DELETE">Synonym for <code>EVERYONE_DELETE</code></const>
      <const name="ALL_EXEC">Synonym for <code>EVERYONE_EXEC</code></const>
      <const name="ALL_READ">Synonym for <code>EVERYONE_READ</code></const>
      <const name="ALL_WRITE">Synonym for <code>EVERYONE_WRITE</code></const>
      <const name="ARCHIVE">Marks the file for future backup.  The flag should be cleared after the backup has succeeded.</const>
      <const name="DELETE">Owner can delete.  If the file system does not support this, deletion is enabled via the <code>WRITE</code> flag.</const>
      <const name="EVERYONE_ACCESS">Synonym for <code>EVERYONE_READ | EVERYONE_WRITE | EVERYONE_EXEC | EVERYONE_DELETE</code></const>
      <const name="EVERYONE_DELETE">Synonym for <code>DELETE | GROUP_DELETE | OTHERS_DELETE</code></const>
      <const name="EVERYONE_EXEC">Synonym for <code>EXEC | GROUP_EXEC | OTHERS_EXEC</code></const>
      <const name="EVERYONE_READ">Synonym for <code>READ | GROUP_READ | OTHERS_READ</code></const>
      <const name="EVERYONE_READWRITE">Synonym for <code>EVERYONE_READ | EVERYONE_WRITE</code></const>
      <const name="EVERYONE_WRITE">Synonym for <code>WRITE | GROUP_WRITE | OTHERS_WRITE</code></const>
      <const name="EXEC">User/Owner can execute.</const>
      <const name="GROUP">Synonym for <code>GROUP_READ | GROUP_WRITE | GROUP_EXEC | GROUP_DELETE</code></const>
      <const name="GROUPID">Allows executables to run with a set group id.</const>
      <const name="GROUP_DELETE">Group members can delete.</const>
      <const name="GROUP_EXEC">Group members can execute.</const>
      <const name="GROUP_READ">Group members can read.</const>
      <const name="GROUP_WRITE">Group members can write.</const>
      <const name="HIDDEN">Recommends that the file is hidden from view by default.</const>
      <const name="INHERIT">Inherit permissions from parent folder and logical OR them with preset permission flags.</const>
      <const name="NETWORK">File is hosted on another machine.</const>
      <const name="OFFLINE">File content for this networked file has not been cached on the local PC.</const>
      <const name="OTHERS">Synonym for <code>OTHERS_READ | OTHERS_WRITE | OTHERS_EXEC | OTHERS_DELETE</code></const>
      <const name="OTHERS_DELETE">Others can delete.</const>
      <const name="OTHERS_EXEC">Others can execute.</const>
      <const name="OTHERS_READ">Others can read.</const>
      <const name="OTHERS_WRITE">Others can write.</const>
      <const name="PASSWORD">File is password protected.</const>
      <const name="READ">User/Owner has read access.  This will not allow compiled code to be executed.</const>
      <const name="USER">Synonym for <code>READ | WRITE | EXEC | DELETE</code></const>
      <const name="USERID">Allows executables to run with a set user id.</const>
      <const name="USER_EXEC">Synonym for <code>EXEC</code></const>
      <const name="USER_READ">Synonym for <code>READ</code></const>
      <const name="USER_WRITE">Synonym for <code>WRITE</code></const>
      <const name="WRITE">User/Owner can write.</const>
    </constants>

  </types>
  <structs>
    <struct name="DateTime" comment="Generic structure for date-time management.">
      <field name="Year" type="INT16">Year</field>
      <field name="Month" type="INT8">Month 1 to 12</field>
      <field name="Day" type="INT8">Day 1 to 31</field>
      <field name="Hour" type="INT8">Hour 0 to 23</field>
      <field name="Minute" type="INT8">Minute 0 to 59</field>
      <field name="Second" type="INT8">Second 0 to 59</field>
      <field name="TimeZone" type="INT8">TimeZone -13 to +13</field>
    </struct>

  </structs>
</book>
