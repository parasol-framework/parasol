<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="class.xsl"?>

<book>
  <info>
    <name>Bitmap</name>
    <type>class</type>
    <module>Display</module>
    <comment>Manages bitmap graphics and provides drawing functionality.</comment>
    <version>2</version>
    <id>f42617e2</id>
    <idstring>BITMAP</idstring>
    <category>Graphics</category>
    <copyright>Paul Manias 2003-2025</copyright>
    <description>
<p>The Bitmap class provides a way of describing an area of memory that an application can draw to, and/or display if the data is held in video memory.  Bitmaps are used in the handling of <class name="Display">Display</class> and <class name="Picture">Picture</class> objects, and form the backbone of Parasol's graphics functionality.  The Bitmap class supports everything from basic graphics primitives to masking and alpha blending features.</p>
<p>To create a new bitmap object, you need to specify its <fl>Width</fl> and <fl>Height</fl> at a minimum.  Preferably, you should also know how many colours you want to use and whether the bitmap data should be held in standard memory (for CPU based reading and writing) or video memory (for hardware based drawing).  After creating a bitmap you can use a number of available drawing methods for the purpose of image management.  Please note that these methods are designed to be called under exclusive conditions, and it is not recommended that you call methods on a bitmap using the message system.</p>
<p>By default, the CPU can only be used to read and write data directly to or from a bitmap when it is held in standard memory (this is the default type).  If the <code>TEXTURE</code> or <code>VIDEO</code> flags are specified in the <fl>DataFlags</fl> field then the CPU cannot access this memory, unless you specifically request it.  To do this, use the <action>Lock</action> and <action>Unlock</action> actions to temporarily gain read/write access to a bitmap.</p>
<p>If you require complex drawing functionality that is not available in the Bitmap class, consider using the functionality provided by the Vector module.</p>
<p>To save the image of a bitmap, either copy its image to a <class name="Picture">Picture</class> object, or use the SaveImage() action to save the data in PNG format.  Raw data can also be processed through a bitmap by using the Read and Write actions.</p></description>
    <source>
      <file>class_bitmap.cpp</file>
    </source>
  </info>

  <actions>
    <action>
      <name>Clear</name>
      <comment>Clears a bitmap's image to <fl>BkgdIndex</fl>.</comment>
      <prototype>ERR acClear(*Object)</prototype>
      <description>
<p>Clearing a bitmap wipes away its graphical contents by drawing a blank area over its existing graphics.  The colour of the blank area is determined by the <fl>BkgdIndex</fl> field.  To clear a bitmap to a different colour, use the <method>DrawRectangle</method> method instead.</p>
<p>If the bitmap supports alpha blending and a transparent result is desired, setting <fl>BkgdIndex</fl> to zero is an efficient way to achieve this outcome.</p>
      </description>
    </action>

    <action>
      <name>CopyData</name>
      <comment>Copies bitmap image data to other bitmaps with colour remapping enabled.</comment>
      <prototype>ERR acCopyData(*Object, OBJECTID Dest)</prototype>
      <input>
        <param type="OBJECTID" name="Dest">The unique ID of the destination object.</param>
      </input>
      <description>
<p>This action will copy the image of the bitmap to any other initialised bitmap that you specify.  Support for copying the image data to other object class types is not provided.</p>
<p>This action features automatic clipping and remapping, for occasions where the bitmaps do not match up in size or colour.</p>
      </description>
    </action>

    <action>
      <name>Draw</name>
      <comment>Clears a bitmap's image to <fl>BkgdIndex</fl>.</comment>
      <prototype>ERR acDraw(*Object, DOUBLE X, DOUBLE Y, DOUBLE Width, DOUBLE Height)</prototype>
      <input>
        <param type="LONG" name="X">The X position of the region to be drawn.</param>
        <param type="LONG" name="Y">The Y position of the region to be drawn.</param>
        <param type="LONG" name="Width">The width of the region to be drawn.</param>
        <param type="LONG" name="Height">The height of the region to be drawn.</param>
      </input>
    </action>

    <action>
      <name>Flush</name>
      <comment>Flushes pending graphics operations and returns when the accelerator is idle.</comment>
      <prototype>ERR acFlush(*Object)</prototype>
      <description>
<p>The Flush() action ensures that client graphics operations are synchronised with the graphics accelerator. Synchronisation is essential prior to drawing to the bitmap with the CPU.  Failure to synchronise may result in corruption in the bitmap's graphics display.</p>
<p>Clients do not need to call this function if solely using the graphics methods provided in the <class name="Bitmap">Bitmap</class> class.</p>
      </description>
    </action>

    <action>
      <name>Init</name>
      <comment>Initialises a bitmap.</comment>
      <prototype>ERR InitObject(*Object)</prototype>
      <description>
<p>This action will initialise a bitmap object so that it is ready for use, which primarily means that a suitable area of memory is reserved for drawing.  If the <fl>Data</fl> field has not already been defined, a new memory block will be allocated for the bitmap region.  The type of memory that is allocated is dependent on the <fl>DataFlags</fl> field, which defaults to <code>MEM::DATA</code>.  To request video RAM, use <code>MEM::VIDEO</code>.  To store graphics data in fast write-able memory, use <code>MEM::TEXTURE</code>.</p>
<p>The Init() action requires that the <fl>Width</fl> and <fl>Height</fl> fields are defined at minimum.</p>
      </description>
    </action>

    <action>
      <name>Lock</name>
      <comment>Locks the bitmap surface for direct read/write access.</comment>
      <prototype>ERR acLock(*Object)</prototype>
    </action>

    <action>
      <name>Query</name>
      <comment>Populates a bitmap with pre-initialised/default values prior to initialisation.</comment>
      <prototype>ERR acQuery(*Object)</prototype>
      <description>
<p>This action will pre-initialise a bitmap object so that its fields are populated with default values.  It stops short of allocating the bitmap's memory.</p>
<p>This action requires that the <fl>Width</fl> and <fl>Height</fl> fields of the bitmap are defined at minimum.  Populating the bitmap fields is done on a best efforts basis, e.g. if the <fl>BytesPerPixel</fl> is set to 2 then it will be determined that the bitmap is a 16 bit, 64k colour bitmap.</p>
      </description>
    </action>

    <action>
      <name>Read</name>
      <comment>Reads raw image data from a bitmap object.</comment>
      <prototype>ERR acRead(*Object, APTR Buffer, LONG Length, LONG *Result)</prototype>
      <input>
        <param type="APTR" name="Buffer">Points a buffer that will receive the data.</param>
        <param type="LONG" name="Length">The total number of bytes to read from the object.  This value cannot exceed the size of the Buffer.</param>
        <param type="LONG" name="Result">The Read action will write this parameter with the total number of bytes read into the Buffer.</param>
      </input>
    </action>

    <action>
      <name>Resize</name>
      <comment>Resizes a bitmap object's dimensions.</comment>
      <prototype>ERR acResize(*Object, DOUBLE Width, DOUBLE Height, DOUBLE Depth)</prototype>
      <input>
        <param type="DOUBLE" name="Width">The new width of the object.</param>
        <param type="DOUBLE" name="Height">The new height of the object.</param>
        <param type="DOUBLE" name="Depth">The new depth of the object.</param>
      </input>
      <description>
<p>Resizing a bitmap will change its <fl>Width</fl>, <fl>Height</fl> and optionally <fl>BitsPerPixel</fl>.  Existing image data is not retained by this process.</p>
<p>The image data is cleared with <fl>Bkgd</fl> if the <code>CLEAR</code> flag is defined in <fl>Flags</fl>.</p>
      </description>
      <result>
        <error code="Okay">Operation successful.</error>
        <error code="FieldNotSet">A required field value is undefined.</error>
        <error code="AllocMemory">A call to AllocMemory() failed to create a new memory block.</error>
        <error code="NullArgs">Function call missing argument value(s)</error>
      </result>
    </action>

    <action>
      <name>SaveImage</name>
      <comment>Saves a bitmap's image to a data object of your choosing in PCX format.</comment>
      <prototype>ERR acSaveImage(*Object, OBJECTID Dest, CLASSID ClassID)</prototype>
      <input>
        <param type="OBJECTID" name="Dest">Refers to an object that will receive the encoded image data.</param>
        <param type="CLASSID" name="ClassID">The Picture class to use for encoding the image data.</param>
      </input>
    </action>

    <action>
      <name>Seek</name>
      <comment>Changes the current byte position for read/write operations.</comment>
      <prototype>ERR acSeek(*Object, DOUBLE Offset, LONG Position)</prototype>
      <input>
        <param type="DOUBLE" name="Offset">The desired offset to seek to, relative to the Position parameter.</param>
        <param type="POS" name="Position">The position that defines the starting point for Offset.</param>
      </input>
    </action>

    <action>
      <name>Unlock</name>
      <comment>Unlocks the bitmap surface once direct access is no longer required.</comment>
      <prototype>ERR acUnlock(*Object)</prototype>
    </action>

    <action>
      <name>Write</name>
      <comment>Writes raw image data to a bitmap object.</comment>
      <prototype>ERR acWrite(*Object, APTR Buffer, LONG Length, LONG Result)</prototype>
      <input>
        <param type="APTR" name="Buffer">A buffer containing the data that will be written to the object.</param>
        <param type="LONG" name="Length">The total number of bytes to write to the object.</param>
        <param type="LONG" name="Result">This parameter with be updated with the total number of bytes written from the Buffer.</param>
      </input>
    </action>

  </actions>

  <methods>
    <method>
      <name>Compress</name>
      <comment>Compresses bitmap data to save memory.</comment>
      <prototype>ERR bmp::Compress(OBJECTPTR Object, INT Level)</prototype>
      <input>
        <param type="INT" name="Level">Level of compression.  Zero uses a default setting (recommended), the maximum is 10.</param>
      </input>
      <description>
<p>A bitmap can be compressed with the CompressBitmap() method to save memory when the bitmap is not in use.  This is useful if a large bitmap needs to be stored in memory and it is anticipated that the bitmap will be used infrequently.</p>
<p>Once a bitmap is compressed, its image data is invalid.  Any attempt to access the bitmap's image data will likely result in a memory access fault.  The image data will remain invalid until the <method>Decompress</method> method is called to restore the bitmap to its original state.</p>
<p>The <code>BMF::COMPRESSED</code> bit will be set in the <fl>Flags</fl> field after a successful call to this function to indicate that the bitmap is compressed.</p>
      </description>
      <result>
        <error code="Okay">Operation successful.</error>
        <error code="AllocMemory">A call to AllocMemory() failed to create a new memory block.</error>
        <error code="ReallocMemory">The reallocation of a memory block failed.</error>
        <error code="CreateObject">A Compression object could not be created.</error>
        <error code="NullArgs">Function call missing argument value(s)</error>
      </result>
    </method>

    <method>
      <name>ConvertToLinear</name>
      <comment>Convert a bitmap's colour space to linear RGB.</comment>
      <prototype>ERR bmp::ConvertToLinear(OBJECTPTR Object)</prototype>
      <description>
<p>Use ConvertToLinear to convert the colour space of a bitmap from sRGB to linear RGB.  If the <code>BMF::ALPHA_CHANNEL</code> flag is enabled on the bitmap, pixels with an alpha value of 0 are ignored.</p>
<p>The <fl>ColourSpace</fl> will be set to <code>LINEAR_RGB</code> on completion.  This method returns immediately if the <fl>ColourSpace</fl> is already set to <code>LINEAR_RGB</code>.</p>
<p>For the sake of efficiency, lookup tables are used to quickly perform the conversion process.</p>
      </description>
      <result>
        <error code="Okay">Operation successful.</error>
        <error code="NothingDone">The Bitmap's content is already in linear RGB format.</error>
        <error code="InvalidDimension">The clipping region is invalid.</error>
        <error code="InvalidState">The Bitmap is not in the expected state.</error>
      </result>
    </method>

    <method>
      <name>ConvertToRGB</name>
      <comment>Convert a bitmap's colour space to standard RGB.</comment>
      <prototype>ERR bmp::ConvertToRGB(OBJECTPTR Object)</prototype>
      <description>
<p>Use ConvertToRGB() to convert the colour space of a bitmap from linear RGB to sRGB.  If the <code>BMF::ALPHA_CHANNEL</code> flag is enabled on the bitmap, pixels with an alpha value of 0 are ignored.</p>
<p>The <fl>ColourSpace</fl> will be set to <code>SRGB</code> on completion.  This method returns immediately if the <fl>ColourSpace</fl> is already set to <code>SRGB</code>.</p>
<p>For the sake of efficiency, lookup tables are used to quickly perform the conversion process.</p>
      </description>
      <result>
        <error code="Okay">Operation successful.</error>
        <error code="NothingDone">The bitmap's content is already in sRGB format.</error>
        <error code="InvalidDimension">The clipping region is invalid.</error>
        <error code="InvalidState">The bitmap is not in the expected state.</error>
      </result>
    </method>

    <method>
      <name>CopyArea</name>
      <comment>Copies a rectangular area from one bitmap to another.</comment>
      <prototype>ERR bmp::CopyArea(OBJECTPTR Object, objBitmap * DestBitmap, BAF Flags, INT X, INT Y, INT Width, INT Height, INT XDest, INT YDest)</prototype>
      <input>
        <param type="objBitmap *" name="DestBitmap">The target bitmap.</param>
        <param type="BAF" name="Flags" lookup="BAF">Optional flags.</param>
        <param type="INT" name="X">The horizontal position of the area to be copied.</param>
        <param type="INT" name="Y">The vertical position of the area to be copied.</param>
        <param type="INT" name="Width">The width of the area.</param>
        <param type="INT" name="Height">The height of the area.</param>
        <param type="INT" name="XDest">The horizontal position to copy the area to.</param>
        <param type="INT" name="YDest">The vertical position to copy the area to.</param>
      </input>
      <description>
<p>This method is a proxy for <function module="Display">CopyArea</function>.</p>
      </description>
      <result>
        <error code="Okay">Operation successful.</error>
        <error code="Mismatch">The target bitmap is not a close enough match to the source bitmap in order to perform the operation.</error>
        <error code="NullArgs">Function call missing argument value(s)</error>
      </result>
    </method>

    <method>
      <name>Decompress</name>
      <comment>Decompresses a compressed bitmap.</comment>
      <prototype>ERR bmp::Decompress(OBJECTPTR Object, INT RetainData)</prototype>
      <input>
        <param type="INT" name="RetainData">Retains the compression data if <code>true</code>.</param>
      </input>
      <description>
<p>The Decompress() method is used to restore a compressed bitmap to its original state.  If the bitmap is not compressed, the method does nothing.</p>
<p>The compressed data will be terminated unless <code>RetainData</code> is <code>true</code>.  Retaining the data will allow the client to repeatedly restore the content of the most recent <method>Compress</method> call.</p>
      </description>
      <result>
        <error code="Okay">Operation successful.</error>
        <error code="AllocMemory">Insufficient memory in recreating the bitmap data buffer.</error>
      </result>
    </method>

    <method>
      <name>Demultiply</name>
      <comment>Reverses the conversion process performed by Premultiply().</comment>
      <prototype>ERR bmp::Demultiply(OBJECTPTR Object)</prototype>
      <description>
<p>Use Demultiply() to normalise RGB values that have previously been converted by <method>Premultiply</method>.  This method will return immediately if the bitmap values are already normalised, as determined by the presence of the <code>PREMUL</code> value in <fl>Flags</fl>.</p>
      </description>
      <result>
        <error code="Okay">Operation successful.</error>
        <error code="NothingDone">The content is already normalised.</error>
        <error code="InvalidDimension">The clipping region is invalid.</error>
        <error code="InvalidState">The Bitmap is not in the expected state (32-bit with an alpha channel).</error>
      </result>
    </method>

    <method>
      <name>DrawRectangle</name>
      <comment>Draws rectangles, both filled and unfilled.</comment>
      <prototype>ERR bmp::DrawRectangle(OBJECTPTR Object, INT X, INT Y, INT Width, INT Height, UINT Colour, BAF Flags)</prototype>
      <input>
        <param type="INT" name="X">The left-most coordinate of the rectangle.</param>
        <param type="INT" name="Y">The top-most coordinate of the rectangle.</param>
        <param type="INT" name="Width">The width of the rectangle.</param>
        <param type="INT" name="Height">The height of the rectangle.</param>
        <param type="UINT" name="Colour">The colour index to use for the rectangle.</param>
        <param type="BAF" name="Flags" lookup="BAF">Supports <code>FILL</code> and <code>BLEND</code>.</param>
      </input>
      <description>
<p>This method draws both filled and unfilled rectangles.  The rectangle is drawn to the target bitmap at position <code>(X, Y)</code> with dimensions determined by the specified <code>Width</code> and <code>Height</code>.  If the <code>Flags</code> parameter sets the <code>FILL</code> flag then the rectangle will be filled, otherwise the rectangle's outline will be drawn.  The colour of the rectangle is determined by the pixel value in the <code>Colour</code> parameter.</p>
      </description>
      <result>
        <error code="Okay">Operation successful.</error>
        <error code="Args">Invalid arguments passed to function.</error>
      </result>
    </method>

    <method>
      <name>GetColour</name>
      <comment>Converts Red, Green, Blue components into a single colour value.</comment>
      <prototype>ERR bmp::GetColour(OBJECTPTR Object, INT Red, INT Green, INT Blue, INT Alpha, UINT * Colour)</prototype>
      <input>
        <param type="INT" name="Red">Red component from 0 - 255.</param>
        <param type="INT" name="Green">Green component from 0 - 255.</param>
        <param type="INT" name="Blue">Blue component value from 0 - 255.</param>
        <param type="INT" name="Alpha">Alpha component value from 0 - 255.</param>
        <param type="UINT *" name="Colour">The resulting colour value will be returned here.</param>
      </input>
      <description>
<p>The GetColour() method is used to convert <code>Red</code>, <code>Green</code>, <code>Blue</code> and <code>Alpha</code> colour components into a single colour index that can be used for directly writing colours to the bitmap.  The result is returned in the <code>Colour</code> parameter.</p>
      </description>
      <result>
        <error code="Okay">Operation successful.</error>
        <error code="NullArgs">Function call missing argument value(s)</error>
      </result>
    </method>

    <method>
      <name>Premultiply</name>
      <comment>Premultiplies RGB channel values by the alpha channel.</comment>
      <prototype>ERR bmp::Premultiply(OBJECTPTR Object)</prototype>
      <description>
<p>Use Premultiply() to convert all RGB values in the bitmap's clipping region to pre-multiplied values.  The exact formula applied per channel is <code>(Colour * Alpha + 0xff)&gt;&gt;8</code>.  The alpha channel is not affected.</p>
<p>This method will only operate on 32 bit bitmaps, and an alpha channel must be present.  If the RGB values are already pre-multiplied, the method returns immediately.</p>
<p>The process can be reversed with a call to <method>Demultiply</method>.</p>
      </description>
      <result>
        <error code="Okay">Operation successful.</error>
        <error code="NothingDone">The content is already premultiplied.</error>
        <error code="InvalidDimension">The clipping region is invalid.</error>
        <error code="InvalidState">The Bitmap is not in the expected state (32-bit with an alpha channel)</error>
      </result>
    </method>

    <method>
      <name>SetClipRegion</name>
      <comment>Sets a clipping region for a bitmap object.</comment>
      <prototype>ERR bmp::SetClipRegion(OBJECTPTR Object, INT Number, INT Left, INT Top, INT Right, INT Bottom, INT Terminate)</prototype>
      <input>
        <param type="INT" name="Number">The number of the clip region to set.</param>
        <param type="INT" name="Left">The horizontal start of the clip region.</param>
        <param type="INT" name="Top">The vertical start of the clip region.</param>
        <param type="INT" name="Right">The right-most edge of the clip region.</param>
        <param type="INT" name="Bottom">The bottom-most edge of the clip region.</param>
        <param type="INT" name="Terminate">Set to <code>true</code> if this is the last clip region in the list, otherwise <code>false</code>.</param>
      </input>
      <description>
<p>This method is a proxy for <function module="Display">SetClipRegion</function>.</p>
      </description>
      <result>
        <error code="Okay">Operation successful.</error>
        <error code="NullArgs">Function call missing argument value(s)</error>
      </result>
    </method>

  </methods>

  <fields>
    <field>
      <name>AmtColours</name>
      <comment>The maximum number of displayable colours.</comment>
      <access read="R" write="I">Read/Init</access>
      <type>INT</type>
    </field>

    <field>
      <name>BitsPerPixel</name>
      <comment>The number of bits per pixel</comment>
      <access read="R" write="I">Read/Init</access>
      <type>INT</type>
      <description>
<p>The BitsPerPixel field clarifies exactly how many bits are being used to manage each pixel on the display.  This includes any 'special' bits that are in use, e.g. alpha-channel bits.</p>
      </description>
    </field>

    <field>
      <name>Bkgd</name>
      <comment>The bitmap's background colour is defined here in RGB format.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>RGB8</type>
      <description>
<p>The default background colour for a bitmap is black.  To change it, set this field with the new RGB colour.  The background colour is used in operations that require a default colour, such as when clearing the bitmap.</p>
<p>The <fl>BkgdIndex</fl> will be updated as a result of setting this field.</p>
      </description>
    </field>

    <field>
      <name>BkgdIndex</name>
      <comment>The bitmap's background colour is defined here as a colour index.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>INT</type>
      <description>
<p>The bitmap's background colour is defined in this field as a colour index.  It is recommended that the <fl>Bkgd</fl> field is used for altering the bitmap background unless efficiency requires that the colour index is calculated and set directly.</p>
      </description>
    </field>

    <field>
      <name>BlendMode</name>
      <comment>Defines the blending algorithm to use when rendering transparent pixels.</comment>
      <access read="R" write="W">Read/Write</access>
      <type lookup="BLM">BLM</type>
      <description>
<p>The BlendMode field defines the blending algorithm to use when rendering transparent pixels.  The default value is <code>AUTO</code> which will use the best blending algorithm available for the current graphics context.</p>
<types lookup="BLM"/>
      </description>
    </field>

    <field>
      <name>ByteWidth</name>
      <comment>The width of the bitmap, in bytes.</comment>
      <access read="R">Read</access>
      <type>INT</type>
      <description>
<p>The ByteWidth of the bitmap is calculated directly from the bitmap's <fl>Width</fl> and <fl>Type</fl> settings. Under no circumstances should you attempt to calculate this value in advance, as it is heavily dependent on the bitmap's <fl>Type</fl>.</p>
<p>The formulas used to calculate the value of this field are:</p>
<pre>Planar      = Width/8
Chunky/8    = Width
Chunky/15   = Width * 2
Chunky/16   = Width * 2
Chunky/24   = Width * 3
Chunky/32   = Width * 4
</pre>
<p>To learn the total byte-width per line including any additional padded bytes, refer to the <fl>LineWidth</fl> field.</p>
      </description>
    </field>

    <field>
      <name>BytesPerPixel</name>
      <comment>The number of bytes per pixel.</comment>
      <access read="R" write="I">Read/Init</access>
      <type>INT</type>
      <description>
<p>This field reflects the number of bytes used to construct one pixel.  The maximum number of bytes a client can typically expect is 4 and the minimum is 1.  If the graphics type is planar then refer to the <fl>BitsPerPixel</fl> field, which should yield more useful information.</p>
      </description>
    </field>

    <field>
      <name>Clip</name>
      <comment>Defines the bitmap's clipping region.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>struct ClipRectangle</type>
      <description>
<p>The Clip field is a short-hand reference for the <fl>ClipLeft</fl>, <fl>ClipTop</fl>, <fl>ClipRight</fl> and <fl>ClipBottom</fl> fields, returning all four values as a single <st>ClipRectangle</st> structure.</p>
      </description>
    </field>

    <field>
      <name>ClipBottom</name>
      <comment>The bottom-most edge of  bitmap's clipping region.</comment>
      <access read="R" write="W">Read/Write</access>
      <type>INT</type>
      <description>
<p>During the initialisation of a bitmap, a default clipping region will be created that matches the bitmap's dimensions. Clipping regions define the area under which graphics can be drawn to a bitmap.  This particular field reflects the bottom-most edge of all clipping regions that have been set or altered through the <method>SetClipRegion</method> method.</p>
      </description>
    </field>

    <field>
      <name>ClipLeft</name>
      <comment>The left-most edge of a bitmap's clipping region.</comment>
      <access read="R" write="W">Read/Write</access>
      <type>INT</type>
      <description>
<p>During the initialisation of a bitmap, a default clipping region will be created that matches the bitmap's dimensions. Clipping regions define the area under which graphics can be drawn to a bitmap.  This particular field reflects the left-most edge of all clipping regions that have been set or altered through the <method>SetClipRegion</method> method.</p>
      </description>
    </field>

    <field>
      <name>ClipRight</name>
      <comment>The right-most edge of a bitmap's clipping region.</comment>
      <access read="R" write="W">Read/Write</access>
      <type>INT</type>
      <description>
<p>During the initialisation of a bitmap, a default clipping region will be created that matches the bitmap's dimensions. Clipping regions define the area under which graphics can be drawn to a bitmap.  This particular field reflects the right-most edge of all clipping regions that have been set or altered through the <method>SetClipRegion</method> method.</p>
      </description>
    </field>

    <field>
      <name>ClipTop</name>
      <comment>The top-most edge of a bitmap's clipping region.</comment>
      <access read="R" write="W">Read/Write</access>
      <type>INT</type>
      <description>
<p>During the initialisation of a bitmap, a default clipping region will be created that matches the bitmap's dimensions. Clipping regions define the area under which graphics can be drawn to a bitmap.  This particular field reflects the top-most edge of all clipping regions that have been set or altered through the <method>SetClipRegion</method> method.</p>
      </description>
    </field>

    <field>
      <name>ColourFormat</name>
      <comment>Describes the colour format used to construct each bitmap pixel.</comment>
      <access read="R">Read</access>
      <type>struct ColourFormat *</type>
      <description>
<p>The ColourFormat field points to a structure that defines the colour format used to construct each bitmap pixel.  It only applies to bitmaps that use 2-bytes per colour value or better.  The structure consists of the following fields:</p>
<struct lookup="ColourFormat"/>
<p>The following C++ methods can called on any bitmap in order to build colour values from individual RGB components:</p>
<pre>packPixel(Red, Green, Blue)
packPixel(Red, Green, Blue, Alpha)
packAlpha(Alpha)
packPixelRGB(RGB8 &amp;RGB)
packPixelRGBA(RGB8 &amp;RGB)
</pre>
<p>The following C macros are optimised versions of the above that are limited to 24 and 32-bit bitmaps:</p>
<pre>PackPixelWB(Red, Green, Blue)
PackPixelWBA(Red, Green, Blue, Alpha)
</pre>
<p>The following C++ methods can be used to unpack individual colour components from any colour value read from the bitmap:</p>
<pre>unpackRed(Colour)
unpackGreen(Colour)
unpackBlue(Colour)
unpackAlpha(Colour)
</pre>
      </description>
    </field>

    <field>
      <name>ColourSpace</name>
      <comment>Defines the colour space for RGB values.</comment>
      <access read="R" write="W">Read/Write</access>
      <type lookup="CS">CS</type>
      <description>
<types lookup="CS"/>
      </description>
    </field>

    <field>
      <name>Data</name>
      <comment>Pointer to a bitmap's data area.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>UBYTE *</type>
      <description>
<p>This field points directly to the start of a bitmap's data area.  Allocating your own bitmap memory is acceptable if creating a bitmap that is not based on video memory.  However, it is usually a better idea for the initialisation process to allocate the correct amount of memory for you by not interfering with this field.</p>
      </description>
    </field>

    <field>
      <name>DataFlags</name>
      <comment>Defines the memory flags to use in allocating a bitmap's data area.</comment>
      <access read="R" write="I">Read/Init</access>
      <type lookup="MEM">MEM</type>
      <description>
<p>This field determines the type of memory that will be allocated for the <fl>Data</fl> field during the initialisation process. This field accepts the <code>MEM::DATA</code>, <code>MEM::VIDEO</code> and <code>MEM::TEXTURE</code> memory flags.</p>
<p>Please note that video based bitmaps may be faster than data bitmaps for certain applications, but the content is typically read-only.  Under normal circumstances it is not possible to use the pixel reading functions, or read from the bitmap <fl>Data</fl> field directly with these bitmap types.  To circumvent this problem use the <action>Lock</action> action to enable read access when you require it.</p>
<types lookup="MEM"/>
      </description>
    </field>

    <field>
      <name>DrawUCPixel</name>
      <comment>Points to a C function that draws pixels to the bitmap using colour indexes.</comment>
      <access read="R">Read</access>
      <type prototype="void (*DrawUCPixel)(objBitmap *, LONG, LONG, ULONG)">FUNCTION *</type>
      <description>
<p>This field points to an internal C function that can be used for drawing pixels to the bitmap.  It is intended that the function is only ever called by C programs and that caution is exercised by the programmer, as no clipping checks will be performed (meaning it is possible to supply invalid coordinates that would result in a segfault).</p>
<p>The prototype of the DrawUCPixel function is <code>Function(*Bitmap, LONG X, LONG Y, uint32_t Colour)</code>.</p>
<p>The new pixel value must be defined in the <code>Colour</code> parameter.</p>
      </description>
    </field>

    <field>
      <name>DrawUCRIndex</name>
      <comment>Points to a C function that draws pixels to the bitmap in RGB format.</comment>
      <access read="R">Read</access>
      <type prototype="void (*DrawUCRIndex)(objBitmap *, UBYTE *, struct RGB8 *)">FUNCTION *</type>
      <description>
<p>This field points to an internal C function that can be used for drawing pixels to the bitmap.  It is intended that the function is only ever called by C programs and that caution is exercised by the programmer, as no clipping checks will be performed (meaning it is possible to supply an invalid address that would result in a segfault).</p>
<p>The prototype of the DrawUCRIndex function is <code>Function(*Bitmap, uint8_t *Data, RGB8 *RGB)</code>.</p>
<p>The Data parameter must point to a location within the Bitmap's graphical address space. The new pixel value must be defined in the <code>RGB</code> parameter.</p>
<p>Note that a colour indexing equivalent of this function is not available in the Bitmap class - this is because it is more efficient to index the Bitmap's <fl>Data</fl> field directly.</p>
      </description>
    </field>

    <field>
      <name>DrawUCRPixel</name>
      <comment>Points to a C function that draws pixels to the bitmap in RGB format.</comment>
      <access read="R">Read</access>
      <type prototype="void (*DrawUCRPixel)(objBitmap *, LONG, LONG, struct RGB8 *)">FUNCTION *</type>
      <description>
<p>This field points to an internal C function that can be used for drawing pixels to the bitmap.  It is intended that the function is only ever called by C programs and that caution is exercised by the programmer, as no clipping checks will be performed (meaning it is possible to supply invalid coordinates that would result in a segfault).</p>
<p>The prototype of the DrawUCRPixel function is <code>Function(*Bitmap, LONG X, LONG Y, RGB8 *RGB)</code>.</p>
<p>The new pixel value must be defined in the <code>RGB</code> parameter.</p>
      </description>
    </field>

    <field>
      <name>Flags</name>
      <comment>Optional flags.</comment>
      <access read="R" write="I">Read/Init</access>
      <type lookup="BMF">BMF</type>
      <description>
<types lookup="BMF"/>
      </description>
    </field>

    <field>
      <name>Height</name>
      <comment>The height of the bitmap, in pixels.</comment>
      <access read="R" write="I">Read/Init</access>
      <type>INT</type>
    </field>

    <field>
      <name>LineWidth</name>
      <comment>The length of each bitmap line in bytes, including alignment.</comment>
      <access read="R">Read</access>
      <type>INT</type>
    </field>

    <field>
      <name>Opacity</name>
      <comment>Determines the translucency setting to use in drawing operations.</comment>
      <access read="R" write="W">Read/Write</access>
      <type>INT</type>
      <description>
<p>Some drawing operations support the concept of applying an opacity rating to create translucent graphics.  By adjusting the opacity rating, you can affect the level of translucency that is applied when executing certain graphics operations.</p>
<p>Methods that support opacity should document the fact that they support the feature.  By default the opacity rating is set to 255 to turn off translucency effects.  Lowering the value will increase the level of translucency when drawing graphics.</p>
      </description>
    </field>

    <field>
      <name>Palette</name>
      <comment>Points to a bitmap's colour palette.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>struct RGBPalette *</type>
      <description>
<p>A palette is an array of containing colour values in standard RGB format <code>0xRRGGBB</code>.  The first value must have a header ID of <code>ID_PALETTE</code>, followed by the amount of values in the array. Following this is the actual list itself - colour 0, then colour 1 and so on. There is no termination signal at the end of the list.</p>
<p>The following example is for a 32 colour palette:</p>
<pre>RGBPalette Palette = {
  ID_PALETTE, VER_PALETTE, 32,
  {{ 0x00,0x00,0x00 }, { 0x10,0x10,0x10 }, { 0x17,0x17,0x17 }, { 0x20,0x20,0x20 },
   { 0x27,0x27,0x27 }, { 0x30,0x30,0x30 }, { 0x37,0x37,0x37 }, { 0x40,0x40,0x40 },
   { 0x47,0x47,0x47 }, { 0x50,0x50,0x50 }, { 0x57,0x57,0x57 }, { 0x60,0x60,0x60 },
   { 0x67,0x67,0x67 }, { 0x70,0x70,0x70 }, { 0x77,0x77,0x77 }, { 0x80,0x80,0x80 },
   { 0x87,0x87,0x87 }, { 0x90,0x90,0x90 }, { 0x97,0x97,0x97 }, { 0xa0,0xa0,0xa0 },
   { 0xa7,0xa7,0xa7 }, { 0xb0,0xb0,0xb0 }, { 0xb7,0xb7,0xb7 }, { 0xc0,0xc0,0xc0 },
   { 0xc7,0xc7,0xc7 }, { 0xd0,0xd0,0xd0 }, { 0xd7,0xd7,0xd7 }, { 0xe0,0xe0,0xe0 },
   { 0xe0,0xe0,0xe0 }, { 0xf0,0xf0,0xf0 }, { 0xf7,0xf7,0xf7 }, { 0xff,0xff,0xff }
   }
};
</pre>
<p>Palettes are created for all bitmap types, including RGB based bitmaps above 8-bit colour.  This is because a number of drawing functions require a palette table for conversion between the bitmap types.</p>
<p>Although the array is dynamic, parent objects such as the Display need to be notified if you want a palette's colours to be propagated to the video display.</p>
      </description>
    </field>

    <field>
      <name>PlaneMod</name>
      <comment>The differential between each bitmap plane.</comment>
      <access read="R">Read</access>
      <type>INT</type>
      <description>
<p>This field specifies the distance (in bytes) between each bitplane.  For non-planar types like <code>CHUNKY</code>, this field will reflect the total size of the bitmap.  The calculation used for <code>PLANAR</code> types is <code>ByteWidth * Height</code>.</p>
      </description>
    </field>

    <field>
      <name>Position</name>
      <comment>The current read/write data position.</comment>
      <access read="R">Read</access>
      <type>INT</type>
      <description>
<p>This field reflects the current byte position for reading and writing raw data to and from a bitmap object.  If you need to change the current byte position, use the Seek action.</p>
      </description>
    </field>

    <field>
      <name>ReadUCPixel</name>
      <comment>Points to a C function that reads pixels from the bitmap in colour index format.</comment>
      <access read="R">Read</access>
      <type prototype="ULONG (*ReadUCPixel)(objBitmap *, LONG, LONG)">FUNCTION *</type>
      <description>
<p>This field points to an internal C function that can be used for reading pixels from the bitmap.  It is intended that the function is only ever called by C programs and that caution is exercised by the programmer, as no clipping checks will be performed (meaning it is possible to supply invalid X/Y coordinates that would result in a segfault).</p>
<p>The prototype of the ReadUCPixel function is <code>Function(*Bitmap, LONG X, LONG Y, LONG *Index)</code>.</p>
<p>The pixel value will be returned in the <code>Index</code> parameter.</p>
      </description>
    </field>

    <field>
      <name>ReadUCRIndex</name>
      <comment>Points to a C function that reads pixels from the bitmap in RGB format.</comment>
      <access read="R">Read</access>
      <type prototype="void (*ReadUCRIndex)(objBitmap *, UBYTE *, struct RGB8 *)">FUNCTION *</type>
      <description>
<p>This field points to an internal C function that can be used for reading pixels from the bitmap.  It is intended that the function is only ever called by C programs and that caution is exercised by the programmer, as no clipping checks will be performed (meaning it is possible to supply an invalid address that would result in a segfault).</p>
<p>The prototype of the ReadUCRIndex function is <code>Function(*Bitmap, uint8_t *Data, RGB8 *RGB)</code>.</p>
<p>The <code>Data</code> parameter must point to a location within the Bitmap's graphical address space. The pixel value will be returned in the <code>RGB</code> parameter.</p>
<p>Note that a colour indexing equivalent of this function is not available in the Bitmap class - this is because it is more efficient to index the Bitmap's <fl>Data</fl> field directly.</p>
      </description>
    </field>

    <field>
      <name>ReadUCRPixel</name>
      <comment>Points to a C function that reads pixels from the bitmap in RGB format.</comment>
      <access read="R">Read</access>
      <type prototype="void (*ReadUCRPixel)(objBitmap *, LONG, LONG, struct RGB8 *)">FUNCTION *</type>
      <description>
<p>This field points to an internal C function that can be used for reading pixels from the bitmap.  It is intended that the function is only ever called by C programs and that caution is exercised by the programmer, as no clipping checks will be performed (meaning it is possible to supply invalid X/Y coordinates that would result in a segfault).</p>
<p>The prototype of the ReadUCRPixel function is <code>Function(*Bitmap, LONG X, LONG Y, RGB8 *RGB)</code>.</p>
<p>The pixel value will be returned in the RGB parameter.  It should be noted that as this function converts the pixel value into RGB format, <fl>ReadUCPixel</fl> or <fl>ReadUCRIndex</fl> should be used as faster alternatives if the pixel value does not need to be de-constructed into its RGB components.</p>
      </description>
    </field>

    <field>
      <name>Size</name>
      <comment>The total size of the bitmap, in bytes.</comment>
      <access read="R">Read</access>
      <type>INT</type>
    </field>

    <field>
      <name>TransColour</name>
      <comment>The transparent colour of the bitmap, in RGB format.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>RGB8</type>
      <description>
<p>The transparent colour of the bitmap is defined here.  Colours in the bitmap that match this value will not be copied during drawing operations.</p>
<p>NOTE: This field should never be set if the bitmap utilises alpha transparency.</p>
      </description>
    </field>

    <field>
      <name>TransIndex</name>
      <comment>The transparent colour of the bitmap, represented as an index.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>INT</type>
      <description>
<p>The transparent colour of the bitmap is defined here.  Colours in the bitmap that match this value will not be copied during graphics operations.  It is recommended that the <fl>TransColour</fl> field is used for altering the bitmap transparency unless efficiency requires that the transparency is set directly.</p>
<p>NOTE: This field should never be set if the bitmap utilises alpha transparency.</p>
      </description>
    </field>

    <field>
      <name>Type</name>
      <comment>Defines the data type of the bitmap.</comment>
      <access read="R" write="I">Read/Init</access>
      <type lookup="BMP">BMP</type>
      <description>
<p>This field defines the graphics data type - either <code>PLANAR</code> (required for 1-bit bitmaps) or <code>CHUNKY</code> (the default).</p>
<types lookup="BMP"/>
      </description>
    </field>

    <field>
      <name>Width</name>
      <comment>The width of the bitmap, in pixels.</comment>
      <access read="R" write="I">Read/Init</access>
      <type>INT</type>
    </field>

  </fields>
  <types>
    <constants lookup="BAF" comment="Instructions for basic graphics operations.">
      <const name="BLEND">Enable alpha blending to the destination if the source supports an alpha channel.</const>
      <const name="COPY">Special <function module="Display">CopyArea</function> option that avoids blending when the destination pixel is empty.</const>
      <const name="DITHER">Perform dithering if the colour formats differ between the source and destination.</const>
      <const name="FILL">For primitive operations such as <function module="Display">DrawRectangle</function>, this will fill the shape with a solid colour or texture.</const>
      <const name="LINEAR">Use linear interpolation to improve the quality of alpha blending.</const>
    </constants>

    <constants lookup="BLM" comment="Defines the blending algorithm to use when transparent pixels are rendered to the bitmap.">
      <const name="AUTO">Use the most suitable of the available algorithms.</const>
      <const name="GAMMA">Use gamma correct blending.  This algorithm is slow but produces a high quality result.</const>
      <const name="LINEAR">Use linear blending.  Applicable if the bitmap is in linear colour space.</const>
      <const name="NONE">Never blend transparent pixels, just copy as-is.</const>
      <const name="SRGB">Use sRGB linear blending.  This algorithm is extremely efficient but produces poor quality results.</const>
    </constants>

    <constants lookup="BMF" comment="Bitmap flags">
      <const name="ACCELERATED_2D">2D video acceleration is available.</const>
      <const name="ACCELERATED_3D">3D video acceleration is available.</const>
      <const name="ALPHA_CHANNEL">For 32-bit images, indicates that an alpha channel is present.</const>
      <const name="BLANK_PALETTE">Forces a blank/black palette on initialisation.</const>
      <const name="CLEAR">Clear graphics on initialisation and when resizing.</const>
      <const name="COMPRESSED">The bitmap data is compressed.</const>
      <const name="FIXED_DEPTH">Prevent changing of bitmap depth after initialisation (e.g. via <code>Resize()</code>).</const>
      <const name="INVERSE_ALPHA">Indicates reverse alpha blending, higher values are transparent.</const>
      <const name="MASK">Declare the <class name="Bitmap">Bitmap</class> as a 1 or 8 bit mask.  Must be set in conjunction with the <class name="Bitmap" field="BitsPerPixel">Bitmap.BitsPerPixel</class> field on initialisation.</const>
      <const name="NEVER_SHRINK">Ignore resize requests that would shrink the size of the bitmap.</const>
      <const name="NO_DATA">Do not allocate memory in the Data field on initialisation.</const>
      <const name="PREMUL">The RGB values are premultiplied (32-bit only).</const>
      <const name="QUERIED">Automatically set after a <code>Query()</code> on the bitmap.</const>
      <const name="TRANSPARENT">Indicates that the bitmap utilises a transparent colour.  This is automatically set if the <class name="Bitmap" field="TransIndex">Bitmap.TransIndex</class> or <class name="Bitmap" field="TransColour">Bitmap.TransColour</class> is defined, and support exists in functions such as <function module="Display">CopyArea</function>.</const>
      <const name="USER">This user flag can be used to tag bitmaps with special meaning.  Not used internally.</const>
    </constants>

    <constants lookup="BMP" comment="Bitmap types">
      <const name="CHUNKY">Chunky pixel mode (default).</const>
      <const name="PLANAR">Planar pixel mode separates pixel bits across multiple planes.  Commonly used for single bit bitmap masks.</const>
    </constants>

    <constants lookup="CS" comment="Colour space options.">
      <const name="CIE_LAB">Cartesian L*a*b* colour space defined by CIE 15.</const>
      <const name="CIE_LCH">Polar L*CHab colour space defined by CIE 15.</const>
      <const name="LINEAR_RGB">Linear RGB is used to improve colour balance in blending operations.</const>
      <const name="SRGB">The default colour-space is sRGB.</const>
    </constants>

  </types>
  <structs>
    <struct name="ColourFormat" typeName="COLOURFORMAT">
      <field name="RedShift" type="UBYTE">Right shift value for red (15/16 bit formats only)</field>
      <field name="GreenShift" type="UBYTE">Right shift value for green</field>
      <field name="BlueShift" type="UBYTE">Right shift value for blue</field>
      <field name="AlphaShift" type="UBYTE">Right shift value for alpha</field>
      <field name="RedMask" type="UBYTE">Unshifted mask value for red (ranges from 0x00 to 0xff)</field>
      <field name="GreenMask" type="UBYTE">Unshifted mask value for green</field>
      <field name="BlueMask" type="UBYTE">Unshifted mask value for blue</field>
      <field name="AlphaMask" type="UBYTE">Unshifted mask value for alpha</field>
      <field name="RedPos" type="UBYTE">Left shift/positional value for red</field>
      <field name="GreenPos" type="UBYTE">Left shift/positional value for green</field>
      <field name="BluePos" type="UBYTE">Left shift/positional value for blue</field>
      <field name="AlphaPos" type="UBYTE">Left shift/positional value for alpha</field>
      <field name="BitsPerPixel" type="UBYTE">Number of bits per pixel for this format.</field>
    </struct>

  </structs>
</book>
