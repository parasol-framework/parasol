<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="class.xsl"?>

<book>
  <info>
    <name>XML</name>
    <type>class</type>
    <module>XML</module>
    <comment>Provides an interface for the management of structured data.</comment>
    <fileExtension>*.xml</fileExtension>
    <fileDescription>Extendable Markup Language (XML)</fileDescription>
    <version>1</version>
    <id>0b88bfd6</id>
    <idstring>XML</idstring>
    <category>Data</category>
    <copyright>Paul Manias Â© 2001-2025</copyright>
    <description>
<p>The XML class is designed to provide robust functionality for creating, parsing and maintaining XML data structures. It supports both well-formed and loosely structured XML documents, offering flexible parsing behaviours to accommodate various XML formats.  The class includes comprehensive support for XPath 2.0 queries, content manipulation and document validation.</p>
<p>The class has been designed in such a way as to accommodate other structured data formats such as JSON and YAML.  In this way, the class not only provides XML support but also serves as Parasol's general-purpose structured data handler.  It also makes it trivial to convert between different structured data formats, and benefit from the cross-application use of features, such as applying XPath 2.0 queries on data originating from YAML.</p>
<header>Data Loading and Parsing</header>
<p>XML documents can be loaded into an XML object through multiple mechanisms:</p>
<p>The <fl>Path</fl> field allows loading from file system sources, with automatic parsing upon initialisation.  The class supports <function module="Core">LoadFile</function> caching for frequently accessed files, improving performance for repeated operations.</p>
<p>The <fl>Statement</fl> field enables direct parsing of XML strings, supporting dynamic content processing and in-memory document construction.</p>
<p>The <fl>Source</fl> field provides object-based input, allowing XML data to be sourced from any object supporting the Read action.</p>
<p>For batch processing scenarios, the <fl>Path</fl> or <fl>Statement</fl> fields can be changed post-initialisation, causing the XML object to clear old data and parse the new.  This approach optimises memory usage by reusing existing object instances rather than creating new ones.</p>
<header>Document Structure and Access</header>
<p>Successfully parsed XML data is accessible through the <fl>Tags</fl> field, which contains a hierarchical array of <st>XMLTag</st> structures.  Each XMLTag represents a complete XML element including its attributes, content and child elements. The structure maintains the original document hierarchy, enabling both tree traversal and direct element access.</p>
<p>C++ developers benefit from direct access to the Tags field, represented as <code>pf::vector&lt;XMLTag&gt;</code>.  This provides efficient iteration and element access with standard STL semantics.  Altering tag attributes is permitted and methods to do so are provided in the C++ header for <code>objXML</code> and <code>XMLTag</code>, with additional functions in the <code>xml</code> namespace. Check the header for details.</p>
<p>Fluid developers need to be aware that reading the <fl>Tags</fl> field generates a copy of the entire tag structure - it should therefore be read only as needed and cached until the XML object is modified.</p>
<header>Not Supported</header>
<p>DTD processing and validation is intentionally not supported.  While the class can parse DOCTYPE declarations, it does not load or  validate against external DTDs as this is now a legacy technology.  Use XML Schema (XSD) for validation instead.</p></description>
    <source>
      <file>xml_class.cpp</file>
    </source>
  </info>

  <actions>
    <action>
      <name>Clear</name>
      <comment>Completely clears all XML data and resets the object to its initial state.</comment>
      <prototype>ERR acClear(*Object)</prototype>
      <description>
<p>The Clear action removes all parsed XML content from the object, including the complete tag hierarchy, cached data structures and internal state information.  This action effectively returns the XML object to its freshly-initialised condition, ready to accept new XML data.</p>
      </description>
    </action>

    <action>
      <name>DataFeed</name>
      <comment>Processes and integrates external XML data into the object's document structure.</comment>
      <prototype>ERR acDataFeed(*Object, OBJECTID Object, DATA Datatype, APTR Buffer, INT Size)</prototype>
      <input>
        <param type="OBJECTID" name="Object">Must refer to the unique ID of the object that you represent. If you do not represent an object, set this parameter to the current task ID.</param>
        <param type="DATA" name="Datatype" lookup="DATA">The type of data being sent.</param>
        <param type="APTR" name="Buffer">The data being sent to the target object.</param>
        <param type="INT" name="Size">The size of the data in Buffer.</param>
      </input>
      <description>
<p>The DataFeed action provides a mechanism for supplying XML content to the object from external sources or streaming data.  This action supports both complete document replacement and incremental content addition, depending on the current state of the XML object.</p>
<p>The action accepts data in XML or plain text format and automatically performs parsing and integration.  When the object contains no existing content, the provided data becomes the complete document structure.  If the object already contains parsed XML, the new data is parsed separately and appended to the existing tag hierarchy.</p>
<p>If the provided data contains malformed XML or cannot be parsed according to the current validation settings, the action will return appropriate error codes without modifying the existing document structure.  This ensures that partial parsing failures do not corrupt previously loaded content.</p>
<p>Attempts to feed data into a read-only XML object will be rejected to maintain document integrity.</p>
<p>Example:</p>
<code>
local xml = obj.new('xml')
local err = xml.acDataFeed(nil, DATA_XML, '<first>First element</first>')
</code>
      </description>
    </action>

    <action>
      <name>GetKey</name>
      <comment>Retrieves data using XPath 2.0 queries.</comment>
      <prototype>ERR acGetKey(*Object, CSTRING Key, STRING Value, INT Size)</prototype>
      <input>
        <param type="CSTRING" name="Key">The name of a key value.</param>
        <param type="STRING" name="Value">Pointer to a buffer space large enough to hold the retrieved value.</param>
        <param type="INT" name="Size">Indicates the byte size of the Buffer.</param>
      </input>
      <description>
<p>The XML class uses key-values for the execution of XPath 2.0 queries.  Documentation of the XPath standard is out of the scope for this document, however the following examples illustrate common uses for this query language and a number of special instructions that we support:</p>
<types type="Path">
<type name="/menu/submenu">Return the content of the submenu tag whose parent is the first menu.</type>
<type name="/menu[2]/submenu">Return the content of the submenu tag whose parent is the third menu.</type>
<type name="count(/menu)">Return a count of all menu tags at the root level.</type>
<type name="/menu/window/@title">Return the value of the title attribute from the window tag.</type>
<type name="exists(/menu/@title)">Return <code>1</code> if a menu with a title attribute can be matched, otherwise <code>0</code>.</type>
<type name="exists(/menu/text())">Return <code>1</code> if menu contains content.</type>
<type name="//window">Return content of the first window discovered at any branch of the XML tree (double-slash enables flat scanning of the XML tree).</type>
</types>
      </description>
    </action>

    <action>
      <name>Reset</name>
      <comment>Clears the information held in an XML object.</comment>
      <prototype>ERR acRefresh(*Object)</prototype>
    </action>

    <action>
      <name>SaveToObject</name>
      <comment>Saves XML data to a storage object (e.g. <class name="File">File</class>).</comment>
      <prototype>ERR acSaveToObject(*Object, OBJECTID Dest, CLASSID ClassID)</prototype>
      <input>
        <param type="OBJECTID" name="Dest">Refers to an object that will receive the encoded data.</param>
        <param type="CLASSID" name="ClassID">Can refer to a sub-class that should be used when encoding the data.</param>
      </input>
    </action>

    <action>
      <name>SetKey</name>
      <comment>Sets attributes and content in the XML tree using XPaths.</comment>
      <prototype>ERR acSetKey(*Object, CSTRING Key, CSTRING Value)</prototype>
      <input>
        <param type="CSTRING" name="Key">The name of the target key.</param>
        <param type="CSTRING" name="Value">The string value to associate with Key.</param>
      </input>
      <description>
<p>Use SetKey to add tag attributes and content using XPaths.  The XPath is specified in the <code>Key</code> parameter and the data is specified in the <code>Value</code> parameter.  Setting the Value to <code>NULL</code> will remove the attribute or existing content, while an empty string will keep an attribute but eliminate any associated data.</p>
<p>It is not possible to add new tags using this action - it is only possible to update existing tags.</p>
<p>Please note that making changes to the XML tree will render all previously obtained tag pointers and indexes invalid.</p>
      </description>
      <result>
        <error code="Okay">Operation successful.</error>
        <error code="Search">Failed to find the tag referenced by the XPath.</error>
        <error code="ReadOnly">Changes to the XML structure are not permitted.</error>
      </result>
    </action>

  </actions>

  <methods>
    <method>
      <name>Count</name>
      <comment>Count all tags that match a given XPath expression.</comment>
      <prototype>ERR xml::Count(OBJECTPTR Object, CSTRING XPath, INT * Result)</prototype>
      <input>
        <param type="CSTRING" name="XPath">A valid XPath expression string defining the elements to count.  The expression must conform to XPath 2.0 syntax with Parasol extensions.</param>
        <param type="INT *" name="Result">Pointer to an integer variable that will receive the total count of matching tags.</param>
      </input>
      <description>
<p>This method will count all tags that match a given <code>XPath</code> and return the value in the <code>Result</code> parameter.  It is optimised for performance and does not modify the XML structure in any way.  It is safe to call concurrently from multiple threads.</p>
      </description>
      <result>
        <error code="Okay">The count operation completed successfully.</error>
        <error code="NullArgs">Either the XPath parameter or Result parameter was NULL.</error>
      </result>
    </method>

    <method>
      <name>Evaluate</name>
      <comment>Run an XPath 2.0 or XQuery expression against the XML data.</comment>
      <prototype>ERR xml::Evaluate(OBJECTPTR Object, CSTRING Statement, CSTRING * Result)</prototype>
      <input>
        <param type="CSTRING" name="Statement">An XPath or XQuery string to evaluate.</param>
        <param type="CSTRING *" name="Result">An allocated string from the evaluation is returned here.</param>
      </input>
      <description>
<p>The Evaluate method allows the execution of XPath 2.0 or XQuery expressions against the data contained within the XML object.  This is a lazy execution method that compiles and evaluates the provided expression in a single step, returning the result as a string.  For more complex scenarios or repeated evaluations, consider using the Compile and Evaluate functions in the XPath module.</p>
      </description>
      <result>
        <error code="Okay">Operation successful.</error>
      </result>
    </method>

    <method>
      <name>Filter</name>
      <comment>Filters the XML data structure to retain only a specific tag and its descendants.</comment>
      <prototype>ERR xml::Filter(OBJECTPTR Object, CSTRING XPath)</prototype>
      <input>
        <param type="CSTRING" name="XPath">A valid XPath expression string that identifies the target tag to retain.  The expression must resolve to exactly one element for successful filtering.</param>
      </input>
      <description>
<p>The Filter method provides a mechanism for reducing large XML documents to a specific subtree, permanently removing all content that exists outside the targeted element and its children.  This operation is particularly valuable for performance optimisation when working with large documents where only a specific section is relevant.</p>
<p>The filtering process begins by locating the target element using the provided XPath expression.  Once found, a new XML structure is created containing only the matched tag and its complete descendant hierarchy.  All sibling tags, parent elements (excluding the direct lineage) and unrelated branches are permanently discarded.</p>
      </description>
      <result>
        <error code="Okay">The filtering operation completed successfully and the XML structure now contains only the specified subtree.</error>
        <error code="Search">No matching tag could be found for the specified XPath expression.</error>
        <error code="NullArgs">The XPath parameter was NULL or empty.</error>
      </result>
    </method>

    <method>
      <name>FindTag</name>
      <comment>Searches for XML elements using XPath expressions with optional callback processing.</comment>
      <prototype>ERR xml::FindTag(OBJECTPTR Object, CSTRING XPath, FUNCTION * Callback, INT * Result)</prototype>
      <input>
        <param type="CSTRING" name="XPath">A valid XPath expression string conforming to XPath 2.0 syntax with Parasol extensions.  Must not be NULL or empty.</param>
        <param type="FUNCTION *" name="Callback">Optional pointer to a callback function for processing multiple matches.</param>
        <param type="INT *" name="Result">Pointer to an integer that will receive the unique ID of the first matching tag.  Only valid when no callback is provided.</param>
      </input>
      <description>
<p>The FindTag method provides the primary mechanism for locating XML elements within the document structure using XPath 2.0 compatible expressions.  The method supports both single-result queries and comprehensive tree traversal with callback-based processing for complex operations.</p>
<p>When no callback function is provided, FindTag returns the first matching element and terminates the search immediately.  This is optimal for simple queries where only the first occurrence is required.</p>
<p>When a callback function is specified, FindTag continues searching through the entire document structure, calling the provided function for each matching element.  This enables comprehensive processing of all matching elements in a single traversal.</p>
<p>The C++ prototype for Callback is <code>ERR Function(*XML, XMLTag &amp;Tag, CSTRING Attrib)</code>.</p>
<p>The callback should return <code>ERR::Okay</code> to continue processing, or <code>ERR::Terminate</code> to halt the search immediately. All other error codes are ignored to maintain search robustness.</p>
<p>Note: If an error occurs, check the <fl>ErrorMsg</fl> field for a custom error message containing further details.</p>
      </description>
      <result>
        <error code="Okay">A matching tag was found (or callback processing completed successfully).</error>
        <error code="Search">No matching tag could be found for the specified XPath expression.</error>
        <error code="NoData">The XML document contains no data to search.</error>
        <error code="NullArgs">The XPath parameter was NULL or the Result parameter was NULL when no callback was provided.</error>
      </result>
    </method>

    <method>
      <name>GetAttrib</name>
      <comment>Retrieves the value of a specific XML attribute from a tagged element.</comment>
      <prototype>ERR xml::GetAttrib(OBJECTPTR Object, INT Index, CSTRING Attrib, CSTRING * Value)</prototype>
      <input>
        <param type="INT" name="Index">The unique identifier of the XML tag to search.  This must correspond to a valid tag ID as returned by methods such as <method>FindTag</method>.</param>
        <param type="CSTRING" name="Attrib">The name of the attribute to retrieve (case insensitive).  If NULL or empty, the element's tag name is returned instead.</param>
        <param type="CSTRING *" name="Value">Pointer to a string pointer that will receive the attribute value.  Set to NULL if the specified attribute does not exist.</param>
      </input>
      <description>
<p>The GetAttrib method provides efficient access to individual attribute values within XML elements.  Given a tag identifier and attribute name, the method performs a case-insensitive search through the element's attribute collection and returns the corresponding value.</p>
<p>When a specific attribute name is provided, the method searches through all attributes of the target tag.  The search is case-insensitive to accommodate XML documents with varying capitalisation conventions.</p>
<p>When the attribute name is NULL or empty, the method returns the tag name itself, providing convenient access to element names without requiring separate API calls.</p>
<header>Performance Considerations</header>
<p>For applications requiring frequent attribute access or high-performance scenarios, C++ developers should consider direct access to the <st>XMLAttrib</st> structure array.  This bypasses the method call overhead and provides immediate access to all attributes simultaneously.</p>
<p>The method performs a linear search through the attribute collection, so performance scales with the number of attributes per element.  For elements with many attributes, caching frequently accessed values may improve performance.</p>
<header>Data Integrity</header>
<p>The returned string pointer references internal XML object memory and remains valid until the XML structure is modified.  Callers should not attempt to modify or free the returned string.  For persistent storage, the string content should be copied to application-managed memory.</p>
      </description>
      <result>
        <error code="Okay">The attribute was successfully found and its value returned.</error>
        <error code="NotFound">Either the specified tag Index does not exist, or the named attribute was not found within the tag.</error>
        <error code="NullArgs">Required arguments were not specified correctly.</error>
      </result>
    </method>

    <method>
      <name>GetContent</name>
      <comment>Extracts the immediate text content of an XML element, excluding nested tags.</comment>
      <prototype>ERR xml::GetContent(OBJECTPTR Object, INT Index, STRING Buffer, INT Length)</prototype>
      <input>
        <param type="INT" name="Index">The unique identifier of the XML element from which to extract content.  This must correspond to a valid tag ID as returned by search methods.</param>
        <param type="STRING" name="Buffer">Pointer to a pre-allocated character buffer that will receive the extracted content string.  Must not be NULL.</param>
        <param type="INT" name="Length">The size of the provided buffer in bytes, including space for null termination.  Must be at least 1.</param>
      </input>
      <description>
<p>The GetContent method provides efficient extraction of text content from XML elements using a shallow parsing approach. It retrieves only the immediate text content of the specified element, deliberately excluding any text contained within nested child elements.  This behaviour is valuable for scenarios requiring precise content extraction without recursive tag processing.</p>
<p>Consider the following XML structure:</p>
<pre>&lt;body&gt;
  Hello
  &lt;bold&gt;emphasis&lt;/bold&gt;
  world!
&lt;/body&gt;
</pre>
<p>The GetContent method would extract <code>Hello world!</code> and deliberately exclude <code>emphasis</code> since it is contained within the nested <code>&lt;bold&gt;</code> element.</p>
<header>Comparison with Deep Extraction</header>
<p>For scenarios requiring complete text extraction including all nested content, use the <method>Serialise</method> method with appropriate flags to perform deep content analysis.  The GetContent method is optimised for cases where nested tag content should be excluded from the result.</p>
<p>If the resulting content exceeds the buffer capacity, the result will be truncated but remain null-terminated.</p>
<p>It is recommended that C++ programs bypass this method and access the <st>XMLAttrib</st> structure directly.</p>
      </description>
      <result>
        <error code="Okay">The content string was successfully extracted and copied to the buffer.</error>
        <error code="NotFound">The tag identified by Index does not exist in the XML structure.</error>
        <error code="Args">The Length parameter was less than 1, indicating insufficient buffer space.</error>
        <error code="BufferOverflow">The buffer was not large enough to hold the complete content.  The result is truncated but valid.</error>
        <error code="NullArgs">Either the Buffer parameter was NULL or other required arguments were missing.</error>
      </result>
    </method>

    <method>
      <name>GetEntity</name>
      <comment>Retrieves the value of a parsed entity declaration.</comment>
      <prototype>ERR xml::GetEntity(OBJECTPTR Object, CSTRING Name, CSTRING * Value)</prototype>
      <input>
        <param type="CSTRING" name="Name">The name of the entity to retrieve.  This must correspond to a parsed entity declaration.</param>
        <param type="CSTRING *" name="Value">Receives the resolved entity value on success.  The returned pointer remains valid while the XML object exists.</param>
      </input>
      <description>
<p>This method returns the expanded value associated with a general entity parsed from the document's DOCTYPE declaration. Entity names are case-sensitive and must match exactly as declared.</p>
      </description>
      <result>
        <error code="Okay">The entity was found and its value returned.</error>
        <error code="Search">No matching entity could be found for the specified name.</error>
        <error code="NullArgs">Either the Name or Value parameter was NULL.</error>
      </result>
    </method>

    <method>
      <name>GetNamespaceURI</name>
      <comment>Retrieve the namespace URI for a given namespace UID.</comment>
      <prototype>ERR xml::GetNamespaceURI(OBJECTPTR Object, UINT NamespaceID, CSTRING * Result)</prototype>
      <input>
        <param type="UINT" name="NamespaceID">The UID of the namespace.</param>
        <param type="CSTRING *" name="Result">Pointer to a string pointer that will receive the namespace URI.</param>
      </input>
      <description>
<p>This method retrieves the original namespace URI string for a given namespace UID.</p>
      </description>
      <result>
        <error code="Okay">The namespace URI was successfully retrieved.</error>
        <error code="Search">No namespace found for the specified UID.</error>
        <error code="NullArgs">Required arguments were not specified correctly.</error>
      </result>
    </method>

    <method>
      <name>GetNotation</name>
      <comment>Retrieves information about a parsed notation declaration.</comment>
      <prototype>ERR xml::GetNotation(OBJECTPTR Object, CSTRING Name, CSTRING * Value)</prototype>
      <input>
        <param type="CSTRING" name="Name">The notation name to look up.</param>
        <param type="CSTRING *" name="Value">Receives the notation descriptor on success.</param>
      </input>
      <description>
<p>Returns the system or public identifier captured for a notation declaration inside the document type definition.  If both public and system identifiers were provided they are returned as a single string separated by a single space.</p>
      </description>
      <result>
        <error code="Okay">The notation was found and its descriptor returned.</error>
        <error code="Search">No matching notation could be found for the specified name.</error>
        <error code="NullArgs">Either the Name or Value parameter was NULL.</error>
      </result>
    </method>

    <method>
      <name>GetTag</name>
      <comment>Returns a pointer to the <st>XMLTag</st> structure for a given tag index.</comment>
      <prototype>ERR xml::GetTag(OBJECTPTR Object, INT Index, struct XMLTag ** Result)</prototype>
      <input>
        <param type="INT" name="Index">The index of the tag that is being retrieved.</param>
        <param type="struct XMLTag **" name="Result">The <st>XMLTag</st> is returned in this parameter.</param>
      </input>
      <description>
<p>This method will return the <st>XMLTag</st> structure for a given tag <code>Index</code>.  The <code>Index</code> is checked to ensure it is valid prior to retrieval, and an <code>ERR::OutOfRange</code> error will be returned if it is invalid.</p>
      </description>
      <result>
        <error code="Okay">Operation successful.</error>
        <error code="NotFound">The Index is not recognised.</error>
        <error code="NullArgs">Function call missing argument value(s)</error>
      </result>
    </method>

    <method>
      <name>InsertContent</name>
      <comment>Inserts text content into the XML document structure at specified positions.</comment>
      <prototype>ERR xml::InsertContent(OBJECTPTR Object, INT Index, XMI Where, CSTRING Content, INT * Result)</prototype>
      <input>
        <param type="INT" name="Index">The unique identifier of the target XML element that will serve as the reference point for insertion.</param>
        <param type="XMI" name="Where" lookup="XMI">Specifies the insertion position relative to the target element.  Use PREV or NEXT for sibling insertion, or CHILD for child content insertion.</param>
        <param type="CSTRING" name="Content">The text content to insert.  Special XML characters will be automatically escaped to ensure document validity.</param>
        <param type="INT *" name="Result">Pointer to an integer that will receive the unique identifier of the newly created content node.</param>
      </input>
      <description>
<p>The InsertContent method will insert content strings into any position within the XML tree.  A content string must be provided in the <code>Content</code> parameter and the target insertion point is specified in the <code>Index</code> parameter. An insertion point relative to the target index must be specified in the <code>Where</code> parameter.  The new tags can be inserted as a child of the target by using a <code>Where</code> value of <code>XMI::CHILD</code>.  To insert behind or after the target, use <code>XMI::PREV</code> or <code>XMI::NEXT</code>.</p>
<p>To modify existing content, call <method>SetAttrib</method> instead.</p>
      </description>
      <result>
        <error code="Okay">The content was successfully inserted and a new content node was created.</error>
        <error code="NotFound">The target Index does not correspond to a valid XML element.</error>
        <error code="Args">The Where parameter specifies an invalid insertion position.</error>
        <error code="ReadOnly">The XML object is in read-only mode and cannot be modified.</error>
        <error code="NullArgs">Required parameters were NULL or not properly specified.</error>
      </result>
    </method>

    <method>
      <name>InsertXML</name>
      <comment>Parse an XML string and insert it in the XML tree.</comment>
      <prototype>ERR xml::InsertXML(OBJECTPTR Object, INT Index, XMI Where, CSTRING XML, INT * Result)</prototype>
      <input>
        <param type="INT" name="Index">The new data will target the tag specified here.</param>
        <param type="XMI" name="Where" lookup="XMI">Use <code>PREV</code> or <code>NEXT</code> to insert behind or ahead of the target tag.  Use <code>CHILD</code> or <code>CHILD_END</code> for a child insert.</param>
        <param type="CSTRING" name="XML">An XML statement to parse.</param>
        <param type="INT *" name="Result">The resulting tag index.</param>
      </input>
      <description>
<p>The InsertXML() method is used to translate and insert a new set of XML tags into any position within the XML tree.  A standard XML statement must be provided in the XML parameter and the target insertion point is specified in the Index parameter.  An insertion point relative to the target index must be specified in the <code>Where</code> parameter.  The new tags can be inserted as a child of the target by using a <code>Where</code> value of <code>XMI::CHILD</code>.  Use <code>XMI::CHILD_END</code> to insert at the end of the child list.  To insert behind or after the target, use <code>XMI::PREV</code> or <code>XMI::NEXT</code>.</p>
      </description>
      <result>
        <error code="Okay">The statement was added successfully.</error>
        <error code="NotFound">The target Index does not correspond to a valid XML element.</error>
        <error code="Args">The Where parameter specifies an invalid insertion position.</error>
        <error code="NoData">The provided XML statement parsed to an empty result.</error>
        <error code="ReadOnly">Changes to the XML data are not permitted.</error>
        <error code="NullArgs">Required parameters were NULL or not properly specified.</error>
      </result>
    </method>

    <method>
      <name>InsertXPath</name>
      <comment>Inserts an XML statement in an XML tree.</comment>
      <prototype>ERR xml::InsertXPath(OBJECTPTR Object, CSTRING XPath, XMI Where, CSTRING XML, INT * Result)</prototype>
      <input>
        <param type="CSTRING" name="XPath">An XPath string that refers to the target insertion point.</param>
        <param type="XMI" name="Where" lookup="XMI">Use <code>PREV</code> or <code>NEXT</code> to insert behind or ahead of the target tag.  Use <code>CHILD</code> for a child insert.</param>
        <param type="CSTRING" name="XML">The statement to process.</param>
        <param type="INT *" name="Result">The index of the new tag is returned here.</param>
      </input>
      <description>
<p>The InsertXPath method is used to translate and insert a new set of XML tags into any position within the XML tree.  A standard XML statement must be provided in the XML parameter and the target insertion point is referenced as a valid <code>XPath</code> location string.  An insertion point relative to the <code>XPath</code> target must be specified in the <code>Where</code> parameter.  The new tags can be inserted as a child of the target by using an Insert value of <code>XMI::CHILD</code> or <code>XMI::CHILD_END</code>.  To insert behind or after the target, use <code>XMI::PREV</code> or <code>XMI::NEXT</code>.</p>
      </description>
      <result>
        <error code="Okay">The XML statement was successfully inserted at the specified XPath location.</error>
        <error code="Search">The XPath could not be resolved to a valid location.</error>
        <error code="ReadOnly">The XML object is in read-only mode and cannot be modified.</error>
        <error code="NullArgs">Required parameters were NULL or not properly specified.</error>
      </result>
    </method>

    <method>
      <name>LoadSchema</name>
      <comment>Load an XML Schema definition to enable schema-aware validation.</comment>
      <prototype>ERR xml::LoadSchema(OBJECTPTR Object, CSTRING Path)</prototype>
      <input>
        <param type="CSTRING" name="Path">File system path to the XML Schema (XSD) document.</param>
      </input>
      <description>
<p>This method parses an XML Schema document and attaches its schema context to the current XML object.  Once loaded, schema metadata is available for validation and XPath evaluation routines that utilise schema-aware behaviour.</p>
      </description>
      <result>
        <error code="Okay">Schema was successfully loaded and parsed.</error>
        <error code="NoData">The schema document did not contain any parsable definitions.</error>
        <error code="CreateObject">The file in Path could not be processed as XML content.</error>
        <error code="NullArgs">The Path argument was not provided.</error>
      </result>
    </method>

    <method>
      <name>MoveTags</name>
      <comment>Move an XML tag group to a new position in the XML tree.</comment>
      <prototype>ERR xml::MoveTags(OBJECTPTR Object, INT Index, INT Total, INT DestIndex, XMI Where)</prototype>
      <input>
        <param type="INT" name="Index">Index of the source tag to be moved.</param>
        <param type="INT" name="Total">The total number of sibling tags (including the targeted tag) to be moved from the source index.  Minimum value of 1.</param>
        <param type="INT" name="DestIndex">The destination tag index.  If the index exceeds the total number of tags, the value will be automatically limited to the last tag index.</param>
        <param type="XMI" name="Where" lookup="XMI">Use <code>PREV</code> or <code>NEXT</code> to insert behind or ahead of the target tag.  Use <code>CHILD</code> for a child insert.</param>
      </input>
      <description>
<p>This method is used to move XML tags within the XML tree structure.  It supports the movement of single and groups of tags from one index to another.  The client must supply the index of the tag that will be moved and the index of the target tag.  All child tags of the source will be included in the move.</p>
<p>An insertion point relative to the target index must be specified in the <code>Where</code> parameter.  The source tag can be inserted as a child of the destination by using a <code>Where</code> of <code>XMI::CHILD</code>.  To insert behind or after the target, use <code>XMI::PREV</code> or <code>XMI::NEXT</code>.</p>
      </description>
      <result>
        <error code="Okay">Tags were moved successfully.</error>
        <error code="NotFound">Either the source or destination tag index does not exist.</error>
        <error code="Args">Invalid parameter values were provided.</error>
        <error code="ReadOnly">The XML object is in read-only mode and cannot be modified.</error>
        <error code="NullArgs">Required parameters were NULL or not properly specified.</error>
        <error code="SanityCheckFailed">An internal consistency check failed during the move operation.</error>
      </result>
    </method>

    <method>
      <name>RegisterNamespace</name>
      <comment>Register a namespace URI and return its UID.</comment>
      <prototype>ERR xml::RegisterNamespace(OBJECTPTR Object, CSTRING URI, UINT * Result)</prototype>
      <input>
        <param type="CSTRING" name="URI">The namespace URI to register. Must not be NULL or empty.</param>
        <param type="UINT *" name="Result">Pointer to an integer that will receive the UID for the namespace URI.</param>
      </input>
      <description>
<p>This method registers a namespace URI and returns a UID that can be used to identify the namespace efficiently throughout the XML document.</p>
      </description>
      <result>
        <error code="Okay">The namespace was successfully registered.</error>
        <error code="Failed">The URI was empty or invalid.</error>
        <error code="NullArgs">Required arguments were not specified correctly.</error>
      </result>
    </method>

    <method>
      <name>RemoveTag</name>
      <comment>Removes tag(s) from the XML structure.</comment>
      <prototype>ERR xml::RemoveTag(OBJECTPTR Object, INT Index, INT Total)</prototype>
      <input>
        <param type="INT" name="Index">Reference to the tag that will be removed.</param>
        <param type="INT" name="Total">The total number of sibling (neighbouring) tags that should also be deleted.  A value of one or less will remove only the indicated tag and its children.  The total may exceed the number of tags actually available, in which case all tags up to the end of the branch will be affected.</param>
      </input>
      <description>
<p>The RemoveTag method is used to remove one or more tags from an XML structure.  Child tags will automatically be discarded as a consequence of using this method, in order to maintain a valid XML structure.</p>
<p>This method is capable of deleting multiple tags if the <code>Total</code> parameter is set to a value greater than 1.  Each consecutive tag and its children following the targeted tag will be removed from the XML structure until the count is exhausted. This is useful for mass delete operations.</p>
<p>This method is volatile and will destabilise any cached address pointers that have been acquired from the XML object.</p>
      </description>
      <result>
        <error code="Okay">The tag(s) were successfully removed.</error>
        <error code="NotFound">The specified tag Index does not exist in the XML structure.</error>
        <error code="ReadOnly">The XML object is in read-only mode and cannot be modified.</error>
        <error code="NullArgs">Required parameters were NULL or not properly specified.</error>
      </result>
    </method>

    <method>
      <name>RemoveXPath</name>
      <comment>Removes tag(s) from the XML structure, using an xpath lookup.</comment>
      <prototype>ERR xml::RemoveXPath(OBJECTPTR Object, CSTRING XPath, INT Limit)</prototype>
      <input>
        <param type="CSTRING" name="XPath">An XML path string.</param>
        <param type="INT" name="Limit">The maximum number of matching tags to delete.  A value of one or zero will remove only the indicated tag and its children.  A value of -1 removes all matching tags.</param>
      </input>
      <description>
<p>The RemoveXPath method is used to remove one or more tags from an XML structure.  Child tags will automatically be discarded as a consequence of using this method, in order to maintain a valid XML structure.</p>
<p>Individual tag attributes can also be removed if an attribute is referenced at the end of the <code>XPath</code>.</p>
<p>The removal routine will be repeated so that each tag that matches the XPath will be deleted, or the <code>Limit</code> is reached.</p>
<p>This method is volatile and will destabilise any cached address pointers that have been acquired from the XML object.</p>
      </description>
      <result>
        <error code="Okay">The matching tag(s) or attribute(s) were successfully removed.</error>
        <error code="NoData">The XML document contains no data to process.</error>
        <error code="ReadOnly">The XML object is in read-only mode and cannot be modified.</error>
        <error code="NullArgs">Required parameters were NULL or not properly specified.</error>
      </result>
    </method>

    <method>
      <name>ResolvePrefix</name>
      <comment>Resolve a namespace prefix to the UID of its namespace URI within a tag's scope.</comment>
      <prototype>ERR xml::ResolvePrefix(OBJECTPTR Object, CSTRING Prefix, INT TagID, UINT * Result)</prototype>
      <input>
        <param type="CSTRING" name="Prefix">The namespace prefix to resolve. Use empty string for default namespace.</param>
        <param type="INT" name="TagID">The tag ID defining the starting scope for namespace resolution.</param>
        <param type="UINT *" name="Result">Pointer to an integer that will receive the resolved namespace hash.</param>
      </input>
      <description>
<p>This method resolves a namespace prefix to its corresponding URI by examining namespace declarations within the specified tag's hierarchical scope. The resolution process:</p>
<list type="ordered">
<li>Walks up the tag hierarchy from the specified tag to the root.</li>
<li>Examines xmlns:prefix and xmlns attributes in each tag to find the declaration.</li>
<li>Returns the UID of the first matching namespace URI found.</li>
</list>
<p>This approach correctly handles nested namespace scopes and prefix redefinitions.</p>
      </description>
      <result>
        <error code="Okay">The prefix was successfully resolved.</error>
        <error code="NotFound">The specified tag was not found.</error>
        <error code="Search">The prefix could not be resolved in any accessible scope.</error>
        <error code="NullArgs">Required arguments were not specified correctly.</error>
      </result>
    </method>

    <method>
      <name>Serialise</name>
      <comment>Serialise part of the XML tree to an XML string.</comment>
      <prototype>ERR xml::Serialise(OBJECTPTR Object, INT Index, XMF Flags, STRING * Result)</prototype>
      <input>
        <param type="INT" name="Index">Index to a source tag for which serialisation will start.  Set to zero to serialise the entire tree.</param>
        <param type="XMF" name="Flags" lookup="XMF">Use <code>INCLUDE_SIBLINGS</code> to include siblings of the tag found at Index.</param>
        <param type="STRING *" name="Result">The resulting string is returned in this parameter.</param>
      </input>
      <description>
<p>The Serialise() method will serialise all or part of the XML data tree to a string.</p>
<p>The string will be allocated as a memory block and stored in the Result parameter.  It must be freed once the data is no longer required.</p>
      </description>
      <result>
        <error code="Okay">The XML string was successfully serialised.</error>
        <error code="NotFound">The specified tag Index does not exist in the XML structure.</error>
        <error code="NoData">No information has been loaded into the XML object.</error>
        <error code="AllocMemory">Failed to allocate memory for the XML string result.</error>
        <error code="NullArgs">Required parameters were NULL or not properly specified.</error>
      </result>
    </method>

    <method>
      <name>SetAttrib</name>
      <comment>Adds, updates and removes XML attributes.</comment>
      <prototype>ERR xml::SetAttrib(OBJECTPTR Object, INT Index, XMS Attrib, CSTRING Name, CSTRING Value)</prototype>
      <input>
        <param type="INT" name="Index">Identifies the tag that is to be updated.</param>
        <param type="XMS" name="Attrib" lookup="XMS">Either the index number of the attribute that is to be updated, or set to <code>NEW</code>, <code>UPDATE</code> or <code>UPDATE_ONLY</code>.</param>
        <param type="CSTRING" name="Name">String containing the new name for the attribute.  If <code>NULL</code>, the name will not be changed.  If Attrib is <code>UPDATE</code> or <code>UPDATE_ONLY</code>, the <code>Name</code> is used to find the attribute.</param>
        <param type="CSTRING" name="Value">String containing the new value for the attribute.  If <code>NULL</code>, the attribute is removed.</param>
      </input>
      <description>
<p>This method is used to update and add attributes to existing XML tags, as well as adding or modifying content.</p>
<p>The data for the attribute is defined in the <code>Name</code> and <code>Value</code> parameters.  Use an empty string if no data is to be associated with the attribute.  Set the <code>Value</code> pointer to <code>NULL</code> to remove the attribute. If both <code>Name</code> and <code>Value</code> are <code>NULL</code>, an error will be returned.</p>
<p>NOTE: The attribute at position 0 declares the name of the tag and should not normally be accompanied with a value declaration.  However, if the tag represents content within its parent, then the Name must be set to <code>NULL</code> and the <code>Value</code> string will determine the content.</p>
      </description>
      <result>
        <error code="Okay">Operation successful.</error>
        <error code="Search">The attribute, identified by <code>Name</code>, could not be found.</error>
        <error code="Args">Invalid arguments passed to function.</error>
        <error code="OutOfRange">The <code>Index</code> or <code>Attrib</code> value is out of range.</error>
        <error code="ReadOnly">The XML object is read-only.</error>
        <error code="NullArgs">Function call missing argument value(s)</error>
      </result>
    </method>

    <method>
      <name>SetTagNamespace</name>
      <comment>Set the namespace for a specific XML tag.</comment>
      <prototype>ERR xml::SetTagNamespace(OBJECTPTR Object, INT TagID, INT NamespaceID)</prototype>
      <input>
        <param type="INT" name="TagID">The unique identifier of the XML tag.</param>
        <param type="INT" name="NamespaceID">The UID of the namespace to assign.</param>
      </input>
      <description>
<p>This method assigns a namespace to an XML tag using the namespace's UID.</p>
      </description>
      <result>
        <error code="Okay">The namespace was successfully assigned to the tag.</error>
        <error code="NotFound">The specified tag was not found.</error>
        <error code="NullArgs">Required arguments were not specified correctly.</error>
      </result>
    </method>

    <method>
      <name>SetVariable</name>
      <comment>Stores a variable that can be referenced in XPath expressions.</comment>
      <prototype>ERR xml::SetVariable(OBJECTPTR Object, CSTRING Key, CSTRING Value)</prototype>
      <input>
        <param type="CSTRING" name="Key">The name of the variable (case sensitive).</param>
        <param type="CSTRING" name="Value">The string value to store.</param>
      </input>
      <description>
<p>This method allows you to store key-value pairs that can be referenced in XPath expressions using the variable syntax <code>$variableName</code>.  Variables are stored as strings and are made available during XPath evaluation.</p>
      </description>
      <result>
        <error code="Okay">Operation successful.</error>
        <error code="ReadOnly">The XML object is read-only.</error>
        <error code="NullArgs">The <code>Key</code> parameter was not specified.</error>
      </result>
    </method>

    <method>
      <name>Sort</name>
      <comment>Sorts XML tags to your specifications.</comment>
      <prototype>ERR xml::Sort(OBJECTPTR Object, CSTRING XPath, CSTRING Sort, XSF Flags)</prototype>
      <input>
        <param type="CSTRING" name="XPath">Sort everything under the specified tag, or <code>NULL</code> to sort the entire top level.</param>
        <param type="CSTRING" name="Sort">Pointer to a sorting instruction string.</param>
        <param type="XSF" name="Flags" lookup="XSF">Optional flags.</param>
      </input>
      <description>
<p>The Sort method is used to sort a single branch of XML tags in ascending or descending order.  An <code>XPath</code> is required that refers to the tag containing each item that will be sorted.  To sort the root level, use an <code>XPath</code> of <code>NULL</code>.</p>
<p>The <code>Sort</code> parameter is used to specify a list of sorting instructions.  The format for the <code>Sort</code> string is <code>Tag:Attrib,Tag:Attrib,...</code>.  The <code>Tag</code> indicates the tag name that should be identified for sorting each node, and child tags are supported for this purpose.  Wildcard filtering is allowed and a <code>Tag</code> value of <code>*</code> will match every tag at the requested <code>XPath</code> level.  The optional <code>Attrib</code> value names the attribute containing the sort string.  To sort on content, do not define an <code>Attrib</code> value (use the format <code>Tag,Tag,...</code>).</p>
      </description>
      <result>
        <error code="Okay">The XML object was successfully sorted.</error>
        <error code="Search">The provided XPath failed to locate a tag.</error>
        <error code="ReadOnly">The XML object is in read-only mode and cannot be modified.</error>
        <error code="NullArgs">Required parameters were NULL or not properly specified.</error>
      </result>
    </method>

    <method>
      <name>ValidateDocument</name>
      <comment>Validate the XML document against the currently loaded schema.</comment>
      <prototype>ERR xml::ValidateDocument(OBJECTPTR Object)</prototype>
      <description>
<p>This method performs structural and simple type validation of the document using the loaded XML Schema.  The Result parameter returns <code>1</code> when the document conforms to the schema, otherwise <code>0</code>.</p>
      </description>
      <result>
        <error code="Okay">Validation completed successfully.</error>
        <error code="Search">The schema does not define the root element present in the document.</error>
        <error code="NoData">The XML document does not contain any parsed tags.</error>
        <error code="NoSupport">No schema has been loaded for this XML object.</error>
        <error code="NullArgs">The Result parameter was not supplied.</error>
      </result>
    </method>

  </methods>

  <fields>
    <field>
      <name>DocType</name>
      <comment>Root element name from DOCTYPE declaration</comment>
      <access read="R" write="S">Read/Set</access>
      <type>STRING</type>
    </field>

    <field>
      <name>ErrorMsg</name>
      <comment>A textual description of the last parse error.</comment>
      <access read="G">Get</access>
      <type>STRING</type>
      <description>
<p>This field may provide a textual description of the last parse error that occurred, in conjunction with the most recently received error code.  Issues parsing malformed XPath expressions may also be reported here.</p>
      </description>
    </field>

    <field>
      <name>Flags</name>
      <comment>Controls XML parsing behaviour and processing options.</comment>
      <access read="R" write="W">Read/Write</access>
      <type lookup="XMF">XMF</type>
      <description>
<types lookup="XMF"/>
      </description>
    </field>

    <field>
      <name>Modified</name>
      <comment>A timestamp of when the XML data was last modified.</comment>
      <access read="R">Read</access>
      <type>INT</type>
      <description>
<p>The Modified field provides an artificial timestamp value of when the XML data was last modified (e.g. by a tag insert or update).  Storing the current Modified value and making comparisons later makes it easy to determine that a change has been made.  A rough idea of the total number of change requests can also be calculated by subtracting out the difference.</p>
      </description>
    </field>

    <field>
      <name>Path</name>
      <comment>Set this field if the XML document originates from a file source.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>STRING</type>
      <description>
<p>XML documents can be loaded from the file system by specifying a file path in this field.  If set post-initialisation, all currently loaded data will be cleared and the file will be parsed automatically.</p>
<p>The XML class supports <function module="Core">LoadFile</function>, so an XML file can be pre-cached by the program if it is frequently used during a program's life cycle.</p>
      </description>
    </field>

    <field>
      <name>PublicID</name>
      <comment>Public identifier for external DTD</comment>
      <access read="R" write="S">Read/Set</access>
      <type>STRING</type>
    </field>

    <field>
      <name>ReadOnly</name>
      <comment>Prevents modifications and enables caching for a loaded XML data source.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>INT</type>
      <description>
<p>This field can be set to <code>true</code> prior to initialisation of an XML object that will use an existing data source.  It prevents modifications to the XML object.  If the data originates from a file path, the data may be cached to optimise parsing where the same data is used across multiple XML objects.</p>
      </description>
    </field>

    <field>
      <name>Source</name>
      <comment>Set this field if the XML data is to be sourced from another object.</comment>
      <access read="R" write="I">Read/Init</access>
      <type>OBJECTPTR</type>
      <description>
<p>An XML document can be loaded from another object by referencing it here, on the condition that the object's class supports the Read action.</p>
<p>If set post-initialisation, all currently loaded data will be cleared and the source object will be parsed automatically.</p>
      </description>
    </field>

    <field>
      <name>Start</name>
      <comment>Set a starting cursor to affect the starting point for some XML operations.</comment>
      <access read="R" write="W">Read/Write</access>
      <type>INT</type>
      <description>
<p>When using any XML function that creates an XML string (e.g. SaveToObject), the XML object will include the entire XML tree by default.  Defining the Start value will restrict processing to a specific tag and its children.</p>
<p>The Start field currently affects the <action>SaveToObject</action> action and the <fl>Statement</fl> field.</p>
      </description>
    </field>

    <field>
      <name>Statement</name>
      <comment>XML data is processed through this field.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>STRING</type>
      <description>
<p>Set the Statement field to parse an XML formatted data string through the object.  If this field is set after initialisation then the XML object will clear any existing data first.</p>
<p>Be aware that setting this field with an invalid statement will result in an empty XML object.</p>
<p>Reading the Statement field will return a serialised string of XML data.  By default all tags will be included in the statement unless a predefined starting position is set by the <fl>Start</fl> field.  The string result is an allocation that must be freed.</p>
      </description>
    </field>

    <field>
      <name>SystemID</name>
      <comment>System identifier for external DTD</comment>
      <access read="R" write="S">Read/Set</access>
      <type>STRING</type>
    </field>

    <field>
      <name>Tags</name>
      <comment>Provides direct access to the XML document structure.</comment>
      <access read="G">Get</access>
      <type>STRUCT []</type>
      <description>
<p>The Tags field exposes the complete XML document structure as a hierarchical array of <st>XMLTag</st> structures.  This field becomes available after successful XML parsing and provides the primary interface for reading XML content programmatically.</p>
<p>Each <st>XMLTag</st> will have at least one attribute set in the <code>Attribs</code> array.  The first attribute will either reflect the tag name or a content string if the <code>Name</code> is undefined.  The <code>Children</code> array provides access to all child elements.</p>
<p>Direct read access to the Tags hierarchy is safe and efficient for traversing the document structure.  However, modifications should be performed using the XML object's methods (<method>InsertXML</method>, <method>SetAttrib</method>, <method>RemoveTag</method>, etc.) to maintain internal consistency and trigger appropriate cache invalidation.</p>
<p>NOTE: Fluid will copy this field on read, caching the value is therefore recommended.</p>
      </description>
    </field>

  </fields>
  <types>
    <constants lookup="XMF" comment="Standard flags for the XML class.">
      <const name="HAS_SCHEMA">Automatically defined when a schema has been loaded into the XML object.</const>
      <const name="INCLUDE_COMMENTS">By default, comments are stripped when parsing XML input unless this flag is specified.</const>
      <const name="INCLUDE_SIBLINGS">Include siblings when building an XML string (<action>GetXMLString</action> only)</const>
      <const name="INCLUDE_WHITESPACE">By default the XML parser will skip content between tags when they contain pure whitespace.  Setting this flag will retain all whitespace.</const>
      <const name="INDENT">Indent the output of serialised XML to improve readability.</const>
      <const name="LOCK_REMOVE">Prevents removal of tags from the XML tree.  This specifically affects the RemoveTag and RemoveXPath methods.</const>
      <const name="LOG_ALL">Print extra log messages.</const>
      <const name="NAMESPACE_AWARE">Enable namespace processing during parsing.</const>
      <const name="NEW">Creates an empty XML object on initialisation - if the <fl>Path</fl> field has been set, the source file will not be loaded.</const>
      <const name="NO_ESCAPE">Turns off escape code conversion.</const>
      <const name="OMIT_TAGS">Prevents tags from being output when the XML is serialised (output content only).</const>
      <const name="PARSE_ENTITY">Enables parsing of DOCTYPE entities.</const>
      <const name="PARSE_HTML">Automatically parse HTML escape codes.</const>
      <const name="READABLE">Indent the output of serialised XML to improve readability.</const>
      <const name="STANDALONE">Automatically defined when the XML declaration specifies standalone="yes".</const>
      <const name="STRIP_CDATA">Do not serialise <code>CDATA</code> sections.  Note that this option is used as a parameter, not an object flag.</const>
      <const name="STRIP_CONTENT">Strip all content from incoming XML data.</const>
      <const name="STRIP_HEADERS">XML headers found in the source data will not be included in the parsed results.</const>
      <const name="WELL_FORMED">By default, the XML class will accept badly structured XML data.  This flag requires that XML statements must be well-formed (tags must balance) or an <code>ERR::BadData</code> error will be returned during processing.</const>
    </constants>

    <constants lookup="XMI" comment="Tag insertion options.">
      <const name="CHILD">Insert as the first child of the target.</const>
      <const name="CHILD_END">Insert as the last child of the target.</const>
      <const name="NEXT">Insert as the next tag of the target.</const>
      <const name="PREV">Insert as the previous tag of the target.</const>
    </constants>

    <constants lookup="XMS" comment="For SetAttrib()">
      <const name="NEW">Adds a new attribute.  Note that if the attribute already exists, this will result in at least two attributes of the same name in the tag.</const>
      <const name="UPDATE">As for <code>UPDATE_ONLY</code>, but if the attribute does not exist, it will be created.</const>
      <const name="UPDATE_ONLY">SetAttrib will find the target attribute and update it.  It is not possible to rename the attribute when using this technique.  <code>ERR::Search</code> is returned if the attribute cannot be found.</const>
    </constants>

    <constants lookup="XPVT" comment="Type descriptors for XPathValue">
      <const name="Boolean"/>
      <const name="Date"/>
      <const name="DateTime"/>
      <const name="NodeSet"/>
      <const name="Number"/>
      <const name="String"/>
      <const name="Time"/>
    </constants>

    <constants lookup="XSF" comment="Options for the Sort method.">
      <const name="CHECK_SORT">Tells the algorithm to check for a 'sort' attribute in each analysed tag and if found, the algorithm will use that as the sort value instead of that indicated in the <code>Attrib</code> field.</const>
      <const name="DESC">Sort in descending order.</const>
    </constants>

  </types>
  <structs>
    <struct name="XMLAttrib" typeName="XMLATTRIB">
      <field name="Name" type="std::string">Name of the attribute</field>
      <field name="Value" type="std::string">Value of the attribute</field>
    </struct>

    <struct name="XMLTag" typeName="XMLTAG">
      <field name="ID" type="INT">Unique ID assigned to the tag on creation</field>
      <field name="ParentID" type="INT">Unique ID of the parent tag</field>
      <field name="LineNo" type="INT">Line number on which this tag was encountered</field>
      <field name="Flags" type="XTF" lookup="XTF">Optional flags</field>
      <field name="NamespaceID" type="UINT">Hash of namespace URI or 0 for no namespace</field>
      <field name="Attribs" type="pf::vector&lt;XMLAttrib&gt;">Array of attributes for this tag</field>
      <field name="Children" type="pf::vector&lt;XMLTag&gt;">Array of child tags</field>
    </struct>

    <struct name="XPathValue" typeName="XPATHVALUE">
      <field name="Type" type="XPVT" lookup="XPVT">Identifies the type of value stored</field>
      <field name="NumberValue" type="DOUBLE">Defined if the type is Number or Boolean</field>
      <field name="StringValue" type="std::string">Defined if the type is String</field>
    </struct>

  </structs>
</book>
