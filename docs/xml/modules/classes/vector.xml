<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="class.xsl"?>

<book>
  <info>
    <name>Vector</name>
    <type>class</type>
    <module>Vector</module>
    <comment>An abstract class for supporting vector graphics objects and functionality.</comment>
    <version>1</version>
    <id>227baf98</id>
    <idstring>ID_VECTOR</idstring>
    <category>Graphics</category>
    <include>modules/vector.h</include>
    <copyright>Paul Manias Â© 2010-2024</copyright>
    <description>
<p>Vector is an abstract class that is used as a blueprint for other vector classes that provide specific functionality for a vector scene.  At this time the classes are <class name="VectorClip">VectorClip</class>, <class name="VectorEllipse">VectorEllipse</class>, <class name="VectorGroup">VectorGroup</class>, <class name="VectorPath">VectorPath</class>, <class name="VectorPolygon">VectorPolygon</class>, <class name="VectorRectangle">VectorRectangle</class>, <class name="VectorSpiral">VectorSpiral</class>, <class name="VectorText">VectorText</class>, <class name="VectorViewport">VectorViewport</class> and <class name="VectorWave">VectorWave</class>.</p>
<p>The majority of sub-classes support all of the functionality provided by Vector.  The general exception is that graphics functions will not be supported by non-graphical classes, for instance <class name="VectorGroup">VectorGroup</class> and <class name="VectorViewport">VectorViewport</class> do not produce a vector path and therefore cannot be rendered.</p>
<p>To simplify the creation of complex vector graphics and maximise compatibility, we have designed the vector management code to use data structures that closely match SVG definitions.  For this reason we do not provide exhaustive documentation on the properties that can be applied to each vector type.  Instead, please refer to the SVG reference manuals from the W3C.  In cases where we are missing support for an SVG feature, assume that future support is intended unless otherwise documented.</p></description>
    <source>
      <file path="vectors/">vector.cpp</file>
    </source>
  </info>

  <actions>
    <action>
      <name>Disable</name>
      <comment>Disabling a vector can be used to trigger style changes and prevent user input.</comment>
      <prototype>ERR acDisable(*Object)</prototype>
    </action>

    <action>
      <name>Draw</name>
      <comment>Draws the surface associated with the vector.</comment>
      <prototype>ERR acDraw(*Object, DOUBLE X, DOUBLE Y, DOUBLE Width, DOUBLE Height)</prototype>
      <input>
        <param type="LONG" name="X">The X position of the region to be drawn.</param>
        <param type="LONG" name="Y">The Y position of the region to be drawn.</param>
        <param type="LONG" name="Width">The width of the region to be drawn.</param>
        <param type="LONG" name="Height">The height of the region to be drawn.</param>
      </input>
      <description>
<p>Calling the Draw action on a vector will schedule a redraw of the scene graph if it is associated with a <class name="Surface">Surface</class>. Internally, drawing is scheduled for the next frame and is not immediate.</p>
      </description>
    </action>

    <action>
      <name>Enable</name>
      <comment>Reverses the effects of disabling the vector.</comment>
      <prototype>ERR acEnable(*Object)</prototype>
    </action>

    <action>
      <name>Hide</name>
      <comment>Changes the vector's visibility setting to hidden.</comment>
      <prototype>ERR acHide(*Object)</prototype>
    </action>

    <action>
      <name>MoveToBack</name>
      <comment>Move a vector to the back of its stack.</comment>
      <prototype>ERR acMoveToBack(*Object)</prototype>
    </action>

    <action>
      <name>MoveToFront</name>
      <comment>Move a vector to the front of its stack.</comment>
      <prototype>ERR acMoveToFront(*Object)</prototype>
    </action>

    <action>
      <name>Show</name>
      <comment>Changes the vector's visibility setting to visible.</comment>
      <prototype>ERR acShow(*Object)</prototype>
    </action>

  </actions>

  <methods>
    <method>
      <name>Debug</name>
      <comment>Internal functionality for debugging.</comment>
      <prototype>ERR vec::Debug(OBJECTPTR Object)</prototype>
      <description>
<p>This internal method prints comprehensive debugging information to the log.</p>
      </description>
      <result>
        <error code="Okay">Operation successful.</error>
      </result>
    </method>

    <method>
      <name>FreeMatrix</name>
      <comment>Remove an allocated VectorMatrix structure.</comment>
      <prototype>ERR vec::FreeMatrix(OBJECTPTR Object, struct VectorMatrix * Matrix)</prototype>
      <input>
        <param type="struct VectorMatrix *" name="Matrix">Reference to the structure that requires removal.</param>
      </input>
      <description>
<p>Transformations allocated from <function module="Vector">NewMatrix</function> can be removed with this method.  If multiple transforms are attached to the vector then it should be noted that this will affect downstream transformations.</p>
      </description>
      <result>
        <error code="Okay">Operation successful.</error>
        <error code="NullArgs">Function call missing argument value(s)</error>
      </result>
    </method>

    <method>
      <name>GetBoundary</name>
      <comment>Returns the graphical boundary of a vector.</comment>
      <prototype>ERR vec::GetBoundary(OBJECTPTR Object, VBF Flags, DOUBLE * X, DOUBLE * Y, DOUBLE * Width, DOUBLE * Height)</prototype>
      <input>
        <param type="VBF" name="Flags" lookup="VBF">Optional flags.</param>
        <param type="DOUBLE *" name="X">The left-most position of the boundary is returned here.</param>
        <param type="DOUBLE *" name="Y">The top-most position of the boundary is returned here.</param>
        <param type="DOUBLE *" name="Width">The width of the boundary is returned here.</param>
        <param type="DOUBLE *" name="Height">The height of the boundary is returned here.</param>
      </input>
      <description>
<p>This method will return the boundary of a vector's path in terms of its top-left position, width and height.  All transformations and position information that applies to the vector will be taken into account when computing the boundary.</p>
<p>If the <code>VBF::INCLUSIVE</code> flag is used, the result will include an analysis of all paths that belong to children of the target vector, including transforms.</p>
<p>If the <code>VBF::NO_TRANSFORM</code> flag is used, the transformation step is not applied to the vector's path.</p>
<p>It is recommended that this method is not called until at least one rendering pass has been made, as some vector dimensions may not be computed before then.</p>
      </description>
      <result>
        <error code="Okay">Operation successful.</error>
        <error code="NoData">The vector does not have a computable path.</error>
        <error code="NullArgs">Function call missing argument value(s)</error>
        <error code="NotPossible">The vector does not support path generation.</error>
      </result>
    </method>

    <method>
      <name>NewMatrix</name>
      <comment>Returns a VectorMatrix structure that allows transformations to be applied to the vector.</comment>
      <prototype>ERR vec::NewMatrix(OBJECTPTR Object, struct VectorMatrix ** Transform, LONG End)</prototype>
      <input>
        <param type="struct VectorMatrix **" name="Transform">A reference to the new transform structure is returned here.</param>
        <param type="LONG" name="End">If <code>true</code>, the matrix priority is lowered by inserting it at the end of the transform list.</param>
      </input>
      <description>
<p>Call NewMatrix() to allocate a transformation matrix that allows transforms to be applied to a vector.  Manipulating the transformation matrix is supported by functions in the Vector module, such as <function module="Vector">Scale</function> and <function module="Vector">Rotate</function>.</p>
<p>Note that if multiple matrices are allocated by the client, they will be applied to the vector in the order of their creation.</p>
<p>The structure will be owned by the Vector object and is automatically terminated when the Vector is destroyed.  If the transform is no longer required before then, it can be manually removed with <function module="Vector">FreeMatrix</function>.</p>
      </description>
      <result>
        <error code="Okay">Operation successful.</error>
        <error code="NullArgs">Function call missing argument value(s)</error>
      </result>
    </method>

    <method>
      <name>PointInPath</name>
      <comment>Checks if point at (X,Y) is within a vector's path.</comment>
      <prototype>ERR vec::PointInPath(OBJECTPTR Object, DOUBLE X, DOUBLE Y)</prototype>
      <input>
        <param type="DOUBLE" name="X">The X coordinate of the point.</param>
        <param type="DOUBLE" name="Y">The Y coordinate of the point.</param>
      </input>
      <description>
<p>This method provides an accurate means of determining if a specific coordinate is inside the path of a vector. Transforms are taken into account, as are clip masks.</p>
      </description>
      <result>
        <error code="Okay">The point is in the path.</error>
        <error code="False">The point is not in the path.</error>
        <error code="NoData">The vector is unable to generate a path based on its current values.</error>
        <error code="NoSupport">The vector type does not support path generation.</error>
        <error code="NullArgs">Function call missing argument value(s)</error>
      </result>
    </method>

    <method>
      <name>Push</name>
      <comment>Push a vector to a new position within its area of the vector stack.</comment>
      <prototype>ERR vec::Push(OBJECTPTR Object, LONG Position)</prototype>
      <input>
        <param type="LONG" name="Position">Specify a relative position index here (-ve to move backwards, +ve to move forwards)</param>
      </input>
      <description>
<p>This method moves the position of a vector within its branch of the vector stack.  Repositioning is relative to the current position of the vector.  Every unit specified in the Position parameter will move the vector by one index in the stack frame.  Negative values will move the vector backwards; positive values move it forward.</p>
<p>It is not possible for an vector to move outside of its branch, i.e. it cannot change its parent.  If the vector reaches the edge of its branch with excess units remaining, the method will return immediately with an <code>ERR::Okay</code> error code.</p>
      </description>
      <result>
        <error code="Okay">Operation successful.</error>
        <error code="NullArgs">Function call missing argument value(s)</error>
      </result>
    </method>

    <method>
      <name>SubscribeFeedback</name>
      <comment>Subscribe to events that relate to the vector.</comment>
      <prototype>ERR vec::SubscribeFeedback(OBJECTPTR Object, FM Mask, FUNCTION * Callback)</prototype>
      <input>
        <param type="FM" name="Mask" lookup="FM">Defines the feedback events required by the client.  Set to <code>0xffffffff</code> if all messages are required.</param>
        <param type="FUNCTION *" name="Callback">The function that will receive feedback events.</param>
      </input>
      <description>
<p>Use this method to receive feedback for events that have affected the state of a vector.</p>
<p>To remove an existing subscription, call this method again with the same <code>Callback</code> and an empty <code>Mask</code>. Alternatively have the callback function return <code>ERR::Terminate</code>.</p>
<p>The prototype for the <code>Callback</code> is <code>ERR callback(*Vector, FM Event)</code></p>
      </description>
      <result>
        <error code="Okay">Operation successful.</error>
        <error code="NullArgs">Function call missing argument value(s)</error>
      </result>
    </method>

    <method>
      <name>SubscribeInput</name>
      <comment>Create a subscription for input events that relate to the vector.</comment>
      <prototype>ERR vec::SubscribeInput(OBJECTPTR Object, JTYPE Mask, FUNCTION * Callback)</prototype>
      <input>
        <param type="JTYPE" name="Mask" lookup="JTYPE">Combine <code>JTYPE</code> flags to define the input messages required by the client.  Set to zero to remove an existing subscription.</param>
        <param type="FUNCTION *" name="Callback">Reference to a function that will receive input messages.</param>
      </input>
      <description>
<p>The SubscribeInput method filters events from <function module="Display">SubscribeInput</function> by limiting their relevance to that of the target vector.  The original events are transferred with some modifications - <code>X</code>, <code>Y</code>, <code>AbsX</code> and <code>AbsY</code> are converted to the vector's coordinate system, and <code>CROSSED_IN</code> and <code>CROSSED_OUT</code> events are triggered during passage through the clipping area.</p>
<p>It is a pre-requisite that the associated <class name="VectorScene">VectorScene</class> has been linked to a <class name="Surface">Surface</class>.</p>
<p>To remove an existing subscription, call this method again with the same <code>Callback</code> and an empty <code>Mask</code>. Alternatively have the function return <code>ERR::Terminate</code>.</p>
<p>Please refer to <function module="Display">SubscribeInput</function> for further information on event management and message handling.</p>
<p>The prototype for the <code>Callback</code> is <code>ERR callback(*Vector, *InputEvent)</code></p>
      </description>
      <result>
        <error code="Okay">Operation successful.</error>
        <error code="FieldNotSet">The VectorScene has no reference to a Surface.</error>
        <error code="AllocMemory">A call to AllocMemory() failed to create a new memory block.</error>
        <error code="NullArgs">Function call missing argument value(s)</error>
        <error code="Function">A call to <function module="Display">SubscribeInput</function> failed.</error>
      </result>
    </method>

    <method>
      <name>SubscribeKeyboard</name>
      <comment>Create a subscription for input events that relate to the vector.</comment>
      <prototype>ERR vec::SubscribeKeyboard(OBJECTPTR Object, FUNCTION * Callback)</prototype>
      <input>
        <param type="FUNCTION *" name="Callback">Reference to a callback function that will receive input messages.</param>
      </input>
      <description>
<p>The SubscribeKeyboard() method provides a callback mechanism for handling keyboard events.  Events are reported when the vector or one of its children has the user focus.  It is a pre-requisite that the associated <class name="VectorScene">VectorScene</class> has been linked to a <class name="Surface">Surface</class>.</p>
<p>The prototype for the callback is as follows, whereby <code>Qualifers</code> are <code>KQ</code> flags and the Code is a <code>K</code> constant representing the raw key value.  The <code>Unicode</code> value is the resulting character when the qualifier and code are translated through the user's keymap.</p>
<p>
<code>ERR callback(*Viewport, LONG Qualifiers, LONG Code, LONG Unicode);</code></p>
<p>If the callback returns <code>ERR::Terminate</code> then the subscription will be ended.  All other error codes are ignored.</p>
      </description>
      <result>
        <error code="Okay">Operation successful.</error>
        <error code="FieldNotSet">The <class name="VectorScene" field="Surface">VectorScene.Surface</class> field has not been defined.</error>
        <error code="AllocMemory">A call to AllocMemory() failed to create a new memory block.</error>
        <error code="NullArgs">Function call missing argument value(s)</error>
        <error code="Function">A call to <function module="Display">SubscribeInput</function> failed.</error>
      </result>
    </method>

    <method>
      <name>Trace</name>
      <comment>Returns the coordinates for a vector path, using callbacks.</comment>
      <prototype>ERR vec::Trace(OBJECTPTR Object, FUNCTION * Callback, DOUBLE Scale, LONG Transform)</prototype>
      <input>
        <param type="FUNCTION *" name="Callback">A function to call with the path coordinates.</param>
        <param type="DOUBLE" name="Scale">Set to <code>1.0</code> (recommended) to trace the path at a scale of 1 to 1.</param>
        <param type="LONG" name="Transform">Set to <code>true</code> if all transforms applicable to the vector should be applied to the path.</param>
      </input>
      <description>
<p>Any vector that generates a path can be traced by calling this method.  Tracing allows the caller to follow the path from point-to-point if the path were to be rendered with a stroke.  The prototype of the callback function is <code>ERR Function(OBJECTPTR Vector, LONG Index, LONG Command, DOUBLE X, DOUBLE Y, APTR Meta)</code>.</p>
<p>The <code>Vector</code> parameter refers to the vector targeted by the method.  The <code>Index</code> is an incrementing counter that reflects the currently plotted point.  The <code>X</code> and <code>Y</code> parameters reflect the coordinate of a point on the path.</p>
<p>If the <code>Callback</code> returns <code>ERR::Terminate</code>, then no further coordinates will be processed.</p>
      </description>
      <result>
        <error code="Okay">Operation successful.</error>
        <error code="NoData">The vector does not define a path.</error>
        <error code="NullArgs">Function call missing argument value(s)</error>
      </result>
    </method>

  </methods>

  <fields>
    <field>
      <name>AppendPath</name>
      <comment>Experimental.  Append the path of the referenced vector during path generation.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>OBJECTPTR</type>
      <description>
<p>The path of an external Vector can be appended to the base path in real-time by making a reference to that vector here.  The operation is completed immediately after the generation of the client vector's base path, prior to any transforms.</p>
<p>It is strongly recommended that the appended vector has its <fl>Visibility</fl> set to <code>HIDDEN</code>.  Any direct transform that is applied to the vector will be utilised, but inherited transforms and placement information will be ignored.</p>
<p>If it is necessary for the two paths to flow from one to the other, set <code>VF::JOIN_PATHS</code> in the <fl>Flags</fl> field.</p>
<p>Note: Appended paths are not compliant with SVG and this feature is considered experimental.</p>
      </description>
    </field>

    <field>
      <name>Child</name>
      <comment>The first child vector, or <code>NULL</code>.</comment>
      <access read="R">Read</access>
      <type class="Vector">*Vector</type>
      <description>
<p>The Child value refers to the first vector that forms a branch under this object.  This field cannot be set directly as it is managed internally.  Instead, use object ownership when a vector needs to be associated with a new parent.</p>
      </description>
    </field>

    <field>
      <name>ClipRule</name>
      <comment>Determines the algorithm to use when clipping the shape.</comment>
      <access read="G" write="S">Get/Set</access>
      <type lookup="VFR">INT</type>
      <description>
<p>The ClipRule attribute only applies to vector shapes when they are contained within a <class name="VectorClip">VectorClip</class> object.  In terms of outcome, the ClipRule works similarly to <fl>FillRule</fl>.</p>
<types lookup="VFR"/>
      </description>
    </field>

    <field>
      <name>ColourSpace</name>
      <comment>Defines the colour space to use when blending the vector with a target bitmap's content.</comment>
      <access read="R" write="W">Read/Write</access>
      <type lookup="VCS">VCS</type>
      <description>
<p>By default, vectors are rendered using the standard RGB colour space and alpha blending rules.  Changing the colour space to <code>LINEAR_RGB</code> will force the renderer to automatically convert sRGB values to linear RGB when blending on the fly.</p>
<types lookup="VCS"/>
      </description>
    </field>

    <field>
      <name>Cursor</name>
      <comment>The mouse cursor to display when the pointer is within the vector's boundary.</comment>
      <access read="R" write="S">Read/Set</access>
      <type lookup="PTC">PTC</type>
      <description>
<p>The Cursor field declares the pointer's cursor image to display within the vector's boundary.  The cursor will automatically switch to the specified image when it enters the boundary defined by the vector's path.  This effect lasts until the cursor vacates the area.</p>
<p>It is a pre-requisite that the associated <class name="VectorScene">VectorScene</class> has been linked to a <class name="Surface">Surface</class>.</p>
<types lookup="PTC"/>
      </description>
    </field>

    <field>
      <name>DashArray</name>
      <comment>Controls the pattern of dashes and gaps used to stroke paths.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>DOUBLE []</type>
      <description>
<p>The DashArray is a list of lengths that alternate between dashes and gaps.  If an odd number of values is provided, then the list of values is repeated to yield an even number of values.  Thus <code>5,3,2</code> is equivalent to <code>5,3,2,5,3,2</code>.</p>
      </description>
    </field>

    <field>
      <name>DashOffset</name>
      <comment>The distance into the dash pattern to start the dash.  Can be a negative number.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>DOUBLE</type>
      <description>
<p>The DashOffset can be set in conjunction with the <fl>DashArray</fl> to shift the dash pattern to the left.  If the offset is negative then the shift will be to the right.</p>
      </description>
    </field>

    <field>
      <name>DisplayScale</name>
      <comment>Returns the scale of the vector as it appears on the display.</comment>
      <access read="G">Get</access>
      <type>DOUBLE</type>
      <description>
<p>The DisplayScale field will return the scale factor of the vector's path as it appears in the final rendering.  For instance if the vector is the child of a viewport scaled down to 50%, the resulting value would be <code>0.5</code>.</p>
      </description>
    </field>

    <field>
      <name>EnableBkgd</name>
      <comment>If true, allows filters to use BackgroundImage and BackgroundAlpha source types.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>INT</type>
      <description>
<p>The EnableBkgd option must be set to true if a section of the vector tree uses filters that have <code>BackgroundImage</code> or <code>BackgroundAlpha</code> as a source.  If it is not set, then filters using <code>BackgroundImage</code> and <code>BackgroundAlpha</code> references will not produce the expected behaviour.</p>
<p>The EnableBkgd option can be enabled on Vector sub-classes <class name="VectorGroup">VectorGroup</class>, <class name="VectorPattern">VectorPattern</class> and <class name="VectorViewport">VectorViewport</class>.  All other sub-classes will ignore the option if used.</p>
      </description>
    </field>

    <field>
      <name>Fill</name>
      <comment>Defines the fill painter using SVG's IRI format.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>STRING</type>
      <description>
<p>The painter used for filling a vector path can be defined through this field using SVG compatible formatting.  The string is parsed through the <function module="Vector">ReadPainter</function> function.  Please refer to it for further details on valid formatting.</p>
<p>It is possible to enable dual-fill painting via this field, whereby a second fill operation can follow the first by separating them with a semi-colon <code>;</code> character.  This feature makes it easy to use a common background fill and follow it with an independent foreground, alleviating the need for additional vector objects.  Be aware that this feature is intended for programmed use-cases and is not SVG compliant.</p>
      </description>
    </field>

    <field>
      <name>FillColour</name>
      <comment>Defines a solid colour for filling the vector path.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>FLOAT []</type>
      <description>
<p>Set the FillColour field to define a solid colour for filling the vector path.  The colour is defined as an array of four 32-bit floating point values between 0 and 1.0.  The array elements consist of Red, Green, Blue and Alpha values in that order.</p>
<p>If the Alpha component is set to zero then the FillColour will be ignored by the renderer.</p>
      </description>
    </field>

    <field>
      <name>FillOpacity</name>
      <comment>The opacity to use when filling the vector.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>DOUBLE</type>
      <description>
<p>The FillOpacity value is used by the painting algorithm when it is rendering a filled vector.  It is multiplied with the <fl>Opacity</fl> to determine a final opacity value for the render.</p>
      </description>
    </field>

    <field>
      <name>FillRule</name>
      <comment>Determines the algorithm to use when filling the shape.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>INT</type>
      <description>
<p>The FillRule field indicates the algorithm which is to be used to determine what parts of the canvas are included when filling the shape. For a simple, non-intersecting path, it is intuitively clear what region lies "inside"; however, for a more complex path, such as a path that intersects itself or where one sub-path encloses another, the interpretation of "inside" is not so obvious.</p>
      </description>
    </field>

    <field>
      <name>Filter</name>
      <comment>Assign a post-effects filter to a vector.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>STRING</type>
      <description>
<p>This field assigns a graphics filter to the rendering pipeline of the vector.  The filter must initially be created using the <class name="VectorFilter">VectorFilter</class> class and added to a VectorScene using <class name="VectorScene" method="AddDef">VectorScene.AddDef()</class>.  The filter can then be referenced by ID in the Filter field of any vector object.  Please refer to the <class name="VectorFilter">VectorFilter</class> class for further details on filter configuration.</p>
<p>The Filter value can be in the format <code>ID</code> or <code>url(<fl>ID</fl>)</code> according to client preference.</p>
      </description>
    </field>

    <field>
      <name>Flags</name>
      <comment>Optional flags.</comment>
      <access read="R" write="I">Read/Init</access>
      <type lookup="VF">VF</type>
      <description>
<types lookup="VF"/>
      </description>
    </field>

    <field>
      <name>ID</name>
      <comment>String identifier for a vector.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>STRING</type>
      <description>
<p>The ID field is provided for the purpose of SVG support.  Where possible we would recommend that you use the existing object name and automatically assigned ID's for identifiers.</p>
      </description>
    </field>

    <field>
      <name>InnerJoin</name>
      <comment>Adjusts the handling of thickly stroked paths that cross back at the join.</comment>
      <access read="G" write="S">Get/Set</access>
      <type lookup="VIJ">INT</type>
      <description>
<p>The InnerJoin value is used to make very technical adjustments to the way that paths are stroked when they form corners.  Visually, the impact of this setting is only noticeable when a path forms an awkward corner that crosses over itself - usually due to the placement of bezier control points.</p>
<p>The available settings are <code>MITER</code>, <code>ROUND</code>, <code>BEVEL</code>, <code>JAG</code> and <code>INHERIT</code>.  The default of <code>MITER</code> is recommended as it is the fastest, but <code>ROUND</code> produces the best results in ensuring that the stroked path is filled correctly.  The most optimal approach is to use the default setting and switch to <code>ROUND</code> if issues are noted near the corners of the path.</p>
<types lookup="VIJ"/>
      </description>
    </field>

    <field>
      <name>LineCap</name>
      <comment>The shape to be used at the start and end of a stroked path.</comment>
      <access read="G" write="S">Get/Set</access>
      <type lookup="VLC">INT</type>
      <description>
<p>LineCap is the equivalent of SVG's stroke-linecap attribute.  It defines the shape to be used at the start and end of a stroked path.</p>
<types lookup="VLC"/>
      </description>
    </field>

    <field>
      <name>LineJoin</name>
      <comment>The shape to be used at path corners that are stroked.</comment>
      <access read="G" write="S">Get/Set</access>
      <type lookup="VLJ">INT</type>
      <description>
<p>LineJoin is the equivalent of SVG's stroke-linejoin attribute.  It defines the shape to be used at path corners that are being stroked.</p>
<types lookup="VLJ"/>
      </description>
    </field>

    <field>
      <name>Mask</name>
      <comment>Reference a VectorClip object here to apply a clipping mask to the rendered vector.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>OBJECTPTR</type>
      <description>
<p>A mask can be applied to a vector by setting the Mask field with a reference to a <class name="VectorClip">VectorClip</class> object.  Please refer to the <class name="VectorClip">VectorClip</class> class for further information.</p>
      </description>
    </field>

    <field>
      <name>Matrices</name>
      <comment>A linked list of transform matrices that have been applied to the vector.</comment>
      <access read="R">Read</access>
      <type>struct VectorMatrix *</type>
      <description>
<p>All transforms that have been allocated via <function module="Vector">NewMatrix</function> can be read from the Matrices field.  Each transform is represented by the <st>VectorMatrix</st> structure, and are linked in the order in which they are added to the vector.</p>
<struct lookup="VectorMatrix"/>
      </description>
    </field>

    <field>
      <name>MiterLimit</name>
      <comment>Imposes a limit on the ratio of the miter length to the StrokeWidth.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>DOUBLE</type>
      <description>
<p>When two line segments meet at a sharp angle and miter joins have been specified in <fl>LineJoin</fl>, it is possible for the miter to extend far beyond the thickness of the line stroking the path. The MiterLimit imposes a limit on the ratio of the miter length to the <fl>StrokeWidth</fl>. When the limit is exceeded, the join is converted from a miter to a bevel.</p>
<p>The ratio of miter length (distance between the outer tip and the inner corner of the miter) to <fl>StrokeWidth</fl> is directly related to the angle (theta) between the segments in user space by the formula: <code>MiterLength / StrokeWidth = 1 / sin ( theta / 2 )</code>.</p>
<p>For example, a miter limit of 1.414 converts miters to bevels for theta less than 90 degrees, a limit of 4.0 converts them for theta less than approximately 29 degrees, and a limit of 10.0 converts them for theta less than approximately 11.5 degrees.</p>
      </description>
    </field>

    <field>
      <name>Morph</name>
      <comment>Enables morphing of the vector to a target path.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>OBJECTPTR</type>
      <description>
<p>If the Morph field is set to a Vector object that generates a path, the vector will be morphed to follow the target vector's path shape.  This works particularly well for text and shapes that follow a horizontal path that is much wider than it is tall.</p>
<p>Squat shapes will fare poorly if morphed, so experimentation may be necessary to understand how the morph feature is best utilised.</p>
      </description>
    </field>

    <field>
      <name>MorphFlags</name>
      <comment>Optional flags that affect morphing.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>INT</type>
    </field>

    <field>
      <name>Next</name>
      <comment>The next vector in the branch, or NULL.</comment>
      <access read="R" write="S">Read/Set</access>
      <type class="Vector">*Vector</type>
      <description>
<p>The Next value refers to the next vector in the branch.  If the value is <code>NULL</code>, the vector is positioned at the end of the branch.</p>
<p>The Next value can be set to another vector at any time, on the condition that both vectors share the same owner.  If this is not true, change the current owner before setting the Next field.  Changing the Next value will result in updates to the <fl>Parent</fl> and <fl>Prev</fl> fields.</p>
      </description>
    </field>

    <field>
      <name>NumericID</name>
      <comment>A unique identifier for the vector.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>INT</type>
      <description>
<p>This field assigns a numeric ID to a vector.  Alternatively it can also reflect a case-sensitive hash of the <fl>ID</fl> field if that has been defined previously.</p>
<p>If NumericID is set by the client, then any value in <fl>ID</fl> will be immediately cleared.</p>
      </description>
    </field>

    <field>
      <name>Opacity</name>
      <comment>Defines an overall opacity for the vector's graphics.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>DOUBLE</type>
      <description>
<p>The overall opacity of a vector can be defined here using a value between 0 and 1.0.  The value will be multiplied with other opacity settings as required during rendering.  For instance, when filling a vector the opacity will be calculated as <code>
<fl>FillOpacity</fl> * Opacity</code>.</p>
      </description>
    </field>

    <field>
      <name>Parent</name>
      <comment>The parent of the vector, or NULL if this is the top-most vector.</comment>
      <access read="R">Read</access>
      <type>OBJECTPTR</type>
      <description>
<p>The Parent value will refer to the owner of the vector within its respective branch.  To check if the vector is at the top or bottom of its branch, please refer to the <fl>Prev</fl> and <fl>Next</fl> fields.</p>
      </description>
    </field>

    <field>
      <name>PathQuality</name>
      <comment>Defines the quality of a path when it is rendered.</comment>
      <access read="R" write="W">Read/Write</access>
      <type lookup="RQ">RQ</type>
      <description>
<p>Adjusting the render quality allows for fine adjustment of the paths produced by the rendering algorithms.  Although the default option of <code>AUTO</code> is recommended, it is optimal to lower the rendering quality to <code>CRISP</code> if the path is composed of lines at 45 degree increments and <code>FAST</code> if points are aligned to whole numbers when rendered to a bitmap.</p>
<types lookup="RQ"/>
      </description>
    </field>

    <field>
      <name>PathTimestamp</name>
      <comment>This counter is modified each time the path is regenerated.</comment>
      <access read="R">Read</access>
      <type>INT</type>
      <description>
<p>The PathTimestamp can be used as a basic means of recording the state of the vector's path, and checking that state for changes at a later time.  For more active monitoring and response, clients should subscribe to the <code>PATH_CHANGED</code> event.</p>
      </description>
    </field>

    <field>
      <name>Prev</name>
      <comment>The previous vector in the branch, or <code>NULL</code>.</comment>
      <access read="R" write="S">Read/Set</access>
      <type class="Vector">*Vector</type>
      <description>
<p>The Prev value refers to the previous vector in the branch.  If the value is <code>NULL</code>, then the vector is positioned at the top of the branch.</p>
<p>The Prev value can be set to another vector at any time, on the condition that both vectors share the same owner.  If this is not true, change the current owner before setting the Prev field.  Changing the value will result in updates to the <fl>Parent</fl> and <fl>Next</fl> values.</p>
      </description>
    </field>

    <field>
      <name>ResizeEvent</name>
      <comment>A callback to trigger when the host viewport is resized.</comment>
      <access write="S">Set</access>
      <type>FUNCTION</type>
      <description>
<p>Use ResizeEvent to receive feedback when the viewport that hosts the vector is resized.  The function prototype is <code>void callback(*VectorViewport, *Vector, DOUBLE X, DOUBLE Y, DOUBLE Width, DOUBLE Height, APTR Meta)</code></p>
<p>The dimension values refer to the current location and size of the viewport.</p>
<p>Note that this callback feature is provided for convenience.  Only one subscription to the viewport is possible at any time.  The conventional means for monitoring the size and position of any vector is to subscribe to the <code>PATH_CHANGED</code> event.</p>
      </description>
    </field>

    <field>
      <name>Scene</name>
      <comment>Short-cut to the top-level <class name="VectorScene">VectorScene</class>.</comment>
      <access read="R">Read</access>
      <type class="VectorScene">*VectorScene</type>
      <description>
<p>All vectors are required to be grouped within the hierarchy of a <class name="VectorScene">VectorScene</class>.  This requirement is enforced on initialisation and a reference to the top-level <class name="VectorScene">VectorScene</class> is recorded in this field.</p>
      </description>
    </field>

    <field>
      <name>Sequence</name>
      <comment>Convert the vector's path to the equivalent SVG path string.</comment>
      <access read="G">Get</access>
      <type>STRING</type>
      <description>
<p>The Sequence is a string of points and instructions that define the path.  It is based on the SVG standard for the path element <code>d</code> attribute, but also provides some additional features that are present in the vector engine.  Commands are case insensitive.</p>
<p>The following commands are supported:</p>
<pre>M: Move To
L: Line To
V: Vertical Line To
H: Horizontal Line To
Q: Quadratic Curve To
T: Quadratic Smooth Curve To
C: Curve To
S: Smooth Curve To
A: Arc
Z: Close Path
</pre>
<p>The use of lower case characters will indicate that the provided coordinates are relative (based on the coordinate of the previous command).</p>
      </description>
    </field>

    <field>
      <name>Stroke</name>
      <comment>Defines the stroke of a path using SVG's IRI format.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>STRING</type>
      <description>
<p>The stroker used for rendering a vector path can be defined through this field.  The string is parsed through the <function>ReadPainter</function> function in the Vector module.  Please refer to it for further details on valid formatting.</p>
      </description>
    </field>

    <field>
      <name>StrokeColour</name>
      <comment>Defines the colour of the path stroke in RGB float format.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>FLOAT []</type>
      <description>
<p>This field defines the colour that will be used in stroking a path, and is comprised of floating point RGBA values. The intensity of each component is measured from 0 - 1.0.  Stroking is disabled if the alpha value is 0.</p>
<p>This field is complemented by the <fl>StrokeOpacity</fl> and <fl>Stroke</fl> fields.</p>
      </description>
    </field>

    <field>
      <name>StrokeOpacity</name>
      <comment>Defines the opacity of the path stroke.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>DOUBLE</type>
      <description>
<p>The StrokeOpacity value expresses the opacity of a path stroke as a value between 0 and 1.0.  A value of zero would render the stroke invisible and the maximum value of one would render it opaque.</p>
<p>Please note that thinly stroked paths may not be able to appear as fully opaque in some cases due to anti-aliased rendering.</p>
      </description>
    </field>

    <field>
      <name>StrokeWidth</name>
      <comment>The width to use when stroking the path.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>DOUBLE</type>
      <description>
<p>The StrokeWidth defines the pixel width of a path when it is stroked.  The path will not be stroked if the value is zero.  A percentage can be used to define the stroke width if it should be scaled to the size of the viewbox (along its diagonal).  Note that this incurs a slight computational penalty when drawing.</p>
<p>The size of the stroke is also affected by scaling factors imposed by transforms and viewports.</p>
      </description>
    </field>

    <field>
      <name>TabOrder</name>
      <comment>Defines the priority of this vector within the tab order.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>INT</type>
      <description>
<p>If a vector maintains a keyboard subscription then it can define its priority within the tab order (the order in which vectors receive the focus when the user presses the tab key).  The highest priority is 1, the lowest is 255 (the default). When two vectors share the same priority, preference is given to the older of the two objects.</p>
      </description>
    </field>

    <field>
      <name>Transition</name>
      <comment>Reference a VectorTransition object here to apply multiple transforms over the vector's path.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>OBJECTPTR</type>
      <description>
<p>A transition can be applied by setting this field with a reference to a <class name="VectorTransition">VectorTransition</class> object.  Please refer to the <class name="VectorTransition">VectorTransition</class> class for further information.</p>
<p>Not all vector types are well-suited or adapted to the use of transitions.  At the time of writing, only <class name="VectorText">VectorText</class> and <class name="VectorWave">VectorWave</class> are able to take full advantage of this feature.</p>
      </description>
    </field>

    <field>
      <name>Visibility</name>
      <comment>Controls the visibility of a vector and its children.</comment>
      <access read="R" write="W">Read/Write</access>
      <type lookup="VIS">VIS</type>
      <description>
<types lookup="VIS"/>
      </description>
    </field>

  </fields>
  <types>
    <constants lookup="FM" comment="Mask for controlling feedback events that are received.">
      <const name="CHILD_HAS_FOCUS">A child of the vector has gained the user focus.</const>
      <const name="HAS_FOCUS">The vector has gained the user focus.</const>
      <const name="LOST_FOCUS">The vector has lost the user focus.</const>
      <const name="PATH_CHANGED">The vector path has been modified or affected by a transform.</const>
    </constants>

    <constants lookup="RQ">
      <const name="AUTO">The default option is chosen by the system.</const>
      <const name="BEST">Use the best quality renderer available and without concerns for computational time taken.</const>
      <const name="CRISP">Use a good quality renderer that produces crisp outlines (no anti-aliasing).</const>
      <const name="FAST">Use the fastest renderer available and allow accuracy to be compromised in favour of speed.  Recommended for normalised paths that are known to be rectangular.</const>
      <const name="PRECISE">Use a high quality renderer to produce accurate results.  Anti-aliasing will be enabled.</const>
    </constants>

    <constants lookup="VBF" comment="Options for vecGetBoundary().">
      <const name="INCLUSIVE">The result will be inclusive of all paths that belong to children of the queried vector.</const>
      <const name="NO_TRANSFORM">The transformation step will not be applied to the vector's path.</const>
    </constants>

    <constants lookup="VCS" comment="Colour space options.">
      <const name="INHERIT">Inherit the colour space option from the parent vector.</const>
      <const name="LINEAR_RGB">Linear RGB is the default colour space for SVG and produces the best results.</const>
      <const name="SRGB">The default colour-space is sRGB, recommended for its speed.</const>
    </constants>

    <constants lookup="VF" comment="Optional flags and indicators for the Vector class.">
      <const name="DISABLED">The vector is disabled and user input should be ignored.</const>
      <const name="HAS_FOCUS">The vector holds the user's input focus.</const>
      <const name="JOIN_PATHS">When appending a new path, use a join operation to connect the tail end to the head.</const>
    </constants>

    <constants lookup="VFR" comment="Vector fill rules for the FillRule field in the Vector class.">
      <const name="EVEN_ODD">This rule determines the 'insideness' of a point on the canvas by drawing a ray from that point to infinity in any direction and counting the number of path segments from the given shape that the ray crosses. If this number is odd, the point is inside; if even, the point is outside.</const>
      <const name="INHERIT">The rule is inherited from the parent vector(s).</const>
      <const name="NON_ZERO">This is the default.  This rule determines the 'insideness' of a point on the canvas by drawing a ray from that point to infinity in any direction and then examining the places where a segment of the shape crosses the ray. Starting with a count of zero, add one each time a path segment crosses the ray from left to right and subtract one each time a path segment crosses the ray from right to left. After counting the crossings, if the result is zero then the point is outside the path. Otherwise, it is inside.</const>
    </constants>

    <constants lookup="VIJ" comment="Inner join options for angled lines.">
      <const name="BEVEL">Blunts the edge of the join.</const>
      <const name="INHERIT">Inherit the parent's join value.</const>
      <const name="JAG">A special non-SVG option.</const>
      <const name="MITER">Forms a sharp point at the join.  Typically not the best looking option.</const>
      <const name="ROUND">Rounds the edge of the join to produce the best looking results.</const>
    </constants>

    <constants lookup="VIS" comment="Options for the Vector class' Visibility field.">
      <const name="COLLAPSE">Hide the vector and its children.  Do not use - provided for SVG compatibility only.</const>
      <const name="HIDDEN">Hide the vector and its children.</const>
      <const name="INHERIT">Inherit the visibility state from the parent.</const>
      <const name="VISIBLE">The default.  Ensures that the vector is visible.</const>
    </constants>

    <constants lookup="VLC" comment="Line-cap options.">
      <const name="BUTT">The default.  The line is sharply squared off at its exact end point.</const>
      <const name="INHERIT">The cap type is inherited from the parent (defaults to butt if unspecified).</const>
      <const name="ROUND">The line cap is a half-circle and the line's end-point forms the center point.</const>
      <const name="SQUARE">Similar to butt, the line is sharply squared off but will extend past the end point by <code>StrokeWidth / 2</code>.</const>
    </constants>

    <constants lookup="VLJ" comment="Options for the look of line joins.">
      <const name="BEVEL">The join is blunted, eliminating overly sharp edges.</const>
      <const name="INHERIT">Inherit the join option from the parent.</const>
      <const name="MITER">The default.  The join will form a pointed edge.</const>
      <const name="MITER_REVERT"/>
      <const name="MITER_ROUND">Default to <code>MITER</code>, but switch to <code>ROUND</code> if the miter limit is exceeded.</const>
      <const name="ROUND">The join is rounded.</const>
    </constants>

  </types>
  <structs>
    <struct name="VectorMatrix" comment="Vector transformation matrix.">
      <field name="Next" type="struct VectorMatrix *">The next transform in the list.</field>
      <field name="Vector" type="objVector *">The vector associated with the transform.</field>
      <field name="ScaleX" type="DOUBLE">Matrix value A</field>
      <field name="ShearY" type="DOUBLE">Matrix value B</field>
      <field name="ShearX" type="DOUBLE">Matrix value C</field>
      <field name="ScaleY" type="DOUBLE">Matrix value D</field>
      <field name="TranslateX" type="DOUBLE">Matrix value E</field>
      <field name="TranslateY" type="DOUBLE">Matrix value F</field>
      <field name="Tag" type="LONG">An optional tag value defined by the client for matrix identification.</field>
    </struct>

  </structs>
</book>
