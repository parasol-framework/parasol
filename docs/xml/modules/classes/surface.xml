<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="class.xsl"?>

<book>
  <info>
    <name>Surface</name>
    <type>class</type>
    <module>Display</module>
    <comment>Manages the display and positioning of 2-Dimensional rendered graphics.</comment>
    <version>1</version>
    <id>b15cfb8e</id>
    <idstring>ID_SURFACE</idstring>
    <category>GUI</category>
    <include>modules/surface.h</include>
    <copyright>Paul Manias 2003-2024</copyright>
    <description>
<p>The Surface class is used to manage the positioning, drawing and interaction with layered display interfaces.  It works in conjunction with the <class name="Bitmap">Bitmap</class> class for rendering graphics, and the <class name="Pointer">Pointer</class> class for user interaction.</p>
<p>On a platform such as Windows or Linux, the top-level surface will typically be hosted in an application window.  On Android or when a full screen display is required, a surface can cover the entire display and be window-less.  The top-level surface can act as a host to additional surfaces, which are referred to as children. Placing more surface objects inside of these children will create a hierarchy of many objects that requires sophisticated management that is provisioned by the Surface class.</p>
<p>Although pure surface based UI's are possible, clients should always pursue the more simplistic approach of using surfaces to host <class name="VectorScene">VectorScene</class> objects that describe vector based interfaces.  Doing so is in keeping with our goal of proving fully scalable interfaces to users, and we optimise features with that use-case in mind.</p></description>
    <source>
      <file path="class_surface/">class_surface.cpp</file>
      <file path="class_surface/">surface_dimensions.cpp</file>
      <file path="class_surface/">surface_drawing.cpp</file>
      <file path="class_surface/">surface_fields.cpp</file>
      <file path="class_surface/">surface_resize.cpp</file>
    </source>
  </info>

  <actions>
    <action>
      <name>Activate</name>
      <comment>Shows a surface object on the display.</comment>
      <prototype>ERR acActivate(*Object)</prototype>
    </action>

    <action>
      <name>Disable</name>
      <comment>Disables a surface object.</comment>
      <prototype>ERR acDisable(*Object)</prototype>
    </action>

    <action>
      <name>Draw</name>
      <comment>Redraws the contents of a surface object.</comment>
      <prototype>ERR acDraw(*Object, DOUBLE X, DOUBLE Y, DOUBLE Width, DOUBLE Height)</prototype>
      <input>
        <param type="LONG" name="X">The X position of the region to be drawn.</param>
        <param type="LONG" name="Y">The Y position of the region to be drawn.</param>
        <param type="LONG" name="Width">The width of the region to be drawn.</param>
        <param type="LONG" name="Height">The height of the region to be drawn.</param>
      </input>
      <description>
<p>Calling the Draw action on a surface object will send redraw messages to every hook that has been attached to the surface object's drawing system.  This has the effect of redrawing all graphics within the surface object.  The procedure is as follows:</p>
<list type="ordered">
<li>If the surface object's <fl>Colour</fl> field has been set, the target bitmap will be cleared to that colour.</li>
<li>If the surface is volatile, graphics from background surfaces will be copied to the  target bitmap.</li>
<li>Subscribers to the surface object are now called via their hooks so that they can draw to the bitmap.</li>
<li>The bitmap is copied to the video display buffer to complete the process.</li>
</list>
<p>Please be aware that:</p>
<list>
<li>If the target surface contains child surfaces, they will not be redrawn unless they are volatile (using special
effects such as transparency, or using the region flag will make a surface volatile).</li>
<li>If the surface object has not had its background colour set, or if the object is not volatile, the bitmap
contents will not be automatically cleared (this is advantageous in situations where a particular object will clear
the surface area first).</li>
</list>
      </description>
    </action>

    <action>
      <name>Enable</name>
      <comment>Enables a disabled surface object.</comment>
      <prototype>ERR acEnable(*Object)</prototype>
    </action>

    <action>
      <name>Focus</name>
      <comment>Changes the primary user focus to the surface object.</comment>
      <prototype>ERR acFocus(*Object)</prototype>
    </action>

    <action>
      <name>Hide</name>
      <comment>Hides a surface object from the display.</comment>
      <prototype>ERR acHide(*Object)</prototype>
    </action>

    <action>
      <name>LostFocus</name>
      <comment>Informs a surface object that it has lost the user focus.</comment>
      <prototype>ERR acLostFocus(*Object)</prototype>
    </action>

    <action>
      <name>Move</name>
      <comment>Moves a surface object to a new display position.</comment>
      <prototype>ERR acMove(*Object, DOUBLE DeltaX, DOUBLE DeltaY, DOUBLE DeltaZ)</prototype>
      <input>
        <param type="DOUBLE" name="DeltaX">The number of units to move along the X axis.</param>
        <param type="DOUBLE" name="DeltaY">The number of units to move along the Y axis.</param>
        <param type="DOUBLE" name="DeltaZ">The number of units to move along the Z axis.</param>
      </input>
    </action>

    <action>
      <name>MoveToBack</name>
      <comment>Moves a surface object to the back of its container.</comment>
      <prototype>ERR acMoveToBack(*Object)</prototype>
    </action>

    <action>
      <name>MoveToFront</name>
      <comment>Moves a surface object to the front of its container.</comment>
      <prototype>ERR acMoveToFront(*Object)</prototype>
    </action>

    <action>
      <name>MoveToPoint</name>
      <comment>Moves a surface object to an absolute coordinate.</comment>
      <prototype>ERR acMoveToPoint(*Object, DOUBLE X, DOUBLE Y, DOUBLE Z, MTF Flags)</prototype>
      <input>
        <param type="DOUBLE" name="X">The new X position to move the object to.</param>
        <param type="DOUBLE" name="Y">The new Y position to move the object to.</param>
        <param type="DOUBLE" name="Z">The new Z position to move the object to.</param>
        <param type="MTF" name="Flags" lookup="MTF">Set the relevant MTF flag for each provided parameter.</param>
      </input>
    </action>

    <action>
      <name>Redimension</name>
      <comment>Moves and resizes a surface object in a single action call.</comment>
      <prototype>ERR acRedimension(*Object, DOUBLE X, DOUBLE Y, DOUBLE Z, DOUBLE Width, DOUBLE Height, DOUBLE Depth)</prototype>
      <input>
        <param type="DOUBLE" name="X">The new X position to apply to the target object.</param>
        <param type="DOUBLE" name="Y">The new Y position to apply to the target object.</param>
        <param type="DOUBLE" name="Z">The new Z position to apply to the target object.</param>
        <param type="DOUBLE" name="Width">The new width of the target object.</param>
        <param type="DOUBLE" name="Height">The new height of the target object.</param>
        <param type="DOUBLE" name="Depth">The new depth of the target object.</param>
      </input>
    </action>

    <action>
      <name>Resize</name>
      <comment>Alters the dimensions of a surface object.</comment>
      <prototype>ERR acResize(*Object, DOUBLE Width, DOUBLE Height, DOUBLE Depth)</prototype>
      <input>
        <param type="DOUBLE" name="Width">The new width of the object.</param>
        <param type="DOUBLE" name="Height">The new height of the object.</param>
        <param type="DOUBLE" name="Depth">The new depth of the object.</param>
      </input>
    </action>

    <action>
      <name>SaveImage</name>
      <comment>Saves the graphics of a surface object.</comment>
      <prototype>ERR acSaveImage(*Object, OBJECTID Dest, CLASSID ClassID)</prototype>
      <input>
        <param type="OBJECTID" name="Dest">Refers to an object that will receive the encoded image data.</param>
        <param type="CLASSID" name="ClassID">The Picture class to use for encoding the image data.</param>
      </input>
      <description>
<p>To store the rendered image of a surface object, use the SaveImage() action.  Calling SaveImage() on a surface object will cause it to render an image of its contents and save them to the given destination object.  Any child surfaces in the region will also be included in the resulting image data.</p>
<p>The image data will be saved in the data format that is indicated by the setting in the <code>ClassID</code> parameter.  Options are limited to members of the <class name="Picture">Picture</class> class, for example <code>CLASSID::JPEG</code> and <code>CLASSID::PICTURE</code> (PNG).  If no <code>ClassID</code> is specified, the user's preferred default file format is used.</p>
      </description>
    </action>

    <action>
      <name>Show</name>
      <comment>Shows a surface object on the display.</comment>
      <prototype>ERR acShow(*Object)</prototype>
    </action>

  </actions>

  <methods>
    <method>
      <name>AddCallback</name>
      <comment>Inserts a function hook into the drawing process of a surface object.</comment>
      <prototype>ERR drw::AddCallback(OBJECTPTR Object, FUNCTION * Callback)</prototype>
      <input>
        <param type="FUNCTION *" name="Callback">Pointer to the callback routine or NULL to remove callbacks for the given Object.</param>
      </input>
      <description>
<p>The AddCallback() method provides a hook for custom functions to draw directly to a surface.  Whenever a surface object performs a redraw event, all functions inserted by this method will be called in their original subscription order with a direct reference to the Surface's target bitmap.  The C/C++ prototype is <code>Function(APTR Context, *Surface, *Bitmap, APTR Meta)</code>.</p>
<p>The Fluid prototype is <code>function draw(Surface, Bitmap)</code></p>
<p>The subscriber can draw to the bitmap surface as it would with any freshly allocated bitmap object (refer to the <class name="Bitmap">Bitmap</class> class).  To get the width and height of the available drawing space, please read the Width and Height fields from the Surface object.  If writing to the bitmap directly, please observe the bitmap's clipping region and the XOffset and YOffset values.</p>
      </description>
      <result>
        <error code="Okay">Operation successful.</error>
        <error code="AllocMemory">A call to AllocMemory() failed to create a new memory block.</error>
        <error code="NullArgs">Function call missing argument value(s)</error>
        <error code="ExecViolation">The call was not made from the process that owns the object.</error>
      </result>
    </method>

    <method>
      <name>ExposeToDisplay</name>
      <comment>Redraws a surface region to the display, preferably from its graphics buffer.</comment>
      <prototype>ERR drw::ExposeToDisplay(OBJECTPTR Object, LONG X, LONG Y, LONG Width, LONG Height, EXF Flags)</prototype>
      <input>
        <param type="LONG" name="X">X coordinate of the expose area.</param>
        <param type="LONG" name="Y">Y coordinate of the expose area.</param>
        <param type="LONG" name="Width">Width of the expose area.</param>
        <param type="LONG" name="Height">Height of the expose area.</param>
        <param type="EXF" name="Flags" lookup="EXF">Optional flags.</param>
      </input>
      <description>
<p>Call the ExposeToDisplay() method to copy a surface region to the display.  The functionality is identical to that of the <function module="Surface">ExposeSurface</function> function.  Please refer to it for further documentation.</p>
      </description>
      <result>
        <error code="Okay">Operation successful.</error>
      </result>
    </method>

    <method>
      <name>InvalidateRegion</name>
      <comment>Redraws all of the content in a surface object.</comment>
      <prototype>ERR drw::InvalidateRegion(OBJECTPTR Object, LONG X, LONG Y, LONG Width, LONG Height)</prototype>
      <input>
        <param type="LONG" name="X">X coordinate of the region to invalidate.</param>
        <param type="LONG" name="Y">Y coordinate of the region to invalidate.</param>
        <param type="LONG" name="Width">Width of the region to invalidate.</param>
        <param type="LONG" name="Height">Height of the region to invalidate.</param>
      </input>
      <description>
<p>Invalidating a surface object will cause everything within a specified area to be redrawn.  This includes child surface objects that intersect with the area that you have specified.  Parent regions that overlap are not included in the redraw.</p>
<p>To quickly redraw an entire surface object's content, call this method directly without supplying an argument structure. If you want to redraw a surface object and ignore all of its surface children then you should use the Draw action instead of this method.</p>
<p>If you want to refresh a surface area to the display then you should use the <method>ExposeToDisplay</method> method instead.  Exposing will use the graphics buffer to refresh the graphics, thus avoiding the speed loss of a complete redraw.</p>
      </description>
      <result>
        <error code="Okay">Operation successful.</error>
        <error code="AccessMemory">Failed to access the internal surface list.</error>
      </result>
    </method>

    <method>
      <name>Minimise</name>
      <comment>For hosted surfaces only, this method will minimise the surface to an icon.</comment>
      <prototype>ERR drw::Minimise(OBJECTPTR Object)</prototype>
      <description>
<p>If a surface is hosted in a desktop window, calling the Minimise() method will perform the default minimise action on that window.  On a platform such as Microsoft Windows, this would normally result in the window being minimised to the task bar.</p>
<p>Calling Minimise() on a surface that is already in the minimised state may result in the host window being restored to the desktop.  This behaviour is platform dependent and should be manually tested to confirm its reliability on the host platform.</p>
      </description>
    </method>

    <method>
      <name>RemoveCallback</name>
      <comment>Removes a callback previously inserted by AddCallback().</comment>
      <prototype>ERR drw::RemoveCallback(OBJECTPTR Object, FUNCTION * Callback)</prototype>
      <input>
        <param type="FUNCTION *" name="Callback">Pointer to the callback routine to remove, or NULL to remove all assoicated callback routines.</param>
      </input>
      <description>
<p>The RemoveCallback() method is used to remove any callback that has been previously inserted by <method>AddCallback</method>.</p>
<p>This method is scope restricted, meaning that callbacks added by other objects will not be affected irrespective of the parameters that are passed to it.</p>
      </description>
      <result>
        <error code="Okay">Operation successful.</error>
        <error code="Search">A search routine in this function failed.</error>
      </result>
    </method>

    <method>
      <name>ResetDimensions</name>
      <comment>Changes the dimensions of a surface.</comment>
      <prototype>ERR drw::ResetDimensions(OBJECTPTR Object, DOUBLE X, DOUBLE Y, DOUBLE XOffset, DOUBLE YOffset, DOUBLE Width, DOUBLE Height, LONG Dimensions)</prototype>
      <input>
        <param type="DOUBLE" name="X">New X coordinate.</param>
        <param type="DOUBLE" name="Y">New Y coordinate.</param>
        <param type="DOUBLE" name="XOffset">New X offset.</param>
        <param type="DOUBLE" name="YOffset">New Y offset.</param>
        <param type="DOUBLE" name="Width">New width.</param>
        <param type="DOUBLE" name="Height">New height.</param>
        <param type="LONG" name="Dimensions" lookup="DMF">Dimension flags.</param>
      </input>
      <description>
<p>The ResetDimensions() method provides a simple way of re-declaring the dimensions of a surface object.  This is sometimes necessary when a surface needs to make a significant alteration to its display configuration.  For instance if the width of the surface is declared through a combination of <code>X</code> and <code>XOffset</code> settings and the width needs to change to a fixed setting, then ResetDimensions() will have to be used.</p>
<p>It is not necessary to define a value for every parameter - only the ones that are relevant to the new dimension settings.  For instance if <code>X</code> and <code>Width</code> are set, <code>XOffset</code> is ignored and the Dimensions value must include <code>DMF_FIXED_X</code> and <code>DMF_FIXED_WIDTH</code> (or the relative equivalents).  Please refer to the <fl>Dimensions</fl> field for a full list of dimension flags that can be specified.</p>
      </description>
      <result>
        <error code="Okay">Operation successful.</error>
        <error code="AccessMemory">Unable to access internal surface list.</error>
        <error code="NullArgs">Function call missing argument value(s)</error>
      </result>
    </method>

    <method>
      <name>ScheduleRedraw</name>
      <comment>Schedules a redraw operation for the next frame.</comment>
      <prototype>ERR drw::ScheduleRedraw(OBJECTPTR Object)</prototype>
      <description>
<p>Use ScheduleRedraw to indicate that a surface needs to be drawn to the display.  The surface and all child surfaces will be drawn on the next frame cycle (typically 1/60th of a second).  All manual draw operations for the target surface are ignored until the scheduled operation is completed.</p>
<p>Scheduling is ideal in situations where a cluster of redraw events may occur within a tight time period, and it would be inefficient to draw those changes to the display individually.</p>
<p>Note that redraw schedules do not 'see each other', meaning if a surface and a child are both scheduled, this will trigger two redraw operations when one would suffice.  It is the client's responsibility to target the most relevant top-level surface for scheduling.</p>
      </description>
      <result>
        <error code="Okay">Operation successful.</error>
      </result>
    </method>

    <method>
      <name>SetDisplay</name>
      <comment>Changes the screen resolution (applies to top-level surface objects only).</comment>
      <prototype>ERR drw::SetDisplay(OBJECTPTR Object, LONG X, LONG Y, LONG Width, LONG Height, LONG InsideWidth, LONG InsideHeight, LONG BitsPerPixel, DOUBLE RefreshRate, LONG Flags)</prototype>
      <input>
        <param type="LONG" name="X">The horizontal coordinate/offset for the display.</param>
        <param type="LONG" name="Y">The vertical coordinate/offset for the display.</param>
        <param type="LONG" name="Width">The width of the display.</param>
        <param type="LONG" name="Height">The height of the display.</param>
        <param type="LONG" name="InsideWidth">The page width of the display must be the same as Width or greater.</param>
        <param type="LONG" name="InsideHeight">The page height of the display must be the same as Height or greater.</param>
        <param type="LONG" name="BitsPerPixel">Bits per pixel - 15, 16, 24 or 32.</param>
        <param type="DOUBLE" name="RefreshRate">Refresh rate.</param>
        <param type="LONG" name="Flags">Optional flags.</param>
      </input>
      <description>
<p>The SetDisplay method is used to change the screen resolution of the top-level surface object (which represents the screen display).  It allows you to set the size of the display and you may also change the bitmap depth and the monitor's refresh rate.  If successful, the change is immediate.</p>
<p>This method exercises some intelligence in adjusting the display to your requested settings.  For instance, if the requested width and/or height is not available, the closest display setting will be chosen.</p>
<p>This method does not work on anything other than top-level surface objects.  The current top-level surface object is usually named "SystemSurface" by default and can be searched for by that name.</p>
      </description>
      <result>
        <error code="Okay">Operation successful.</error>
        <error code="Failed">General failure.</error>
        <error code="Args">Invalid arguments passed to function.</error>
      </result>
    </method>

    <method>
      <name>SetOpacity</name>
      <comment>Alters the opacity of a surface object.</comment>
      <prototype>ERR drw::SetOpacity(OBJECTPTR Object, DOUBLE Value, DOUBLE Adjustment)</prototype>
      <input>
        <param type="DOUBLE" name="Value">The new opacity value between 0 and 100% (ignored if you have set the Adjustment parameter).</param>
        <param type="DOUBLE" name="Adjustment">Adjustment value to add or subtract from the existing opacity (set to zero if you want to set a fixed Value instead).</param>
      </input>
      <description>
<p>This method will change the opacity of the surface and execute a redraw to make the changes to the display.</p>
      </description>
      <result>
        <error code="Okay">The opacity of the surface object was changed.</error>
        <error code="NullArgs">Function call missing argument value(s)</error>
      </result>
    </method>

  </methods>

  <fields>
    <field>
      <name>AbsX</name>
      <comment>The absolute horizontal position of a surface object.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>INT</type>
      <description>
<p>This field returns the absolute horizontal position of a surface object. The absolute value is calculated based on the surface object's position relative to the top most surface object in the local hierarchy.</p>
<p>It is possible to set this field, but only after initialisation of the surface object has occurred.</p>
      </description>
    </field>

    <field>
      <name>AbsY</name>
      <comment>The absolute vertical position of a surface object.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>INT</type>
      <description>
<p>This field returns the absolute vertical position of a surface object. The absolute value is calculated based on the surface object's position relative to the top most surface object in the local hierarchy.</p>
<p>It is possible to set this field, but only after initialisation of the surface object has occurred.</p>
      </description>
    </field>

    <field>
      <name>Align</name>
      <comment>This field allows you to align a surface area within its owner.</comment>
      <access read="R" write="W">Read/Write</access>
      <type lookup="ALIGN">ALIGN</type>
      <description>
<p>If you would like to set an abstract position for a surface area, you can give it an alignment.  This feature is most commonly used for horizontal and vertical centring, as aligning to the the edges of a surface area is already handled by existing dimension fields.  Note that setting the alignment overrides any settings in related coordinate fields. Valid alignment flags are <code>BOTTOM</code>, <code>CENTER/MIDDLE</code>, <code>LEFT</code>, <code>HORIZONTAL</code>, <code>RIGHT</code>, <code>TOP</code>, <code>VERTICAL</code>.</p>
<types lookup="ALIGN"/>
      </description>
    </field>

    <field>
      <name>BitsPerPixel</name>
      <comment>Defines the number of bits per pixel for a surface.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>INT</type>
      <description>
<p>The BitsPerPixel field may be set prior to initialisation in order to force a particular bits-per-pixel setting that may not match the display.  This will result in the graphics system converting each pixel when drawing the surface to the display and as such is not recommended.</p>
      </description>
    </field>

    <field>
      <name>Bottom</name>
      <comment>Returns the bottom-most coordinate of a surface object, <code>Y + Height</code>.</comment>
      <access read="G">Get</access>
      <type>INT</type>
    </field>

    <field>
      <name>BottomLimit</name>
      <comment>Prevents a surface object from moving beyond a given point at the bottom of its container.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>INT</type>
      <description>
<p>A client can prevent a surface object from moving beyond a given point at the bottom of its container by setting this field. If for example you were to set the BottomLimit to 5, then any attempt to move the surface object into or beyond the 5 units at the bottom of its container would fail.</p>
<p>Limits only apply to movement, as induced through the <action>Move</action> action.  This means that limits can be over-ridden by setting the coordinate fields directly (which can be useful in certain cases).</p>
      </description>
    </field>

    <field>
      <name>BottomMargin</name>
      <comment>Manipulates the bottom margin of a surface object.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>INT</type>
      <description>
<p>The Surface class supports margin settings, which are similar to the concept of margins on printed paper.  Margin values have no significant meaning or effect on a surface object itself, but they are often used by other objects and can be helpful in interface construction.  For instance, the Window script uses margins to indicate the space available for placing graphics and other surface objects inside of it.</p>
<p>By default, all margins are set to zero when a new surface object is created.</p>
      </description>
    </field>

    <field>
      <name>Buffer</name>
      <comment>The ID of the bitmap that manages the surface's graphics.</comment>
      <access read="R">Read</access>
      <type>OBJECTID</type>
      <description>
<p>Each surface is assigned a bitmap buffer that is referred to in this field. In many cases the bitmap will be shared between multiple surfaces.  A client should avoid interacting with the buffer unless circumstances are such that there are no other means to get access to internal graphics information.</p>
<p>Please note that the bitmap object represents an off-screen, temporary buffer.  Drawing to the bitmap directly will have no impact on the display.</p>
      </description>
    </field>

    <field>
      <name>Colour</name>
      <comment>String-based field for setting the background colour.</comment>
      <access read="R" write="W">Read/Write</access>
      <type>RGB8</type>
      <description>
<p>If the surface object should have a plain background colour, set this field to the colour value that you want to use. The colour must be specified in the standard format of <code>#RRGGBB</code> for hexadecimal or <code>Red,Green,Blue</code> for decimal components.</p>
<p>Surface objects that do not have a colour will not be cleared when being drawn.  The background will thus consist of 'junk' graphics and the background will need to be drawn using another method.  This gives your the power to choose the fastest drawing model to suit your needs.</p>
<p>If you set the Colour and later want to turn the background colour off, write a <code>NULL</code> value to the Colour field or set the Alpha component to zero.  Changing the Colour field does not cause a graphics redraw.</p>
      </description>
    </field>

    <field>
      <name>Cursor</name>
      <comment>A default cursor image can be set here for changing the mouse pointer.</comment>
      <access read="R" write="S">Read/Set</access>
      <type lookup="PTC">PTC</type>
      <description>
<p>The Cursor field provides a convenient way of setting the pointer's cursor image in a single operation.  The mouse pointer will automatically switch to the specified cursor image when it enters the surface area.</p>
<p>The available cursor image settings are listed in the <class name="Pointer" field="CursorID">Pointer.CursorID</class> documentation.</p>
<p>The Cursor field may be written with valid cursor names or their ID's, as you prefer.</p>
<types lookup="PTC"/>
      </description>
    </field>

    <field>
      <name>Dimensions</name>
      <comment>Indicates currently active dimension settings.</comment>
      <access read="R" write="S">Read/Set</access>
      <type lookup="DMF">INT</type>
      <description>
<p>The dimension settings of a surface object can be read from this field.  The flags indicate the dimension fields that are in use, and whether the values are fixed or relative.</p>
<p>It is strongly recommended that this field is never set manually, because the flags are automatically managed for the client when setting fields such as <fl>X</fl> and <fl>Width</fl>.  If circumstances require manual configuration, take care to ensure that the flags do not conflict.  For instance, <code>FIXED_X</code> and <code>SCALED_X</code> cannot be paired, nor could <code>FIXED_X</code>, <code>FIXED_XOFFSET</code> and <code>FIXED_WIDTH</code> simultaneously.</p>
<types lookup="DMF"/>
      </description>
    </field>

    <field>
      <name>Display</name>
      <comment>Refers to the <class name="Display">Display</class> object that is managing the surface's graphics.</comment>
      <access read="R">Read</access>
      <type>OBJECTID</type>
      <description>
<p>All surfaces belong to a <class name="Display">Display</class> object that manages drawing to the user's video display.  This field refers to the Display object of which the surface is a member.</p>
      </description>
    </field>

    <field>
      <name>Drag</name>
      <comment>This object-based field is used to control the dragging of objects around the display.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>OBJECTID</type>
      <description>
<p>Click-dragging of surfaces is enabled by utilising the Drag field.</p>
<p>To use, write this field with reference to a Surface that is to be dragged when the user starts a click-drag operation. For instance, if you create a window with a title-bar at the top, you would set the Drag field of the title-bar to point to the object ID of the window. If necessary, you can set the Drag field to point back to your surface object (this can be useful for creating icons and other small widgets).</p>
<p>To turn off dragging, set the field to zero.</p>
      </description>
    </field>

    <field>
      <name>DragStatus</name>
      <comment>Indicates the draggable state when dragging is enabled.</comment>
      <access read="R">Read</access>
      <type lookup="DRAG">DRAG</type>
      <description>
<p>If the surface is draggable, the DragStatus indicates the current state of the surface with respect to it being dragged.</p>
<types lookup="DRAG"/>
      </description>
    </field>

    <field>
      <name>Flags</name>
      <comment>Optional flags.</comment>
      <access read="R" write="S">Read/Set</access>
      <type lookup="RNF">RNF</type>
      <description>
<p>The Flags field allows special options to be set for a surface object.  Use a logical-OR operation when setting this field so that existing flags are not overwritten.  To not do so can produce unexpected behaviour.</p>
<types lookup="RNF"/>
      </description>
    </field>

    <field>
      <name>Height</name>
      <comment>Defines the height of a surface object.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>INT</type>
      <description>
<p>The height of a surface object is manipulated through this field.  Alternatively, use the <action>Resize</action> action to adjust the Width and Height at the same time.  A client can set the Height as a fixed value by default, or as a scaled value in conjunction with the <code>FD_SCALED</code> flag.  Scaled values are multiplied by the height of their parent container.</p>
<p>Setting the Height while a surface object is on display causes an immediate graphical update to reflect the change. Any objects that are within the surface area will be re-drawn and resized as necessary.</p>
<p>If a value less than zero is passed to an initialised surface, the height will be 'turned off' - this is convenient for pairing the <fl>Y</fl> and <fl>YOffset</fl> fields together for dynamic height adjustment.</p>
      </description>
    </field>

    <field>
      <name>InsideHeight</name>
      <comment>Defines the amount of space between the vertical margins.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>INT</type>
      <description>
<p>A client can determine the internal height of a surface object by reading the InsideHeight field.  The returned value is the result of calculating this formula: <code>Height - TopMargin - BottomMargin</code>.</p>
<p>If the <fl>TopMargin</fl> and <fl>BottomMargin</fl> fields are not set, the returned value will be equal to the surface object's height.</p>
      </description>
    </field>

    <field>
      <name>InsideWidth</name>
      <comment>Defines the amount of space between the horizontal margins.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>INT</type>
      <description>
<p>A client can determine the internal width of a surface object by reading the InsideWidth field.  The returned value is the result of calculating this formula: <code>Width - LeftMargin - RightMargin</code>.</p>
<p>If the <fl>LeftMargin</fl> and <fl>RightMargin</fl> fields are not set, the returned value will be equal to the surface object's width.</p>
      </description>
    </field>

    <field>
      <name>LeftLimit</name>
      <comment>Prevents a surface object from moving beyond a given point on the left-hand side.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>INT</type>
      <description>
<p>A client can prevent a surface object from moving beyond a given point at the left-hand side of its container by setting this field.  If for example you were to set the LeftLimit to 3, then any attempt to move the surface object into or beyond the 3 units at the left of its container would fail.</p>
<p>Limits only apply to movement, as induced through the <action>Move</action> action.  This means it is possible to override limits by setting the coordinate fields directly.</p>
      </description>
    </field>

    <field>
      <name>LeftMargin</name>
      <comment>Manipulates the left margin of a surface object.</comment>
      <access read="R" write="W">Read/Write</access>
      <type>INT</type>
      <description>
<p>The Surface class supports margin settings, which are similar to the concept of margins on printed paper.  Margin values have no significant meaning or effect on a surface object itself, but they are often used by other objects and can be helpful in interface construction.  For instance, the Window template uses margins to indicate the space available for placing graphics and other surface objects inside of it.</p>
<p>By default, all margins are set to zero when a new surface object is created.</p>
      </description>
    </field>

    <field>
      <name>MaxHeight</name>
      <comment>Prevents the height of a surface object from exceeding a certain value.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>INT</type>
      <description>
<p>A client can limit the maximum height of a surface object by setting this field.  Limiting the height affects resizing, making it impossible to use the Resize() action to extend beyond the height you specify.</p>
<p>It is possible to circumvent the MaxHeight by setting the Height field directly.  Note that the MaxHeight value refers to the inside-height of the surface area, thus the overall maximum height will include both the <fl>TopMargin</fl> and <fl>BottomMargin</fl> values.</p>
      </description>
    </field>

    <field>
      <name>MaxWidth</name>
      <comment>Prevents the width of a surface object from exceeding a certain value.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>INT</type>
      <description>
<p>A client can limit the maximum width of a surface object by setting this field.  Limiting the width affects resizing, making it impossible to use the <action>Resize</action> action to extend beyond the width you specify.</p>
<p>It is possible to circumvent the MaxWidth by setting the Width field directly.  Note that the MaxWidth value refers to the inside-width of the surface area, thus the overall maximum width will include both the <fl>LeftMargin</fl> and <fl>RightMargin</fl> values.</p>
      </description>
    </field>

    <field>
      <name>MinHeight</name>
      <comment>Prevents the height of a surface object from shrinking beyond a certain value.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>INT</type>
      <description>
<p>A client can prevent the height of a surface object from shrinking too far by setting this field.  This feature specifically affects resizing, making it impossible to use the Resize() action to shrink the height of a surface object to a value less than the one you specify.</p>
<p>It is possible to circumvent the MinHeight by setting the <fl>Height</fl> field directly.</p>
      </description>
    </field>

    <field>
      <name>MinWidth</name>
      <comment>Prevents the width of a surface object from shrinking beyond a certain value.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>INT</type>
      <description>
<p>A client can prevent the width of a surface object from shrinking too far by setting this field.  This feature specifically affects resizing, making it impossible to use the <action>Resize</action> action to shrink the width of a surface object to a value less than the one you specify.</p>
<p>It is possible to circumvent the MinWidth by setting the <fl>Width</fl> field directly.</p>
      </description>
    </field>

    <field>
      <name>Modal</name>
      <comment>Sets the surface as modal (prevents user interaction with other surfaces).</comment>
      <access read="R" write="S">Read/Set</access>
      <type>INT</type>
      <description>
<p>If <code>true</code>, the surface will become the modal surface for the program when it is shown.  This prevents interaction with other surfaces until the modal surface is either hidden or destroyed.  Children of the modal surface may be interacted with normally.</p>
      </description>
    </field>

    <field>
      <name>Movement</name>
      <comment>Limits the movement of a surface object to vertical or horizontal shifts.</comment>
      <access read="R" write="S">Read/Set</access>
      <type lookup="MOVE">INT</type>
      <description>
<p>The directions in which a surface object can move can be limited by setting the Movement field.  By default, a surface object is capable of moving both horizontally and vertically.</p>
<p>This field is only effective in relation to the Move action, and it is possible to circumvent the restrictions by setting the coordinate fields directly.</p>
<types lookup="MOVE"/>
      </description>
    </field>

    <field>
      <name>Opacity</name>
      <comment>Affects the level of translucency applied to a surface object.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>DOUBLE</type>
      <description>
<p>This field determines the translucency level of a surface area.  The default setting is 100%, which means that the surface will be solid.  Any other value that you set here will alter the impact of a surface over its destination area. High values will retain the boldness of the graphics, while low values can surface it close to invisible.</p>
<p>Note: The translucent drawing routine works by drawing the surface content to its internal buffer first, then copying the graphics that are immediately in the background straight over the top with an alpha-blending routine.  This is not always ideal and better results might be obtainable with the pre-copy feature.</p>
<p>Please note that the use of translucency is realised at a significant cost to CPU usage.</p>
      </description>
    </field>

    <field>
      <name>Parent</name>
      <comment>The parent for a surface is defined here.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>OBJECTID</type>
      <description>
<p>The parent for child surfaces is defined here.  Top level surfaces will have no parent.  If the Parent field is not set prior to initialisation, the surface class will attempt to discover a valid parent by checking its ownership chain for a surface object.  This behaviour can be switched off by setting a Parent of zero prior to initialisation.</p>
      </description>
    </field>

    <field>
      <name>PopOver</name>
      <comment>Keeps a surface in front of another surface in the Z order.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>OBJECTID</type>
      <description>
<p>Setting the PopOver field to a sibling surface ID will keep the surface in front of its sibling at all times.  For dialog windows, it is recommended that the popover and modal options be combined together to prevent interaction with other surfaces created by the current program.</p>
<p>Setting the PopOver field to zero will return the surface to its normal state.</p>
<p>If an object that does not belong to the Surface class is detected, an attempt will be made to read that object's Surface field, if available.  If this does not yield a valid surface then <code>ERR::InvalidObject</code> is returned.</p>
      </description>
    </field>

    <field>
      <name>Right</name>
      <comment>Returns the right-most coordinate of a surface object, <code>X + Width</code>.</comment>
      <access read="G">Get</access>
      <type>INT</type>
    </field>

    <field>
      <name>RightLimit</name>
      <comment>Prevents a surface object from moving beyond a given point on the right-hand side.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>INT</type>
      <description>
<p>A client can prevent a surface object from moving beyond a given point at the right-hand side of its container by setting this field.  If for example you were to set the RightLimit to 8, then any attempt to move the surface object into or beyond the 8 units at the right-hand side of its container would fail.</p>
<p>Limits only apply to movement, as induced through the <action>Move</action> action.  This means that limits can be over-ridden by setting the coordinate fields directly (which can be useful in certain cases).</p>
      </description>
    </field>

    <field>
      <name>RightMargin</name>
      <comment>Manipulates the right margin of a surface object.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>INT</type>
      <description>
<p>The Surface class supports margin settings, which are similar to the concept of margins on printed paper.  Margin values have no significant meaning or effect on a surface object itself, but they are often used by other objects and can be helpful in interface construction.  For instance, the Window template uses margins to indicate the space available for placing graphics and other surface objects inside of it.</p>
<p>By default, all margins are set to zero when a new surface object is created.</p>
      </description>
    </field>

    <field>
      <name>Root</name>
      <comment>Surface that is acting as a root for many surface children (useful when applying translucency)</comment>
      <access>-/-</access>
      <type>OBJECTID</type>
    </field>

    <field>
      <name>TopLimit</name>
      <comment>Prevents a surface object from moving beyond a given point at the top of its container.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>INT</type>
      <description>
<p>A client can prevent a surface object from moving beyond a given point at the top of its container by setting this field. If for example you were to set the TopLimit to 10, then any attempt to move the surface object into or beyond the 10 units at the top of its container would fail.</p>
<p>Limits only apply to movement, as induced through the <action>Move</action> action.  This means that limits can be over-ridden by setting the coordinate fields directly (which can be useful in certain cases).</p>
      </description>
    </field>

    <field>
      <name>TopMargin</name>
      <comment>Manipulates the top margin of a surface object.</comment>
      <access read="R" write="W">Read/Write</access>
      <type>INT</type>
      <description>
<p>The Surface class supports margin settings, which are similar to the concept of margins on printed paper.  Margin values have no significant meaning or effect on a surface object itself, but they are often used by other objects and can be helpful in interface construction.  For instance, the Window template uses margins to indicate the space available for placing graphics and other surface objects inside of it.</p>
<p>By default, all margins are set to zero when a new surface object is created.</p>
      </description>
    </field>

    <field>
      <name>UserFocus</name>
      <comment>Refers to the surface object that has the current focus.</comment>
      <access read="G">Get</access>
      <type>INT</type>
      <description>
<p>Returns the surface object that has the primary user focus.  Returns zero if no object has the focus.</p>
      </description>
    </field>

    <field>
      <name>Visible</name>
      <comment>Indicates the visibility of a surface object.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>INT</type>
      <description>
<p>If you need to know if a surface object is visible or hidden, you can read this field to find out either way.  A <code>true</code> value is returned if the object is visible and <code>false</code> is returned if the object is invisible.  Note that visibility is subject to the properties of the container that the surface object resides in.  For example, if a surface object is visible but is contained within a surface object that is invisible, the end result is that both objects are actually invisible.</p>
<p>Visibility is directly affected by the <action>Hide</action> and <action>Show</action> actions if you wish to change the visibility of a surface object.</p>
      </description>
    </field>

    <field>
      <name>VisibleHeight</name>
      <comment>The visible height of the surface area, relative to its parents.</comment>
      <access read="G">Get</access>
      <type>INT</type>
      <description>
<p>To determine the visible area of a surface, read the <fl>VisibleX</fl>, <fl>VisibleY</fl>, <fl>VisibleWidth</fl> and VisibleHeight fields.</p>
<p>The 'visible area' is determined by the position of the surface relative to its parents.  For example, if the surface is 100 pixels across and smallest parent is 50 pixels across, the number of pixels visible to the user must be 50 pixels or less, depending on the position of the surface.</p>
<p>If none of the surface area is visible then zero is returned.  The result is never negative.</p>
      </description>
    </field>

    <field>
      <name>VisibleWidth</name>
      <comment>The visible width of the surface area, relative to its parents.</comment>
      <access read="G">Get</access>
      <type>INT</type>
      <description>
<p>To determine the visible area of a surface, read the VisibleX, VisibleY, VisibleWidth and VisibleHeight fields.</p>
<p>The 'visible area' is determined by the position of the surface relative to its parents.  For example, if the surface is 100 pixels across and smallest parent is 50 pixels across, the number of pixels visible to the user must be 50 pixels or less, depending on the position of the surface.</p>
<p>If none of the surface area is visible then zero is returned.  The result is never negative.</p>
      </description>
    </field>

    <field>
      <name>VisibleX</name>
      <comment>The first visible X coordinate of the surface area, relative to its parents.</comment>
      <access read="G">Get</access>
      <type>INT</type>
      <description>
<p>To determine the visible area of a surface, read the VisibleX, <fl>VisibleY</fl>, <fl>VisibleWidth</fl> and <fl>VisibleHeight</fl> fields.</p>
<p>The 'visible area' is determined by the position of the surface relative to its parents.  For example, if the surface is 100 pixels across and smallest parent is 50 pixels across, the number of pixels visible to the user must be 50 pixels or less, depending on the position of the surface.</p>
<p>If none of the surface area is visible then zero is returned.  The result is never negative.</p>
      </description>
    </field>

    <field>
      <name>VisibleY</name>
      <comment>The first visible Y coordinate of the surface area, relative to its parents.</comment>
      <access read="G">Get</access>
      <type>INT</type>
      <description>
<p>To determine the visible area of a surface, read the <fl>VisibleX</fl>, VisibleY, <fl>VisibleWidth</fl> and <fl>VisibleHeight</fl> fields.</p>
<p>The 'visible area' is determined by the position of the surface relative to its parents.  For example, if the surface is 100 pixels across and smallest parent is 50 pixels across, the number of pixels visible to the user must be 50 pixels or less, depending on the position of the surface.</p>
<p>If none of the surface area is visible then zero is returned.  The result is never negative.</p>
      </description>
    </field>

    <field>
      <name>Width</name>
      <comment>Defines the width of a surface object.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>INT</type>
      <description>
<p>The width of a surface object is manipulated through this field.  Alternatively, use the <action>Resize</action> action to adjust the Width and <fl>Height</fl> at the same time.  A client can set the Width as a fixed value by default, or as a scaled value in conjunction with the <code>FD_SCALED</code> flag.  Scaled values are multiplied by the width of their parent container.</p>
<p>Setting the Width while a surface object is on display causes an immediate graphical update to reflect the change.  Any objects that are within the surface area will be re-drawn and resized as necessary.</p>
<p>Width values of 0 or less are illegal, and will result in an <code>ERR::OutOfRange</code> error-code.</p>
      </description>
    </field>

    <field>
      <name>WindowHandle</name>
      <comment>Refers to a surface object's window handle, if relevant.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>APTR</type>
      <description>
<p>This field refers to the window handle of a surface object, but only if such a thing is relevant to the platform that the system is running on.  Currently, this field is only usable when creating a primary surface object within an X11 window manager or Microsoft Windows.</p>
<p>It is possible to set the WindowHandle field prior to initialisation if you want a surface object to be based on a window that already exists.</p>
      </description>
    </field>

    <field>
      <name>WindowType</name>
      <comment>Indicator for surfaces that represent themselves as a desktop window.</comment>
      <access read="G" write="S">Get/Set</access>
      <type lookup="SWIN">INT</type>
      <description>
<p>This field affects a surface's status on hosted desktops such as Windows and X11. It only affects top-level surfaces that have no parent - child surfaces ignore this field.  Surfaces created in the desktop area will also ignore this field, as the desktop is treated as a parent.</p>
<p>It is the responsibility of the developer to provide window gadgets such as titlebars and set the resize borders for custom surfaces.</p>
<types lookup="SWIN"/>
      </description>
    </field>

    <field>
      <name>X</name>
      <comment>Determines the horizontal position of a surface object.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>INT</type>
      <description>
<p>The horizontal position of a surface object can be set through this field.  You have the choice of setting a fixed coordinate (the default) or a scaled coordinate if you use the <code>FD_SCALED</code> flag.</p>
<p>If you set the X while the surface object is on display, the position of the surface area will be updated immediately.</p>
      </description>
    </field>

    <field>
      <name>XOffset</name>
      <comment>Determines the horizontal offset of a surface object.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>INT</type>
      <description>
<p>The XOffset has a dual purpose depending on whether or not it is set in conjunction with the <fl>X</fl> or <fl>Width</fl> fields.</p>
<p>If set in conjunction with the <fl>X</fl> field, the width of the surface object will be from that X coordinate up to the width of the container, minus the value given in the XOffset.  This means that the width of the surface object is dynamically calculated in relation to the width of its container.</p>
<p>If the XOffset field is set in conjunction with a fixed or scaled width then the surface object will be positioned at an X coordinate calculated from the formula <code>X = ContainerWidth - SurfaceWidth - XOffset</code>.</p>
      </description>
    </field>

    <field>
      <name>Y</name>
      <comment>Determines the vertical position of a surface object.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>INT</type>
      <description>
<p>The vertical position of a surface object can be set through this field.  You have the choice of setting a fixed coordinate (the default) or a scaled coordinate if you use the <code>FD_SCALED</code> flag.</p>
<p>If the value is changed while the surface is on display, its position will be updated immediately.</p>
      </description>
    </field>

    <field>
      <name>YOffset</name>
      <comment>Determines the vertical offset of a surface object.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>INT</type>
      <description>
<p>The YOffset has a dual purpose depending on whether or not it is set in conjunction with the <fl>Y</fl> or <fl>Height</fl> fields.</p>
<p>If set in conjunction with the <fl>Y</fl> field, the height of the surface object will be from that Y coordinate up to the height of the container, minus the value given in the YOffset.  This means that the height of the surface object is dynamically calculated in relation to the height of its container.</p>
<p>If the YOffset field is set in conjunction with a fixed or scaled height then the surface object will be positioned at a Y coordinate calculated from the formula <code>Y = ContainerHeight - SurfaceHeight - YOffset</code>.</p>
      </description>
    </field>

  </fields>
  <types>
    <constants lookup="ALIGN" comment="Universal values for alignment of graphics and text">
      <const name="BOTTOM">Align to bottom</const>
      <const name="CENTER">Synonym for <code>HORIZONTAL | VERTICAL</code></const>
      <const name="HORIZONTAL">Align to horizontal center</const>
      <const name="LEFT">Align to left</const>
      <const name="MIDDLE">Synonym for <code>HORIZONTAL | VERTICAL</code></const>
      <const name="RIGHT">Align to right</const>
      <const name="TOP">Align to top</const>
      <const name="VERTICAL">Align to vertical center</const>
    </constants>

    <constants lookup="BAF" comment="Instructions for basic graphics operations.">
      <const name="BLEND">Enable alpha blending to the destination if the source supports an alpha channel.</const>
      <const name="COPY">Special <function module="Display">CopyArea</function> option that avoids blending when the destination pixel is empty.</const>
      <const name="DITHER">Perform dithering if the colour formats differ between the source and destination.</const>
      <const name="FILL">For primitive operations such as <function module="Display">DrawRectangle</function>, this will fill the shape with a solid colour or texture.</const>
      <const name="LINEAR">Use linear interpolation to improve the quality of alpha blending.</const>
    </constants>

    <constants lookup="BDF" comment="CopySurface() flags">
      <const name="DITHER">Allow the use of dithering to improve image quality at a cost of speed.</const>
      <const name="REDRAW">Redraw the surface before performing the copy operation.</const>
    </constants>

    <constants lookup="CRF" comment="Flags for the SetCursor() function.">
      <const name="BUFFER">Use of the <code>BUFFER</code> option allows the cursor request to be buffered in the event that the cursor is locked at the time of calling the <function module="Display">SetCursor</function> function.  Use of this flag is highly recommended in most circumstances, but may not be used in conjunction with the <code>ANCHOR</code> option.</const>
      <const name="LMB">Release the cursor after the left mouse button is held and released.</const>
      <const name="MMB">Release the cursor after the middle mouse button is held and released.</const>
      <const name="NO_BUTTONS">Set the cursor only on the condition that the user is not holding down any buttons.  <code>ERR::NothingDone</code> is returned if the user has a button held down.</const>
      <const name="RESTRICT">Similar to the anchor option, but allows the pointer to move within the surface referred to by ObjectID.</const>
      <const name="RMB">Release the cursor after the right mouse button is held and released.</const>
    </constants>

    <constants lookup="CSRF" comment="Flags for CopySurface().">
      <const name="ALPHA">Enable alpha blending if the source is in 32-bit colour format with an alpha channel.</const>
      <const name="CLIP">Enable clipping of the source coordinates.</const>
      <const name="DEFAULT_FORMAT">Ignore the colour format defined in the source surface (if any) and generate a default format based on the <code>BitsPerPixel</code> value.</const>
      <const name="OFFSET">Adjust X and Y coordinates by the offset values defined in the <class name="Surface" field="XOffset">Surface.XOffset</class> and <class name="Surface" field="YOffset">Surface.YOffset</class> fields.</const>
      <const name="TRANSLUCENT">Perform a translucent copy operation, using the strength value specified in the <class name="Surface" field="Opacity">Surface.Opacity</class> field.</const>
      <const name="TRANSPARENT">Enable transparent copying, whereby colours matching the source's <code>Colour</code> field will be ignored.</const>
    </constants>

    <constants lookup="DMF">
      <const name="FIXED_CENTER_X">The CenterX field is a fixed size.</const>
      <const name="FIXED_CENTER_Y">The CenterY field is a fixed size.</const>
      <const name="FIXED_DEPTH">The Depth field is a fixed size.</const>
      <const name="FIXED_HEIGHT">The Height field is a fixed size.</const>
      <const name="FIXED_RADIUS">Synonym for <code>FIXED_RADIUS_X | FIXED_RADIUS_Y</code></const>
      <const name="FIXED_RADIUS_X">The RadiusX field is a fixed size.</const>
      <const name="FIXED_RADIUS_Y">The RadiusY field is a fixed size.</const>
      <const name="FIXED_WIDTH">The Width field is a fixed suze.</const>
      <const name="FIXED_X">The X field is a fixed coordinate.</const>
      <const name="FIXED_X_OFFSET">The XOffset field is a fixed coordinate.</const>
      <const name="FIXED_Y">The Y field is a fixed coordinate.</const>
      <const name="FIXED_Y_OFFSET">The YOffset field is a fixed coordinate.</const>
      <const name="FIXED_Z">The Z field is a fixed coordinate.</const>
      <const name="HEIGHT">Synonym for <code>FIXED_HEIGHT | SCALED_HEIGHT</code></const>
      <const name="HEIGHT_FLAGS">Synonym for <code>FIXED_HEIGHT | SCALED_HEIGHT | FIXED_Y_OFFSET | SCALED_Y_OFFSET</code></const>
      <const name="HORIZONTAL_FLAGS">Synonym for <code>FIXED_WIDTH | SCALED_WIDTH | FIXED_X_OFFSET | SCALED_X_OFFSET | FIXED_X | SCALED_X</code></const>
      <const name="SCALED_CENTER_X">The CenterX field is scaled to this object's parent.</const>
      <const name="SCALED_CENTER_Y">The CenterY field is scaled to this object's parent.</const>
      <const name="SCALED_DEPTH">The Depth field is scaled to this object's parent.</const>
      <const name="SCALED_HEIGHT">The Height field is scaled to this object's parent.</const>
      <const name="SCALED_RADIUS">Synonym for <code>SCALED_RADIUS_X | SCALED_RADIUS_Y</code></const>
      <const name="SCALED_RADIUS_X">The RadiusX field is scaled to this object's parent.</const>
      <const name="SCALED_RADIUS_Y">The RadiusY field is a scaled size to this object's parent.</const>
      <const name="SCALED_WIDTH">The Width field is scaled to this object's parent.</const>
      <const name="SCALED_X">The X field is scaled to this object's parent.</const>
      <const name="SCALED_X_OFFSET">The XOffset field is scaled to this object's parent.</const>
      <const name="SCALED_Y">The Y field is scaled to this object's parent.</const>
      <const name="SCALED_Y_OFFSET">The YOffset field is scaled to this object's parent.</const>
      <const name="SCALED_Z">The Z field is a scaled coordinate to this object's parent.</const>
      <const name="STATUS_CHANGE">Synonym for <code>STATUS_CHANGE_H | STATUS_CHANGE_V</code></const>
      <const name="STATUS_CHANGE_H"/>
      <const name="STATUS_CHANGE_V"/>
      <const name="VERTICAL_FLAGS">Synonym for <code>FIXED_HEIGHT | SCALED_HEIGHT | FIXED_Y_OFFSET | SCALED_Y_OFFSET | FIXED_Y | SCALED_Y</code></const>
      <const name="WIDTH">Synonym for <code>FIXED_WIDTH | SCALED_WIDTH</code></const>
      <const name="WIDTH_FLAGS">Synonym for <code>FIXED_WIDTH | SCALED_WIDTH | FIXED_X_OFFSET | SCALED_X_OFFSET</code></const>
      <const name="X">Synonym for <code>FIXED_X | SCALED_X</code></const>
      <const name="X_OFFSET">Synonym for <code>FIXED_X_OFFSET | SCALED_X_OFFSET</code></const>
      <const name="Y">Synonym for <code>FIXED_Y | SCALED_Y</code></const>
      <const name="Y_OFFSET">Synonym for <code>FIXED_Y_OFFSET | SCALED_Y_OFFSET</code></const>
    </constants>

    <constants lookup="DRAG">
      <const name="ANCHOR">The surface is being dragged and the mouse pointer is anchored to the surface.</const>
      <const name="NONE">The surface is not being dragged.</const>
      <const name="NORMAL">The surface is being dragged.</const>
    </constants>

    <constants lookup="DT" comment="Flags for GetDisplayType().">
      <const name="GLES">The display is driven by OpenGLES.</const>
      <const name="NATIVE">The display is native (supported by internal drivers).</const>
      <const name="WINGDI">The display is driven by Microsoft Windows drivers.</const>
      <const name="X11">The display is driven by the X Window System (X11, X.Org, XFree86)</const>
    </constants>

    <constants lookup="EXF" comment="Optional flags for the ExposeSurface() function.">
      <const name="ABSOLUTE">The supplied coordinates for exposure are absolute (relative to the display).</const>
      <const name="ABSOLUTE_COORDS">The supplied coordinates for exposure are absolute (relative to the display).</const>
      <const name="CHILDREN">If set, all child surfaces that intersect with exposed region will be included in the expose operation.</const>
      <const name="REDRAW_VOLATILE">Redraw every volatile object that intersects with the expose region, including internal volatile children.</const>
      <const name="REDRAW_VOLATILE_OVERLAP">Only redraw volatile objects that obscure the expose region from a position outside of the target surface and its children.  Useful if no redrawing has occurred in the surface, but the surface has moved to a new position and the parents need to be redrawn.</const>
    </constants>

    <constants lookup="FLIP" comment="Flags for the bitmap Flip method.">
      <const name="HORIZONTAL">Flip the bitmap from top to bottom.</const>
      <const name="VERTICAL">Flip the bitmap from left to right.</const>
    </constants>

    <constants lookup="HOST">
      <const name="STICK_TO_FRONT">The hosted display sticks to the front.</const>
      <const name="TASKBAR">The hosted display is given a taskbar button.</const>
      <const name="TRANSLUCENCE">Change the alpha channel level for the entire window.</const>
      <const name="TRANSPARENT">Defines an RGB colour that is to be used as transparent.</const>
      <const name="TRAY_ICON">All new displays are represented in the system tray when this option is active.</const>
    </constants>

    <constants lookup="JET" comment="JET constants are documented in GetInputEvent()">
      <const name="ABS_XY">The X, Y values are defined as absolute coordinates, relative to the top-left of the display.</const>
      <const name="ANALOG2_XY">As for <code>ANALOG_XY</code>, this type covers a second analog stick if present.</const>
      <const name="ANALOG2_Z">As for <code>ANALOG_Z</code>, this type covers a second analog stick if present.</const>
      <const name="ANALOG_XY">Position for the default analog control (on gamepads this is the left analog control).  Analog values range between -1.0 and 1.0.  A value of zero indicates that the control is at rest.</const>
      <const name="ANALOG_Z">3D or yoke position for the default analog control.  A negative value indicates that the control has been pulled out and a positive value indicates that it has been pushed in.</const>
      <const name="BUTTON_1">Left mouse button, XBox A button, PS square button.  Value is pressure sensitive, ranging between 0 - 1.0 (0 is released, 1.0 is fully depressed).</const>
      <const name="BUTTON_10">Non-specific button assignment.</const>
      <const name="BUTTON_2">Right mouse button, XBox X button, PS cross button.</const>
      <const name="BUTTON_3">Middle mouse button, XBox Y button, PS triangle.</const>
      <const name="BUTTON_4">XBox B button, PS circle.</const>
      <const name="BUTTON_5">Left analog stick depressed.</const>
      <const name="BUTTON_6">Right analog stick depressed.</const>
      <const name="BUTTON_7">Non-specific button assignment.</const>
      <const name="BUTTON_8">Non-specific button assignment.</const>
      <const name="BUTTON_9">Non-specific button assignment.</const>
      <const name="BUTTON_SELECT">Gamepad select button - value is 0 or 1.</const>
      <const name="BUTTON_START">Gamepad start button - value is 0 or 1.</const>
      <const name="CROSSED_IN">This message is sent by the input system when the mouse pointer enters an area for the first time.  The message value refers to the object ID of the container being monitored for movement.</const>
      <const name="CROSSED_OUT">This message is sent by the input system when the mouse pointer leaves an area.  The message value refers to the object ID of the container being monitored for movement.</const>
      <const name="DEVICE_TILT_XY">Controller tilted on the X/Y axis.  Value indicates angle, -ve = left, +ve = right</const>
      <const name="DEVICE_TILT_Z">Controller is rising or falling.  Value expressed as 'speed',</const>
      <const name="DIGITAL_XY">Digital movement from a relative location.  Value is +/- n, where n is the number of units moved horizontally.  Mouse movement will normally exceed a value of 1, whereas gamepad movement is limited to a value of +/- 1 except in the case of successive presses.</const>
      <const name="DISPLAY_EDGE">Recently supplied input occurred at the edge of the display.</const>
      <const name="LEFT_BUMPER_1">Gamepad left-hand bumper 1 (top) - pressure sensitive value from 0 - 1.0.</const>
      <const name="LEFT_BUMPER_2">Gamepad left-hand bumper 2 (lower) - pressure sensitive value from 0 - 1.0.</const>
      <const name="PEN_TILT_XY">For pen-based input, this type indicates the vertical tilt of the pen device.  A value of 0 indicates that the pen is laid flat with nib at the bottom, 0.5 is 90 degrees, 1.0 is laid flat with nib at the top.</const>
      <const name="PRESSURE">Amount of pressure applied, ranges from 0 (none) to 1.0 (normal) and possibly higher if user presses hard enough</const>
      <const name="RIGHT_BUMPER_1">Gamepad right-hand bumper 1 (top) - pressure sensitive value from 0 - 1.0.</const>
      <const name="RIGHT_BUMPER_2">Gamepad right-hand bumper 2 (lower) - pressure sensitive value from 0 - 1.0.</const>
      <const name="TRIGGER_LEFT">Gamepad left-hand trigger - value is between 0 - 1.0 (0 is released, 1.0 is fully depressed).</const>
      <const name="TRIGGER_RIGHT">Gamepad right-hand trigger.</const>
      <const name="WHEEL">Mouse wheel rotation - the value generally reflects the number of 'clicks' rotated on the wheel.</const>
      <const name="WHEEL_TILT">Some mouse wheels can be tilted to the left or right.  Ranges from -1.0 to +1.0</const>
    </constants>

    <constants lookup="JTYPE" comment="JTYPE flags are used to categorise input types.">
      <const name="ANALOG">Analog movement (ranging from -1.0 to 1.0)</const>
      <const name="ANCHORED">Cursor has been anchored with LockCursor()</const>
      <const name="BUTTON">Input is a physical button or switch</const>
      <const name="CROSSING">Crossing events manage the entering and leaving of an area.</const>
      <const name="DBL_CLICK">Set by the input system if the Type is a button and the button has been clicked in quick succession so as to be classed as a double-click.</const>
      <const name="DIGITAL">D-Pad or digital joystick source (restricted to +/- 1)</const>
      <const name="DRAGGED">Set if sufficient movement occurred between the original click and its point of release (usually requires a 3 or more pixel difference).</const>
      <const name="DRAG_ITEM">This special flag is set by the input system if the pointer is click-dragging an object at the time of the event.</const>
      <const name="EXT_MOVEMENT">Extended or indirect movement information.  This covers all types of movement that are unconnected to coordinate positioning -  mouse wheel movement and pen tilt are two such examples.</const>
      <const name="MOVEMENT">X/Y coordinate movement only. Movement such as the wheel mouse spinning is not covered by this type as it does not influence the coordinate system.</const>
      <const name="REPEATED">Input is a repeated entry (i.e. user is holding down a button and a repetition timer is being triggered)</const>
      <const name="SECONDARY">Indicates to the receiver of this message that it is not the primary/original recipient</const>
    </constants>

    <constants lookup="LVF" comment="drwLockBitmap() result flags">
      <const name="EXPOSE_CHANGES"/>
    </constants>

    <constants lookup="PTC" comment="Predefined cursor styles">
      <const name="CROSSHAIR">The cross hair is used for targeting specific pixel points (common in paint programs).</const>
      <const name="CUSTOM">Works in conjunction with the SetCustomCursor() function to represent a program defined bitmap.</const>
      <const name="DEFAULT">The default cursor (usually an arrow pointing to the upper left).</const>
      <const name="DRAGGABLE">Used to indicate that a surface or object can be dragged by the user.</const>
      <const name="END"/>
      <const name="HAND">The hand cursor is often used for indicating click-able content (hyper-links, icons etc).</const>
      <const name="HAND_LEFT">Similar to the standard hand cursor, but points to the left.</const>
      <const name="HAND_RIGHT">Similar to the standard hand cursor, but points to the right.</const>
      <const name="INVISIBLE">The cursor graphic is invisible (but will continue to operate as normal in all other respects).</const>
      <const name="MAGNIFIER">Represents a magnifying glass.</const>
      <const name="NO_CHANGE"/>
      <const name="PAINTBRUSH">The paintbrush cursor is typically employed by paint programs.</const>
      <const name="SIZE_BOTTOM">Sizing cursor - for resizing the bottom edge of any rectangular area.</const>
      <const name="SIZE_BOTTOM_LEFT">Sizing cursor - for resizing the bottom left corner of any rectangular area.</const>
      <const name="SIZE_BOTTOM_RIGHT">Sizing cursor - for resizing the bottom right corner of any rectangular area.</const>
      <const name="SIZE_LEFT">Sizing cursor - for resizing the left edge of any rectangular area.</const>
      <const name="SIZE_RIGHT">Sizing cursor - for resizing the right edge of any rectangular area.</const>
      <const name="SIZE_TOP">Sizing cursor - for resizing the top edge of any rectangular area.</const>
      <const name="SIZE_TOP_LEFT">Sizing cursor - for resizing the top left corner of any rectangular area.</const>
      <const name="SIZE_TOP_RIGHT">Sizing cursor - for resizing the top right corner of any rectangular area.</const>
      <const name="SIZING">Multi-directional sizing cursor - for resizing in any direction.</const>
      <const name="SLEEP">The sleep cursor is used to inform the user that the computer is busy.</const>
      <const name="SPLIT_HORIZONTAL">The horizontal split cursor is typically used for splitting rectangles in half, or dragging a horizontal split within a large rectangular space.</const>
      <const name="SPLIT_VERTICAL">The vertical split cursor is typically used for splitting rectangles in half, or dragging a vertical split within a large rectangular space.</const>
      <const name="STOP">The stop cursor is used to inform the user that an operation is not possible (e.g. drag and drop to an unsupported object area).</const>
      <const name="TEXT">The text cursor is popular for the precise positioning of text cursors.</const>
    </constants>

    <constants lookup="RNF" comment="Switches for the Surface class' Flags field.">
      <const name="AFTER_COPY">Read-only.  Indicates that after-copy mode has been enabled.</const>
      <const name="ASPECT_RATIO">When resizing, enforce the aspect ratio as defined by <class name="Surface" field="MinWidth">Surface.MinWidth</class> and <class name="Surface" field="MinHeight">Surface.MinHeight</class>.</const>
      <const name="AUTO_QUIT">The surface object will send a quit message to its supporting process when and if the Close method is called.  This flag is typically used when a surface object represents a core window for an application.</const>
      <const name="COMPOSITE">Do not copy background information into the surface buffer - composite on the fly instead</const>
      <const name="DISABLED">This flag is set if the Disable action has been called on a surface object.  Calling the Enable action will turn off the flag setting.</const>
      <const name="FIXED_BUFFER">Passes the <code>NEVER_SHRINK</code> option to the surface bitmap</const>
      <const name="FIXED_DEPTH">The target buffer always remains at the same depth</const>
      <const name="FULL_SCREEN">Allow the surface to open as a new screen display</const>
      <const name="GRAB_FOCUS">Helps application windows manage the user's focus within the window</const>
      <const name="HAS_FOCUS">Read-only.  If set, this flag indicates that the surface object currently has the focus.</const>
      <const name="HOST">Define host on initialisation to create a container that can host surfaces from other processes.</const>
      <const name="IGNORE_FOCUS">Focus is diverted directly to the parent</const>
      <const name="INIT_ONLY">Synonym for <code>HOST | TRANSPARENT | DISABLED | PRECOPY | VIDEO | FIXED_BUFFER | PERVASIVE_COPY | FIXED_DEPTH | FULL_SCREEN | IGNORE_FOCUS</code></const>
      <const name="NO_FOCUS">Prevents any kind of focussing on this object; no circumvention is possible</const>
      <const name="NO_HORIZONTAL">Turns off all horizontal movement (applies to the <code>Move()</code> action only).</const>
      <const name="NO_PRECOMPOSITE">Do not copy background information into the surface buffer - composite on the fly instead</const>
      <const name="NO_VERTICAL">Turns off all vertical movement (applies to the <code>Move()</code> action only).</const>
      <const name="PERVASIVE_COPY">This flag can be set in conjunction with after-copy mode.  It forces the after-copy support routine to copy graphics over the entire surface area, rather than avoiding the graphics of child surfaces.</const>
      <const name="POST_COMPOSITE">Do not copy background information into the surface buffer - composite on the fly instead</const>
      <const name="PRECOPY">Enables pre-copy mode, which means that all graphics behind the surface object are copied into the bitmap buffer prior to any redraw.  This mode can have a noticable impact on CPU time when drawing.</const>
      <const name="READ_ONLY">Synonym for <code>HAS_FOCUS | CURSOR | AFTER_COPY</code></const>
      <const name="STICKY">Prevents any response to the Move action.  It can be circumvented by writing to coordinate fields directly.</const>
      <const name="STICK_TO_BACK">Enable if the surface object must stick to the back of its container.</const>
      <const name="STICK_TO_FRONT">Enable if the surface object must stick to the front of its container.</const>
      <const name="TOTAL_REDRAW">Perform a total redraw of the entire surface when drawing - no partial draws</const>
      <const name="TRANSPARENT">Enables transparency, which means that the internal graphics routines will ignore this surface during redraws.  It is typically used when creating containers that will host other surfaces.</const>
      <const name="VIDEO">Set this flag if you would like the surface object's data to be managed in video memory only.  While this can give some speed advantages, be warned that video based surfaces are limited to write-only operations.</const>
      <const name="VISIBLE">If a surface object is visible to the user, the <code>VISIBLE</code> flag will be set.  If the flag is not set, the surface object is hidden.</const>
      <const name="VOLATILE">Synonym for <code>PRECOPY | AFTER_COPY | CURSOR</code></const>
      <const name="WRITE_ONLY">Set this flag if you would like the surface object's data to be managed in video memory only.  While this can give some speed advantages, be warned that video based surfaces are limited to write-only operations.</const>
    </constants>

    <constants lookup="RT">
      <const name="ROOT">Can be used by window surfaces to identify themselves as a root layer.</const>
    </constants>

    <constants lookup="SWIN" comment="Options for the Surface WindowType field.">
      <const name="HOST">Default to the standard hosted window mode with full titlebar, borders and taskbar representation.</const>
      <const name="ICON_TRAY">Create a borderless (custom) window with icon tray representation.</const>
      <const name="NONE">Create a borderless (custom) window with no UI representation.</const>
      <const name="TASKBAR">Create a borderless (custom) window with taskbar representation.</const>
    </constants>

    <constants lookup="WH" comment="Events for WindowHook()">
      <const name="CLOSE"/>
    </constants>

  </types>
  <structs>
    <struct name="BitmapSurface" typeName="BITMAPSURFACE">
      <field name="Data" type="APTR">Pointer to the bitmap graphics data.</field>
      <field name="Width" type="WORD">Pixel width of the bitmap.</field>
      <field name="Height" type="WORD">Pixel height of the bitmap.</field>
      <field name="LineWidth" type="LONG">The distance between bitmap lines, measured in bytes.</field>
      <field name="BitsPerPixel" type="UBYTE">The number of bits per pixel (8, 15, 16, 24, 32).</field>
      <field name="BytesPerPixel" type="UBYTE">The number of bytes per pixel (1, 2, 3, 4).</field>
      <field name="Opacity" type="UBYTE">Opacity level of the source if <code>CSRF::TRANSLUCENT</code> is used.</field>
      <field name="Version" type="UBYTE">Version of this structure.</field>
      <field name="Colour" type="LONG">Colour index to use if <code>CSRF::TRANSPARENT</code> is used.</field>
      <field name="Clip" type="struct ClipRectangle">A clipping rectangle will restrict drawing operations to this region if <code>CSRF::CLIP</code> is used.</field>
      <field name="XOffset" type="WORD">Offset all X coordinate references by the given value.</field>
      <field name="YOffset" type="WORD">Offset all Y coordinate references by the given value.</field>
      <field name="Format" type="struct ColourFormat">The colour format of this bitmap's pixels, or alternatively use <code>CSRF::DEFAULT_FORMAT</code>.</field>
    </struct>

    <struct name="ColourFormat" typeName="COLOURFORMAT">
      <field name="RedShift" type="UBYTE">Right shift value for red (15/16 bit formats only)</field>
      <field name="GreenShift" type="UBYTE">Right shift value for green</field>
      <field name="BlueShift" type="UBYTE">Right shift value for blue</field>
      <field name="AlphaShift" type="UBYTE">Right shift value for alpha</field>
      <field name="RedMask" type="UBYTE">Unshifted mask value for red (ranges from 0x00 to 0xff)</field>
      <field name="GreenMask" type="UBYTE">Unshifted mask value for green</field>
      <field name="BlueMask" type="UBYTE">Unshifted mask value for blue</field>
      <field name="AlphaMask" type="UBYTE">Unshifted mask value for alpha</field>
      <field name="RedPos" type="UBYTE">Left shift/positional value for red</field>
      <field name="GreenPos" type="UBYTE">Left shift/positional value for green</field>
      <field name="BluePos" type="UBYTE">Left shift/positional value for blue</field>
      <field name="AlphaPos" type="UBYTE">Left shift/positional value for alpha</field>
      <field name="BitsPerPixel" type="UBYTE">Number of bits per pixel for this format.</field>
    </struct>

    <struct name="CursorInfo">
      <field name="Width" type="LONG">Maximum cursor width for custom cursors</field>
      <field name="Height" type="LONG">Maximum cursor height for custom cursors</field>
      <field name="Flags" type="LONG">Currently unused</field>
      <field name="BitsPerPixel" type="WORD">Preferred bits-per-pixel setting for custom cursors</field>
    </struct>

    <struct name="DisplayInfo" typeName="DISPLAYINFO">
      <field name="Display" type="OBJECTID">Object ID related to the display</field>
      <field name="Flags" type="SCR" lookup="SCR">Display flags</field>
      <field name="Width" type="WORD">Pixel width of the display</field>
      <field name="Height" type="WORD">Pixel height of the display</field>
      <field name="BitsPerPixel" type="WORD">Bits per pixel</field>
      <field name="BytesPerPixel" type="WORD">Bytes per pixel</field>
      <field name="AccelFlags" type="ACF" lookup="ACF">Flags describing supported hardware features.</field>
      <field name="AmtColours" type="LONG">Total number of supported colours.</field>
      <field name="PixelFormat" type="struct PixelFormat">The colour format to use for each pixel.</field>
      <field name="MinRefresh" type="FLOAT">Minimum refresh rate</field>
      <field name="MaxRefresh" type="FLOAT">Maximum refresh rate</field>
      <field name="RefreshRate" type="FLOAT">Recommended refresh rate</field>
      <field name="Index" type="LONG">Display mode ID (internal)</field>
      <field name="HDensity" type="LONG">Horizontal pixel density per inch.</field>
      <field name="VDensity" type="LONG">Vertical pixel density per inch.</field>
    </struct>

    <struct name="InputEvent">
      <field name="Next" type="const struct InputEvent *">Next event in the chain</field>
      <field name="Value" type="DOUBLE">The value associated with the Type</field>
      <field name="Timestamp" type="LARGE">PreciseTime() of the recorded input</field>
      <field name="RecipientID" type="OBJECTID">Surface that the input message is being conveyed to</field>
      <field name="OverID" type="OBJECTID">Surface that is directly under the mouse pointer at the time of the event</field>
      <field name="AbsX" type="DOUBLE">Absolute horizontal position of mouse cursor (relative to the top left of the display)</field>
      <field name="AbsY" type="DOUBLE">Absolute vertical position of mouse cursor (relative to the top left of the display)</field>
      <field name="X" type="DOUBLE">Horizontal position relative to the surface that the pointer is over - unless a mouse button is held or pointer is anchored - then the coordinates are relative to the click-held surface</field>
      <field name="Y" type="DOUBLE">Vertical position relative to the surface that the pointer is over - unless a mouse button is held or pointer is anchored - then the coordinates are relative to the click-held surface</field>
      <field name="DeviceID" type="OBJECTID">The hardware device that this event originated from</field>
      <field name="Type" type="JET" lookup="JET">JET constant that describes the event</field>
      <field name="Flags" type="JTYPE" lookup="JTYPE">Broad descriptors for the given <code>Type</code> (see <code>JTYPE</code> flags).  Automatically defined when delivered to the pointer object</field>
      <field name="Mask" type="JTYPE" lookup="JTYPE">Mask to use for checking against subscribers</field>
    </struct>

    <struct name="SurfaceInfo" typeName="SURFACEINFO">
      <field name="Data" type="APTR">Bitmap data memory ID</field>
      <field name="ParentID" type="OBJECTID">Object that contains the surface area</field>
      <field name="BitmapID" type="OBJECTID">Surface bitmap buffer</field>
      <field name="DisplayID" type="OBJECTID">Refers to the display if this object is at root level</field>
      <field name="Flags" type="RNF" lookup="RNF">Surface flags</field>
      <field name="X" type="LONG">Horizontal coordinate</field>
      <field name="Y" type="LONG">Vertical coordinate</field>
      <field name="Width" type="LONG">Width of the surface area</field>
      <field name="Height" type="LONG">Height of the surface area</field>
      <field name="AbsX" type="LONG">Absolute X coordinate</field>
      <field name="AbsY" type="LONG">Absolute Y coordinate</field>
      <field name="Level" type="WORD">Branch level within the tree</field>
      <field name="BitsPerPixel" type="BYTE">Bits per pixel of the bitmap</field>
      <field name="BytesPerPixel" type="BYTE">Bytes per pixel of the bitmap</field>
      <field name="LineWidth" type="LONG">Line width of the bitmap, in bytes</field>
    </struct>

  </structs>
</book>
