<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="class.xsl"?>

<book>
  <info>
    <name>Surface</name>
    <type>class</type>
    <module>Display</module>
    <comment>Manages the display and positioning of 2-Dimensional rendered graphics.</comment>
    <version>1</version>
    <id>b15cfb8e</id>
    <idstring>ID_SURFACE</idstring>
    <category>GUI</category>
    <include>modules/surface.h</include>
    <copyright>Paul Manias 2003-2023</copyright>
    <description>
<p>The Surface class is used to manage the positioning, drawing and interaction with layered display interfaces.  It works in conjunction with the <class name="Bitmap">Bitmap</class> class for rendering graphics, and the <class name="Pointer">Pointer</class> class for user interaction.</p>
<p>On a platform such as Windows or Linux, the top-level surface will typically be hosted in an application window.  On Android or when a full screen display is required, a surface can cover the entire display and be window-less.  The top-level surface can act as a host to additional surfaces, which are referred to as children. Placing more surface objects inside of these children will create a hierarchy of many objects that requires sophisticated management that is provisioned by the Surface class.</p>
<p>Although pure surface based UI's are possible, clients should always pursue the more simplistic approach of using surfaces to host <class name="VectorScene">VectorScene</class> objects that describe vector based interfaces.  Doing so is in keeping with our goal of proving fully scalable interfaces to users, and we optimise features with that use-case in mind.</p></description>
    <source>
      <file path="class_surface/">class_surface.cpp</file>
      <file path="class_surface/">surface_dimensions.cpp</file>
      <file path="class_surface/">surface_drawing.cpp</file>
      <file path="class_surface/">surface_fields.cpp</file>
      <file path="class_surface/">surface_resize.cpp</file>
    </source>
  </info>

  <actions>
    <action>
      <name>Activate</name>
      <comment>Shows a surface object on the display.</comment>
    </action>

    <action>
      <name>Disable</name>
      <comment>Disables a surface object.</comment>
    </action>

    <action>
      <name>Draw</name>
      <comment>Redraws the contents of a surface object.</comment>
      <description>
<p>Calling the Draw action on a surface object will send redraw messages to every hook that has been attached to the surface object's drawing system.  This has the effect of redrawing all graphics within the surface object.  The procedure is as follows:</p>
<list type="ordered">
<li>If the surface object's <field>Colour</field> field has been set, the target bitmap will be cleared to that colour.</li>
<li>If the surface is volatile, graphics from background surfaces will be copied to the  target bitmap.</li>
<li>Subscribers to the surface object are now called via their hooks so that they can draw to the bitmap.</li>
<li>The bitmap is copied to the video display buffer to complete the process.</li>
</list>
<p>Please be aware that:</p>
<list>
<li>If the target surface contains child surfaces, they will not be redrawn unless they are volatile (using special
effects such as transparency, or using the region flag will make a surface volatile).</li>
<li>If the surface object has not had its background colour set, or if the object is not volatile, the bitmap
contents will not be automatically cleared (this is advantageous in situations where a particular object will clear
the surface area first).</li>
</list>
      </description>
    </action>

    <action>
      <name>Enable</name>
      <comment>Enables a disabled surface object.</comment>
    </action>

    <action>
      <name>Focus</name>
      <comment>Changes the primary user focus to the surface object.</comment>
    </action>

    <action>
      <name>Hide</name>
      <comment>Hides a surface object from the display.</comment>
    </action>

    <action>
      <name>LostFocus</name>
      <comment>Informs a surface object that it has lost the user focus.</comment>
    </action>

    <action>
      <name>Move</name>
      <comment>Moves a surface object to a new display position.</comment>
    </action>

    <action>
      <name>MoveToBack</name>
      <comment>Moves a surface object to the back of its container.</comment>
    </action>

    <action>
      <name>MoveToFront</name>
      <comment>Moves a surface object to the front of its container.</comment>
    </action>

    <action>
      <name>MoveToPoint</name>
      <comment>Moves a surface object to an absolute coordinate.</comment>
    </action>

    <action>
      <name>Redimension</name>
      <comment>Moves and resizes a surface object in a single action call.</comment>
    </action>

    <action>
      <name>Resize</name>
      <comment>Alters the dimensions of a surface object.</comment>
    </action>

    <action>
      <name>SaveImage</name>
      <comment>Saves the graphical image of a surface object.</comment>
      <description>
<p>If you need to store the image (graphical content) of a surface object, use the SaveImage action.  Calling SaveImage on a surface object will cause it to generate an image of its contents and save them to the given destination object.  Any child surfaces in the region will also be included in the resulting image data.</p>
<p>The image data will be saved in the data format that is indicated by the setting in the ClassID argument.  Options are limited to members of the <class name="Picture">Picture</class> class, for example <code>ID_JPEG</code> and <code>ID_PICTURE</code> (PNG).  If no ClassID is specified, the user's preferred default file format is used.</p>
      </description>
    </action>

    <action>
      <name>Scroll</name>
      <comment>Scrolls surface content to a new position.</comment>
      <description>
<p>Calling the Scroll action on a surface object with the <code>SCROLL_CONTENT</code> flag set will cause it to move its contents in the requested direction.  The Surface class uses the Move action to achieve scrolling, so any objects that do not support Move will remain at their given position.  Everything else will be shifted by the same amount of units as specified in the DeltaX, DeltaY and DeltaZ arguments.</p>
<p>Some objects may support a 'sticky' field that can be set to TRUE to prevent them from being moved.  This feature is present in the Surface class, amongst others.</p>
<p>If the surface object does not have the <code>SCROLL_CONTENT</code> flag set, the call will flow through to any objects that may be listening for the Scroll action on the surface.</p>
      </description>
    </action>

    <action>
      <name>ScrollToPoint</name>
      <comment>Moves the content of a surface object to a specific point.</comment>
    </action>

    <action>
      <name>Show</name>
      <comment>Shows a surface object on the display.</comment>
    </action>

  </actions>

  <methods>
    <method>
      <name>AddCallback</name>
      <comment>Inserts a function hook into the drawing process of a surface object.</comment>
      <prototype>ERROR drwAddCallback(OBJECTPTR Object, FUNCTION * Callback)</prototype>
      <input>
        <param type="FUNCTION *" name="Callback">Pointer to the callback routine or NULL to remove callbacks for the given Object.</param>
      </input>
      <description>
<p>The AddCallback() method provides a gateway for custom functions to draw directly to a surface.  Whenever a surface object performs a redraw event, all functions inserted by this method will be called in their original subscription order with a direct reference to the Surface's target bitmap.  The C/C++ prototype is <code>Function(APTR Context, *Surface, *Bitmap)</code>.</p>
<p>The Fluid prototype is <code>function draw(Surface, Bitmap)</code></p>
<p>The subscriber can draw to the bitmap surface as it would with any freshly allocated bitmap object (refer to the <class name="Bitmap">Bitmap</class> class).  To get the width and height of the available drawing space, please read the Width and Height fields from the Surface object.  If writing to the bitmap directly, please observe the bitmap's clipping region and the XOffset and YOffset values.</p>
      </description>
      <result>
        <error code="Okay">Operation successful.</error>
        <error code="AllocMemory">A call to AllocMemory() failed to create a new memory block.</error>
        <error code="NullArgs">Function call missing argument value(s)</error>
        <error code="ExecViolation">The call was not made from the process that owns the object.</error>
      </result>
    </method>

    <method>
      <name>Expose</name>
      <comment>Redraws a surface region to the display, preferably from its graphics buffer.</comment>
      <prototype>ERROR drwExpose(OBJECTPTR Object, LONG X, LONG Y, LONG Width, LONG Height, LONG Flags)</prototype>
      <input>
        <param type="LONG" name="X">X coordinate of the expose area.</param>
        <param type="LONG" name="Y">Y coordinate of the expose area.</param>
        <param type="LONG" name="Width">Width of the expose area.</param>
        <param type="LONG" name="Height">Height of the expose area.</param>
        <param type="LONG" name="Flags" lookup="EXF">Optional flags.</param>
      </input>
      <description>
<p>Call the Expose method to copy a surface region to the display.  The functionality is identical to that of the ExposeSurface() function in the Surface module.  Please refer to it for further documentation.</p>
      </description>
      <result>
        <error code="Okay">Operation successful.</error>
      </result>
    </method>

    <method>
      <name>InvalidateRegion</name>
      <comment>Redraws all of the content in a surface object.</comment>
      <prototype>ERROR drwInvalidateRegion(OBJECTPTR Object, LONG X, LONG Y, LONG Width, LONG Height)</prototype>
      <input>
        <param type="LONG" name="X">X coordinate of the region to invalidate.</param>
        <param type="LONG" name="Y">Y coordinate of the region to invalidate.</param>
        <param type="LONG" name="Width">Width of the region to invalidate.</param>
        <param type="LONG" name="Height">Height of the region to invalidate.</param>
      </input>
      <description>
<p>Invalidating a surface object will cause everything within a specified area to be redrawn.  This includes child surface objects that intersect with the area that you have specified.  Parent regions that overlap are not included in the redraw.</p>
<p>To quickly redraw an entire surface object's content, call this method directly without supplying an argument structure. If you want to redraw a surface object and ignore all of its surface children then you should use the Draw action instead of this method.</p>
<p>If you want to refresh a surface area to the display then you should use the <method>Expose</method> method instead.  Exposing will use the graphics buffer to refresh the graphics, thus avoiding the speed loss of a complete redraw.</p>
      </description>
      <result>
        <error code="Okay">Operation successful.</error>
        <error code="AccessMemory">Failed to access the internal surface list.</error>
      </result>
    </method>

    <method>
      <name>Minimise</name>
      <comment>For hosted surfaces only, this method will minimise the surface to an icon.</comment>
      <prototype>ERROR drwMinimise(OBJECTPTR Object)</prototype>
      <description>
<p>If a surface is hosted in a desktop window, calling the Minimise method will perform the default minimise action on that window.  On a platform such as Microsoft Windows, this would normally result in the window being minimised to the task bar.</p>
<p>Calling Minimise on a surface that is already in the minimised state may result in the host window being restored to the desktop.  This behaviour is platform dependent and should be manually tested to confirm its reliability on the host platform.</p>
      </description>
    </method>

    <method>
      <name>RemoveCallback</name>
      <comment>Removes a callback previously inserted by AddCallback().</comment>
      <prototype>ERROR drwRemoveCallback(OBJECTPTR Object, FUNCTION * Callback)</prototype>
      <input>
        <param type="FUNCTION *" name="Callback">Pointer to the callback routine to remove, or NULL to remove all assoicated callback routines.</param>
      </input>
      <description>
<p>The RemoveCallback() method is used to remove any callback that has been previously inserted by <method>AddCallback</method>.</p>
<p>This method is scope restricted, meaning that callbacks added by other objects will not be affected irrespective of the parameters that are passed to it.</p>
      </description>
      <result>
        <error code="Okay">Operation successful.</error>
        <error code="Search">A search routine in this function failed.</error>
      </result>
    </method>

    <method>
      <name>ResetDimensions</name>
      <comment>Changes the dimensions of a surface.</comment>
      <prototype>ERROR drwResetDimensions(OBJECTPTR Object, DOUBLE X, DOUBLE Y, DOUBLE XOffset, DOUBLE YOffset, DOUBLE Width, DOUBLE Height, LONG Dimensions)</prototype>
      <input>
        <param type="DOUBLE" name="X">New X coordinate.</param>
        <param type="DOUBLE" name="Y">New Y coordinate.</param>
        <param type="DOUBLE" name="XOffset">New X offset.</param>
        <param type="DOUBLE" name="YOffset">New Y offset.</param>
        <param type="DOUBLE" name="Width">New width.</param>
        <param type="DOUBLE" name="Height">New height.</param>
        <param type="LONG" name="Dimensions" lookup="DMF">Dimension flags.</param>
      </input>
      <description>
<p>The ResetDimensions method provides a simple way of re-declaring the dimensions of a surface object.  This is sometimes necessary when a surface needs to make a significant alteration to its method of display.  For instance if the width of the surface is declared through a combination of X and XOffset settings and the width needs to change to a fixed setting, then ResetDimensions will have to be used.</p>
<p>It is not necessary to define a value for every parameter - only the ones that are relevant to the new dimension settings.  For instance if X and Width are set, XOffset is ignored and the Dimensions value must include <code>DMF_FIXED_X</code> and <code>DMF_FIXED_WIDTH</code> (or the relative equivalents).  Please refer to the <field>Dimensions</field> field for a full list of dimension flags that can be specified.</p>
      </description>
      <result>
        <error code="Okay">Operation successful.</error>
        <error code="AccessMemory">Unable to access internal surface list.</error>
        <error code="NullArgs">Function call missing argument value(s)</error>
      </result>
    </method>

    <method>
      <name>ScheduleRedraw</name>
      <comment>Schedules a redraw operation for the next frame.</comment>
      <prototype>ERROR drwScheduleRedraw(OBJECTPTR Object)</prototype>
      <description>
<p>Use ScheduleRedraw to indicate that a surface needs to be drawn to the display.  The surface and all child surfaces will be drawn on the next frame cycle (typically 1/60th of a second).  All manual draw operations for the target surface are ignored until the scheduled operation is completed.</p>
<p>Scheduling is ideal in situations where a cluster of redraw events may occur within a tight time period, and it would be inefficient to draw those changes to the display individually.</p>
<p>Note that redraw schedules do not 'see each other', meaning if a surface and a child are both scheduled, this will trigger two redraw operations when one would suffice.  It is the client's responsibility to target the most relevant top-level surface for scheduling.</p>
      </description>
      <result>
        <error code="Okay">Operation successful.</error>
      </result>
    </method>

    <method>
      <name>SetDisplay</name>
      <comment>Changes the screen resolution (applies to top-level surface objects only).</comment>
      <prototype>ERROR drwSetDisplay(OBJECTPTR Object, LONG X, LONG Y, LONG Width, LONG Height, LONG InsideWidth, LONG InsideHeight, LONG BitsPerPixel, DOUBLE RefreshRate, LONG Flags)</prototype>
      <input>
        <param type="LONG" name="X">The horizontal coordinate/offset for the display.</param>
        <param type="LONG" name="Y">The vertical coordinate/offset for the display.</param>
        <param type="LONG" name="Width">The width of the display.</param>
        <param type="LONG" name="Height">The height of the display.</param>
        <param type="LONG" name="InsideWidth">The page width of the display must be the same as Width or greater.</param>
        <param type="LONG" name="InsideHeight">The page height of the display must be the same as Height or greater.</param>
        <param type="LONG" name="BitsPerPixel">Bits per pixel - 15, 16, 24 or 32.</param>
        <param type="DOUBLE" name="RefreshRate">Refresh rate.</param>
        <param type="LONG" name="Flags">Optional flags.</param>
      </input>
      <description>
<p>The SetDisplay method is used to change the screen resolution of the top-level surface object (which represents the screen display).  It allows you to set the size of the display and you may also change the bitmap depth and the monitor's refresh rate.  If successful, the change is immediate.</p>
<p>This method exercises some intelligence in adjusting the display to your requested settings.  For instance, if the requested width and/or height is not available, the closest display setting will be chosen.</p>
<p>This method does not work on anything other than top-level surface objects.  The current top-level surface object is usually named "SystemSurface" by default and can be searched for by that name.</p>
      </description>
      <result>
        <error code="Okay">Operation successful.</error>
        <error code="Failed">General failure.</error>
        <error code="Args">Invalid arguments passed to function.</error>
      </result>
    </method>

    <method>
      <name>SetOpacity</name>
      <comment>Alters the opacity of a surface object.</comment>
      <prototype>ERROR drwSetOpacity(OBJECTPTR Object, DOUBLE Value, DOUBLE Adjustment)</prototype>
      <input>
        <param type="DOUBLE" name="Value">The new opacity value between 0 and 100% (ignored if you have set the Adjustment parameter).</param>
        <param type="DOUBLE" name="Adjustment">Adjustment value to add or subtract from the existing opacity (set to zero if you want to set a fixed Value instead).</param>
      </input>
      <description>
<p>This method will change the opacity of the surface and execute a redraw to make the changes to the display.</p>
      </description>
      <result>
        <error code="Okay">The opacity of the surface object was changed.</error>
        <error code="NullArgs">Function call missing argument value(s)</error>
      </result>
    </method>

  </methods>

  <fields>
    <field>
      <name>AbsX</name>
      <comment>The absolute horizontal position of a surface object.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>INT</type>
      <description>
<p>This field returns the absolute horizontal position of a surface object. The absolute value is calculated based on the surface object's position relative to the top most surface object in the local hierarchy.</p>
<p>It is possible to set this field, but only after initialisation of the surface object has occurred.</p>
      </description>
    </field>

    <field>
      <name>AbsY</name>
      <comment>The absolute vertical position of a surface object.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>INT</type>
      <description>
<p>This field returns the absolute vertical position of a surface object. The absolute value is calculated based on the surface object's position relative to the top most surface object in the local hierarchy.</p>
<p>It is possible to set this field, but only after initialisation of the surface object has occurred.</p>
      </description>
    </field>

    <field>
      <name>Align</name>
      <comment>This field allows you to align a surface area within its owner.</comment>
      <access read="R" write="W">Read/Write</access>
      <type lookup="ALIGN">ALIGN</type>
      <description>
<p>If you would like to set an abstract position for a surface area, you can give it an alignment.  This feature is most commonly used for horizontal and vertical centring, as aligning to the the edges of a surface area is already handled by existing dimension fields.  Note that setting the alignment overrides any settings in related coordinate fields. Valid alignment flags are <code>BOTTOM</code>, <code>CENTER/MIDDLE</code>, <code>LEFT</code>, <code>HORIZONTAL</code>, <code>RIGHT</code>, <code>TOP</code>, <code>VERTICAL</code>.</p>
<types lookup="ALIGN"/>
      </description>
    </field>

    <field>
      <name>BitsPerPixel</name>
      <comment>Defines the number of bits per pixel for a surface.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>INT</type>
      <description>
<p>The BitsPerPixel field may be set prior to initialisation in order to force a particular bits-per-pixel setting that may not match the display.  This will result in the graphics system converting each pixel when drawing the surface to the display and as such is not recommended.</p>
      </description>
    </field>

    <field>
      <name>Bottom</name>
      <comment>Returns the bottom-most coordinate of a surface object (Y + Height).</comment>
      <access read="G">Get</access>
      <type>INT</type>
    </field>

    <field>
      <name>BottomLimit</name>
      <comment>Prevents a surface object from moving beyond a given point at the bottom of its container.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>INT</type>
      <description>
<p>You can prevent a surface object from moving beyond a given point at the bottom of its container by setting this field. If for example you were to set the BottomLimit to 5, then any attempt to move the surface object into or beyond the 5 units at the bottom of its container would fail.</p>
<p>Limits only apply to movement, as induced through the Move() action.  This means that limits can be over-ridden by setting the coordinate fields directly (which can be useful in certain cases).</p>
      </description>
    </field>

    <field>
      <name>BottomMargin</name>
      <comment>Manipulates the bottom margin of a surface object.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>INT</type>
      <description>
<p>The Surface class supports margin settings, which are similar to the concept of margins on printed paper.  Margin values have no significant meaning or effect on a surface object itself, but they are often used by other objects and can be helpful in interface construction.  For instance, the Window template uses margins to indicate the space available for placing graphics and other surface objects inside of it.</p>
<p>By default, all margins are set to zero when a new surface object is created.</p>
      </description>
    </field>

    <field>
      <name>Buffer</name>
      <comment>The ID of the bitmap that manages the surface's graphics.</comment>
      <access read="R">Read</access>
      <type>OBJECTID</type>
      <description>
<p>Each surface is assigned a bitmap buffer that is referred to in this field. In many cases the bitmap will be shared between multiple surfaces.  A client should avoid interacting with the buffer unless circumstances are such that there are no other means to get access to internal graphics information.</p>
<p>Please note that the bitmap object represents an off-screen, temporary buffer.  Drawing to the bitmap directly will have no impact on the display.</p>
      </description>
    </field>

    <field>
      <name>Colour</name>
      <comment>String-based field for setting the background colour.</comment>
      <access read="R" write="W">Read/Write</access>
      <type>RGB8</type>
      <description>
<p>If the surface object should have a plain background colour, set this field to the colour value that you want to use. The colour must be specified in the standard format of '#RRGGBB' for hexadecimal or 'Red,Green,Blue' for a decimal colour.</p>
<p>Surface objects that do not have a colour will not be cleared when being drawn.  The background will thus consist of 'junk' graphics and the background will need to be drawn using another method.  This gives your the power to choose the fastest drawing model to suit your needs.</p>
<p>If you set the Colour and later want to turn the background colour off, write a NULL value to the Colour field or set the Alpha component to zero.  Changing the Colour field does not cause a graphics redraw.</p>
      </description>
    </field>

    <field>
      <name>Cursor</name>
      <comment>A default cursor image can be set here for changing the mouse pointer.</comment>
      <access read="R" write="S">Read/Set</access>
      <type lookup="PTC">PTC</type>
      <description>
<p>The Cursor field provides a convenient way of setting the pointer's cursor image in a single operation.  The mouse pointer will automatically switch to the specified cursor image when it enters the surface area.</p>
<p>The available cursor image settings are listed in the <class name="Pointer" index="CursorID">Pointer:CursorID</class> documentation.</p>
<p>The Cursor field may be written with valid cursor names or their ID's, as you prefer.</p>
<types lookup="PTC"/>
      </description>
    </field>

    <field>
      <name>Dimensions</name>
      <comment>Indicates currently active dimension settings.</comment>
      <access read="R" write="S">Read/Set</access>
      <type lookup="DMF">INT</type>
      <description>
<p>The dimension settings of a surface object can be read from this field.  The flags indicate the dimension fields that are in use, and whether the values are fixed or relative.</p>
<p>It is strongly recommended that this field is never set manually, because the flags are automatically managed for the client when setting fields such as <field>X</field> and <field>Width</field>.  If circumstances require manual configuration, take care to ensure that the flags do not conflict.  For instance, <code>FIXED_X</code> and <code>RELATIVE_X</code> cannot be paired, nor could <code>FIXED_X</code>, <code>FIXED_XOFFSET</code> and <code>FIXED_WIDTH</code> simultaneously.</p>
<types lookup="DMF"/>
      </description>
    </field>

    <field>
      <name>Display</name>
      <comment>Refers to the <class name="Display">Display</class> object that is managing the surface's graphics.</comment>
      <access read="R">Read</access>
      <type>OBJECTID</type>
      <description>
<p>All surfaces belong to a <class name="Display">Display</class> object that manages drawing to the user's video display.  This field refers to the Display object of which the surface is a member.</p>
      </description>
    </field>

    <field>
      <name>Drag</name>
      <comment>This object-based field is used to control the dragging of objects around the display.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>OBJECTID</type>
      <description>
<p>Click-dragging of surfaces is enabled by utilising the Drag field.</p>
<p>To use, write this field with reference to a Surface that is to be dragged when the user starts a click-drag operation. For instance, if you create a window with a title-bar at the top, you would set the Drag field of the title-bar to point to the object ID of the window. If necessary, you can set the Drag field to point back to your surface object (this can be useful for creating icons and other small widgets).</p>
<p>To turn off dragging, set the field to zero.</p>
      </description>
    </field>

    <field>
      <name>DragStatus</name>
      <comment>Indicates the draggable state when dragging is enabled.</comment>
      <access read="R">Read</access>
      <type lookup="DRAG">DRAG</type>
      <description>
<p>If the surface is draggable, the DragStatus indicates the current state of the surface with respect to it being dragged.</p>
<types lookup="DRAG"/>
      </description>
    </field>

    <field>
      <name>Flags</name>
      <comment>Optional flags.</comment>
      <access read="R" write="S">Read/Set</access>
      <type lookup="RNF">INT</type>
      <description>
<p>The Flags field allows special options to be set for a surface object.  Use a logical-OR operation when setting this field so that existing flags are not overwritten.  To not do so can produce unexpected behaviour.</p>
<types lookup="RNF"/>
      </description>
    </field>

    <field>
      <name>Height</name>
      <comment>Defines the height of a surface object.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>INT</type>
      <description>
<p>The height of a surface object is manipulated through this field, although you can also use the Resize() action, which is faster if you need to set both the Width and the Height.  You can set the Height as a fixed value by default, or as a relative value if you set the <code>FD_PERCENT</code> marker. Relative heights are always calculated in relationship to a surface object's container, e.g. if the container is 200 pixels high and surface Height is 80%, then your surface object will be 160 pixels high.</p>
<p>Setting the Height while a surface object is on display causes an immediate graphical update to reflect the change. Any objects that are within the surface area will be re-drawn and resized as necessary.</p>
<p>If a value less than zero is passed to an initialised surface, the height will be 'turned off' - this is convenient for pairing the Y and YOffset fields together for dynamic height adjustment.</p>
      </description>
    </field>

    <field>
      <name>InsideHeight</name>
      <comment>Defines the amount of space between the vertical margins.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>INT</type>
      <description>
<p>You can determine the internal height of a surface object by reading the InsideHeight field.  The returned value is the result of calculating this formula: <code>Height - TopMargin - BottomMargin</code>.</p>
<p>If the TopMargin and BottomMargin fields are not set, the returned value will be equal to the surface object's height.</p>
      </description>
    </field>

    <field>
      <name>InsideWidth</name>
      <comment>Defines the amount of space between the horizontal margins.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>INT</type>
      <description>
<p>You can determine the internal width of a surface object by reading the InsideWidth field.  The returned value is the result of calculating this formula: <code>Width - LeftMargin - RightMargin</code>.</p>
<p>If the LeftMargin and RightMargin fields are not set, the returned value will be equal to the surface object's width.</p>
      </description>
    </field>

    <field>
      <name>LeftLimit</name>
      <comment>Prevents a surface object from moving beyond a given point on the left-hand side.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>INT</type>
      <description>
<p>You can prevent a surface object from moving beyond a given point at the left-hand side of its container by setting this field.  If for example you were to set the LeftLimit to 3, then any attempt to move the surface object into or beyond the 3 units at the left of its container would fail.</p>
<p>Limits only apply to movement, as induced through the <action>Move</action> action.  This means it is possible to override limits by setting the coordinate fields directly.</p>
      </description>
    </field>

    <field>
      <name>LeftMargin</name>
      <comment>Manipulates the left margin of a surface object.</comment>
      <access read="R" write="W">Read/Write</access>
      <type>INT</type>
      <description>
<p>The Surface class supports margin settings, which are similar to the concept of margins on printed paper.  Margin values have no significant meaning or effect on a surface object itself, but they are often used by other objects and can be helpful in interface construction.  For instance, the Window template uses margins to indicate the space available for placing graphics and other surface objects inside of it.</p>
<p>By default, all margins are set to zero when a new surface object is created.</p>
      </description>
    </field>

    <field>
      <name>MaxHeight</name>
      <comment>Prevents the height of a surface object from exceeding a certain value.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>INT</type>
      <description>
<p>You can limit the maximum height of a surface object by setting this field.  Limiting the height affects resizing, making it impossible to use the Resize() action to extend beyond the height you specify.</p>
<p>It is possible to circumvent the MaxHeight by setting the Height field directly.  Note that the MaxHeight value refers to the inside-height of the surface area, thus the overall maximum height will include both the <field>TopMargin</field> and <field>BottomMargin</field> values.</p>
      </description>
    </field>

    <field>
      <name>MaxWidth</name>
      <comment>Prevents the width of a surface object from exceeding a certain value.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>INT</type>
      <description>
<p>You can limit the maximum width of a surface object by setting this field.  Limiting the width affects resizing, making it impossible to use the Resize() action to extend beyond the width you specify.</p>
<p>It is possible to circumvent the MaxWidth by setting the Width field directly.  Note that the MaxWidth value refers to the inside-width of the surface area, thus the overall maximum width will include both the LeftMargin and RightMargin values.</p>
      </description>
    </field>

    <field>
      <name>MinHeight</name>
      <comment>Prevents the height of a surface object from shrinking beyond a certain value.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>INT</type>
      <description>
<p>You can prevent the height of a surface object from shrinking too far by setting this field.  This feature specifically affects resizing, making it impossible to use the Resize() action to shrink the height of a surface object to a value less than the one you specify.</p>
<p>It is possible to circumvent the MinHeight by setting the <field>Height</field> field directly.</p>
      </description>
    </field>

    <field>
      <name>MinWidth</name>
      <comment>Prevents the width of a surface object from shrinking beyond a certain value.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>INT</type>
      <description>
<p>You can prevent the width of a surface object from shrinking too far by setting this field.  This feature specifically affects resizing, making it impossible to use the Resize() action to shrink the width of a surface object to a value less than the one you specify.</p>
<p>It is possible to circumvent the MinWidth by setting the Width field directly.</p>
      </description>
    </field>

    <field>
      <name>Modal</name>
      <comment>Sets the surface as modal (prevents user interaction with other surfaces).</comment>
      <access read="R" write="S">Read/Set</access>
      <type>INT</type>
      <description>
<p>If TRUE, the surface will become the modal surface for the program when it is shown.  This prevents interaction with other surfaces until the modal surface is either hidden or destroyed.  Children of the modal surface may be interacted with normally.</p>
      </description>
    </field>

    <field>
      <name>Movement</name>
      <comment>Limits the movement of a surface object to vertical or horizontal shifts.</comment>
      <access read="R" write="S">Read/Set</access>
      <type lookup="MOVE">INT</type>
      <description>
<p>The directions in which a surface object can move can be limited by setting the Movement field.  By default, a surface object is capable of moving both horizontally and vertically.</p>
<p>This field is only effective in relation to the Move action, and it is possible to circumvent the restrictions by setting the coordinate fields directly.</p>
<types lookup="MOVE"/>
      </description>
    </field>

    <field>
      <name>Opacity</name>
      <comment>Affects the level of translucency applied to a surface object.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>DOUBLE</type>
      <description>
<p>This field determines the translucency level of a surface area.  The default setting is 100%, which means that the surface will be solid.  Any other value that you set here will alter the impact of a surface over its destination area. High values will retain the boldness of the graphics, while low values can surface it close to invisible.</p>
<p>Note: The translucent drawing routine works by drawing the surface content to its internal buffer first, then copying the graphics that are immediately in the background straight over the top with an alpha-blending routine.  This is not always ideal and better results might be obtainable with the pre-copy feature.</p>
<p>Please note that the use of translucency is realised at a significant cost to CPU usage.</p>
      </description>
    </field>

    <field>
      <name>Parent</name>
      <comment>The parent for a surface is defined here.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>OBJECTID</type>
      <description>
<p>The parent for child surfaces is defined here.  Top level surfaces will have no parent.  If the Parent field is not set prior to initialisation, the surface class will attempt to discover a valid parent by checking its ownership chain for a surface object.  This behaviour can be switched off by setting a Parent of zero prior to initialisation.</p>
      </description>
    </field>

    <field>
      <name>PopOver</name>
      <comment>Keeps a surface in front of another surface in the Z order.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>OBJECTID</type>
      <description>
<p>Setting the PopOver field to a sibling surface ID will keep the surface in front of its sibling at all times.  For dialog windows, it is recommended that the popover and modal options be combined together to prevent interaction with other surfaces created by the current program.</p>
<p>Setting the PopOver field to zero will return the surface to its normal state.</p>
<p>If an object that does not belong to the Surface class is detected, an attempt will be made to read that object's Surface field, if available.  If this does not yield a valid surface then ERR_InvalidObject is returned.</p>
      </description>
    </field>

    <field>
      <name>Right</name>
      <comment>Returns the right-most coordinate of a surface object (X + Width).</comment>
      <access read="G">Get</access>
      <type>INT</type>
    </field>

    <field>
      <name>RightLimit</name>
      <comment>Prevents a surface object from moving beyond a given point on the right-hand side.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>INT</type>
      <description>
<p>You can prevent a surface object from moving beyond a given point at the right-hand side of its container by setting this field.  If for example you were to set the RightLimit to 8, then any attempt to move the surface object into or beyond the 8 units at the right-hand side of its container would fail.</p>
<p>Limits only apply to movement, as induced through the <action>Move</action> action.  This means that limits can be over-ridden by setting the coordinate fields directly (which can be useful in certain cases).</p>
      </description>
    </field>

    <field>
      <name>RightMargin</name>
      <comment>Manipulates the right margin of a surface object.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>INT</type>
      <description>
<p>The Surface class supports margin settings, which are similar to the concept of margins on printed paper.  Margin values have no significant meaning or effect on a surface object itself, but they are often used by other objects and can be helpful in interface construction.  For instance, the Window template uses margins to indicate the space available for placing graphics and other surface objects inside of it.</p>
<p>By default, all margins are set to zero when a new surface object is created.</p>
      </description>
    </field>

    <field>
      <name>Root</name>
      <comment>Surface that is acting as a root for many surface children (useful when applying translucency)</comment>
      <access>-/-</access>
      <type>OBJECTID</type>
    </field>

    <field>
      <name>TopLimit</name>
      <comment>Prevents a surface object from moving beyond a given point at the top of its container.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>INT</type>
      <description>
<p>You can prevent a surface object from moving beyond a given point at the top of its container by setting this field. If for example you were to set the TopLimit to 10, then any attempt to move the surface object into or beyond the 10 units at the top of its container would fail.</p>
<p>Limits only apply to movement, as induced through the Move() action.  This means that limits can be over-ridden by setting the coordinate fields directly (which can be useful in certain cases).</p>
      </description>
    </field>

    <field>
      <name>TopMargin</name>
      <comment>Manipulates the top margin of a surface object.</comment>
      <access read="R" write="W">Read/Write</access>
      <type>INT</type>
      <description>
<p>The Surface class supports margin settings, which are similar to the concept of margins on printed paper.  Margin values have no significant meaning or effect on a surface object itself, but they are often used by other objects and can be helpful in interface construction.  For instance, the Window template uses margins to indicate the space available for placing graphics and other surface objects inside of it.</p>
<p>By default, all margins are set to zero when a new surface object is created.</p>
      </description>
    </field>

    <field>
      <name>UserFocus</name>
      <comment>Refers to the surface object that has the current focus.</comment>
      <access read="G">Get</access>
      <type>INT</type>
      <description>
<p>Returns the surface object that has the primary user focus.  Returns NULL if no object has the focus.</p>
      </description>
    </field>

    <field>
      <name>Visible</name>
      <comment>Indicates the visibility of a surface object.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>INT</type>
      <description>
<p>If you need to know if a surface object is visible or hidden, you can read this field to find out either way.  A TRUE value is returned if the object is visible and FALSE is returned if the object is invisible.  Note that visibility is subject to the properties of the container that the surface object resides in.  For example, if a surface object is visible but is contained within a surface object that is invisible, the end result is that both objects are actually invisible.</p>
<p>Visibility is directly affected by the Hide and Show actions if you wish to change the visibility of a surface object.</p>
      </description>
    </field>

    <field>
      <name>VisibleHeight</name>
      <comment>The visible height of the surface area, relative to its parents.</comment>
      <access read="G">Get</access>
      <type>INT</type>
      <description>
<p>To determine the visible area of a surface, read the VisibleX, VisibleY, VisibleWidth and VisibleHeight fields.</p>
<p>The 'visible area' is determined by the position of the surface relative to its parents.  For example, if the surface is 100 pixels across and smallest parent is 50 pixels across, the number of pixels visible to the user must be 50 pixels or less, depending on the position of the surface.</p>
<p>If none of the surface area is visible then zero is returned.  The result is never negative.</p>
      </description>
    </field>

    <field>
      <name>VisibleWidth</name>
      <comment>The visible width of the surface area, relative to its parents.</comment>
      <access read="G">Get</access>
      <type>INT</type>
      <description>
<p>To determine the visible area of a surface, read the VisibleX, VisibleY, VisibleWidth and VisibleHeight fields.</p>
<p>The 'visible area' is determined by the position of the surface relative to its parents.  For example, if the surface is 100 pixels across and smallest parent is 50 pixels across, the number of pixels visible to the user must be 50 pixels or less, depending on the position of the surface.</p>
<p>If none of the surface area is visible then zero is returned.  The result is never negative.</p>
      </description>
    </field>

    <field>
      <name>VisibleX</name>
      <comment>The first visible X coordinate of the surface area, relative to its parents.</comment>
      <access read="G">Get</access>
      <type>INT</type>
      <description>
<p>To determine the visible area of a surface, read the VisibleX, VisibleY, VisibleWidth and VisibleHeight fields.</p>
<p>The 'visible area' is determined by the position of the surface relative to its parents.  For example, if the surface is 100 pixels across and smallest parent is 50 pixels across, the number of pixels visible to the user must be 50 pixels or less, depending on the position of the surface.</p>
<p>If none of the surface area is visible then zero is returned.  The result is never negative.</p>
      </description>
    </field>

    <field>
      <name>VisibleY</name>
      <comment>The first visible Y coordinate of the surface area, relative to its parents.</comment>
      <access read="G">Get</access>
      <type>INT</type>
      <description>
<p>To determine the visible area of a surface, read the VisibleX, VisibleY, VisibleWidth and VisibleHeight fields.</p>
<p>The 'visible area' is determined by the position of the surface relative to its parents.  For example, if the surface is 100 pixels across and smallest parent is 50 pixels across, the number of pixels visible to the user must be 50 pixels or less, depending on the position of the surface.</p>
<p>If none of the surface area is visible then zero is returned.  The result is never negative.</p>
      </description>
    </field>

    <field>
      <name>Width</name>
      <comment>Defines the width of a surface object.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>INT</type>
      <description>
<p>The width of a surface object is manipulated through this field, although you can also use the Resize() action, which is faster if you need to set both the Width and the Height.  You can set the Width as a fixed value by default, or as a relative value if you set the <code>FD_PERCENT</code> field.  Relative widths are always calculated in relationship to a surface object's container, e.g. if the container is 200 pixels wide and surface Width is 80%, then your surface object will be 160 pixels wide.</p>
<p>Setting the Width while a surface object is on display causes an immediate graphical update to reflect the change.  Any objects that are within the surface area will be re-drawn and resized as necessary.</p>
<p>Width values of 0 or less are illegal, and will result in an <code>ERR_OutOfRange</code> error-code.</p>
      </description>
    </field>

    <field>
      <name>WindowHandle</name>
      <comment>Refers to a surface object's window handle, if relevant.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>APTR</type>
      <description>
<p>This field refers to the window handle of a surface object, but only if such a thing is relevant to the platform that the system is running on.  Currently, this field is only usable when creating a primary surface object within an X11 window manager or Microsoft Windows.</p>
<p>It is possible to set the WindowHandle field prior to initialisation if you want a surface object to be based on a window that already exists.</p>
      </description>
    </field>

    <field>
      <name>WindowType</name>
      <comment>Indicator for surfaces that represent themselves as a desktop window.</comment>
      <access read="G" write="S">Get/Set</access>
      <type lookup="SWIN">INT</type>
      <description>
<p>This field affects a surface's status on hosted desktops such as Windows and X11. It only affects top-level surfaces that have no parent - child surfaces ignore this field.  Surfaces created in the desktop area will also ignore this field, as the desktop is treated as a parent.</p>
<p>It is the responsibility of the developer to provide window gadgets such as titlebars and set the resize borders for custom surfaces.</p>
<types lookup="SWIN"/>
      </description>
    </field>

    <field>
      <name>X</name>
      <comment>Determines the horizontal position of a surface object.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>INT</type>
      <description>
<p>The horizontal position of a surface object can be set through this field.  You have the choice of setting a fixed coordinate (the default) or a relative coordinate if you use the <code>FD_PERCENT</code> flag.</p>
<p>If you set the X while the surface object is on display, the position of the surface area will be updated immediately.</p>
      </description>
    </field>

    <field>
      <name>XOffset</name>
      <comment>Determines the horizontal offset of a surface object.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>INT</type>
      <description>
<p>The XOffset has a dual purpose depending on whether or not it is set in conjunction with the X or Width fields.</p>
<p>If set in conjunction with the X field, the width of the surface object will be from that X coordinate up to the width of the container, minus the value given in the XOffset.  This means that the width of the surface object is dynamically calculated in relation to the width of its container.</p>
<p>If the XOffset field is set in conjunction with a fixed or relative width then the surface object will be positioned at an X coordinate calculated from the formula <code>X = ContainerWidth - SurfaceWidth - XOffset</code>.</p>
      </description>
    </field>

    <field>
      <name>Y</name>
      <comment>Determines the vertical position of a surface object.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>INT</type>
      <description>
<p>The vertical position of a surface object can be set through this field.  You have the choice of setting a fixed coordinate (the default) or a relative coordinate if you use the FD_PERCENT flag.</p>
<p>If the value is changed while the surface is on display, its position will be updated immediately.</p>
      </description>
    </field>

    <field>
      <name>YOffset</name>
      <comment>Determines the vertical offset of a surface object.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>INT</type>
      <description>
<p>The YOffset has a dual purpose depending on whether or not it is set in conjunction with the Y or Height fields.</p>
<p>If set in conjunction with the Y field, the height of the surface object will be from that Y coordinate up to the height of the container, minus the value given in the YOffset.  This means that the height of the surface object is dynamically calculated in relation to the height of its container.</p>
<p>If the YOffset field is set in conjunction with a fixed or relative height then the surface object will be positioned at a Y coordinate calculated from the formula "Y = ContainerHeight - SurfaceHeight - YOffset".</p>
      </description>
    </field>

  </fields>
  <types>
    <constants lookup="BAF" comment="Instructions for basic graphics operations.">
      <const name="BLEND">Enable alpha blending to the destination if the source supports an alpha channel.</const>
      <const name="COPY">Special CopyArea() option that avoids blending when the destination pixel is empty.</const>
      <const name="DITHER">Perform dithering if the colour formats differ between the source and destination.</const>
      <const name="FILL">For primitive operations such as DrawRectangle(), this will fill the shape with a solid colour or texture.</const>
      <const name="LINEAR">Use linear interpolation to improve the quality of alpha blending.</const>
    </constants>

    <constants lookup="BDF" comment="CopySurface() flags">
      <const name="DITHER">Allow the use of dithering to improve image quality at a cost of speed.</const>
      <const name="REDRAW">Redraw the surface before performing the copy operation.</const>
    </constants>

    <constants lookup="CRF" comment="Flags for the SetCursor() function.">
      <const name="BUFFER">Use of the BUFFER option allows the cursor request to be buffered in the event that the cursor is locked at the time of calling the SetCursor() function.  Use of this flag is highly recommended in most circumstances, but may not be used in conjunction with the ANCHOR option.</const>
      <const name="LMB">Release the cursor after the left mouse button is held and released.</const>
      <const name="MMB">Release the cursor after the middle mouse button is held and released.</const>
      <const name="NO_BUTTONS">Set the cursor only on the condition that the user is not holding down any buttons.  ERR_NothingDone is returned if the user has a button held down.</const>
      <const name="RESTRICT">Similar to the anchor option, but allows the pointer to move within the surface referred to by ObjectID.</const>
      <const name="RMB">Release the cursor after the right mouse button is held and released.</const>
    </constants>

    <constants lookup="CSRF" comment="Flags for CopySurface().">
      <const name="ALPHA">Enable alpha blending if the source is in 32-bit colour format with an alpha channel.</const>
      <const name="CLIP">Enable clipping of the source coordinates.</const>
      <const name="DEFAULT_FORMAT">Ignore the colour format defined in the source surface (if any) and generate a default format based on the BitsPerPixel value.</const>
      <const name="OFFSET">Adjust X and Y coordinates by the offset values defined in the Surface' XOffset and YOffset fields.</const>
      <const name="TRANSLUCENT">Perform a translucent copy operation, using the strength value specified in the Surface Opacity field.</const>
      <const name="TRANSPARENT">Enable transparent copying, whereby colours matching the source's Colour field will be ignored.</const>
    </constants>

    <constants lookup="DRAG">
      <const name="ANCHOR">The surface is being dragged and the mouse pointer is anchored to the surface.</const>
      <const name="NONE">The surface is not being dragged.</const>
      <const name="NORMAL">The surface is being dragged.</const>
    </constants>

    <constants lookup="DT" comment="Flags for GetDisplayType().">
      <const name="GLES">The display is driven by OpenGLES.</const>
      <const name="NATIVE">The display is native (supported by internal drivers).</const>
      <const name="WINDOWS">The display is driven by Microsoft Windows drivers.</const>
      <const name="X11">The display is driven by the X Window System (X11, X.Org, XFree86)</const>
    </constants>

    <constants lookup="EXF" comment="Optional flags for the ExposeSurface() function.">
      <const name="ABSOLUTE">The supplied coordinates for exposure are absolute (relative to the display).</const>
      <const name="ABSOLUTE_COORDS">The supplied coordinates for exposure are absolute (relative to the display).</const>
      <const name="CHILDREN">If set, all child surfaces that intersect with exposed region will be included in the expose operation.</const>
      <const name="REDRAW_VOLATILE">Redraw every volatile object that intersects with the expose region, including internal volatile children.</const>
      <const name="REDRAW_VOLATILE_OVERLAP">Only redraw volatile objects that obscure the expose region from a position outside of the target surface and its children.  Useful if no redrawing has occurred in the surface, but the surface has moved to a new position and the parents need to be redrawn.</const>
    </constants>

    <constants lookup="FLIP" comment="Flags for the bitmap Flip method.">
      <const name="HORIZONTAL">Flip the bitmap from top to bottom.</const>
      <const name="VERTICAL">Flip the bitmap from left to right.</const>
    </constants>

    <constants lookup="HOST">
      <const name="STICK_TO_FRONT">The hosted display sticks to the front.</const>
      <const name="TASKBAR">The hosted display is given a taskbar button.</const>
      <const name="TRANSLUCENCE">Change the alpha channel level for the entire window.</const>
      <const name="TRANSPARENT">Defines an RGB colour that is to be used as transparent.</const>
      <const name="TRAY_ICON">All new displays are represented in the system tray when this option is active.</const>
    </constants>

    <constants lookup="LVF" comment="drwLockBitmap() result flags">
      <const name="EXPOSE_CHANGES"/>
    </constants>

    <constants lookup="RNF">
      <const name="AFTER_COPY">Read-only.  Indicates that after-copy mode has been enabled.</const>
      <const name="ASPECT_RATIO">When resizing, enforce the aspect ratio as defined by MinWidth and MinHeight.</const>
      <const name="AUTO_QUIT">The surface object will send a quit message to its supporting process when and if the Close method is called.  This flag is typically used when a surface object represents a core window for an application.</const>
      <const name="COMPOSITE">Do not copy background information into the surface buffer - composite on the fly instead</const>
      <const name="DISABLED">This flag is set if the Disable action has been called on a surface object.  Calling the Enable action will turn off the flag setting.</const>
      <const name="FIXED_BUFFER">Passes the NEVER_SHRINK option to the surface bitmap</const>
      <const name="FIXED_DEPTH">The target buffer always remains at the same depth</const>
      <const name="FULL_SCREEN">Allow the surface to open as a new screen display</const>
      <const name="GRAB_FOCUS">Helps application windows manage the user's focus within the window</const>
      <const name="HAS_FOCUS">Read-only.  If set, this flag indicates that the surface object currently has the focus.</const>
      <const name="HOST">Define host on initialisation to create a container that can host surfaces from other processes.</const>
      <const name="IGNORE_FOCUS">Focus is diverted directly to the parent</const>
      <const name="INIT_ONLY">Synonym for HOST | TRANSPARENT | DISABLED | PRECOPY | VIDEO | FIXED_BUFFER | PERVASIVE_COPY | FIXED_DEPTH | FULL_SCREEN | IGNORE_FOCUS</const>
      <const name="NO_FOCUS">Prevents any kind of focussing on this object; no circumvention is possible</const>
      <const name="NO_HORIZONTAL">Turns off all horizontal movement (applies to the Move action only).</const>
      <const name="NO_PRECOMPOSITE">Do not copy background information into the surface buffer - composite on the fly instead</const>
      <const name="NO_VERTICAL">Turns off all vertical movement (applies to the Move action only).</const>
      <const name="PERVASIVE_COPY">This flag can be set in conjunction with after-copy mode.  It forces the after-copy support routine to copy graphics over the entire surface area, rather than avoiding the graphics of child surfaces.</const>
      <const name="POST_COMPOSITE">Do not copy background information into the surface buffer - composite on the fly instead</const>
      <const name="PRECOPY">Enables pre-copy mode, which means that all graphics behind the surface object are copied into the bitmap buffer prior to any redraw.  This mode can have a noticable impact on CPU time when drawing.</const>
      <const name="READ_ONLY">Synonym for HAS_FOCUS | CURSOR | AFTER_COPY</const>
      <const name="SCROLL_CONTENT">If set, the surface object will send Move and MoveToPoint messages if the Scroll and ScrollToPoint actions are ever called on the object.</const>
      <const name="STICKY">Prevents any response to the Move action.  It can be circumvented by writing to coordinate fields directly.</const>
      <const name="STICK_TO_BACK">Enable if the surface object must stick to the back of its container.</const>
      <const name="STICK_TO_FRONT">Enable if the surface object must stick to the front of its container.</const>
      <const name="TOTAL_REDRAW">Perform a total redraw of the entire surface when drawing - no partial draws</const>
      <const name="TRANSPARENT">Enables transparency, which means that the internal graphics routines will ignore this surface during redraws.  It is typically used when creating containers that will host other surfaces.</const>
      <const name="VIDEO">Set this flag if you would like the surface object's data to be managed in video memory only.  While this can give some speed advantages, be warned that video based surfaces are limited to write-only operations.</const>
      <const name="VISIBLE">If a surface object is visible to the user, the VISIBLE flag will be set.  If the flag is not set, the surface object is hidden.</const>
      <const name="VOLATILE">Synonym for PRECOPY | AFTER_COPY | CURSOR</const>
      <const name="WRITE_ONLY">Set this flag if you would like the surface object's data to be managed in video memory only.  While this can give some speed advantages, be warned that video based surfaces are limited to write-only operations.</const>
    </constants>

    <constants lookup="SWIN" comment="Options for the Surface WindowType field.">
      <const name="HOST">Default to the standard hosted window mode with full titlebar, borders and taskbar representation.</const>
      <const name="ICON_TRAY">Create a borderless (custom) window with icon tray representation.</const>
      <const name="NONE">Create a borderless (custom) window with no UI representation.</const>
      <const name="TASKBAR">Create a borderless (custom) window with taskbar representation.</const>
    </constants>

    <constants lookup="WH" comment="Events for WindowHook()">
      <const name="CLOSE"/>
    </constants>

  </types>
  <structs>
    <struct name="BitmapSurface" typeName="BITMAPSURFACE">
      <field name="Data" type="APTR">Pointer to the bitmap graphics data.</field>
      <field name="Width" type="WORD">Pixel width of the bitmap.</field>
      <field name="Height" type="WORD">Pixel height of the bitmap.</field>
      <field name="LineWidth" type="LONG">The distance between bitmap lines, measured in bytes.</field>
      <field name="BitsPerPixel" type="UBYTE">The number of bits per pixel (8, 15, 16, 24, 32).</field>
      <field name="BytesPerPixel" type="UBYTE">The number of bytes per pixel (1, 2, 3, 4).</field>
      <field name="Opacity" type="UBYTE">Opacity level of the source if CSRF_TRANSLUCENT is used.</field>
      <field name="Version" type="UBYTE">Version of this structure.</field>
      <field name="Colour" type="LONG">Colour index to use if CSRF_TRANSPARENT is used.</field>
      <field name="Clip" type="struct ClipRectangle">A clipping rectangle will restrict drawing operations to this region if CSRF_CLIP is used.</field>
      <field name="XOffset" type="WORD">Offset all X coordinate references by the given value.</field>
      <field name="YOffset" type="WORD">Offset all Y coordinate references by the given value.</field>
      <field name="Format" type="struct ColourFormat">The colour format of this bitmap's pixels, or alternatively use CSRF_DEFAULT_FORMAT.</field>
      <field name="Private" type="APTR">A private pointer reserved for internal usage</field>
    </struct>

    <struct name="CursorInfo">
      <field name="Width" type="LONG">Maximum cursor width for custom cursors</field>
      <field name="Height" type="LONG">Maximum cursor height for custom cursors</field>
      <field name="Flags" type="LONG">Currently unused</field>
      <field name="BitsPerPixel" type="WORD">Preferred bits-per-pixel setting for custom cursors</field>
    </struct>

    <struct name="DisplayInfo" typeName="DISPLAYINFO">
      <field name="Display" type="OBJECTID">Object ID related to the display</field>
      <field name="Flags" type="LONG" lookup="SCR">Display flags</field>
      <field name="Width" type="WORD">Pixel width of the display</field>
      <field name="Height" type="WORD">Pixel height of the display</field>
      <field name="BitsPerPixel" type="WORD">Bits per pixel</field>
      <field name="BytesPerPixel" type="WORD">Bytes per pixel</field>
      <field name="AccelFlags" type="LARGE" lookup="ACF">Flags describing supported hardware features.</field>
      <field name="AmtColours" type="LONG">Total number of supported colours.</field>
      <field name="PixelFormat" type="struct PixelFormat">The colour format to use for each pixel.</field>
      <field name="MinRefresh" type="FLOAT">Minimum refresh rate</field>
      <field name="MaxRefresh" type="FLOAT">Maximum refresh rate</field>
      <field name="RefreshRate" type="FLOAT">Recommended refresh rate</field>
      <field name="Index" type="LONG">Display mode ID (internal)</field>
      <field name="HDensity" type="LONG">Horizontal pixel density per inch.</field>
      <field name="VDensity" type="LONG">Vertical pixel density per inch.</field>
    </struct>

    <struct name="SurfaceInfo" typeName="SURFACEINFO">
      <field name="Data" type="APTR">Bitmap data memory ID</field>
      <field name="ParentID" type="OBJECTID">Object that contains the surface area</field>
      <field name="BitmapID" type="OBJECTID">Surface bitmap buffer</field>
      <field name="DisplayID" type="OBJECTID">Refers to the display if this object is at root level</field>
      <field name="Flags" type="LONG" lookup="RNF">Surface flags</field>
      <field name="X" type="LONG">Horizontal coordinate</field>
      <field name="Y" type="LONG">Vertical coordinate</field>
      <field name="Width" type="LONG">Width of the surface area</field>
      <field name="Height" type="LONG">Height of the surface area</field>
      <field name="AbsX" type="LONG">Absolute X coordinate</field>
      <field name="AbsY" type="LONG">Absolute Y coordinate</field>
      <field name="Level" type="WORD">Branch level within the tree</field>
      <field name="BitsPerPixel" type="BYTE">Bits per pixel of the bitmap</field>
      <field name="BytesPerPixel" type="BYTE">Bytes per pixel of the bitmap</field>
      <field name="LineWidth" type="LONG">Line width of the bitmap, in bytes</field>
    </struct>

  </structs>
</book>
