<?xml version="1.0" encoding="UTF-8"?>
<ai:m xmlns:ai="http://parasol-framework.org/ai-docs" n="Audio" v="1" cl="Audio,Sound">
  <ai:f n="MixContinue" c="Continue playing a stopped channel." p="ERR snd::MixContinue(objAudio * Audio, INT Handle)" r="ERR">
    <ai:i n="Audio" t="objAudio *" c="The target Audio object."/>
    <ai:i n="Handle" t="INT" c="The target channel."/>
    <ai:e c="Okay"/>
    <ai:e c="NullArgs"/>
  </ai:f>
  <ai:f n="MixEndSequence" c="Ends the buffering of mix commands." p="ERR snd::MixEndSequence(objAudio * Audio, INT Handle)" r="ERR">
    <ai:i n="Audio" t="objAudio *" c="The target Audio object."/>
    <ai:i n="Handle" t="INT" c="The target channel."/>
    <ai:e c="Okay"/>
    <ai:e c="NullArgs"/>
  </ai:f>
  <ai:f n="MixFrequency" c="Sets a channel's playback rate." p="ERR snd::MixFrequency(objAudio * Audio, INT Handle, INT Frequency)" r="ERR">
    <ai:i n="Audio" t="objAudio *" c="The target Audio object."/>
    <ai:i n="Handle" t="INT" c="The target channel."/>
    <ai:i n="Frequency" t="INT" c="The desired frequency."/>
    <ai:e c="Okay"/>
    <ai:e c="NullArgs"/>
  </ai:f>
  <ai:f n="MixMute" c="Mutes the audio of a channel." p="ERR snd::MixMute(objAudio * Audio, INT Handle, INT Mute)" r="ERR">
    <ai:i n="Audio" t="objAudio *" c="The target Audio object."/>
    <ai:i n="Handle" t="INT" c="The target channel."/>
    <ai:i n="Mute" t="INT" c="Set to true to mute the channel. A value of 0 will undo the mute setting."/>
    <ai:e c="Okay"/>
    <ai:e c="NullArgs"/>
  </ai:f>
  <ai:f n="MixPan" c="Sets a channel's panning value." p="ERR snd::MixPan(objAudio * Audio, INT Handle, DOUBLE Pan)" r="ERR">
    <ai:i n="Audio" t="objAudio *" c="The target Audio object."/>
    <ai:i n="Handle" t="INT" c="The target channel."/>
    <ai:i n="Pan" t="DOUBLE" c="The desired pan value between -1.0 and 1.0."/>
    <ai:e c="Okay"/>
    <ai:e c="NullArgs"/>
  </ai:f>
  <ai:f n="MixPlay" c="Commences channel playback at a set frequency." p="ERR snd::MixPlay(objAudio * Audio, INT Handle, INT Position)" r="ERR">
    <ai:i n="Audio" t="objAudio *" c="The target Audio object."/>
    <ai:i n="Handle" t="INT" c="The target channel."/>
    <ai:i n="Position" t="INT" c="The new playing position, measured in bytes."/>
    <ai:e c="Okay"/>
    <ai:e c="Failed"/>
    <ai:e c="OutOfRange"/>
    <ai:e c="NullArgs"/>
  </ai:f>
  <ai:f n="MixRate" c="Sets a new update rate for a channel." p="ERR snd::MixRate(objAudio * Audio, INT Handle, INT Rate)" r="ERR">
    <ai:i n="Audio" t="objAudio *" c="The target Audio object."/>
    <ai:i n="Handle" t="INT" c="The channel set allocated from OpenChannels()."/>
    <ai:i n="Rate" t="INT" c="The new update rate in milliseconds."/>
    <ai:e c="Okay"/>
    <ai:e c="NullArgs"/>
  </ai:f>
  <ai:f n="MixSample" c="Associate a sound sample with a mixer channel." p="ERR snd::MixSample(objAudio * Audio, INT Handle, INT Sample)" r="ERR">
    <ai:i n="Audio" t="objAudio *" c="The target Audio object."/>
    <ai:i n="Handle" t="INT" c="The target channel."/>
    <ai:i n="Sample" t="INT" c="A sample handle allocated from Audio.AddSample() or Audio.AddStream()."/>
    <ai:e c="Okay"/>
    <ai:e c="NullArgs"/>
  </ai:f>
  <ai:f n="MixStartSequence" c="Initiates buffering of mix commands." p="ERR snd::MixStartSequence(objAudio * Audio, INT Handle)" r="ERR">
    <ai:i n="Audio" t="objAudio *" c="The target Audio object."/>
    <ai:i n="Handle" t="INT" c="The target channel."/>
    <ai:e c="Okay"/>
    <ai:e c="NullArgs"/>
  </ai:f>
  <ai:f n="MixStop" c="Stops all playback on a channel." p="ERR snd::MixStop(objAudio * Audio, INT Handle)" r="ERR">
    <ai:i n="Audio" t="objAudio *" c="The target Audio object."/>
    <ai:i n="Handle" t="INT" c="The target channel."/>
    <ai:e c="Okay"/>
    <ai:e c="NullArgs"/>
  </ai:f>
  <ai:f n="MixStopLoop" c="Cancels any playback loop configured for a channel." p="ERR snd::MixStopLoop(objAudio * Audio, INT Handle)" r="ERR">
    <ai:i n="Audio" t="objAudio *" c="The target Audio object."/>
    <ai:i n="Handle" t="INT" c="The target channel."/>
    <ai:e c="Okay"/>
    <ai:e c="NullArgs"/>
  </ai:f>
  <ai:f n="MixVolume" c="Changes the volume of a channel." p="ERR snd::MixVolume(objAudio * Audio, INT Handle, DOUBLE Volume)" r="ERR">
    <ai:i n="Audio" t="objAudio *" c="The target Audio object."/>
    <ai:i n="Handle" t="INT" c="The target channel."/>
    <ai:i n="Volume" t="DOUBLE" c="The new volume for the channel."/>
    <ai:e c="Okay"/>
    <ai:e c="NullArgs"/>
  </ai:f>
  <ai:c l="ADF" c="Optional flags for the Audio object.">
    <ai:k n="AUTO_SAVE" c="Save configuration information on exit."/>
    <ai:k n="FILTER_HIGH" c="Enable a high level of output filtering to minimise distortion."/>
    <ai:k n="FILTER_LOW" c="Enable a low level of output filtering to minimise distortion."/>
    <ai:k n="OVER_SAMPLING" c="Enables oversampling for higher quality audio at the cost of slower mixing."/>
    <ai:k n="STEREO" c="Enable stereo output (set by default if the platform supports stereo). If not set, output is in mono."/>
    <ai:k n="SYSTEM_WIDE" c="Mixer changes should be applied system-wide."/>
    <ai:k n="VOL_RAMPING" c="Enable volume ramping for softer playback when a sample is played multiple times (enabled by default)."/>
  </ai:c>
  <ai:c l="CHF" c="Optional flags for the AudioChannel structure.">
    <ai:k n="BACKWARD" c="Play channel backwards."/>
    <ai:k n="CHANGED" c="Sample change"/>
    <ai:k n="MUTE" c="Channel is muted."/>
    <ai:k n="VOL_RAMP" c="Volume ramping is enabled."/>
  </ai:c>
  <ai:c l="CHS" c="Channel status types for the AudioChannel structure.">
    <ai:k n="FADE_OUT" c="Playback is fading out."/>
    <ai:k n="FINISHED" c="Playback concluded by reaching the sample end."/>
    <ai:k n="PLAYING" c="Sample playing and not released."/>
    <ai:k n="RELEASED" c="Sample playing and note has been released."/>
    <ai:k n="STOPPED" c="Playing was stopped by the client."/>
  </ai:c>
  <ai:c l="LOOP" c="Loop modes for the AudioLoop structure.">
    <ai:k n="AMIGA" c="Single loop: Amiga style."/>
    <ai:k n="AMIGA_NONE" c="Amiga loop: Do nothing."/>
    <ai:k n="DOUBLE" c="Double loop: When the note is released, playing shifts to the second loop."/>
    <ai:k n="SINGLE" c="Single loop: Releasing will end the note."/>
    <ai:k n="SINGLE_RELEASE" c="Single loop: Sample data after the loop will be played when the note is released."/>
  </ai:c>
  <ai:c l="LTYPE" c="Loop types for the AudioLoop structure.">
    <ai:k n="BIDIRECTIONAL" c="The sample will play in reverse whenever it hits the end marker, then forwards when it hits the start marker."/>
    <ai:k n="UNIDIRECTIONAL" c="The sample playback position returns to the byte position specified in the Loop1Start field."/>
  </ai:c>
  <ai:c l="NOTE" c="Definitions for the Note field. An 'S' indicates a sharp note.">
    <ai:k n="A"/>
    <ai:k n="AS"/>
    <ai:k n="B"/>
    <ai:k n="C"/>
    <ai:k n="CS"/>
    <ai:k n="D"/>
    <ai:k n="DS"/>
    <ai:k n="E"/>
    <ai:k n="F"/>
    <ai:k n="FS"/>
    <ai:k n="G"/>
    <ai:k n="GS"/>
    <ai:k n="OCTAVE"/>
  </ai:c>
  <ai:c l="SDF" c="Sound flags">
    <ai:k n="LOOP" c="Enables sample looping. The LoopStart and LoopEnd fields determine where the looping area lies within the sample data."/>
    <ai:k n="NEW" c="Create the sample from scratch (e.g. for audio recording purposes)."/>
    <ai:k n="RESTRICT_PLAY" c="Restricts playback so that the sound can never play on more than one channel at any given time."/>
    <ai:k n="STEREO" c="Indicates that the sound has multiple audio channels."/>
    <ai:k n="STREAM" c="Read-Only. Indicates that streaming is enabled."/>
  </ai:c>
  <ai:c l="SFM" c="These audio bit formats are supported by AddSample and AddStream.">
    <ai:k n="F_BIG_ENDIAN" c="Combine this flag with any audio format to declare it as big endian."/>
    <ai:k n="S16_BIT_MONO" c="16-bit mono signed sample."/>
    <ai:k n="S16_BIT_STEREO" c="16-bit stereo signed sample."/>
    <ai:k n="U8_BIT_MONO" c="8-bit mono unsigned sample."/>
    <ai:k n="U8_BIT_STEREO" c="8-bit stereo unsigned sample."/>
  </ai:c>
  <ai:c l="STREAM" c="Streaming options">
    <ai:k n="ALWAYS" c="Stream if the sample length exceeds 64k."/>
    <ai:k n="NEVER" c="No streaming - load all data into memory."/>
    <ai:k n="SMART" c="Smart streaming is the default. If the sample appears to be relatively small with respect to available system RAM, it will be loaded into memory. Otherwise it will be streamed."/>
  </ai:c>
  <ai:c l="SVF" c="Flags for the SetVolume() method.">
    <ai:k n="CAPTURE" c="Set input, not output."/>
    <ai:k n="MUTE" c="Mute the audio for this channel."/>
    <ai:k n="UNMUTE" c="Unmute the audio for this channel."/>
  </ai:c>
  <ai:c l="VCF" c="Volume control flags">
    <ai:k n="CAPTURE" c="The mixer supports audio input."/>
    <ai:k n="JOINED" c="The mixer channels are joined (e.g. left and right speakers cannot be adjusted separately)."/>
    <ai:k n="MONO" c="The mixer is restricted to mono input/output."/>
    <ai:k n="MUTE" c="The mixer is muted."/>
    <ai:k n="PLAYBACK" c="The mixer supports audio output."/>
    <ai:k n="SYNC" c="The mixer is synchronised."/>
  </ai:c>
  <ai:s n="AudioLoop">
    <ai:f n="LoopMode" t="LOOP" c="Loop mode (single, double)"/>
    <ai:f n="Loop1Type" t="LTYPE" c="First loop type (unidirectional, bidirectional)"/>
    <ai:f n="Loop2Type" t="LTYPE" c="Second loop type (unidirectional, bidirectional)"/>
    <ai:f n="Loop1Start" t="INT" c="Start of the first loop"/>
    <ai:f n="Loop1End" t="INT" c="End of the first loop"/>
    <ai:f n="Loop2Start" t="INT" c="Start of the second loop"/>
    <ai:f n="Loop2End" t="INT" c="End of the second loop"/>
  </ai:s>
</ai:m>
