<?xml version="1.0" encoding="UTF-8"?>
<ai:m xmlns:ai="http://parasol-framework.org/ai-docs" n="Vector" v="1" cl="BlurFX,ColourFX,CompositeFX,ConvolveFX,DisplacementFX,FilterEffect,FloodFX,ImageFX,LightingFX,MergeFX,MorphologyFX,OffsetFX,RemapFX,SourceFX,TurbulenceFX,Vector,VectorClip,VectorColour,VectorEllipse,VectorFilter,VectorGradient,VectorGroup,VectorImage,VectorPath,VectorPattern,VectorPolygon,VectorRectangle,VectorScene,VectorShape,VectorSpiral,VectorText,VectorTransition,VectorViewport,VectorWave,WaveFunctionFX">
  <ai:f n="ApplyPath" c="Copy a pre-generated or custom path to a VectorPath object." p="ERR vec::ApplyPath(APTR Path, objVectorPath * VectorPath)" r="ERR">
    <ai:i n="Path" t="APTR" c="The source path to be copied."/>
    <ai:i n="VectorPath" t="objVectorPath *" c="The target VectorPath object."/>
    <ai:e c="Okay"/>
    <ai:e c="NullArgs"/>
  </ai:f>
  <ai:f n="ArcTo" c="Alter a path by setting an arc-to command at the current vertex position." p="void vec::ArcTo(APTR Path, DOUBLE RX, DOUBLE RY, DOUBLE Angle, DOUBLE X, DOUBLE Y, ARC Flags)">
    <ai:i n="Path" t="APTR" c="The vector path to modify."/>
    <ai:i n="RX" t="DOUBLE" c="The horizontal radius of the arc."/>
    <ai:i n="RY" t="DOUBLE" c="The vertical radius of the arc."/>
    <ai:i n="Angle" t="DOUBLE" c="The angle of the arc, expressed in radians."/>
    <ai:i n="X" t="DOUBLE" c="The horizontal end point for the arc command."/>
    <ai:i n="Y" t="DOUBLE" c="The vertical end point for the arc command."/>
    <ai:i n="Flags" t="ARC" c="Optional flags."/>
  </ai:f>
  <ai:f n="CharWidth" c="Returns the width of a character." p="DOUBLE vec::CharWidth(APTR FontHandle, UINT Char, UINT KChar, DOUBLE * Kerning)" r="DOUBLE">
    <ai:i n="FontHandle" t="APTR" c="The font to use for calculating the character width."/>
    <ai:i n="Char" t="UINT" c="A 32-bit unicode character."/>
    <ai:i n="KChar" t="UINT" c="A unicode character to use for calculating the font kerning (optional)."/>
    <ai:i n="Kerning" t="DOUBLE *" c="The resulting kerning value (optional)."/>
  </ai:f>
  <ai:f n="ClosePath" c="Close the path by connecting the beginning and end points." p="void vec::ClosePath(APTR Path)">
    <ai:i n="Path" t="APTR" c="The vector path to modify."/>
  </ai:f>
  <ai:f n="Curve3" c="Alter a path by inserting a quadratic bezier curve command at the current vertex position." p="void vec::Curve3(APTR Path, DOUBLE CtrlX, DOUBLE CtrlY, DOUBLE X, DOUBLE Y)">
    <ai:i n="Path" t="APTR" c="The vector path to modify."/>
    <ai:i n="CtrlX" t="DOUBLE" c="Control point horizontal coordinate."/>
    <ai:i n="CtrlY" t="DOUBLE" c="Control point vertical coordinate."/>
    <ai:i n="X" t="DOUBLE" c="The horizontal end point for the curve3 command."/>
    <ai:i n="Y" t="DOUBLE" c="The vertical end point for the curve3 command."/>
  </ai:f>
  <ai:f n="Curve4" c="Alter a path by inserting a curve4 command at the current vertex position." p="void vec::Curve4(APTR Path, DOUBLE CtrlX1, DOUBLE CtrlY1, DOUBLE CtrlX2, DOUBLE CtrlY2, DOUBLE X, DOUBLE Y)">
    <ai:i n="Path" t="APTR" c="The vector path to modify."/>
    <ai:i n="CtrlX1" t="DOUBLE" c="Control point 1 horizontal coordinate."/>
    <ai:i n="CtrlY1" t="DOUBLE" c="Control point 1 vertical coordinate."/>
    <ai:i n="CtrlX2" t="DOUBLE" c="Control point 2 horizontal coordinate."/>
    <ai:i n="CtrlY2" t="DOUBLE" c="Control point 2 vertical coordinate."/>
    <ai:i n="X" t="DOUBLE" c="The horizontal end point for the curve4 command."/>
    <ai:i n="Y" t="DOUBLE" c="The vertical end point for the curve4 command."/>
  </ai:f>
  <ai:f n="DrawPath" c="Draws a vector path to a target bitmap." p="ERR vec::DrawPath(objBitmap * Bitmap, APTR Path, DOUBLE StrokeWidth, OBJECTPTR StrokeStyle, OBJECTPTR FillStyle)" r="ERR">
    <ai:i n="Bitmap" t="objBitmap *" c="Pointer to a target Bitmap object."/>
    <ai:i n="Path" t="APTR" c="The vector path to render."/>
    <ai:i n="StrokeWidth" t="DOUBLE" c="The width of the stroke. Set to 0 if no stroke is required."/>
    <ai:i n="StrokeStyle" t="OBJECTPTR" c="Pointer to a valid object for stroke definition, or NULL if none required."/>
    <ai:i n="FillStyle" t="OBJECTPTR" c="Pointer to a valid object for fill definition, or NULL if none required."/>
    <ai:e c="Okay"/>
    <ai:e c="NullArgs"/>
  </ai:f>
  <ai:f n="FlushMatrix" c="Flushes matrix changes to a vector." p="ERR vec::FlushMatrix(struct VectorMatrix * Matrix)" r="ERR">
    <ai:i n="Matrix" t="struct VectorMatrix *" c="The matrix to be flushed."/>
    <ai:e c="Okay"/>
    <ai:e c="NullArgs"/>
  </ai:f>
  <ai:f n="GenerateEllipse" c="Generates an elliptical path." p="ERR vec::GenerateEllipse(DOUBLE CX, DOUBLE CY, DOUBLE RX, DOUBLE RY, INT Vertices, APTR * Path)" r="ERR">
    <ai:i n="CX" t="DOUBLE" c="Horizontal center point of the ellipse."/>
    <ai:i n="CY" t="DOUBLE" c="Vertical center point of the ellipse."/>
    <ai:i n="RX" t="DOUBLE" c="Horizontal radius of the ellipse."/>
    <ai:i n="RY" t="DOUBLE" c="Vertical radius of the ellipse."/>
    <ai:i n="Vertices" t="INT" c="Optional. If &gt;= 3, the total number of generated vertices will be limited to the specified value."/>
    <ai:i n="Path" t="APTR *" c="A pointer variable that will receive the resulting path."/>
    <ai:e c="Okay"/>
    <ai:e c="AllocMemory"/>
    <ai:e c="NullArgs"/>
  </ai:f>
  <ai:f n="GeneratePath" c="Generates a path from an SVG path command sequence, or an empty path for custom configuration." p="ERR vec::GeneratePath(CSTRING Sequence, APTR * Path)" r="ERR">
    <ai:i n="Sequence" t="CSTRING" c="The command sequence to process. If no sequence is specified then the path will be empty."/>
    <ai:i n="Path" t="APTR *" c="A pointer variable that will receive the resulting path."/>
    <ai:e c="Okay"/>
    <ai:e c="AllocMemory"/>
    <ai:e c="NullArgs"/>
  </ai:f>
  <ai:f n="GenerateRectangle" c="Generate a rectangular path at (x,y) with size (width,height)." p="ERR vec::GenerateRectangle(DOUBLE X, DOUBLE Y, DOUBLE Width, DOUBLE Height, APTR * Path)" r="ERR">
    <ai:i n="X" t="DOUBLE" c="The horizontal position of the rectangle."/>
    <ai:i n="Y" t="DOUBLE" c="The vertical position of the rectangle."/>
    <ai:i n="Width" t="DOUBLE" c="The width of the rectangle."/>
    <ai:i n="Height" t="DOUBLE" c="The height of the rectangle."/>
    <ai:i n="Path" t="APTR *" c="A pointer variable that will receive the resulting path."/>
    <ai:e c="Okay"/>
    <ai:e c="AllocMemory"/>
    <ai:e c="NullArgs"/>
  </ai:f>
  <ai:f n="GetFontHandle" c="Returns a handle for a given font family." p="ERR vec::GetFontHandle(CSTRING Family, CSTRING Style, INT Weight, INT Size, APTR * Handle)" r="ERR">
    <ai:i n="Family" t="CSTRING" c="The name of the font family to access."/>
    <ai:i n="Style" t="CSTRING" c="The preferred style to choose from the family. Use Regular or NULL for the default."/>
    <ai:i n="Weight" t="INT" c="Equivalent to CSS font-weight; a value of 400 or 0 will equate to normal."/>
    <ai:i n="Size" t="INT" c="The font-size, measured in pixels @ 72 DPI."/>
    <ai:i n="Handle" t="APTR *" c="The resulting font handle is returned here."/>
    <ai:e c="Okay"/>
    <ai:e c="Args"/>
    <ai:e c="NullArgs"/>
  </ai:f>
  <ai:f n="GetFontMetrics" c="Returns a set of display metric values for a font." p="ERR vec::GetFontMetrics(APTR Handle, struct FontMetrics * Info)" r="ERR">
    <ai:i n="Handle" t="APTR" c="A font handle obtained from GetFontHandle."/>
    <ai:i n="Info" t="struct FontMetrics *" c="The font metrics for the Handle will be stored here."/>
    <ai:e c="Okay"/>
    <ai:e c="NullArgs"/>
  </ai:f>
  <ai:f n="GetVertex" c="Retrieve the coordinates of the current vertex." p="INT vec::GetVertex(APTR Path, DOUBLE * X, DOUBLE * Y)" r="INT">
    <ai:i n="Path" t="APTR" c="The vector path to query."/>
    <ai:i n="X" t="DOUBLE *" c="Pointer to a double that will receive the X coordinate value."/>
    <ai:i n="Y" t="DOUBLE *" c="Pointer to a double that will receive the Y coordinate value."/>
  </ai:f>
  <ai:f n="LineTo" c="Alter a path by setting a line-to command at the current vertex position." p="void vec::LineTo(APTR Path, DOUBLE X, DOUBLE Y)">
    <ai:i n="Path" t="APTR" c="The vector path to modify."/>
    <ai:i n="X" t="DOUBLE" c="The line end point on the horizontal plane."/>
    <ai:i n="Y" t="DOUBLE" c="The line end point on the vertical plane."/>
  </ai:f>
  <ai:f n="MoveTo" c="Alter a path by setting a move-to command at the current vertex position." p="void vec::MoveTo(APTR Path, DOUBLE X, DOUBLE Y)">
    <ai:i n="Path" t="APTR" c="The vector path to modify."/>
    <ai:i n="X" t="DOUBLE" c="The horizontal end point for the command."/>
    <ai:i n="Y" t="DOUBLE" c="The vertical end point for the command."/>
  </ai:f>
  <ai:f n="Multiply" c="Combines a matrix with a series of matrix values." p="ERR vec::Multiply(struct VectorMatrix * Matrix, DOUBLE ScaleX, DOUBLE ShearY, DOUBLE ShearX, DOUBLE ScaleY, DOUBLE TranslateX, DOUBLE TranslateY)" r="ERR">
    <ai:i n="Matrix" t="struct VectorMatrix *" c="The target transformation matrix."/>
    <ai:i n="ScaleX" t="DOUBLE" c="Matrix value A."/>
    <ai:i n="ShearY" t="DOUBLE" c="Matrix value B."/>
    <ai:i n="ShearX" t="DOUBLE" c="Matrix value C."/>
    <ai:i n="ScaleY" t="DOUBLE" c="Matrix value D."/>
    <ai:i n="TranslateX" t="DOUBLE" c="Matrix value E."/>
    <ai:i n="TranslateY" t="DOUBLE" c="Matrix value F."/>
    <ai:e c="Okay"/>
    <ai:e c="NullArgs"/>
  </ai:f>
  <ai:f n="MultiplyMatrix" c="Combines a source matrix with a target." p="ERR vec::MultiplyMatrix(struct VectorMatrix * Target, struct VectorMatrix * Source)" r="ERR">
    <ai:i n="Target" t="struct VectorMatrix *" c="The target transformation matrix."/>
    <ai:i n="Source" t="struct VectorMatrix *" c="The source transformation matrix."/>
    <ai:e c="Okay"/>
    <ai:e c="NullArgs"/>
  </ai:f>
  <ai:f n="ParseTransform" c="Parse an SVG transformation string and apply the values to a matrix." p="ERR vec::ParseTransform(struct VectorMatrix * Matrix, CSTRING Transform)" r="ERR">
    <ai:i n="Matrix" t="struct VectorMatrix *" c="The target transformation matrix."/>
    <ai:i n="Transform" t="CSTRING" c="The transform to apply, expressed as a string instruction."/>
    <ai:e c="Okay"/>
    <ai:e c="NullArgs"/>
  </ai:f>
  <ai:f n="ReadPainter" c="Parses a painter string to its colour, gradient, pattern or image value." p="ERR vec::ReadPainter(objVectorScene * Scene, CSTRING IRI, struct VectorPainter * Painter, CSTRING * Result)" r="ERR">
    <ai:i n="Scene" t="objVectorScene *" c="Optional. Required if url() references are to be resolved."/>
    <ai:i n="IRI" t="CSTRING" c="The IRI string to be translated."/>
    <ai:i n="Painter" t="struct VectorPainter *" c="This VectorPainter structure will store the deserialised result."/>
    <ai:i n="Result" t="CSTRING *" c="Optional pointer for storing the end of the parsed IRI string. NULL is returned if there is no further content to parse or an error occurred."/>
    <ai:e c="Okay"/>
    <ai:e c="Failed"/>
    <ai:e c="NullArgs"/>
  </ai:f>
  <ai:f n="ResetMatrix" c="Resets a transformation matrix to its default state." p="ERR vec::ResetMatrix(struct VectorMatrix * Matrix)" r="ERR">
    <ai:i n="Matrix" t="struct VectorMatrix *" c="The target transformation matrix."/>
    <ai:e c="Okay"/>
    <ai:e c="NullArgs"/>
  </ai:f>
  <ai:f n="RewindPath" c="Resets the vertex seek position to zero." p="void vec::RewindPath(APTR Path)">
    <ai:i n="Path" t="APTR" c="The vector path to rewind."/>
  </ai:f>
  <ai:f n="Rotate" c="Applies a rotation transformation to a matrix." p="ERR vec::Rotate(struct VectorMatrix * Matrix, DOUBLE Angle, DOUBLE CenterX, DOUBLE CenterY)" r="ERR">
    <ai:i n="Matrix" t="struct VectorMatrix *" c="The target transformation matrix."/>
    <ai:i n="Angle" t="DOUBLE" c="Angle of rotation, in degrees."/>
    <ai:i n="CenterX" t="DOUBLE" c="Center of rotation on the horizontal axis."/>
    <ai:i n="CenterY" t="DOUBLE" c="Center of rotation on the vertical axis."/>
    <ai:e c="Okay"/>
    <ai:e c="NullArgs"/>
  </ai:f>
  <ai:f n="Scale" c="Scale the size of the vector by (x,y)" p="ERR vec::Scale(struct VectorMatrix * Matrix, DOUBLE X, DOUBLE Y)" r="ERR">
    <ai:i n="Matrix" t="struct VectorMatrix *" c="The target transformation matrix."/>
    <ai:i n="X" t="DOUBLE" c="The scale factor on the x-axis."/>
    <ai:i n="Y" t="DOUBLE" c="The scale factor on the y-axis."/>
    <ai:e c="Okay"/>
    <ai:e c="NullArgs"/>
  </ai:f>
  <ai:f n="Skew" c="Skews the matrix along the horizontal and/or vertical axis." p="ERR vec::Skew(struct VectorMatrix * Matrix, DOUBLE X, DOUBLE Y)" r="ERR">
    <ai:i n="Matrix" t="struct VectorMatrix *" c="The target transformation matrix."/>
    <ai:i n="X" t="DOUBLE" c="The angle to skew along the horizontal."/>
    <ai:i n="Y" t="DOUBLE" c="The angle to skew along the vertical."/>
    <ai:e c="Okay"/>
    <ai:e c="OutOfRange"/>
    <ai:e c="NullArgs"/>
  </ai:f>
  <ai:f n="Smooth3" c="Alter a path by setting a smooth3 command at the current vertex position." p="void vec::Smooth3(APTR Path, DOUBLE X, DOUBLE Y)">
    <ai:i n="Path" t="APTR" c="The vector path to modify."/>
    <ai:i n="X" t="DOUBLE" c="The horizontal end point for the smooth3 command."/>
    <ai:i n="Y" t="DOUBLE" c="The vertical end point for the smooth3 command."/>
  </ai:f>
  <ai:f n="Smooth4" c="Alter a path by setting a smooth4 command at the current vertex position." p="void vec::Smooth4(APTR Path, DOUBLE CtrlX, DOUBLE CtrlY, DOUBLE X, DOUBLE Y)">
    <ai:i n="Path" t="APTR" c="The vector path to modify."/>
    <ai:i n="CtrlX" t="DOUBLE" c="Control point horizontal coordinate."/>
    <ai:i n="CtrlY" t="DOUBLE" c="Control point vertical coordinate."/>
    <ai:i n="X" t="DOUBLE" c="The horizontal end point for the smooth4 instruction."/>
    <ai:i n="Y" t="DOUBLE" c="The vertical end point for the smooth4 instruction."/>
  </ai:f>
  <ai:f n="StringWidth" c="Calculate the pixel width of a UTF-8 string, for a given font." p="DOUBLE vec::StringWidth(APTR FontHandle, CSTRING String, INT Chars)" r="DOUBLE">
    <ai:i n="FontHandle" t="APTR" c="A font handle obtained from GetFontHandle."/>
    <ai:i n="String" t="CSTRING" c="Pointer to a null-terminated string."/>
    <ai:i n="Chars" t="INT" c="The maximum number of unicode characters to process in calculating the string width. Set to -1 for all chars."/>
  </ai:f>
  <ai:f n="TracePath" c="Returns the coordinates for a vector path, using callbacks." p="ERR vec::TracePath(APTR Path, FUNCTION * Callback, DOUBLE Scale)" r="ERR">
    <ai:i n="Path" t="APTR" c="The vector path to trace."/>
    <ai:i n="Callback" t="FUNCTION *" c="A function to call with the path coordinates."/>
    <ai:i n="Scale" t="DOUBLE" c="Set to 1.0 (recommended) to trace the path at a scale of 1 to 1."/>
    <ai:e c="Okay"/>
    <ai:e c="NullArgs"/>
  </ai:f>
  <ai:f n="Translate" c="Translates the vector by (X,Y)." p="ERR vec::Translate(struct VectorMatrix * Matrix, DOUBLE X, DOUBLE Y)" r="ERR">
    <ai:i n="Matrix" t="struct VectorMatrix *" c="The target transformation matrix."/>
    <ai:i n="X" t="DOUBLE" c="Translation along the x-axis."/>
    <ai:i n="Y" t="DOUBLE" c="Translation along the y-axis."/>
    <ai:e c="Okay"/>
    <ai:e c="NullArgs"/>
  </ai:f>
  <ai:f n="TranslatePath" c="Translates a path by (x,y)" p="void vec::TranslatePath(APTR Path, DOUBLE X, DOUBLE Y)">
    <ai:i n="Path" t="APTR" c="Pointer to a generated path."/>
    <ai:i n="X" t="DOUBLE" c="Translate the path horizontally by the given value."/>
    <ai:i n="Y" t="DOUBLE" c="Translate the path vertically by the given value."/>
  </ai:f>
  <ai:c l="ARC" c="Options for drawing arcs.">
    <ai:k n="LARGE" c="The arc will take the longest available drawing path rather than the shortest."/>
    <ai:k n="SWEEP" c="Inverts the default behaviour in generating the arc path (go clockwise)."/>
  </ai:c>
  <ai:c l="ARF" c="Aspect ratios control alignment, scaling and clipping.">
    <ai:k n="MEET" c="Aspect ratio is preserved. The entire viewbox will be visible in the viewport. The viewbox is scaled up as much as possible."/>
    <ai:k n="NONE" c="Scale the viewbox to match the size of the viewport. Aspect ratio is not preserved."/>
    <ai:k n="SLICE" c="Aspect ratio is preserved. The viewbox can extend beyond the viewport's edges on one axis. The viewbox is scaled up as much as possible."/>
    <ai:k n="X_MAX" c="Align to the right."/>
    <ai:k n="X_MID" c="Align to the horizontal center."/>
    <ai:k n="X_MIN" c="Align to the left."/>
    <ai:k n="Y_MAX" c="Align to the bottom."/>
    <ai:k n="Y_MID" c="Align to the vertical center."/>
    <ai:k n="Y_MIN" c="Align to the top."/>
  </ai:c>
  <ai:c l="CM" c="Colour modes for ColourFX.">
    <ai:k n="BRIGHTNESS" c="Adjust brightness using the first parameter to define the intensity."/>
    <ai:k n="COLOURISE" c="Colourise the input with the first 3 parameters used as RGB multipliers and the fourth parameter controlling intensity from 0 - 1.0."/>
    <ai:k n="CONTRAST" c="Adjust contrast using the first parameter to define the intensity from -1.0 to 1.0."/>
    <ai:k n="DESATURATE" c="Desaturate the input completely so that it is rendered in greyscale."/>
    <ai:k n="HUE" c="Adjust the hue by 0 - 360 degrees using the first parameter."/>
    <ai:k n="HUE_ROTATE" c="Rotate the hue by 0 - 360 degrees, controlled by the first parameter."/>
    <ai:k n="LUMINANCE_ALPHA" c="Converts each RGB value to greyscale, which then overrides the alpha channel."/>
    <ai:k n="MATRIX" c="Process the supplied 5x4 matrix values."/>
    <ai:k n="NONE" c="Do nothing."/>
    <ai:k n="SATURATE" c="Adjust colour saturation with the first parameter defining the multiplier."/>
  </ai:c>
  <ai:c l="CMP" c="Component selection for RemapFX methods.">
    <ai:k n="ALL" c="All colour channels."/>
    <ai:k n="ALPHA" c="The alpha channel."/>
    <ai:k n="BLUE" c="The blue colour channel."/>
    <ai:k n="GREEN" c="The green colour channel."/>
    <ai:k n="RED" c="The red colour channel."/>
  </ai:c>
  <ai:c l="DMF">
    <ai:k n="FIXED_CENTER_X" c="The CenterX field is a fixed size."/>
    <ai:k n="FIXED_CENTER_Y" c="The CenterY field is a fixed size."/>
    <ai:k n="FIXED_DEPTH" c="The Depth field is a fixed size."/>
    <ai:k n="FIXED_HEIGHT" c="The Height field is a fixed size."/>
    <ai:k n="FIXED_RADIUS_X" c="The RadiusX field is a fixed size."/>
    <ai:k n="FIXED_RADIUS_Y" c="The RadiusY field is a fixed size."/>
    <ai:k n="FIXED_WIDTH" c="The Width field is a fixed suze."/>
    <ai:k n="FIXED_X" c="The X field is a fixed coordinate."/>
    <ai:k n="FIXED_X_OFFSET" c="The XOffset field is a fixed coordinate."/>
    <ai:k n="FIXED_Y" c="The Y field is a fixed coordinate."/>
    <ai:k n="FIXED_Y_OFFSET" c="The YOffset field is a fixed coordinate."/>
    <ai:k n="FIXED_Z" c="The Z field is a fixed coordinate."/>
    <ai:k n="SCALED_CENTER_X" c="The CenterX field is scaled to this object's parent."/>
    <ai:k n="SCALED_CENTER_Y" c="The CenterY field is scaled to this object's parent."/>
    <ai:k n="SCALED_DEPTH" c="The Depth field is scaled to this object's parent."/>
    <ai:k n="SCALED_HEIGHT" c="The Height field is scaled to this object's parent."/>
    <ai:k n="SCALED_RADIUS_X" c="The RadiusX field is scaled to this object's parent."/>
    <ai:k n="SCALED_RADIUS_Y" c="The RadiusY field is a scaled size to this object's parent."/>
    <ai:k n="SCALED_WIDTH" c="The Width field is scaled to this object's parent."/>
    <ai:k n="SCALED_X" c="The X field is scaled to this object's parent."/>
    <ai:k n="SCALED_X_OFFSET" c="The XOffset field is scaled to this object's parent."/>
    <ai:k n="SCALED_Y" c="The Y field is scaled to this object's parent."/>
    <ai:k n="SCALED_Y_OFFSET" c="The YOffset field is scaled to this object's parent."/>
    <ai:k n="SCALED_Z" c="The Z field is a scaled coordinate to this object's parent."/>
    <ai:k n="STATUS_CHANGE_H"/>
    <ai:k n="STATUS_CHANGE_V"/>
  </ai:c>
  <ai:c l="EM">
    <ai:k n="DUPLICATE" c="The input image is extended along its borders by duplicating the color values at its edges."/>
    <ai:k n="NONE" c="The input image is extended with colour values of zero."/>
    <ai:k n="WRAP" c="The input image is extended by taking the color values from the opposite edge of the image."/>
  </ai:c>
  <ai:c l="FM" c="Mask for controlling feedback events that are received.">
    <ai:k n="CHILD_HAS_FOCUS" c="A child of the vector has gained the user focus."/>
    <ai:k n="HAS_FOCUS" c="The vector has gained the user focus."/>
    <ai:k n="LOST_FOCUS" c="The vector has lost the user focus."/>
    <ai:k n="PATH_CHANGED" c="The vector path has been modified or affected by a transform."/>
  </ai:c>
  <ai:c l="LS" c="Light source identifiers.">
    <ai:k n="DISTANT" c="Distant light source."/>
    <ai:k n="POINT" c="Point light source."/>
    <ai:k n="SPOT" c="Spot light source."/>
  </ai:c>
  <ai:c l="LT" c="Lighting algorithm for the LightingFX class.">
    <ai:k n="DIFFUSE" c="Select diffuse lighting."/>
    <ai:k n="SPECULAR" c="Select specular lighting."/>
  </ai:c>
  <ai:c l="MOP" c="MorphologyFX options.">
    <ai:k n="DILATE" c="Dilate (fatten) the input source."/>
    <ai:k n="ERODE" c="Erode (thin) the input source."/>
  </ai:c>
  <ai:c l="OP" c="Operators for CompositionFX.">
    <ai:k n="ARITHMETIC" c="The SVG 'arithmetic' blending algorithm."/>
    <ai:k n="ATOP" c="The Porter-Duff 'atop' operator; the mix alpha channel has priority and the input channel does not occlude."/>
    <ai:k n="BURN"/>
    <ai:k n="CONTRAST"/>
    <ai:k n="DARKEN" c="Use the darker colour components of the mix and input values."/>
    <ai:k n="DIFFERENCE" c="Output the difference between the input and mix colours."/>
    <ai:k n="DODGE" c="Gives a brighter result than SCREEN by decreasing the contrast between the input and mix colours."/>
    <ai:k n="EXCLUSION" c="Produce the difference between the mix and input values around a reference point of mid-grey."/>
    <ai:k n="HARD_LIGHT"/>
    <ai:k n="IN" c="The Porter-Duff 'in' operator; the input alpha channel has priority and the mix channel is secondary."/>
    <ai:k n="INVERT"/>
    <ai:k n="INVERT_RGB"/>
    <ai:k n="LIGHTEN" c="Use the lighter colour components of the mix and input values."/>
    <ai:k n="MINUS" c="The input colour value is subtracted from the mix."/>
    <ai:k n="MULTIPLY"/>
    <ai:k n="OUT" c="The Porter-Duff 'out' operator; the mix alpha channel is inversed with the input channel."/>
    <ai:k n="OVER" c="The Porter-Duff 'over' operator, this is the default operation for standard alpha blending."/>
    <ai:k n="OVERLAY" c="Combines the multiply and screen blend modes, with the mix determining tonal strength."/>
    <ai:k n="PLUS" c="Add the input and mix colour values together."/>
    <ai:k n="SCREEN" c="Produces a result brighter than the input."/>
    <ai:k n="SOFT_LIGHT"/>
    <ai:k n="XOR" c="The Porter-Duff 'xor' operator; blend as normal but occlusion occurs when input and mix alpha channels interact."/>
  </ai:c>
  <ai:c l="PE">
    <ai:k n="Arc"/>
    <ai:k n="ArcRel"/>
    <ai:k n="ClosePath"/>
    <ai:k n="Curve"/>
    <ai:k n="CurveRel"/>
    <ai:k n="HLine"/>
    <ai:k n="HLineRel"/>
    <ai:k n="Line"/>
    <ai:k n="LineRel"/>
    <ai:k n="Move"/>
    <ai:k n="MoveRel"/>
    <ai:k n="QuadCurve"/>
    <ai:k n="QuadCurveRel"/>
    <ai:k n="QuadSmooth"/>
    <ai:k n="QuadSmoothRel"/>
    <ai:k n="Smooth"/>
    <ai:k n="SmoothRel"/>
    <ai:k n="VLine"/>
    <ai:k n="VLineRel"/>
  </ai:c>
  <ai:c l="RC">
    <ai:k n="ALL" c="Synonym for FINAL_PATH | BASE_PATH | TRANSFORM"/>
    <ai:k n="BASE_PATH" c="The base path (shape of the vector) must be recalculated."/>
    <ai:k n="DIRTY" c="Synonym for FINAL_PATH | BASE_PATH | TRANSFORM"/>
    <ai:k n="FINAL_PATH" c="The final path will need to be recalculated, so as to take transforms and/or scaled coordinates into account."/>
    <ai:k n="TRANSFORM" c="The transform matrix must be recalculated. This includes movement, e.g. changing the CX, CY of an ellipse."/>
  </ai:c>
  <ai:c l="RQ">
    <ai:k n="AUTO" c="The default option is chosen by the system."/>
    <ai:k n="BEST" c="Use the best quality renderer available and without concerns for computational time taken."/>
    <ai:k n="CRISP" c="Use a good quality renderer that produces crisp outlines (no anti-aliasing)."/>
    <ai:k n="FAST" c="Use the fastest renderer available and allow accuracy to be compromised in favour of speed. Recommended for normalised paths that are known to be rectangular."/>
    <ai:k n="PRECISE" c="Use a high quality renderer to produce accurate results. Anti-aliasing will be enabled."/>
  </ai:c>
  <ai:c l="TB">
    <ai:k n="NOISE" c="Use the fractal noise function."/>
    <ai:k n="TURBULENCE" c="Use the standard turbulence function."/>
  </ai:c>
  <ai:c l="VBF" c="Options for vecGetBoundary().">
    <ai:k n="INCLUSIVE" c="The result will be inclusive of all paths that belong to children of the queried vector."/>
    <ai:k n="NO_TRANSFORM" c="The transformation step will not be applied to the vector's path."/>
  </ai:c>
  <ai:c l="VCLF" c="Options for VectorClip.">
    <ai:k n="APPLY_FILLS" c="Apply fill instructions when drawing the clipping path(s)."/>
    <ai:k n="APPLY_STROKES" c="Apply stroke instructions when drawing the clipping path(s)."/>
  </ai:c>
  <ai:c l="VCS" c="Colour space options.">
    <ai:k n="INHERIT" c="Inherit the colour space option from the parent vector."/>
    <ai:k n="LINEAR_RGB" c="Linear RGB is the default colour space for SVG and produces the best results."/>
    <ai:k n="SRGB" c="The default colour-space is sRGB, recommended for its speed."/>
  </ai:c>
  <ai:c l="VF" c="Optional flags and indicators for the Vector class.">
    <ai:k n="DISABLED" c="The vector is disabled and user input should be ignored."/>
    <ai:k n="HAS_FOCUS" c="The vector holds the user's input focus."/>
    <ai:k n="ISOLATED" c="Enables isolation mode, which results in a bitmap buffer being allocated for the vector and its children while drawing."/>
    <ai:k n="JOIN_PATHS" c="When appending a new path, use a join operation to connect the tail end to the head."/>
  </ai:c>
  <ai:c l="VFA" c="Define the aspect ratio for VectorFilter unit scaling.">
    <ai:k n="MEET" c="Scale X/Y values independently and in relation to the width/height of the parent viewport."/>
    <ai:k n="NONE" c="Scale X/Y values on a 1:1 basis, in relation to the diagonal of the parent viewport."/>
  </ai:c>
  <ai:c l="VFR" c="Vector fill rules for the FillRule field in the Vector class.">
    <ai:k n="EVEN_ODD" c="This rule determines the 'insideness' of a point on the canvas by drawing a ray from that point to infinity in any direction and counting the number of path segments from the given shape that the ray crosses. If this number is odd, the point is inside; if even, the point is outside."/>
    <ai:k n="INHERIT" c="The rule is inherited from the parent vector(s)."/>
    <ai:k n="NON_ZERO" c="This is the default. This rule determines the 'insideness' of a point on the canvas by drawing a ray from that point to infinity in any direction and then examining the places where a segment of the shape crosses the ray. Starting with a count of zero, add one each time a path segment crosses the ray from left to right and subtract one each time a path segment crosses the ray from right to left. After counting the crossings, if the result is zero then the point is outside the path. Otherwise, it is inside."/>
  </ai:c>
  <ai:c l="VGF" c="Gradient flags">
    <ai:k n="CONTAIN_FOCAL" c="Contain the FX,FY point to the base radius."/>
    <ai:k n="FIXED_CX" c="CX is fixed"/>
    <ai:k n="FIXED_CY" c="CY is fixed"/>
    <ai:k n="FIXED_FOCAL_RADIUS" c="Focal radius is fixed"/>
    <ai:k n="FIXED_FX" c="FX is fixed"/>
    <ai:k n="FIXED_FY" c="FY is fixed"/>
    <ai:k n="FIXED_RADIUS" c="Radius is fixed"/>
    <ai:k n="FIXED_X1" c="X1 is fixed"/>
    <ai:k n="FIXED_X2" c="X2 is fixed"/>
    <ai:k n="FIXED_Y1" c="Y1 is fixed"/>
    <ai:k n="FIXED_Y2" c="Y2 is fixed"/>
    <ai:k n="SCALED_CX" c="CX is scaled"/>
    <ai:k n="SCALED_CY" c="CY is scaled"/>
    <ai:k n="SCALED_FOCAL_RADIUS" c="Focal radius is scaled"/>
    <ai:k n="SCALED_FX" c="FX is scaled"/>
    <ai:k n="SCALED_FY" c="FY is scaled"/>
    <ai:k n="SCALED_RADIUS" c="Radius is scaled"/>
    <ai:k n="SCALED_X1" c="X1 is scaled"/>
    <ai:k n="SCALED_X2" c="X2 is scaled"/>
    <ai:k n="SCALED_Y1" c="Y1 is scaled"/>
    <ai:k n="SCALED_Y2" c="Y2 is scaled"/>
  </ai:c>
  <ai:c l="VGT" c="VectorGradient options.">
    <ai:k n="CONIC" c="The conic gradient is a variant on the radial type, whereby the colour values are drawn as a line that revolves around the cone's center point."/>
    <ai:k n="CONTOUR" c="Contoured gradients follow the contours of the vector path in which they are rendered."/>
    <ai:k n="DIAMOND" c="A diamond gradient is drawn as a square emanating from the center point."/>
    <ai:k n="LINEAR" c="A linear gradient is drawn from (X1, Y1) to (X2, Y2)."/>
    <ai:k n="RADIAL" c="A radial gradient is drawn from CenterX, CenterY to Radius. An optional focal point can be expressed with FX and FY."/>
  </ai:c>
  <ai:c l="VIJ" c="Inner join options for angled lines.">
    <ai:k n="BEVEL" c="Blunts the edge of the join."/>
    <ai:k n="INHERIT" c="Inherit the parent's join value."/>
    <ai:k n="JAG" c="A special non-SVG option."/>
    <ai:k n="MITER" c="Forms a sharp point at the join. Typically not the best looking option."/>
    <ai:k n="ROUND" c="Rounds the edge of the join to produce the best looking results."/>
  </ai:c>
  <ai:c l="VIS" c="Options for the Vector class' Visibility field.">
    <ai:k n="COLLAPSE" c="Hide the vector and its children. Do not use - provided for SVG compatibility only."/>
    <ai:k n="HIDDEN" c="Hide the vector and its children."/>
    <ai:k n="INHERIT" c="Inherit the visibility state from the parent."/>
    <ai:k n="VISIBLE" c="The default. Ensures that the vector is visible."/>
  </ai:c>
  <ai:c l="VLC" c="Line-cap options.">
    <ai:k n="BUTT" c="The default. The line is sharply squared off at its exact end point."/>
    <ai:k n="INHERIT" c="The cap type is inherited from the parent (defaults to butt if unspecified)."/>
    <ai:k n="ROUND" c="The line cap is a half-circle and the line's end-point forms the center point."/>
    <ai:k n="SQUARE" c="Similar to butt, the line is sharply squared off but will extend past the end point by StrokeWidth / 2."/>
  </ai:c>
  <ai:c l="VLJ" c="Options for the look of line joins.">
    <ai:k n="BEVEL" c="The join is blunted, eliminating overly sharp edges."/>
    <ai:k n="INHERIT" c="Inherit the join option from the parent."/>
    <ai:k n="MITER" c="The default. A sharp corner is used to join path segments. The corner is formed by extending the outer edges of the stroke at the tangents of the path segments until they intersect. If the ‘stroke-miterlimit’ is exceeded, the line join falls back to BEVEL."/>
    <ai:k n="MITER_ROUND" c="Default to MITER, but switch to ROUND if the miter limit is exceeded."/>
    <ai:k n="MITER_SMART" c="An alternative form of MITER that extends beyond the intersection point, similarly to the miter-clip SVG rules."/>
    <ai:k n="ROUND" c="The join is rounded."/>
  </ai:c>
  <ai:c l="VMF" c="Morph flags">
    <ai:k n="AUTO_SPACING" c="Applicable when used on VectorText, auto-spacing allows the spacing between glyphs to be shrunk or expanded along the target path so that they can produce a better fit. The default is for the glyphs to conform to their original spacing requirements."/>
    <ai:k n="STRETCH" c="Applicable when used on VectorText, the stretch option converts glyph outlines into paths, and then all end points and control points will be adjusted to be along the perpendicular vectors from the path, thereby stretching and possibly warping the glyphs. With this approach, connected glyphs, such as in cursive scripts, will maintain their connections."/>
    <ai:k n="X_MAX" c="Align the source so that it is morphed along the right of the target path."/>
    <ai:k n="X_MID" c="Align the source so that it is morphed along the middle of the target path."/>
    <ai:k n="X_MIN" c="Align the source so that it is morphed along the left of the target path."/>
    <ai:k n="Y_MAX" c="Align the source so that it is morphed along the bottom of the target path."/>
    <ai:k n="Y_MID" c="Align the source so that it is morphed along the middle of the target path."/>
    <ai:k n="Y_MIN" c="Align the source so that it is morphed along the top of the target path."/>
  </ai:c>
  <ai:c l="VOF" c="Viewport overflow options.">
    <ai:k n="HIDDEN" c="All content is clipped to within the viewport's boundary."/>
    <ai:k n="INHERIT" c="The overflow state is inherited from the parent."/>
    <ai:k n="SCROLL" c="All content is clipped to within the viewport's boundary. A mechanism to scroll the viewport's content may be provided to the user (SVG capability not currently implemented)."/>
    <ai:k n="VISIBLE" c="The content is not clipped to the viewport's boundary. This is the default."/>
  </ai:c>
  <ai:c l="VPF" c="Optional flags for the VectorScene object.">
    <ai:k n="BITMAP_SIZED" c="Automatically adjust the VectorScene.PageWidth and VectorScene.PageHeight to match the target Bitmap.Width and Bitmap.Height."/>
    <ai:k n="OUTLINE_VIEWPORTS" c="Draw a green outline around all viewport paths. Extremely useful for debugging layout issues."/>
    <ai:k n="RENDER_TIME" c="Compute the drawing frame-rate for the RenderTime field."/>
    <ai:k n="RESIZE" c="The vector will be stretched to fit the VectorScene.PageWidth and VectorScene.PageHeight values, if defined by the client."/>
  </ai:c>
  <ai:c l="VSF" c="Filter source types - these are used internally">
    <ai:k n="ALPHA" c="As for GRAPHIC except that only the alpha channel is used."/>
    <ai:k n="BKGD" c="An image snapshot of the SVG document under the filter region at the time that the filter element was invoked."/>
    <ai:k n="BKGD_ALPHA" c="As for BKGD but only the alpha channel is used."/>
    <ai:k n="FILL" c="The value of the fill property on the target element for the filter effect."/>
    <ai:k n="GRAPHIC" c="Represents the graphics elements that were the original input into the filter element."/>
    <ai:k n="IGNORE" c="The filter does not require an input source."/>
    <ai:k n="PREVIOUS" c="Use the previous effect as input, or source graphic if no previous effect."/>
    <ai:k n="REFERENCE" c="This value is an assigned name for the filter primitive in the form of a custom-ident. If supplied, then graphics that result from processing this filter primitive can be referenced by an in attribute on a subsequent filter primitive within the same filter element. If no value is provided, the output will only be available for re-use as the implicit input into the next filter primitive if that filter primitive provides no value for its in attribute."/>
    <ai:k n="STROKE" c="The value of the stroke property on the target element for the filter effect."/>
  </ai:c>
  <ai:c l="VSM">
    <ai:k n="AUTO" c="The default option is chosen by the system. This will typically be BILINEAR, but slow machines may switch to nearest neighbour and high speed machines could use more advanced methods."/>
    <ai:k n="BESSEL"/>
    <ai:k n="BICUBIC" c="Produces a similar result to BILINEAR at a slightly higher CPU cost and a marginally sharper after-effect."/>
    <ai:k n="BILINEAR" c="Bilinear is a common algorithm that produces a reasonable quality image quickly."/>
    <ai:k n="BLACKMAN" c="Five times slower than BILINEAR, the final result will be less sharp than SINC."/>
    <ai:k n="GAUSSIAN"/>
    <ai:k n="KAISER"/>
    <ai:k n="LANCZOS" c="This well known algorithm may serve as a point of comparison for evaluating the results of other methods. It shares characteristics with SINC and BLACKMAN."/>
    <ai:k n="MITCHELL"/>
    <ai:k n="NEIGHBOUR" c="Nearest neighbour is the fastest sampler at the cost of poor quality."/>
    <ai:k n="QUADRIC"/>
    <ai:k n="SINC" c="Five times slower than BILINEAR, the final result is of very good quality."/>
    <ai:k n="SPLINE16" c="About twice as slow as BILINEAR, this method produces a considerably better result, and is a good choice for enlarging images without producing artifacts when contrasting colours are present."/>
  </ai:c>
  <ai:c l="VSPREAD" c="Spread method options define the method to use for tiling filled graphics.">
    <ai:k n="CLIP" c="Do not scale the graphic. Clip it if it extends past imposed boundaries."/>
    <ai:k n="PAD" c="Scale the graphic to the object bounds."/>
    <ai:k n="REFLECT" c="Tile the graphic, reflecting the image alternately on the X and Y axis."/>
    <ai:k n="REFLECT_X" c="Tile the graphic, reflecting the image alternately on the X axis only."/>
    <ai:k n="REFLECT_Y" c="Tile the graphic, reflecting the image alternately on the Y axis only."/>
    <ai:k n="REPEAT" c="Tile the graphic repeatedly."/>
    <ai:k n="UNDEFINED" c="Either the default setting will be applied or the setting will be inherited from a parent object."/>
  </ai:c>
  <ai:c l="VTS" c="Options for stretching text in VectorText.">
    <ai:k n="CONDENSED"/>
    <ai:k n="EXPANDED"/>
    <ai:k n="EXTRA_CONDENSED"/>
    <ai:k n="EXTRA_EXPANDED"/>
    <ai:k n="INHERIT"/>
    <ai:k n="NARROWER"/>
    <ai:k n="NORMAL"/>
    <ai:k n="SEMI_CONDENSED"/>
    <ai:k n="SEMI_EXPANDED"/>
    <ai:k n="ULTRA_CONDENSED"/>
    <ai:k n="ULTRA_EXPANDED"/>
    <ai:k n="WIDER"/>
  </ai:c>
  <ai:c l="VTXF" c="VectorText flags.">
    <ai:k n="AREA_SELECTED" c="Automatically set if a region of text has been selected."/>
    <ai:k n="BLINK" c="Enable animated blinking (not supported - exists as SVG dummy option)."/>
    <ai:k n="EDIT" c="Allow user editing of the text if the nearest viewport has the focus."/>
    <ai:k n="EDITABLE" c="Allow user editing of the text if the nearest viewport has the focus."/>
    <ai:k n="LINE_THROUGH" c="Enable a strike-through line in the text."/>
    <ai:k n="NO_SYS_KEYS" c="Disables support for system-keys that enable common key combinations such as Ctrl-C, Ctrl-X etc."/>
    <ai:k n="OVERLINE" c="Enable overlining of the text."/>
    <ai:k n="OVERWRITE" c="Turns on overwrite mode (if off, insert mode is enabled)."/>
    <ai:k n="RASTER" c="Rasterise glyphs to a texture cache for very fast rendering. This feature is not compatible with scalable graphics conventions."/>
    <ai:k n="SECRET" c="Hide all characters from the UI by using generic symbols in place of glyphs."/>
    <ai:k n="UNDERLINE" c="Enable underlining of the text."/>
  </ai:c>
  <ai:c l="VUNIT">
    <ai:k n="BOUNDING_BOX" c="Coordinates are scaled to the object's bounding box."/>
    <ai:k n="UNDEFINED" c="Either the default setting will be applied or the setting will be inherited from a parent object."/>
    <ai:k n="USERSPACE" c="Coordinates are scaled to the current viewport."/>
  </ai:c>
  <ai:c l="WVC" c="Wave options.">
    <ai:k n="BOTTOM" c="Close the path across the bottom of its area."/>
    <ai:k n="NONE" c="Do not close the path."/>
    <ai:k n="TOP" c="Close the path across the top of its area."/>
  </ai:c>
  <ai:c l="WVS" c="Wave style options.">
    <ai:k n="ANGLED" c="Chevron style angles at 45 degrees either side of the peak and bottom edge."/>
    <ai:k n="CURVED" c="Standard sine-wave curvature, this is the default."/>
    <ai:k n="SAWTOOTH" c="Sawtooth patterns rise at 45 degrees to the peak, then direct 90 degrees to the bottom."/>
  </ai:c>
  <ai:s n="FontMetrics">
    <ai:f n="Height" t="INT" c="Capitalised font height"/>
    <ai:f n="LineSpacing" t="INT" c="Vertical advance from one line to the next"/>
    <ai:f n="Ascent" t="INT" c="Height from the baseline to the top of the font, including accents."/>
    <ai:f n="Descent" t="INT" c="Height from the baseline to the bottom of the font"/>
  </ai:s>
  <ai:s n="GradientStop">
    <ai:f n="Offset" t="DOUBLE" c="An offset in the range of 0 - 1.0"/>
    <ai:f n="RGB" t="struct FRGB" c="A floating point RGB value."/>
  </ai:s>
  <ai:s n="MergeSource">
    <ai:f n="SourceType" t="VSF" c="The type of the required source."/>
    <ai:f n="Effect" t="objFilterEffect *" c="Effect pointer if the SourceType is REFERENCE."/>
  </ai:s>
  <ai:s n="PathCommand">
    <ai:f n="Type" t="PE" c="The command type"/>
    <ai:f n="LargeArc" t="UINT8" c="Equivalent to the large-arc-flag in SVG, it ensures that the arc follows the longest drawing path when TRUE."/>
    <ai:f n="Sweep" t="UINT8" c="Equivalent to the sweep-flag in SVG, it inverts the default behaviour in generating arc paths."/>
    <ai:f n="Pad1" t="UINT8" c="Private"/>
    <ai:f n="X" t="DOUBLE" c="The targeted X coordinate (absolute or scaled) for the command"/>
    <ai:f n="Y" t="DOUBLE" c="The targeted Y coordinate (absolute or scaled) for the command"/>
    <ai:f n="AbsX" t="DOUBLE" c="Private"/>
    <ai:f n="AbsY" t="DOUBLE" c="Private"/>
    <ai:f n="X2" t="DOUBLE" c="The X2 coordinate for curve commands, or RX for arcs"/>
    <ai:f n="Y2" t="DOUBLE" c="The Y2 coordinate for curve commands, or RY for arcs"/>
    <ai:f n="X3" t="DOUBLE" c="The X3 coordinate for curve-to or smooth-curve-to"/>
    <ai:f n="Y3" t="DOUBLE" c="The Y3 coordinate for curve-to or smooth-curve-to"/>
    <ai:f n="Angle" t="DOUBLE" c="Arc angle"/>
  </ai:s>
  <ai:s n="Transition">
    <ai:f n="Offset" t="DOUBLE" c="An offset from 0.0 to 1.0 at which to apply the transform."/>
    <ai:f n="Transform" t="CSTRING" c="A transform string, as per SVG guidelines."/>
  </ai:s>
  <ai:s n="VectorMatrix">
    <ai:f n="Next" t="struct VectorMatrix *" c="The next transform in the list."/>
    <ai:f n="Vector" t="objVector *" c="The vector associated with the transform."/>
    <ai:f n="ScaleX" t="DOUBLE" c="Matrix value A"/>
    <ai:f n="ShearY" t="DOUBLE" c="Matrix value B"/>
    <ai:f n="ShearX" t="DOUBLE" c="Matrix value C"/>
    <ai:f n="ScaleY" t="DOUBLE" c="Matrix value D"/>
    <ai:f n="TranslateX" t="DOUBLE" c="Matrix value E"/>
    <ai:f n="TranslateY" t="DOUBLE" c="Matrix value F"/>
    <ai:f n="Tag" t="INT" c="An optional tag value defined by the client for matrix identification."/>
  </ai:s>
  <ai:s n="VectorPainter">
    <ai:f n="Pattern" t="objVectorPattern *" c="A VectorPattern object, suitable for pattern based fills."/>
    <ai:f n="Image" t="objVectorImage *" c="A VectorImage object, suitable for image fills."/>
    <ai:f n="Gradient" t="objVectorGradient *" c="A VectorGradient object, suitable for gradient fills."/>
    <ai:f n="Colour" t="struct FRGB" c="A single RGB colour definition, suitable for block colour fills."/>
  </ai:s>
  <ai:s n="VectorPoint">
    <ai:f n="X" t="DOUBLE" c="The X coordinate of this point."/>
    <ai:f n="Y" t="DOUBLE" c="The Y coordinate of this point."/>
    <ai:f n="XScaled" t="UINT8" c="TRUE if the X value is scaled to its viewport (between 0 and 1.0)."/>
    <ai:f n="YScaled" t="UINT8" c="TRUE if the Y value is scaled to its viewport (between 0 and 1.0)."/>
  </ai:s>
</ai:m>
