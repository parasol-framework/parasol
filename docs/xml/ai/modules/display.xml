<?xml version="1.0" encoding="UTF-8"?>
<ai:m xmlns:ai="http://parasol-framework.org/ai-docs" n="Display" p="gfx" v="1" st="stable" cl="Bitmap,Clipboard,Controller,Display,Pointer,Surface">
  <ai:f n="AccessPointer" c="Returns a lock on the default pointer object." p="objPointer * gfx::AccessPointer()" r="objPointer *"/>
  <ai:f n="CheckIfChild" c="Check if a surface is the child of another surface." p="ERR gfx::CheckIfChild(OBJECTID Parent, OBJECTID Child)" r="ERR">
    <ai:i n="Parent" t="OBJECTID" c="The surface that is assumed to be the parent."/>
    <ai:i n="Child" t="OBJECTID" c="The child surface to check."/>
    <ai:e c="True"/>
    <ai:e c="False"/>
    <ai:e c="NullArgs"/>
  </ai:f>
  <ai:f n="CopyArea" c="Copies a rectangular area from one bitmap to another." p="ERR gfx::CopyArea(objBitmap * Bitmap, objBitmap * Dest, BAF Flags, INT X, INT Y, INT Width, INT Height, INT XDest, INT YDest)" r="ERR">
    <ai:i n="Bitmap" t="objBitmap *" c="The source bitmap."/>
    <ai:i n="Dest" t="objBitmap *" c="Pointer to the destination bitmap."/>
    <ai:i n="Flags" t="BAF" c="Optional flags."/>
    <ai:i n="X" t="INT" c="The horizontal position of the area to be copied."/>
    <ai:i n="Y" t="INT" c="The vertical position of the area to be copied."/>
    <ai:i n="Width" t="INT" c="The width of the area."/>
    <ai:i n="Height" t="INT" c="The height of the area."/>
    <ai:i n="XDest" t="INT" c="The horizontal position to copy the area to."/>
    <ai:i n="YDest" t="INT" c="The vertical position to copy the area to."/>
    <ai:e c="Okay"/>
    <ai:e c="Mismatch"/>
    <ai:e c="InvalidState"/>
    <ai:e c="NullArgs"/>
  </ai:f>
  <ai:f n="CopyRawBitmap" c="Copies graphics data from an arbitrary surface to a bitmap." p="ERR gfx::CopyRawBitmap(struct BitmapSurfaceV2 * Surface, objBitmap * Dest, CSRF Flags, INT X, INT Y, INT Width, INT Height, INT XDest, INT YDest)" r="ERR">
    <ai:i n="Surface" t="struct BitmapSurfaceV2 *" c="Description of the surface source."/>
    <ai:i n="Dest" t="objBitmap *" c="Destination bitmap."/>
    <ai:i n="Flags" t="CSRF" c="Optional flags."/>
    <ai:i n="X" t="INT" c="Horizontal source coordinate."/>
    <ai:i n="Y" t="INT" c="Vertical source coordinate."/>
    <ai:i n="Width" t="INT" c="Source width."/>
    <ai:i n="Height" t="INT" c="Source height."/>
    <ai:i n="XDest" t="INT" c="Horizontal destination coordinate."/>
    <ai:i n="YDest" t="INT" c="Vertical destination coordinate."/>
    <ai:e c="Okay"/>
    <ai:e c="Args"/>
    <ai:e c="NullArgs"/>
  </ai:f>
  <ai:f n="CopySurface" c="Copies surface graphics data into any bitmap object" p="ERR gfx::CopySurface(OBJECTID Surface, objBitmap * Bitmap, BDF Flags, INT X, INT Y, INT Width, INT Height, INT XDest, INT YDest)" r="ERR">
    <ai:i n="Surface" t="OBJECTID" c="The ID of the surface object to copy from."/>
    <ai:i n="Bitmap" t="objBitmap *" c="Must reference a target Bitmap object."/>
    <ai:i n="Flags" t="BDF" c="Optional flags."/>
    <ai:i n="X" t="INT" c="The horizontal source coordinate."/>
    <ai:i n="Y" t="INT" c="The vertical source coordinate."/>
    <ai:i n="Width" t="INT" c="The width of the graphic that will be copied."/>
    <ai:i n="Height" t="INT" c="The height of the graphic that will be copied."/>
    <ai:i n="XDest" t="INT" c="The horizontal target coordinate."/>
    <ai:i n="YDest" t="INT" c="The vertical target coordinate."/>
    <ai:e c="Okay"/>
    <ai:e c="Search"/>
    <ai:e c="AccessObject"/>
    <ai:e c="NullArgs"/>
  </ai:f>
  <ai:f n="DrawPixel" c="Draws a single pixel to a bitmap." p="void gfx::DrawPixel(objBitmap * Bitmap, INT X, INT Y, UINT Colour)">
    <ai:i n="Bitmap" t="objBitmap *" c="The target bitmap object."/>
    <ai:i n="X" t="INT" c="The horizontal coordinate of the pixel."/>
    <ai:i n="Y" t="INT" c="The vertical coordinate of the pixel."/>
    <ai:i n="Colour" t="UINT" c="The colour value to use for the pixel."/>
  </ai:f>
  <ai:f n="DrawRGBPixel" c="Draws a 24 bit pixel to a Bitmap." p="void gfx::DrawRGBPixel(objBitmap * Bitmap, INT X, INT Y, struct RGB8 * RGB)">
    <ai:i n="Bitmap" t="objBitmap *" c="The target bitmap object."/>
    <ai:i n="X" t="INT" c="Horizontal coordinate of the pixel."/>
    <ai:i n="Y" t="INT" c="Vertical coordinate of the pixel."/>
    <ai:i n="RGB" t="struct RGB8 *" c="The colour to be drawn, in RGB format."/>
  </ai:f>
  <ai:f n="DrawRectangle" c="Draws rectangles, both filled and unfilled." p="void gfx::DrawRectangle(objBitmap * Bitmap, INT X, INT Y, INT Width, INT Height, UINT Colour, BAF Flags)">
    <ai:i n="Bitmap" t="objBitmap *" c="Pointer to the target Bitmap."/>
    <ai:i n="X" t="INT" c="The left-most coordinate of the rectangle."/>
    <ai:i n="Y" t="INT" c="The top-most coordinate of the rectangle."/>
    <ai:i n="Width" t="INT" c="The width of the rectangle."/>
    <ai:i n="Height" t="INT" c="The height of the rectangle."/>
    <ai:i n="Colour" t="UINT" c="The colour value to use for the rectangle."/>
    <ai:i n="Flags" t="BAF" c="Use FILL to fill the rectangle."/>
  </ai:f>
  <ai:f n="ExposeSurface" c="Exposes the content of a surface to the display." p="ERR gfx::ExposeSurface(OBJECTID Surface, INT X, INT Y, INT Width, INT Height, EXF Flags)" r="ERR">
    <ai:i n="Surface" t="OBJECTID" c="The ID of the surface object that will be exposed."/>
    <ai:i n="X" t="INT" c="The horizontal coordinate of the area to expose."/>
    <ai:i n="Y" t="INT" c="The vertical coordinate of the area to expose."/>
    <ai:i n="Width" t="INT" c="The width of the expose area."/>
    <ai:i n="Height" t="INT" c="The height of the expose area."/>
    <ai:i n="Flags" t="EXF" c="Optional flags - using CHILDREN will expose all intersecting child regions."/>
    <ai:e c="Okay"/>
    <ai:e c="Search"/>
    <ai:e c="NullArgs"/>
  </ai:f>
  <ai:f n="GetColourFormat" c="Generates the values for a ColourFormat structure for a given bit depth." p="void gfx::GetColourFormat(struct ColourFormat * Format, INT BitsPerPixel, INT RedMask, INT GreenMask, INT BlueMask, INT AlphaMask)">
    <ai:i n="Format" t="struct ColourFormat *" c="Pointer to an empty ColourFormat structure."/>
    <ai:i n="BitsPerPixel" t="INT" c="The depth that you would like to generate colour values for. Ignored if mask values are set."/>
    <ai:i n="RedMask" t="INT" c="Red component bit mask value. Set this value to zero if the BitsPerPixel parameter is used."/>
    <ai:i n="GreenMask" t="INT" c="Green component bit mask value."/>
    <ai:i n="BlueMask" t="INT" c="Blue component bit mask value."/>
    <ai:i n="AlphaMask" t="INT" c="Alpha component bit mask value."/>
  </ai:f>
  <ai:f n="GetCursorInfo" c="Retrieves graphics information from the active mouse cursor." p="ERR gfx::GetCursorInfo(struct CursorInfo * Info, INT Size)" r="ERR">
    <ai:i n="Info" t="struct CursorInfo *" c="Pointer to a CursorInfo structure."/>
    <ai:i n="Size" t="INT" c="The byte-size of the Info structure."/>
    <ai:e c="Okay"/>
    <ai:e c="NoSupport"/>
    <ai:e c="NullArgs"/>
  </ai:f>
  <ai:f n="GetCursorPos" c="Returns the coordinates of the UI pointer." p="ERR gfx::GetCursorPos(DOUBLE * X, DOUBLE * Y)" r="ERR">
    <ai:i n="X" t="DOUBLE *" c="Variable that will store the pointer's horizontal coordinate."/>
    <ai:i n="Y" t="DOUBLE *" c="Variable that will store the pointer's vertical coordinate."/>
    <ai:e c="Okay"/>
    <ai:e c="AccessObject"/>
  </ai:f>
  <ai:f n="GetDisplayInfo" c="Retrieves display information." p="ERR gfx::GetDisplayInfo(OBJECTID Display, struct DisplayInfoV3 ** Info)" r="ERR">
    <ai:i n="Display" t="OBJECTID" c="Object ID of the display to be analysed."/>
    <ai:i n="Info" t="struct DisplayInfoV3 **" c="This reference will receive a pointer to a DISPLAYINFO structure."/>
    <ai:e c="Okay"/>
    <ai:e c="AllocMemory"/>
    <ai:e c="NullArgs"/>
  </ai:f>
  <ai:f n="GetDisplayType" c="Returns the type of display supported." p="DT gfx::GetDisplayType()" r="DT"/>
  <ai:f n="GetInputTypeName" c="Returns the string name for an input type." p="CSTRING gfx::GetInputTypeName(JET Type)" r="CSTRING">
    <ai:i n="Type" t="JET" c="JET type integer."/>
  </ai:f>
  <ai:f n="GetModalSurface" c="Returns the current modal surface (if defined)." p="OBJECTID gfx::GetModalSurface()" r="OBJECTID"/>
  <ai:f n="GetRelativeCursorPos" c="Returns the coordinates of the pointer cursor, relative to a surface object." p="ERR gfx::GetRelativeCursorPos(OBJECTID Surface, DOUBLE * X, DOUBLE * Y)" r="ERR">
    <ai:i n="Surface" t="OBJECTID" c="Unique ID of the surface that the coordinates need to be relative to."/>
    <ai:i n="X" t="DOUBLE *" c="Variable that will store the pointer's horizontal coordinate."/>
    <ai:i n="Y" t="DOUBLE *" c="Variable that will store the pointer's vertical coordinate."/>
    <ai:e c="Okay"/>
    <ai:e c="AccessObject"/>
  </ai:f>
  <ai:f n="GetSurfaceCoords" c="Returns the dimensions of a surface." p="ERR gfx::GetSurfaceCoords(OBJECTID Surface, INT * X, INT * Y, INT * AbsX, INT * AbsY, INT * Width, INT * Height)" r="ERR">
    <ai:i n="Surface" t="OBJECTID" c="The surface to query. If zero, the top-level display is queried."/>
    <ai:i n="X" t="INT *" c="The X coordinate of the surface is returned here."/>
    <ai:i n="Y" t="INT *" c="The Y coordinate of the surface is returned here."/>
    <ai:i n="AbsX" t="INT *" c="The absolute X coordinate of the surface is returned here."/>
    <ai:i n="AbsY" t="INT *" c="The absolute Y coordinate of the surface is returned here."/>
    <ai:i n="Width" t="INT *" c="The width of the surface is returned here."/>
    <ai:i n="Height" t="INT *" c="The height of the surface is returned here."/>
    <ai:e c="Okay"/>
    <ai:e c="Search"/>
  </ai:f>
  <ai:f n="GetSurfaceFlags" c="Retrieves the Flags field from a Surface." p="ERR gfx::GetSurfaceFlags(OBJECTID Surface, RNF * Flags)" r="ERR">
    <ai:i n="Surface" t="OBJECTID" c="The surface to query. If zero, the top-level surface is queried."/>
    <ai:i n="Flags" t="RNF *" c="The flags value is returned here."/>
    <ai:e c="Okay"/>
    <ai:e c="AccessMemory"/>
    <ai:e c="NullArgs"/>
  </ai:f>
  <ai:f n="GetSurfaceInfo" c="Retrieves display information for any surface object without having to access it directly." p="ERR gfx::GetSurfaceInfo(OBJECTID Surface, struct SurfaceInfoV2 ** Info)" r="ERR">
    <ai:i n="Surface" t="OBJECTID" c="The unique ID of a Surface to query. If zero, the root surface is returned."/>
    <ai:i n="Info" t="struct SurfaceInfoV2 **" c="This parameter will receive a SurfaceInfo pointer that describes the surface object."/>
    <ai:e c="Okay"/>
    <ai:e c="Search"/>
    <ai:e c="NullArgs"/>
  </ai:f>
  <ai:f n="GetUserFocus" c="Returns the ID of the surface that currently has the user's focus." p="OBJECTID gfx::GetUserFocus()" r="OBJECTID"/>
  <ai:f n="GetVisibleArea" c="Returns the visible region of a Surface." p="ERR gfx::GetVisibleArea(OBJECTID Surface, INT * X, INT * Y, INT * AbsX, INT * AbsY, INT * Width, INT * Height)" r="ERR">
    <ai:i n="Surface" t="OBJECTID" c="The surface to query. If zero, the top-level display will be queried."/>
    <ai:i n="X" t="INT *" c="The X coordinate of the visible area."/>
    <ai:i n="Y" t="INT *" c="The Y coordinate of the visible area."/>
    <ai:i n="AbsX" t="INT *" c="The absolute X coordinate of the visible area."/>
    <ai:i n="AbsY" t="INT *" c="The absolute Y coordinate of the visible area."/>
    <ai:i n="Width" t="INT *" c="The visible width of the surface."/>
    <ai:i n="Height" t="INT *" c="The visible height of the surface."/>
    <ai:e c="Okay"/>
    <ai:e c="Failed"/>
    <ai:e c="Search"/>
  </ai:f>
  <ai:f n="LockCursor" c="Anchors the cursor so that it cannot move without explicit movement signals." p="ERR gfx::LockCursor(OBJECTID Surface)" r="ERR">
    <ai:i n="Surface" t="OBJECTID" c="Refers to the surface object that the pointer should send movement signals to."/>
    <ai:e c="Okay"/>
    <ai:e c="NoSupport"/>
    <ai:e c="AccessObject"/>
    <ai:e c="NullArgs"/>
  </ai:f>
  <ai:f n="ReadPixel" c="Reads a pixel's colour from the target bitmap." p="UINT gfx::ReadPixel(objBitmap * Bitmap, INT X, INT Y)" r="UINT">
    <ai:i n="Bitmap" t="objBitmap *" c="Pointer to a bitmap object."/>
    <ai:i n="X" t="INT" c="The horizontal coordinate of the pixel."/>
    <ai:i n="Y" t="INT" c="The vertical coordinate of the pixel."/>
  </ai:f>
  <ai:f n="ReadRGBPixel" c="Reads a pixel's colour from the target bitmap." p="void gfx::ReadRGBPixel(objBitmap * Bitmap, INT X, INT Y, struct RGB8 ** RGB)">
    <ai:i n="Bitmap" t="objBitmap *" c="Pointer to a bitmap object."/>
    <ai:i n="X" t="INT" c="The horizontal coordinate of the pixel."/>
    <ai:i n="Y" t="INT" c="The vertical coordinate of the pixel."/>
    <ai:i n="RGB" t="struct RGB8 **" c="The colour values will be stored in this RGB8 structure."/>
  </ai:f>
  <ai:f n="Resample" c="Resamples a bitmap by dithering it to a new set of colour masks." p="ERR gfx::Resample(objBitmap * Bitmap, struct ColourFormat * ColourFormat)" r="ERR">
    <ai:i n="Bitmap" t="objBitmap *" c="The bitmap object to be resampled."/>
    <ai:i n="ColourFormat" t="struct ColourFormat *" c="The new colour format to be applied to the bitmap."/>
    <ai:e c="Okay"/>
    <ai:e c="NullArgs"/>
  </ai:f>
  <ai:f n="RestoreCursor" c="Returns the pointer image to its original state." p="ERR gfx::RestoreCursor(PTC Cursor, OBJECTID Owner)" r="ERR">
    <ai:i n="Cursor" t="PTC" c="The cursor image that the pointer will be restored to (0 for the default)."/>
    <ai:i n="Owner" t="OBJECTID" c="The ownership ID that was given in the initial call to SetCursor()."/>
    <ai:e c="Okay"/>
    <ai:e c="Args"/>
  </ai:f>
  <ai:f n="ScaleToDPI" c="Scales a value to the active display's DPI." p="DOUBLE gfx::ScaleToDPI(DOUBLE Value)" r="DOUBLE">
    <ai:i n="Value" t="DOUBLE" c="The number to be scaled."/>
  </ai:f>
  <ai:f n="SetClipRegion" c="Sets a clipping region for a bitmap object." p="void gfx::SetClipRegion(objBitmap * Bitmap, INT Number, INT Left, INT Top, INT Right, INT Bottom, INT Terminate)">
    <ai:i n="Bitmap" t="objBitmap *" c="The target bitmap."/>
    <ai:i n="Number" t="INT" c="The number of the clip region to set."/>
    <ai:i n="Left" t="INT" c="The horizontal start of the clip region."/>
    <ai:i n="Top" t="INT" c="The vertical start of the clip region."/>
    <ai:i n="Right" t="INT" c="The right-most edge of the clip region."/>
    <ai:i n="Bottom" t="INT" c="The bottom-most edge of the clip region."/>
    <ai:i n="Terminate" t="INT" c="Set to true if this is the last clip region in the list, otherwise false."/>
  </ai:f>
  <ai:f n="SetCursor" c="Sets the cursor image and can anchor the pointer to any surface." p="ERR gfx::SetCursor(OBJECTID Surface, CRF Flags, PTC Cursor, CSTRING Name, OBJECTID Owner)" r="ERR">
    <ai:i n="Surface" t="OBJECTID" c="Refers to the surface object that the pointer should anchor itself to, if the RESTRICT flag is used. Otherwise, this parameter can be set to a surface that the new cursor image should be limited to. The object referred to here must be publicly accessible to all tasks."/>
    <ai:i n="Flags" t="CRF" c="Optional flags that affect the cursor."/>
    <ai:i n="Cursor" t="PTC" c="The ID of the cursor image that is to be set."/>
    <ai:i n="Name" t="CSTRING" c="The name of the cursor image that is to be set (if Cursor is zero)."/>
    <ai:i n="Owner" t="OBJECTID" c="The object nominated as the owner of the anchor, and/or owner of the cursor image setting."/>
    <ai:e c="Okay"/>
    <ai:e c="NothingDone"/>
    <ai:e c="Args"/>
    <ai:e c="LockFailed"/>
    <ai:e c="NoSupport"/>
    <ai:e c="OutOfRange"/>
    <ai:e c="AccessObject"/>
  </ai:f>
  <ai:f n="SetCursorPos" c="Changes the position of the pointer cursor." p="ERR gfx::SetCursorPos(DOUBLE X, DOUBLE Y)" r="ERR">
    <ai:i n="X" t="DOUBLE" c="The new horizontal coordinate for the pointer."/>
    <ai:i n="Y" t="DOUBLE" c="The new vertical coordinate for the pointer."/>
    <ai:e c="Okay"/>
    <ai:e c="AccessObject"/>
  </ai:f>
  <ai:f n="SetCustomCursor" c="Sets the cursor to a customised bitmap image." p="ERR gfx::SetCustomCursor(OBJECTID Surface, CRF Flags, objBitmap * Bitmap, INT HotX, INT HotY, OBJECTID Owner)" r="ERR">
    <ai:i n="Surface" t="OBJECTID" c="Refers to the Surface object that the pointer should restrict itself to, if the RESTRICT flag is used. Otherwise, this parameter can be set to a surface that the new cursor image should be limited to. The object referred to here must be publicly accessible to all tasks."/>
    <ai:i n="Flags" t="CRF" c="Optional flags affecting the cursor are set here."/>
    <ai:i n="Bitmap" t="objBitmap *" c="The Bitmap to set for the mouse cursor."/>
    <ai:i n="HotX" t="INT" c="The horizontal position of the cursor hot-spot."/>
    <ai:i n="HotY" t="INT" c="The vertical position of the cursor hot-spot."/>
    <ai:i n="Owner" t="OBJECTID" c="The object nominated as the owner of the anchor."/>
    <ai:e c="Okay"/>
    <ai:e c="Args"/>
    <ai:e c="NoSupport"/>
    <ai:e c="AccessObject"/>
  </ai:f>
  <ai:f n="SetHostOption" c="Alter options associated with the host display system." p="ERR gfx::SetHostOption(HOST Option, INT64 Value)" r="ERR">
    <ai:i n="Option" t="HOST" c="One of TRAY_ICON, TASKBAR or STICK_TO_FRONT."/>
    <ai:i n="Value" t="INT64" c="The value to be applied to the option."/>
    <ai:e c="Okay"/>
  </ai:f>
  <ai:f n="SetModalSurface" c="Enables a modal surface for the current task." p="OBJECTID gfx::SetModalSurface(OBJECTID Surface)" r="OBJECTID">
    <ai:i n="Surface" t="OBJECTID" c="The surface to enable as modal."/>
  </ai:f>
  <ai:f n="StartCursorDrag" c="Attaches an item to the cursor for the purpose of drag and drop." p="ERR gfx::StartCursorDrag(OBJECTID Source, INT Item, CSTRING Datatypes, OBJECTID Surface)" r="ERR">
    <ai:i n="Source" t="OBJECTID" c="Refers to an object that is managing the source data."/>
    <ai:i n="Item" t="INT" c="A custom number that represents the item being dragged from the source."/>
    <ai:i n="Datatypes" t="CSTRING" c="A null terminated byte array that lists the datatypes supported by the source item, in order of conversion preference."/>
    <ai:i n="Surface" t="OBJECTID" c="A 32-bit composite surface that represents the item being dragged."/>
    <ai:e c="Okay"/>
    <ai:e c="InUse"/>
    <ai:e c="Failed"/>
    <ai:e c="AccessObject"/>
    <ai:e c="NullArgs"/>
  </ai:f>
  <ai:f n="SubscribeInput" c="Subscribe to incoming input messages for any active surface object." p="ERR gfx::SubscribeInput(FUNCTION * Callback, OBJECTID SurfaceFilter, JTYPE Mask, OBJECTID DeviceFilter, INT * Handle)" r="ERR">
    <ai:i n="Callback" t="FUNCTION *" c="Reference to a callback function that will receive input messages."/>
    <ai:i n="SurfaceFilter" t="OBJECTID" c="Optional. Only the input messages that match the given Surface ID will be received."/>
    <ai:i n="Mask" t="JTYPE" c="Combine JTYPE flags to define the input messages required by the client. Set to 0xffffffff if all messages are required."/>
    <ai:i n="DeviceFilter" t="OBJECTID" c="Optional. Only the input messages that match the given device ID will be received. NOTE - Support not yet implemented, set to zero."/>
    <ai:i n="Handle" t="INT *" c="A handle for the subscription is returned here."/>
    <ai:e c="Okay"/>
    <ai:e c="NullArgs"/>
  </ai:f>
  <ai:f n="Sync" c="Waits for the completion of all active bitmap operations." p="void gfx::Sync(objBitmap * Bitmap)">
    <ai:i n="Bitmap" t="objBitmap *" c="Pointer to the bitmap that you want to synchronise or NULL to sleep on the graphics accelerator."/>
  </ai:f>
  <ai:f n="UnlockCursor" c="Undoes an earlier call to LockCursor()" p="ERR gfx::UnlockCursor(OBJECTID Surface)" r="ERR">
    <ai:i n="Surface" t="OBJECTID" c="Refers to the surface object used for calling LockCursor()."/>
    <ai:e c="Okay"/>
    <ai:e c="AccessObject"/>
    <ai:e c="NullArgs"/>
  </ai:f>
  <ai:f n="UnsubscribeInput" c="Removes an input subscription." p="ERR gfx::UnsubscribeInput(INT Handle)" r="ERR">
    <ai:i n="Handle" t="INT" c="Reference to a handle returned by SubscribeInput."/>
    <ai:e c="Okay"/>
    <ai:e c="NotFound"/>
    <ai:e c="NullArgs"/>
  </ai:f>
  <ai:f n="WindowHook" c="Adds a function hook for receiving window messages from a host desktop." p="ERR gfx::WindowHook(OBJECTID SurfaceID, WH Event, FUNCTION * Callback)" r="ERR">
    <ai:i n="SurfaceID" t="OBJECTID" c="A hosted surface to be monitored."/>
    <ai:i n="Event" t="WH" c="A window hook event."/>
    <ai:i n="Callback" t="FUNCTION *" c="A function to callback when the event is triggered."/>
    <ai:e c="Okay"/>
    <ai:e c="NullArgs"/>
  </ai:f>
  <ai:c l="ACF" c="Acceleration flags for GetDisplayInfo().">
    <ai:k n="SOFTWARE_BLIT" c="Software blitting is used (or forced) for this display."/>
    <ai:k n="VIDEO_BLIT" c="Video blitting is supported for this display."/>
  </ai:c>
  <ai:c l="ALIGN" c="Universal values for alignment of graphics and text">
    <ai:k n="BOTTOM" c="Align to bottom"/>
    <ai:k n="CENTER" c="Synonym for HORIZONTAL | VERTICAL"/>
    <ai:k n="HORIZONTAL" c="Align to horizontal center"/>
    <ai:k n="LEFT" c="Align to left"/>
    <ai:k n="MIDDLE" c="Synonym for HORIZONTAL | VERTICAL"/>
    <ai:k n="RIGHT" c="Align to right"/>
    <ai:k n="TOP" c="Align to top"/>
    <ai:k n="VERTICAL" c="Align to vertical center"/>
  </ai:c>
  <ai:c l="BAF" c="Instructions for basic graphics operations.">
    <ai:k n="BLEND" c="Enable alpha blending to the destination if the source supports an alpha channel."/>
    <ai:k n="COPY" c="Special CopyArea option that avoids blending when the destination pixel is empty."/>
    <ai:k n="DITHER" c="Perform dithering if the colour formats differ between the source and destination."/>
    <ai:k n="FILL" c="For primitive operations such as DrawRectangle, this will fill the shape with a solid colour or texture."/>
    <ai:k n="LINEAR" c="Use linear interpolation to improve the quality of alpha blending."/>
  </ai:c>
  <ai:c l="BDF" c="CopySurface() flags">
    <ai:k n="DITHER" c="Allow the use of dithering to improve image quality at a cost of speed."/>
    <ai:k n="REDRAW" c="Redraw the surface before performing the copy operation."/>
  </ai:c>
  <ai:c l="BLM" c="Defines the blending algorithm to use when transparent pixels are rendered to the bitmap.">
    <ai:k n="AUTO" c="Use the most suitable of the available algorithms."/>
    <ai:k n="GAMMA" c="Use gamma correct blending. This algorithm is slow but produces a high quality result."/>
    <ai:k n="LINEAR" c="Use linear blending. Applicable if the bitmap is in linear colour space."/>
    <ai:k n="NONE" c="Never blend transparent pixels, just copy as-is."/>
    <ai:k n="SRGB" c="Use sRGB linear blending. This algorithm is extremely efficient but produces poor quality results."/>
  </ai:c>
  <ai:c l="BMF" c="Bitmap flags">
    <ai:k n="ACCELERATED_2D" c="2D video acceleration is available."/>
    <ai:k n="ACCELERATED_3D" c="3D video acceleration is available."/>
    <ai:k n="ALPHA_CHANNEL" c="For 32-bit images, indicates that an alpha channel is present."/>
    <ai:k n="BLANK_PALETTE" c="Forces a blank/black palette on initialisation."/>
    <ai:k n="CLEAR" c="Clear graphics on initialisation and when resizing."/>
    <ai:k n="COMPRESSED" c="The bitmap data is compressed."/>
    <ai:k n="FIXED_DEPTH" c="Prevent changing of bitmap depth after initialisation (e.g. via Resize())."/>
    <ai:k n="INVERSE_ALPHA" c="Indicates reverse alpha blending, higher values are transparent."/>
    <ai:k n="MASK" c="Declare the Bitmap as a 1 or 8 bit mask. Must be set in conjunction with the Bitmap.BitsPerPixel field on initialisation."/>
    <ai:k n="NEVER_SHRINK" c="Ignore resize requests that would shrink the size of the bitmap."/>
    <ai:k n="NO_DATA" c="Do not allocate memory in the Data field on initialisation."/>
    <ai:k n="PREMUL" c="The RGB values are premultiplied (32-bit only)."/>
    <ai:k n="QUERIED" c="Automatically set after a Query() on the bitmap."/>
    <ai:k n="TRANSPARENT" c="Indicates that the bitmap utilises a transparent colour. This is automatically set if the Bitmap.TransIndex or Bitmap.TransColour is defined, and support exists in functions such as CopyArea."/>
    <ai:k n="USER" c="This user flag can be used to tag bitmaps with special meaning. Not used internally."/>
  </ai:c>
  <ai:c l="BMP" c="Bitmap types">
    <ai:k n="CHUNKY" c="Chunky pixel mode (default)."/>
    <ai:k n="PLANAR" c="Planar pixel mode separates pixel bits across multiple planes. Commonly used for single bit bitmap masks."/>
  </ai:c>
  <ai:c l="CEF">
    <ai:k n="DELETE" c="Requests that the original file source is deleted if a successful paste operation takes place."/>
    <ai:k n="EXTEND" c="Instead of replacing existing clipboard data, add the new data to the group."/>
  </ai:c>
  <ai:c l="CLIPTYPE" c="Clipboard types">
    <ai:k n="AUDIO" c="An audio clip that is recognised by the Sound class (such as wav's and mp3's)."/>
    <ai:k n="DATA" c="Raw information that is uncategorised can be defined as a data clip."/>
    <ai:k n="FILE" c="Pure file references are stored as file clips. This type is typically used by file managers for moving and copying files."/>
    <ai:k n="IMAGE" c="Images that are recognised by the Picture class may be stored as this type (such as jpeg's and png files)."/>
    <ai:k n="OBJECT" c="An object that has been deserialised into binary form."/>
    <ai:k n="TEXT" c="Plain text files such as ASCII and UTF-8 must be identified through this clip type."/>
  </ai:c>
  <ai:c l="CPF" c="Clipboard flags">
    <ai:k n="DRAG_DROP" c="Enables drag and drop mode. The clipboard content will be private and not share data with the host system in this mode."/>
    <ai:k n="HISTORY_BUFFER" c="Enables the history buffer. Note that this results in active clipboard monitoring and the program will make copies of all potential clipboard content - whether it is used or not."/>
    <ai:k n="HOST" c="This indicator is automatically set when a clipboard was created due to incoming content from the host system."/>
  </ai:c>
  <ai:c l="CRF" c="Flags for the SetCursor() function.">
    <ai:k n="BUFFER" c="Use of the BUFFER option allows the cursor request to be buffered in the event that the cursor is locked at the time of calling the SetCursor function. Use of this flag is highly recommended in most circumstances, but may not be used in conjunction with the ANCHOR option."/>
    <ai:k n="LMB" c="Release the cursor after the left mouse button is held and released."/>
    <ai:k n="MMB" c="Release the cursor after the middle mouse button is held and released."/>
    <ai:k n="NO_BUTTONS" c="Set the cursor only on the condition that the user is not holding down any buttons. ERR::NothingDone is returned if the user has a button held down."/>
    <ai:k n="RESTRICT" c="Similar to the anchor option, but allows the pointer to move within the surface referred to by ObjectID."/>
    <ai:k n="RMB" c="Release the cursor after the right mouse button is held and released."/>
  </ai:c>
  <ai:c l="CS" c="Colour space options.">
    <ai:k n="CIE_LAB" c="Cartesian L*a*b* colour space defined by CIE 15."/>
    <ai:k n="CIE_LCH" c="Polar L*CHab colour space defined by CIE 15."/>
    <ai:k n="LINEAR_RGB" c="Linear RGB is used to improve colour balance in blending operations."/>
    <ai:k n="SRGB" c="The default colour-space is sRGB."/>
  </ai:c>
  <ai:c l="CSRF" c="Flags for CopySurface().">
    <ai:k n="ALPHA" c="Enable alpha blending if the source is in 32-bit colour format with an alpha channel."/>
    <ai:k n="CLIP" c="Enable clipping of the source coordinates."/>
    <ai:k n="DEFAULT_FORMAT" c="Ignore the colour format defined in the source surface (if any) and generate a default format based on the BitsPerPixel value."/>
    <ai:k n="OFFSET" c="Adjust X and Y coordinates by the offset values defined in the Surface.XOffset and Surface.YOffset fields."/>
    <ai:k n="TRANSLUCENT" c="Perform a translucent copy operation, using the strength value specified in the Surface.Opacity field."/>
    <ai:k n="TRANSPARENT" c="Enable transparent copying, whereby colours matching the source's Colour field will be ignored."/>
  </ai:c>
  <ai:c l="CT">
    <ai:k n="AUDIO"/>
    <ai:k n="DATA"/>
    <ai:k n="END"/>
    <ai:k n="FILE"/>
    <ai:k n="IMAGE"/>
    <ai:k n="OBJECT"/>
    <ai:k n="TEXT"/>
  </ai:c>
  <ai:c l="DMF">
    <ai:k n="FIXED_CENTER_X" c="The CenterX field is a fixed size."/>
    <ai:k n="FIXED_CENTER_Y" c="The CenterY field is a fixed size."/>
    <ai:k n="FIXED_DEPTH" c="The Depth field is a fixed size."/>
    <ai:k n="FIXED_HEIGHT" c="The Height field is a fixed size."/>
    <ai:k n="FIXED_RADIUS_X" c="The RadiusX field is a fixed size."/>
    <ai:k n="FIXED_RADIUS_Y" c="The RadiusY field is a fixed size."/>
    <ai:k n="FIXED_WIDTH" c="The Width field is a fixed suze."/>
    <ai:k n="FIXED_X" c="The X field is a fixed coordinate."/>
    <ai:k n="FIXED_X_OFFSET" c="The XOffset field is a fixed coordinate."/>
    <ai:k n="FIXED_Y" c="The Y field is a fixed coordinate."/>
    <ai:k n="FIXED_Y_OFFSET" c="The YOffset field is a fixed coordinate."/>
    <ai:k n="FIXED_Z" c="The Z field is a fixed coordinate."/>
    <ai:k n="SCALED_CENTER_X" c="The CenterX field is scaled to this object's parent."/>
    <ai:k n="SCALED_CENTER_Y" c="The CenterY field is scaled to this object's parent."/>
    <ai:k n="SCALED_DEPTH" c="The Depth field is scaled to this object's parent."/>
    <ai:k n="SCALED_HEIGHT" c="The Height field is scaled to this object's parent."/>
    <ai:k n="SCALED_RADIUS_X" c="The RadiusX field is scaled to this object's parent."/>
    <ai:k n="SCALED_RADIUS_Y" c="The RadiusY field is a scaled size to this object's parent."/>
    <ai:k n="SCALED_WIDTH" c="The Width field is scaled to this object's parent."/>
    <ai:k n="SCALED_X" c="The X field is scaled to this object's parent."/>
    <ai:k n="SCALED_X_OFFSET" c="The XOffset field is scaled to this object's parent."/>
    <ai:k n="SCALED_Y" c="The Y field is scaled to this object's parent."/>
    <ai:k n="SCALED_Y_OFFSET" c="The YOffset field is scaled to this object's parent."/>
    <ai:k n="SCALED_Z" c="The Z field is a scaled coordinate to this object's parent."/>
    <ai:k n="STATUS_CHANGE_H"/>
    <ai:k n="STATUS_CHANGE_V"/>
  </ai:c>
  <ai:c l="DPMS" c="Possible modes for the Display class' PowerMode field.">
    <ai:k n="DEFAULT" c="Use the default DPMS mode as defined by the display driver."/>
    <ai:k n="OFF" c="Stop sending power to the display in order to turn it off (it may not be possible to restart the display without the user's intervention)."/>
    <ai:k n="STANDBY" c="Puts the display into standby (reduced power) mode."/>
    <ai:k n="SUSPEND" c="Puts the display into suspend mode (blanks the display output while maintaining normal power levels)."/>
  </ai:c>
  <ai:c l="DRAG">
    <ai:k n="ANCHOR" c="The surface is being dragged and the mouse pointer is anchored to the surface."/>
    <ai:k n="NONE" c="The surface is not being dragged."/>
    <ai:k n="NORMAL" c="The surface is being dragged."/>
  </ai:c>
  <ai:c l="DSF">
    <ai:k n="NO_DRAW" c="Drawing and exposures are disabled"/>
    <ai:k n="NO_EXPOSE" c="Drawing is enabled, exposures are disabled"/>
  </ai:c>
  <ai:c l="DT" c="Flags for GetDisplayType().">
    <ai:k n="GLES" c="The display is driven by OpenGLES."/>
    <ai:k n="NATIVE" c="The display is native (supported by internal drivers)."/>
    <ai:k n="WINGDI" c="The display is driven by Microsoft Windows drivers."/>
    <ai:k n="X11" c="The display is driven by the X Window System (X11, X.Org, XFree86)"/>
  </ai:c>
  <ai:c l="EXF" c="Optional flags for the ExposeSurface() function.">
    <ai:k n="ABSOLUTE" c="The supplied coordinates for exposure are absolute (relative to the display)."/>
    <ai:k n="ABSOLUTE_COORDS" c="The supplied coordinates for exposure are absolute (relative to the display)."/>
    <ai:k n="CHILDREN" c="If set, all child surfaces that intersect with exposed region will be included in the expose operation."/>
    <ai:k n="REDRAW_VOLATILE" c="Redraw every volatile object that intersects with the expose region, including internal volatile children."/>
    <ai:k n="REDRAW_VOLATILE_OVERLAP" c="Only redraw volatile objects that obscure the expose region from a position outside of the target surface and its children. Useful if no redrawing has occurred in the surface, but the surface has moved to a new position and the parents need to be redrawn."/>
  </ai:c>
  <ai:c l="GMF" c="Flags for gamma operations.">
    <ai:k n="SAVE" c="Save the provided settings permanently."/>
  </ai:c>
  <ai:c l="HOST">
    <ai:k n="STICK_TO_FRONT" c="The hosted display sticks to the front."/>
    <ai:k n="TASKBAR" c="The hosted display is given a taskbar button."/>
    <ai:k n="TRANSLUCENCE" c="Change the alpha channel level for the entire window."/>
    <ai:k n="TRANSPARENT" c="Defines an RGB colour that is to be used as transparent."/>
    <ai:k n="TRAY_ICON" c="All new displays are represented in the system tray when this option is active."/>
  </ai:c>
  <ai:c l="IRF" c="Flags for RedrawSurface().">
    <ai:k n="FORCE_DRAW" c="Forces redrawing to the surface buffer (overrides visibility checks)."/>
    <ai:k n="IGNORE_CHILDREN" c="Do not draw child surfaces (this includes volatile children)."/>
    <ai:k n="IGNORE_NV_CHILDREN" c="Do not draw child surfaces unless they are volatile."/>
    <ai:k n="RELATIVE" c="Coordinate parameters are expressed in relative format. Right and Bottom reflect Width and Height respectively."/>
    <ai:k n="SINGLE_BITMAP" c="Only draw children and/or siblings when they share our bitmap space."/>
  </ai:c>
  <ai:c l="JET" c="JET constants are documented in GetInputEvent()">
    <ai:k n="ABS_XY" c="The X, Y values are defined as absolute coordinates, relative to the top-left of the display."/>
    <ai:k n="BUTTON_1" c="Left mouse button; XBox A button, PS square button. Value is pressure sensitive, ranging between 0 - 1.0 (0 is released, 1.0 is fully depressed)."/>
    <ai:k n="BUTTON_10" c="Non-specific button assignment."/>
    <ai:k n="BUTTON_2" c="Right mouse button; XBox X button, PS cross button."/>
    <ai:k n="BUTTON_3" c="Middle mouse button; XBox Y button, PS triangle."/>
    <ai:k n="BUTTON_4" c="Alt. mouse button 1; XBox B button, PS circle."/>
    <ai:k n="BUTTON_5" c="Alt. mouse button 2."/>
    <ai:k n="BUTTON_6" c="Non-specific button assignment."/>
    <ai:k n="BUTTON_7" c="Non-specific button assignment."/>
    <ai:k n="BUTTON_8" c="Non-specific button assignment."/>
    <ai:k n="BUTTON_9" c="Non-specific button assignment."/>
    <ai:k n="CROSSED_IN" c="This message is sent by the input system when the mouse pointer enters an area for the first time. The message value refers to the object ID of the container being monitored for movement."/>
    <ai:k n="CROSSED_OUT" c="This message is sent by the input system when the mouse pointer leaves an area. The message value refers to the object ID of the container being monitored for movement."/>
    <ai:k n="DEVICE_TILT_XY" c="Controller tilted on the X/Y axis. Value indicates angle, -ve = left, +ve = right"/>
    <ai:k n="DEVICE_TILT_Z" c="Controller is rising or falling. Value expressed as 'speed',"/>
    <ai:k n="DISPLAY_EDGE" c="Recently supplied input occurred at the edge of the display."/>
    <ai:k n="PEN_TILT_XY" c="For pen-based input, this type indicates the vertical tilt of the pen device. A value of 0 indicates that the pen is laid flat with nib at the bottom, 0.5 is 90 degrees, 1.0 is laid flat with nib at the top."/>
    <ai:k n="PRESSURE" c="Amount of pressure applied, ranges from 0 (none) to 1.0 (normal) and possibly higher if user presses hard enough"/>
    <ai:k n="WHEEL" c="Mouse wheel rotation - the value generally reflects the number of 'clicks' rotated on the wheel."/>
    <ai:k n="WHEEL_TILT" c="Some mouse wheels can be tilted to the left or right. Ranges from -1.0 to +1.0"/>
  </ai:c>
  <ai:c l="JTYPE" c="JTYPE flags are used to categorise input types.">
    <ai:k n="ANALOG" c="Analog movement (ranging from -1.0 to 1.0)"/>
    <ai:k n="ANCHORED" c="Cursor has been anchored with LockCursor()"/>
    <ai:k n="BUTTON" c="Input is a physical button or switch"/>
    <ai:k n="CROSSING" c="Crossing events manage the entering and leaving of an area."/>
    <ai:k n="DBL_CLICK" c="Set by the input system if the Type is a button and the button has been clicked in quick succession so as to be classed as a double-click."/>
    <ai:k n="DIGITAL" c="D-Pad or digital joystick source (restricted to +/- 1)"/>
    <ai:k n="DRAGGED" c="Set if sufficient movement occurred between the original click and its point of release (usually requires a 3 or more pixel difference)."/>
    <ai:k n="DRAG_ITEM" c="This special flag is set by the input system if the pointer is click-dragging an object at the time of the event."/>
    <ai:k n="EXT_MOVEMENT" c="Extended or indirect movement information. This covers all types of movement that are unconnected to coordinate positioning - mouse wheel movement and pen tilt are two such examples."/>
    <ai:k n="MOVEMENT" c="X/Y coordinate movement only. Movement such as the wheel mouse spinning is not covered by this type as it does not influence the coordinate system."/>
    <ai:k n="REPEATED" c="Input is a repeated entry (i.e. user is holding down a button and a repetition timer is being triggered)"/>
    <ai:k n="SECONDARY" c="Indicates to the receiver of this message that it is not the primary/original recipient"/>
  </ai:c>
  <ai:c l="LVF" c="drwLockBitmap() result flags">
    <ai:k n="EXPOSE_CHANGES"/>
  </ai:c>
  <ai:c l="MON" c="Flags for the Display class SetMonitor() method.">
    <ai:k n="AUTO_DETECT" c="Monitor settings to be auto-detected on startup."/>
    <ai:k n="BIT_6" c="The device is limited to 6-bit colour production in real terms."/>
  </ai:c>
  <ai:c l="PF" c="Flags for the Pointer class.">
    <ai:k n="ANCHOR" c="Allow the pointer to be anchored."/>
    <ai:k n="UNUSED"/>
    <ai:k n="VISIBLE" c="Indicates that the pointer is currently visible. Read-only."/>
  </ai:c>
  <ai:c l="PTC" c="Predefined cursor styles">
    <ai:k n="CROSSHAIR" c="The cross hair is used for targeting specific pixel points (common in paint programs)."/>
    <ai:k n="CUSTOM" c="Works in conjunction with the SetCustomCursor() function to represent a program defined bitmap."/>
    <ai:k n="DEFAULT" c="The default cursor (usually an arrow pointing to the upper left)."/>
    <ai:k n="DRAGGABLE" c="Used to indicate that a surface or object can be dragged by the user."/>
    <ai:k n="END"/>
    <ai:k n="HAND" c="The hand cursor is often used for indicating click-able content (hyper-links, icons etc)."/>
    <ai:k n="HAND_LEFT" c="Similar to the standard hand cursor, but points to the left."/>
    <ai:k n="HAND_RIGHT" c="Similar to the standard hand cursor, but points to the right."/>
    <ai:k n="INVISIBLE" c="The cursor graphic is invisible (but will continue to operate as normal in all other respects)."/>
    <ai:k n="MAGNIFIER" c="Represents a magnifying glass."/>
    <ai:k n="NO_CHANGE"/>
    <ai:k n="PAINTBRUSH" c="The paintbrush cursor is typically employed by paint programs."/>
    <ai:k n="SIZE_BOTTOM" c="Sizing cursor - for resizing the bottom edge of any rectangular area."/>
    <ai:k n="SIZE_BOTTOM_LEFT" c="Sizing cursor - for resizing the bottom left corner of any rectangular area."/>
    <ai:k n="SIZE_BOTTOM_RIGHT" c="Sizing cursor - for resizing the bottom right corner of any rectangular area."/>
    <ai:k n="SIZE_LEFT" c="Sizing cursor - for resizing the left edge of any rectangular area."/>
    <ai:k n="SIZE_RIGHT" c="Sizing cursor - for resizing the right edge of any rectangular area."/>
    <ai:k n="SIZE_TOP" c="Sizing cursor - for resizing the top edge of any rectangular area."/>
    <ai:k n="SIZE_TOP_LEFT" c="Sizing cursor - for resizing the top left corner of any rectangular area."/>
    <ai:k n="SIZE_TOP_RIGHT" c="Sizing cursor - for resizing the top right corner of any rectangular area."/>
    <ai:k n="SIZING" c="Multi-directional sizing cursor - for resizing in any direction."/>
    <ai:k n="SLEEP" c="The sleep cursor is used to inform the user that the computer is busy."/>
    <ai:k n="SPLIT_HORIZONTAL" c="The horizontal split cursor is typically used for splitting rectangles in half, or dragging a horizontal split within a large rectangular space."/>
    <ai:k n="SPLIT_VERTICAL" c="The vertical split cursor is typically used for splitting rectangles in half, or dragging a vertical split within a large rectangular space."/>
    <ai:k n="STOP" c="The stop cursor is used to inform the user that an operation is not possible (e.g. drag and drop to an unsupported object area)."/>
    <ai:k n="TEXT" c="The text cursor is popular for the precise positioning of text cursors."/>
  </ai:c>
  <ai:c l="RNF" c="Switches for the Surface class' Flags field.">
    <ai:k n="AFTER_COPY" c="Read-only. Indicates that after-copy mode has been enabled."/>
    <ai:k n="ASPECT_RATIO" c="When resizing, enforce the aspect ratio as defined by the diagonal from Surface.MinWidth, Surface.MinHeight to Surface.MaxWidth, Surface.MaxHeight."/>
    <ai:k n="AUTO_QUIT" c="The surface object will send a quit message to its supporting process when and if the Close method is called. This flag is typically used when a surface object represents a core window for an application."/>
    <ai:k n="COMPOSITE" c="Do not copy background information into the surface buffer - composite on the fly instead"/>
    <ai:k n="DISABLED" c="This flag is set if the Disable action has been called on a surface object. Calling the Enable action will turn off the flag setting."/>
    <ai:k n="FIXED_BUFFER" c="Passes the NEVER_SHRINK option to the surface bitmap"/>
    <ai:k n="FIXED_DEPTH" c="The target buffer always remains at the same depth"/>
    <ai:k n="FULL_SCREEN" c="Allow the surface to open as a new screen display"/>
    <ai:k n="GRAB_FOCUS" c="Helps application windows manage the user's focus within the window"/>
    <ai:k n="HAS_FOCUS" c="Read-only. If set, this flag indicates that the surface object currently has the focus."/>
    <ai:k n="HOST" c="Define host on initialisation to create a container that can host surfaces from other processes."/>
    <ai:k n="IGNORE_FOCUS" c="Focus is diverted directly to the parent"/>
    <ai:k n="INIT_ONLY" c="Synonym for HOST | TRANSPARENT | DISABLED | PRECOPY | VIDEO | FIXED_BUFFER | PERVASIVE_COPY | FIXED_DEPTH | FULL_SCREEN | IGNORE_FOCUS"/>
    <ai:k n="NO_FOCUS" c="Prevents any kind of focussing on this object; no circumvention is possible"/>
    <ai:k n="NO_HORIZONTAL" c="Turns off all horizontal movement (applies to the Move() action only)."/>
    <ai:k n="NO_PRECOMPOSITE" c="Do not copy background information into the surface buffer - composite on the fly instead"/>
    <ai:k n="NO_VERTICAL" c="Turns off all vertical movement (applies to the Move() action only)."/>
    <ai:k n="PERVASIVE_COPY" c="This flag can be set in conjunction with after-copy mode. It forces the after-copy support routine to copy graphics over the entire surface area, rather than avoiding the graphics of child surfaces."/>
    <ai:k n="POST_COMPOSITE" c="Do not copy background information into the surface buffer - composite on the fly instead"/>
    <ai:k n="PRECOPY" c="Enables pre-copy mode, which means that all graphics behind the surface object are copied into the bitmap buffer prior to any redraw. This mode can have a noticable impact on CPU time when drawing."/>
    <ai:k n="READ_ONLY" c="Synonym for HAS_FOCUS | CURSOR | AFTER_COPY"/>
    <ai:k n="STICKY" c="Prevents any response to the Move action. It can be circumvented by writing to coordinate fields directly."/>
    <ai:k n="STICK_TO_BACK" c="Enable if the surface object must stick to the back of its container."/>
    <ai:k n="STICK_TO_FRONT" c="Enable if the surface object must stick to the front of its container."/>
    <ai:k n="TOTAL_REDRAW" c="Perform a total redraw of the entire surface when drawing - no partial draws"/>
    <ai:k n="TRANSPARENT" c="Enables transparency, which means that the internal graphics routines will ignore this surface during redraws. It is typically used when creating containers that will host other surfaces."/>
    <ai:k n="VIDEO" c="Set this flag if you would like the surface object's data to be managed in video memory only. While this can give some speed advantages, be warned that video based surfaces are limited to write-only operations."/>
    <ai:k n="VISIBLE" c="If a surface object is visible to the user, the VISIBLE flag will be set. If the flag is not set, the surface object is hidden."/>
    <ai:k n="VOLATILE" c="Synonym for PRECOPY | AFTER_COPY | CURSOR"/>
    <ai:k n="WRITE_ONLY" c="Set this flag if you would like the surface object's data to be managed in video memory only. While this can give some speed advantages, be warned that video based surfaces are limited to write-only operations."/>
  </ai:c>
  <ai:c l="RT">
    <ai:k n="ROOT" c="Can be used by window surfaces to identify themselves as a root layer."/>
  </ai:c>
  <ai:c l="SCR" c="Display flags.">
    <ai:k n="ALPHA_BLEND" c="Enables alpha channel blending (if display is hosted and 32-bit)."/>
    <ai:k n="AUTO_SAVE" c="Saves settings to the global display state when the object is freed."/>
    <ai:k n="BIT_6" c="Display is limited to 6-bit output per colour gun."/>
    <ai:k n="BORDERLESS" c="If display is hosted, create it as a popup / borderless window."/>
    <ai:k n="BUFFER" c="Set if you would like a complementing buffer in video RAM."/>
    <ai:k n="COMPOSITE" c="Enables alpha channel blending (if display is hosted and 32-bit)."/>
    <ai:k n="CUSTOM_WINDOW" c="The display has been created with a custom window reference."/>
    <ai:k n="DPMS_ENABLED" c="Power saving through DPMS is supported."/>
    <ai:k n="FLIPPABLE" c="If SCR::BUFFER is used, this flag may be set by the display manager if it is possible to flip the buffer."/>
    <ai:k n="GRAB_CONTROLLERS" c="Grab controllers for receiving input when the display has the focus."/>
    <ai:k n="GTF_ENABLED" c="GTF frequency timings are supported."/>
    <ai:k n="HOSTED" c="The display is a desktop hosted window."/>
    <ai:k n="MAXIMISE" c="Special win32 flag."/>
    <ai:k n="MAXSIZE" c="For GetDisplayInfo only, indicates that the width and height values indicate the display's maximum size."/>
    <ai:k n="NO_ACCELERATION" c="2D graphics card acceleration is not available."/>
    <ai:k n="POWERSAVE" c="Power saving is active (read-only)."/>
    <ai:k n="READ_ONLY" c="Synonym for MAXIMISE | CUSTOM_WINDOW | FLIPPABLE | GTF_ENABLED | DPMS_ENABLED | POWERSAVE | HOSTED | MAXSIZE | REFRESH | BIT_6 | VISIBLE | NO_ACCELERATION"/>
    <ai:k n="REFRESH" c="For GetDisplayInfo only, used to indicate that a display change has recently occurred and cache refresh is required."/>
    <ai:k n="VISIBLE" c="Set if the screen is on display."/>
  </ai:c>
  <ai:c l="SWIN" c="Options for the Surface WindowType field.">
    <ai:k n="HOST" c="Default to the standard hosted window mode with full titlebar, borders and taskbar representation."/>
    <ai:k n="ICON_TRAY" c="Create a borderless (custom) window with icon tray representation."/>
    <ai:k n="NONE" c="Create a borderless (custom) window with no UI representation."/>
    <ai:k n="TASKBAR" c="Create a borderless (custom) window with taskbar representation."/>
  </ai:c>
  <ai:c l="WH" c="Events for WindowHook()">
    <ai:k n="CLOSE"/>
  </ai:c>
  <ai:s n="BitmapSurface">
    <ai:f n="Data" t="APTR" c="Pointer to the bitmap graphics data."/>
    <ai:f n="Width" t="INT16" c="Pixel width of the bitmap."/>
    <ai:f n="Height" t="INT16" c="Pixel height of the bitmap."/>
    <ai:f n="LineWidth" t="INT" c="The distance between bitmap lines, measured in bytes."/>
    <ai:f n="BitsPerPixel" t="UINT8" c="The number of bits per pixel (8, 15, 16, 24, 32)."/>
    <ai:f n="BytesPerPixel" t="UINT8" c="The number of bytes per pixel (1, 2, 3, 4)."/>
    <ai:f n="Opacity" t="UINT8" c="Opacity level of the source if CSRF::TRANSLUCENT is used."/>
    <ai:f n="Version" t="UINT8" c="Version of this structure."/>
    <ai:f n="Colour" t="INT" c="Colour index to use if CSRF::TRANSPARENT is used."/>
    <ai:f n="Clip" t="struct ClipRectangle" c="A clipping rectangle will restrict drawing operations to this region if CSRF::CLIP is used."/>
    <ai:f n="XOffset" t="INT16" c="Offset all X coordinate references by the given value."/>
    <ai:f n="YOffset" t="INT16" c="Offset all Y coordinate references by the given value."/>
    <ai:f n="Format" t="struct ColourFormat" c="The colour format of this bitmap's pixels, or alternatively use CSRF::DEFAULT_FORMAT."/>
  </ai:s>
  <ai:s n="ColourFormat">
    <ai:f n="RedShift" t="UINT8" c="Right shift value for red (15/16 bit formats only)"/>
    <ai:f n="GreenShift" t="UINT8" c="Right shift value for green"/>
    <ai:f n="BlueShift" t="UINT8" c="Right shift value for blue"/>
    <ai:f n="AlphaShift" t="UINT8" c="Right shift value for alpha"/>
    <ai:f n="RedMask" t="UINT8" c="Unshifted mask value for red (ranges from 0x00 to 0xff)"/>
    <ai:f n="GreenMask" t="UINT8" c="Unshifted mask value for green"/>
    <ai:f n="BlueMask" t="UINT8" c="Unshifted mask value for blue"/>
    <ai:f n="AlphaMask" t="UINT8" c="Unshifted mask value for alpha"/>
    <ai:f n="RedPos" t="UINT8" c="Left shift/positional value for red"/>
    <ai:f n="GreenPos" t="UINT8" c="Left shift/positional value for green"/>
    <ai:f n="BluePos" t="UINT8" c="Left shift/positional value for blue"/>
    <ai:f n="AlphaPos" t="UINT8" c="Left shift/positional value for alpha"/>
    <ai:f n="BitsPerPixel" t="UINT8" c="Number of bits per pixel for this format."/>
  </ai:s>
  <ai:s n="CursorInfo">
    <ai:f n="Width" t="INT" c="Maximum cursor width for custom cursors"/>
    <ai:f n="Height" t="INT" c="Maximum cursor height for custom cursors"/>
    <ai:f n="Flags" t="INT" c="Currently unused"/>
    <ai:f n="BitsPerPixel" t="INT16" c="Preferred bits-per-pixel setting for custom cursors"/>
  </ai:s>
  <ai:s n="DisplayInfo">
    <ai:f n="Display" t="OBJECTID" c="Object ID related to the display"/>
    <ai:f n="Flags" t="SCR" c="Display flags"/>
    <ai:f n="Width" t="INT16" c="Pixel width of the display"/>
    <ai:f n="Height" t="INT16" c="Pixel height of the display"/>
    <ai:f n="BitsPerPixel" t="INT16" c="Bits per pixel"/>
    <ai:f n="BytesPerPixel" t="INT16" c="Bytes per pixel"/>
    <ai:f n="AccelFlags" t="ACF" c="Flags describing supported hardware features."/>
    <ai:f n="AmtColours" t="INT" c="Total number of supported colours."/>
    <ai:f n="PixelFormat" t="struct PixelFormat" c="The colour format to use for each pixel."/>
    <ai:f n="MinRefresh" t="FLOAT" c="Minimum refresh rate"/>
    <ai:f n="MaxRefresh" t="FLOAT" c="Maximum refresh rate"/>
    <ai:f n="RefreshRate" t="FLOAT" c="Recommended refresh rate"/>
    <ai:f n="Index" t="INT" c="Display mode ID (internal)"/>
    <ai:f n="HDensity" t="INT" c="Horizontal pixel density per inch."/>
    <ai:f n="VDensity" t="INT" c="Vertical pixel density per inch."/>
  </ai:s>
  <ai:s n="InputEvent">
    <ai:f n="Next" t="const struct InputEvent *" c="Next event in the chain"/>
    <ai:f n="Value" t="DOUBLE" c="The value associated with the Type"/>
    <ai:f n="Timestamp" t="INT64" c="PreciseTime() of the recorded input"/>
    <ai:f n="RecipientID" t="OBJECTID" c="Surface that the input message is being conveyed to"/>
    <ai:f n="OverID" t="OBJECTID" c="Surface that is directly under the mouse pointer at the time of the event"/>
    <ai:f n="AbsX" t="DOUBLE" c="Absolute horizontal position of mouse cursor (relative to the top left of the display)"/>
    <ai:f n="AbsY" t="DOUBLE" c="Absolute vertical position of mouse cursor (relative to the top left of the display)"/>
    <ai:f n="X" t="DOUBLE" c="Horizontal position relative to the surface that the pointer is over - unless a mouse button is held or pointer is anchored - then the coordinates are relative to the click-held surface"/>
    <ai:f n="Y" t="DOUBLE" c="Vertical position relative to the surface that the pointer is over - unless a mouse button is held or pointer is anchored - then the coordinates are relative to the click-held surface"/>
    <ai:f n="DeviceID" t="OBJECTID" c="The hardware device that this event originated from"/>
    <ai:f n="Type" t="JET" c="JET constant that describes the event"/>
    <ai:f n="Flags" t="JTYPE" c="Broad descriptors for the given Type (see JTYPE flags). Automatically defined when delivered to the pointer object"/>
    <ai:f n="Mask" t="JTYPE" c="Mask to use for checking against subscribers"/>
  </ai:s>
  <ai:s n="PixelFormat">
    <ai:f n="RedShift" t="UINT8" c="Right shift value"/>
    <ai:f n="GreenShift" t="UINT8" c="Green shift value"/>
    <ai:f n="BlueShift" t="UINT8" c="Blue shift value"/>
    <ai:f n="AlphaShift" t="UINT8" c="Alpha shift value"/>
    <ai:f n="RedMask" t="UINT8" c="The unshifted red mask value (ranges from 0x00 to 0xff)"/>
    <ai:f n="GreenMask" t="UINT8" c="The unshifted green mask value (ranges from 0x00 to 0xff)"/>
    <ai:f n="BlueMask" t="UINT8" c="The unshifted blue mask value (ranges from 0x00 to 0xff)"/>
    <ai:f n="AlphaMask" t="UINT8" c="The unshifted alpha mask value (ranges from 0x00 to 0xff)"/>
    <ai:f n="RedPos" t="UINT8" c="Left shift/positional value for red"/>
    <ai:f n="GreenPos" t="UINT8" c="Left shift/positional value for green"/>
    <ai:f n="BluePos" t="UINT8" c="Left shift/positional value for blue"/>
    <ai:f n="AlphaPos" t="UINT8" c="Left shift/positional value for alpha"/>
  </ai:s>
  <ai:s n="SurfaceCoords">
    <ai:f n="X" t="INT" c="Horizontal coordinate"/>
    <ai:f n="Y" t="INT" c="Vertical coordinate"/>
    <ai:f n="Width" t="INT" c="Width"/>
    <ai:f n="Height" t="INT" c="Height"/>
    <ai:f n="AbsX" t="INT" c="Absolute X"/>
    <ai:f n="AbsY" t="INT" c="Absolute Y"/>
  </ai:s>
  <ai:s n="SurfaceInfo">
    <ai:f n="Data" t="APTR" c="Bitmap data memory ID"/>
    <ai:f n="ParentID" t="OBJECTID" c="Object that contains the surface area"/>
    <ai:f n="BitmapID" t="OBJECTID" c="Surface bitmap buffer"/>
    <ai:f n="DisplayID" t="OBJECTID" c="Refers to the display if this object is at root level"/>
    <ai:f n="Flags" t="RNF" c="Surface flags"/>
    <ai:f n="X" t="INT" c="Horizontal coordinate"/>
    <ai:f n="Y" t="INT" c="Vertical coordinate"/>
    <ai:f n="Width" t="INT" c="Width of the surface area"/>
    <ai:f n="Height" t="INT" c="Height of the surface area"/>
    <ai:f n="AbsX" t="INT" c="Absolute X coordinate"/>
    <ai:f n="AbsY" t="INT" c="Absolute Y coordinate"/>
    <ai:f n="Level" t="INT16" c="Branch level within the tree"/>
    <ai:f n="BitsPerPixel" t="INT8" c="Bits per pixel of the bitmap"/>
    <ai:f n="BytesPerPixel" t="INT8" c="Bytes per pixel of the bitmap"/>
    <ai:f n="LineWidth" t="INT" c="Line width of the bitmap, in bytes"/>
  </ai:s>
  <ai:s n="xrMode">
    <ai:f n="Width" t="INT" c="Horizontal"/>
    <ai:f n="Height" t="INT" c="Vertical"/>
    <ai:f n="Depth" t="INT" c="bit depth"/>
  </ai:s>
</ai:m>
