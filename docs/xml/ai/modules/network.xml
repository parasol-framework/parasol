<?xml version="1.0" encoding="UTF-8"?>
<ai:m xmlns:ai="http://parasol-framework.org/ai-docs" n="Network" p="net" v="1" st="stable" cl="ClientSocket,NetClient,NetLookup,NetSocket,Proxy">
  <ai:f n="AddressToStr" c="Converts an IPAddress structure to an IPAddress in dotted string form." p="CSTRING net::AddressToStr(struct IPAddress * IPAddress)" r="CSTRING">
    <ai:i n="IPAddress" t="struct IPAddress *" c="A pointer to the IPAddress structure."/>
  </ai:f>
  <ai:f n="HostToLong" c="Converts a 32 bit (unsigned) long from host to network byte order." p="UINT net::HostToLong(UINT Value)" r="UINT">
    <ai:i n="Value" t="UINT" c="Data in host byte order to be converted to network byte order"/>
  </ai:f>
  <ai:f n="HostToShort" c="Converts a 16 bit (unsigned) word from host to network byte order." p="UINT net::HostToShort(UINT Value)" r="UINT">
    <ai:i n="Value" t="UINT" c="Data in host byte order to be converted to network byte order"/>
  </ai:f>
  <ai:f n="LongToHost" c="Converts a 32 bit (unsigned) long from network to host byte order." p="UINT net::LongToHost(UINT Value)" r="UINT">
    <ai:i n="Value" t="UINT" c="Data in network byte order to be converted to host byte order"/>
  </ai:f>
  <ai:f n="SetSSL" c="Alters SSL settings on an initialised NetSocket object." p="ERR net::SetSSL(objNetSocket * NetSocket, CSTRING Command, CSTRING Value)" r="ERR">
    <ai:i n="NetSocket" t="objNetSocket *" c="The target NetSocket object."/>
    <ai:i n="Command" t="CSTRING" c="Name of a command or option to set (case-sensitive, camel-case)."/>
    <ai:i n="Value" t="CSTRING" c="Value to set for the command or option."/>
    <ai:e c="Okay"/>
    <ai:e c="NoSupport"/>
    <ai:e c="NullArgs"/>
  </ai:f>
  <ai:f n="ShortToHost" c="Converts a 16 bit (unsigned) word from network to host byte order." p="UINT net::ShortToHost(UINT Value)" r="UINT">
    <ai:i n="Value" t="UINT" c="Data in network byte order to be converted to host byte order"/>
  </ai:f>
  <ai:f n="StrToAddress" c="Converts an IP Address in string form to an IPAddress structure." p="ERR net::StrToAddress(CSTRING String, struct IPAddress * Address)" r="ERR">
    <ai:i n="String" t="CSTRING" c="A null-terminated string containing the IP Address in dotted format."/>
    <ai:i n="Address" t="struct IPAddress *" c="Must point to an IPAddress structure that will be filled in."/>
    <ai:e c="Okay"/>
    <ai:e c="Failed"/>
    <ai:e c="NullArgs"/>
  </ai:f>
  <ai:c l="IPADDR" c="Address types for the IPAddress structure.">
    <ai:k n="V4"/>
    <ai:k n="V6"/>
  </ai:c>
  <ai:c l="NLF" c="Options for NetLookup">
    <ai:k n="NO_CACHE" c="Contact the name service and do not use the local DNS cache."/>
  </ai:c>
  <ai:c l="NSF">
    <ai:k n="DISABLE_SERVER_VERIFY" c="Disable SSL certificate verification (for testing only)."/>
    <ai:k n="LOG_ALL" c="Print extra log messages."/>
    <ai:k n="MULTI_CONNECT" c="Allow multiple connections from the same IP when in server mode."/>
    <ai:k n="SERVER" c="Puts the socket into server mode. In this state the netsocket object will wait for incoming connections from clients."/>
    <ai:k n="SSL" c="Use Secure Sockets Layer for all communication."/>
    <ai:k n="SYNCHRONOUS" c="Use synchronous (blocking) network calls."/>
  </ai:c>
  <ai:c l="NTC" c="NetSocket states">
    <ai:k n="CONNECTED" c="There is an active connection at present."/>
    <ai:k n="CONNECTING" c="A connection is being established."/>
    <ai:k n="DISCONNECTED" c="There is no connection."/>
    <ai:k n="HANDSHAKING" c="An SSL connection is being established."/>
    <ai:k n="MULTISTATE" c="In server mode the NetSocket will be set to MULTISTATE to indicate one or more client connections."/>
    <ai:k n="RESOLVING" c="The host name is being resolved."/>
  </ai:c>
  <ai:c l="SCV" c="These error codes for certificate validation match the OpenSSL error codes (X509 definitions)">
    <ai:k n="AKID_ISSUER_SERIAL_MISMATCH"/>
    <ai:k n="AKID_SKID_MISMATCH"/>
    <ai:k n="APPLICATION_VERIFICATION"/>
    <ai:k n="CERT_CHAIN_TOO_LONG"/>
    <ai:k n="CERT_HAS_EXPIRED"/>
    <ai:k n="CERT_NOT_YET_VALID"/>
    <ai:k n="CERT_REJECTED"/>
    <ai:k n="CERT_REVOKED"/>
    <ai:k n="CERT_SIGNATURE_FAILURE"/>
    <ai:k n="CERT_UNTRUSTED"/>
    <ai:k n="CRL_HAS_EXPIRED"/>
    <ai:k n="CRL_NOT_YET_VALID"/>
    <ai:k n="CRL_SIGNATURE_FAILURE"/>
    <ai:k n="DEPTH_ZERO_SELF_SIGNED_CERT"/>
    <ai:k n="ERROR_IN_CERT_NOT_AFTER_FIELD"/>
    <ai:k n="ERROR_IN_CERT_NOT_BEFORE_FIELD"/>
    <ai:k n="ERROR_IN_CRL_LAST_UPDATE_FIELD"/>
    <ai:k n="ERROR_IN_CRL_NEXT_UPDATE_FIELD"/>
    <ai:k n="INVALID_CA"/>
    <ai:k n="INVALID_PURPOSE"/>
    <ai:k n="KEYUSAGE_NO_CERTSIGN"/>
    <ai:k n="OK"/>
    <ai:k n="OUT_OF_MEM"/>
    <ai:k n="PATH_LENGTH_EXCEEDED"/>
    <ai:k n="SELF_SIGNED_CERT_IN_CHAIN"/>
    <ai:k n="SUBJECT_ISSUER_MISMATCH"/>
    <ai:k n="UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY"/>
    <ai:k n="UNABLE_TO_DECRYPT_CERT_SIGNATURE"/>
    <ai:k n="UNABLE_TO_DECRYPT_CRL_SIGNATURE"/>
    <ai:k n="UNABLE_TO_GET_CRL"/>
    <ai:k n="UNABLE_TO_GET_ISSUER_CERT"/>
    <ai:k n="UNABLE_TO_GET_ISSUER_CERT_LOCALLY"/>
    <ai:k n="UNABLE_TO_VERIFY_LEAF_SIGNATURE"/>
  </ai:c>
  <ai:s n="IPAddress">
    <ai:f n="Data" t="INT" s="4" c="128-bit array for supporting both V4 and V6 IP addresses."/>
    <ai:f n="Type" t="IPADDR" c="Identifies the address Data value as a V4 or V6 address type."/>
    <ai:f n="Pad" t="INT" c="Unused padding for 64-bit alignment"/>
  </ai:s>
</ai:m>
