<?xml version="1.0" encoding="UTF-8"?>
<ai:cl xmlns:ai="http://parasol-framework.org/ai-docs" n="Vector" mod="Vector" c="An abstract class for supporting vector graphics objects and functionality." cat="Graphics" id="227baf98" v="1">
  <ai:a n="Disable" c="Disabling a vector can be used to trigger style changes and prevent user input." p="ERR acDisable(*Object)"/>
  <ai:a n="Draw" c="Draws the surface associated with the vector." p="ERR acDraw(*Object, DOUBLE X, DOUBLE Y, DOUBLE Width, DOUBLE Height)">
    <ai:i n="X" t="INT" c="The X position of the region to be drawn."/>
    <ai:i n="Y" t="INT" c="The Y position of the region to be drawn."/>
    <ai:i n="Width" t="INT" c="The width of the region to be drawn."/>
    <ai:i n="Height" t="INT" c="The height of the region to be drawn."/>
  </ai:a>
  <ai:a n="Enable" c="Reverses the effects of disabling the vector." p="ERR acEnable(*Object)"/>
  <ai:a n="Hide" c="Changes the vector's visibility setting to hidden." p="ERR acHide(*Object)"/>
  <ai:a n="MoveToBack" c="Move a vector to the back of its stack." p="ERR acMoveToBack(*Object)"/>
  <ai:a n="MoveToFront" c="Move a vector to the front of its stack." p="ERR acMoveToFront(*Object)"/>
  <ai:a n="Show" c="Changes the vector's visibility setting to visible." p="ERR acShow(*Object)"/>
  <ai:m n="Debug" c="Internal functionality for debugging." p="ERR vec::Debug(OBJECTPTR Object)">
    <ai:e c="Okay"/>
  </ai:m>
  <ai:m n="FreeMatrix" c="Remove an allocated VectorMatrix structure." p="ERR vec::FreeMatrix(OBJECTPTR Object, struct VectorMatrix * Matrix)">
    <ai:i n="Matrix" t="struct VectorMatrix *" c="Reference to the structure that requires removal."/>
    <ai:e c="Okay"/>
    <ai:e c="NullArgs"/>
  </ai:m>
  <ai:m n="GetBoundary" c="Returns the graphical boundary of a vector." p="ERR vec::GetBoundary(OBJECTPTR Object, VBF Flags, DOUBLE * X, DOUBLE * Y, DOUBLE * Width, DOUBLE * Height)">
    <ai:i n="Flags" t="VBF" c="Optional flags."/>
    <ai:i n="X" t="DOUBLE *" c="The left-most position of the boundary is returned here."/>
    <ai:i n="Y" t="DOUBLE *" c="The top-most position of the boundary is returned here."/>
    <ai:i n="Width" t="DOUBLE *" c="The width of the boundary is returned here."/>
    <ai:i n="Height" t="DOUBLE *" c="The height of the boundary is returned here."/>
    <ai:e c="Okay"/>
    <ai:e c="NoData"/>
    <ai:e c="NullArgs"/>
    <ai:e c="NotPossible"/>
  </ai:m>
  <ai:m n="NewMatrix" c="Returns a VectorMatrix structure that allows transformations to be applied to the vector." p="ERR vec::NewMatrix(OBJECTPTR Object, struct VectorMatrix ** Transform, INT End)">
    <ai:i n="Transform" t="struct VectorMatrix **" c="A reference to the new transform structure is returned here."/>
    <ai:i n="End" t="INT" c="If true, the matrix priority is lowered by inserting it at the end of the transform list."/>
    <ai:e c="Okay"/>
    <ai:e c="NullArgs"/>
  </ai:m>
  <ai:m n="PointInPath" c="Checks if point at (X,Y) is within a vector's path." p="ERR vec::PointInPath(OBJECTPTR Object, DOUBLE X, DOUBLE Y)">
    <ai:i n="X" t="DOUBLE" c="The X coordinate of the point."/>
    <ai:i n="Y" t="DOUBLE" c="The Y coordinate of the point."/>
    <ai:e c="Okay"/>
    <ai:e c="False"/>
    <ai:e c="NoData"/>
    <ai:e c="NoSupport"/>
    <ai:e c="NullArgs"/>
  </ai:m>
  <ai:m n="Push" c="Push a vector to a new position within its area of the vector stack." p="ERR vec::Push(OBJECTPTR Object, INT Position)">
    <ai:i n="Position" t="INT" c="Specify a relative position index here (-ve to move backwards, +ve to move forwards)"/>
    <ai:e c="Okay"/>
    <ai:e c="NullArgs"/>
  </ai:m>
  <ai:m n="SubscribeFeedback" c="Subscribe to events that relate to the vector." p="ERR vec::SubscribeFeedback(OBJECTPTR Object, FM Mask, FUNCTION * Callback)">
    <ai:i n="Mask" t="FM" c="Defines the feedback events required by the client. Set to 0xffffffff if all messages are required."/>
    <ai:i n="Callback" t="FUNCTION *" c="The function that will receive feedback events."/>
    <ai:e c="Okay"/>
    <ai:e c="NullArgs"/>
  </ai:m>
  <ai:m n="SubscribeInput" c="Create a subscription for input events that relate to the vector." p="ERR vec::SubscribeInput(OBJECTPTR Object, JTYPE Mask, FUNCTION * Callback)">
    <ai:i n="Mask" t="JTYPE" c="Combine JTYPE flags to define the input messages required by the client. Set to zero to remove an existing subscription."/>
    <ai:i n="Callback" t="FUNCTION *" c="Reference to a function that will receive input messages."/>
    <ai:e c="Okay"/>
    <ai:e c="FieldNotSet"/>
    <ai:e c="AllocMemory"/>
    <ai:e c="NullArgs"/>
    <ai:e c="Function"/>
  </ai:m>
  <ai:m n="SubscribeKeyboard" c="Create a subscription for input events that relate to the vector." p="ERR vec::SubscribeKeyboard(OBJECTPTR Object, FUNCTION * Callback)">
    <ai:i n="Callback" t="FUNCTION *" c="Reference to a callback function that will receive input messages."/>
    <ai:e c="Okay"/>
    <ai:e c="FieldNotSet"/>
    <ai:e c="AllocMemory"/>
    <ai:e c="NullArgs"/>
    <ai:e c="Function"/>
  </ai:m>
  <ai:m n="Trace" c="Returns the coordinates for a vector path, using callbacks." p="ERR vec::Trace(OBJECTPTR Object, FUNCTION * Callback, DOUBLE Scale, INT Transform)">
    <ai:i n="Callback" t="FUNCTION *" c="A function to call with the path coordinates."/>
    <ai:i n="Scale" t="DOUBLE" c="Set to 1.0 (recommended) to trace the path at a scale of 1 to 1."/>
    <ai:i n="Transform" t="INT" c="Set to true if all transforms applicable to the vector should be applied to the path."/>
    <ai:e c="Okay"/>
    <ai:e c="NoData"/>
    <ai:e c="NullArgs"/>
  </ai:m>
  <ai:f n="AppendPath" c="Experimental. Append the path of the referenced vector during path generation." t="OBJECTPTR" a="GS"/>
  <ai:f n="Child" c="The first child vector, or NULL." t="*Vector" a="R"/>
  <ai:f n="ClipRule" c="Determines the algorithm to use when clipping the shape." t="INT" a="GS"/>
  <ai:f n="ColourSpace" c="Defines the colour space to use when blending the vector with a target bitmap's content." t="VCS" a="RW"/>
  <ai:f n="Cursor" c="The mouse cursor to display when the pointer is within the vector's boundary." t="PTC" a="RS"/>
  <ai:f n="DashArray" c="Controls the pattern of dashes and gaps used to stroke paths." t="DOUBLE []" a="GS"/>
  <ai:f n="DashOffset" c="The distance into the dash pattern to start the dash. Can be a negative number." t="DOUBLE" a="RS"/>
  <ai:f n="DisplayScale" c="Returns the scale of the vector as it appears on the display." t="DOUBLE" a="G"/>
  <ai:f n="Fill" c="Defines the fill painter using SVG's IRI format." t="STRING" a="GS"/>
  <ai:f n="FillColour" c="Defines a solid colour for filling the vector path." t="FLOAT []" a="GS"/>
  <ai:f n="FillOpacity" c="The opacity to use when filling the vector." t="DOUBLE" a="GS"/>
  <ai:f n="FillRule" c="Determines the algorithm to use when filling the shape." t="INT" a="GS"/>
  <ai:f n="Filter" c="Assign a post-effects filter to a vector." t="STRING" a="GS"/>
  <ai:f n="Flags" c="Optional flags." t="VF" a="RI"/>
  <ai:f n="ID" c="String identifier for a vector." t="STRING" a="GS"/>
  <ai:f n="InnerJoin" c="Adjusts the handling of thickly stroked paths that cross back at the join." t="INT" a="GS"/>
  <ai:f n="LineCap" c="The shape to be used at the start and end of a stroked path." t="INT" a="GS"/>
  <ai:f n="LineJoin" c="The shape to be used at path corners that are stroked." t="INT" a="GS"/>
  <ai:f n="Mask" c="Reference a VectorClip object here to apply a clipping mask to the rendered vector." t="OBJECTPTR" a="GS"/>
  <ai:f n="Matrices" c="A linked list of transform matrices that have been applied to the vector." t="struct VectorMatrix *" a="R"/>
  <ai:f n="MiterLimit" c="Imposes a limit on the ratio of the miter length to the StrokeWidth." t="DOUBLE" a="RS"/>
  <ai:f n="Morph" c="Enables morphing of the vector to a target path." t="OBJECTPTR" a="GS"/>
  <ai:f n="MorphFlags" c="Optional flags that affect morphing." t="INT" a="GS"/>
  <ai:f n="Next" c="The next vector in the branch, or NULL." t="*Vector" a="RS"/>
  <ai:f n="NumericID" c="A unique identifier for the vector." t="INT" a="GS"/>
  <ai:f n="Opacity" c="Defines an overall opacity for the vector's graphics." t="DOUBLE" a="RS"/>
  <ai:f n="Parent" c="The parent of the vector, or NULL if this is the top-most vector." t="OBJECTPTR" a="R"/>
  <ai:f n="PathQuality" c="Defines the quality of a path when it is rendered." t="RQ" a="RW"/>
  <ai:f n="PathTimestamp" c="This counter is modified each time the path is regenerated." t="INT" a="R"/>
  <ai:f n="Prev" c="The previous vector in the branch, or NULL." t="*Vector" a="RS"/>
  <ai:f n="ResizeEvent" c="A callback to trigger when the host viewport is resized." t="FUNCTION" a="S"/>
  <ai:f n="Scene" c="Short-cut to the top-level VectorScene." t="*VectorScene" a="R"/>
  <ai:f n="Sequence" c="Convert the vector's path to the equivalent SVG path string." t="STRING" a="G"/>
  <ai:f n="Stroke" c="Defines the stroke of a path using SVG's IRI format." t="STRING" a="GS"/>
  <ai:f n="StrokeColour" c="Defines the colour of the path stroke in RGB float format." t="FLOAT []" a="GS"/>
  <ai:f n="StrokeOpacity" c="Defines the opacity of the path stroke." t="DOUBLE" a="GS"/>
  <ai:f n="StrokeWidth" c="The width to use when stroking the path." t="DOUBLE" a="GS"/>
  <ai:f n="TabOrder" c="Defines the priority of this vector within the tab order." t="INT" a="GS"/>
  <ai:f n="Transition" c="Reference a VectorTransition object here to apply multiple transforms over the vector's path." t="OBJECTPTR" a="GS"/>
  <ai:f n="Visibility" c="Controls the visibility of a vector and its children." t="VIS" a="RS"/>
</ai:cl>
