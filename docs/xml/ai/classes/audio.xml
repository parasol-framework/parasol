<?xml version="1.0" encoding="UTF-8"?>
<ai:cl xmlns:ai="http://parasol-framework.org/ai-docs" n="Audio" mod="Audio" c="Supports a machine's audio hardware and provides a client-server audio management service." cat="Audio" id="0f1c28b7" v="1">
  <ai:a n="Activate" c="Enables access to the audio hardware and initialises the mixer." p="ERR acActivate(*Object)">
    <ai:e c="Okay"/>
    <ai:e c="Failed"/>
    <ai:e c="AllocMemory"/>
  </ai:a>
  <ai:a n="Deactivate" c="Disables the audio mixer and returns device resources to the system." p="ERR acDeactivate(*Object)"/>
  <ai:a n="SaveSettings" c="Saves the current audio settings." p="ERR acSaveSettings(*Object)"/>
  <ai:a n="SaveToObject" c="Saves the current audio settings to another object." p="ERR acSaveToObject(*Object, OBJECTID Dest, CLASSID ClassID)">
    <ai:i n="Dest" t="OBJECTID" c="Refers to an object that will receive the encoded data."/>
    <ai:i n="ClassID" t="CLASSID" c="Can refer to a sub-class that should be used when encoding the data."/>
  </ai:a>
  <ai:m n="AddSample" c="Adds a new sample to an audio object for channel-based playback." p="ERR snd::AddSample(OBJECTPTR Object, FUNCTION OnStop, SFM SampleFormat, APTR Data, INT DataSize, struct AudioLoop * Loop, INT LoopSize, INT * Result)">
    <ai:i n="OnStop" t="FUNCTION" c="This optional callback function will be called when the stream stops playing."/>
    <ai:i n="SampleFormat" t="SFM" c="Indicates the format of the sample data that you are adding."/>
    <ai:i n="Data" t="APTR" c="Points to the address of the sample data."/>
    <ai:i n="DataSize" t="INT" c="Size of the sample data, in bytes."/>
    <ai:i n="Loop" t="struct AudioLoop *" c="Optional sample loop information."/>
    <ai:i n="LoopSize" t="INT" c="Must be set to sizeof(AudioLoop) if Loop is defined."/>
    <ai:i n="Result" t="INT *" c="The resulting sample handle will be returned in this parameter."/>
    <ai:e c="Okay"/>
    <ai:e c="Args"/>
    <ai:e c="AllocMemory"/>
    <ai:e c="NullArgs"/>
  </ai:m>
  <ai:m n="AddStream" c="Adds a new sample-stream to an Audio object for channel-based playback." p="ERR snd::AddStream(OBJECTPTR Object, FUNCTION Callback, FUNCTION OnStop, SFM SampleFormat, INT SampleLength, INT PlayOffset, struct AudioLoop * Loop, INT LoopSize, INT * Result)">
    <ai:i n="Callback" t="FUNCTION" c="This callback function must be able to return raw audio data for streaming."/>
    <ai:i n="OnStop" t="FUNCTION" c="This optional callback function will be called when the stream stops playing."/>
    <ai:i n="SampleFormat" t="SFM" c="Indicates the format of the sample data that you are adding."/>
    <ai:i n="SampleLength" t="INT" c="Total byte-length of the sample data that is being streamed. May be set to zero if the length is infinite or unknown."/>
    <ai:i n="PlayOffset" t="INT" c="Offset the playing position by this byte index."/>
    <ai:i n="Loop" t="struct AudioLoop *" c="Refers to sample loop information, or NULL if no loop is required."/>
    <ai:i n="LoopSize" t="INT" c="Must be set to sizeof(AudioLoop)."/>
    <ai:i n="Result" t="INT *" c="The resulting sample handle will be returned in this parameter."/>
    <ai:e c="Okay"/>
    <ai:e c="Args"/>
    <ai:e c="AllocMemory"/>
    <ai:e c="NullArgs"/>
  </ai:m>
  <ai:m n="Beep" c="Generates system alert tones through the platform's audio notification system." p="ERR snd::Beep(OBJECTPTR Object, INT Pitch, INT Duration, INT Volume)">
    <ai:i n="Pitch" t="INT" c="The pitch of the beep in HZ."/>
    <ai:i n="Duration" t="INT" c="The duration of the beep in milliseconds."/>
    <ai:i n="Volume" t="INT" c="The volume of the beep, from 0 to 100."/>
    <ai:e c="Okay"/>
    <ai:e c="NoSupport"/>
    <ai:e c="NullArgs"/>
  </ai:m>
  <ai:m n="CloseChannels" c="Frees audio channels that have been allocated for sample playback." p="ERR snd::CloseChannels(OBJECTPTR Object, INT Handle)">
    <ai:i n="Handle" t="INT" c="Must refer to a channel handle returned from the OpenChannels method."/>
    <ai:e c="Okay"/>
    <ai:e c="Args"/>
    <ai:e c="NullArgs"/>
  </ai:m>
  <ai:m n="OpenChannels" c="Allocates audio channels that can be used for sample playback." p="ERR snd::OpenChannels(OBJECTPTR Object, INT Total, INT * Result)">
    <ai:i n="Total" t="INT" c="Total of channels to allocate."/>
    <ai:i n="Result" t="INT *" c="The resulting channel handle is returned in this parameter."/>
    <ai:e c="Okay"/>
    <ai:e c="OutOfRange"/>
    <ai:e c="AllocMemory"/>
    <ai:e c="NullArgs"/>
  </ai:m>
  <ai:m n="RemoveSample" c="Removes a sample from the global sample list and deallocates its resources." p="ERR snd::RemoveSample(OBJECTPTR Object, INT Handle)">
    <ai:i n="Handle" t="INT" c="The handle of the sample that requires removal."/>
    <ai:e c="Okay"/>
    <ai:e c="OutOfRange"/>
    <ai:e c="NullArgs"/>
  </ai:m>
  <ai:m n="SetSampleLength" c="Sets the byte length of a streaming sample." p="ERR snd::SetSampleLength(OBJECTPTR Object, INT Sample, INT64 Length)">
    <ai:i n="Sample" t="INT" c="A sample handle from AddStream()."/>
    <ai:i n="Length" t="INT64" c="Byte length of the sample stream."/>
    <ai:e c="Okay"/>
    <ai:e c="Failed"/>
    <ai:e c="Args"/>
    <ai:e c="NullArgs"/>
  </ai:m>
  <ai:m n="SetVolume" c="Sets the volume for input and output mixers." p="ERR snd::SetVolume(OBJECTPTR Object, INT Index, CSTRING Name, SVF Flags, INT Channel, DOUBLE Volume)">
    <ai:i n="Index" t="INT" c="The index of the mixer that you want to set."/>
    <ai:i n="Name" t="CSTRING" c="If the correct index number is unknown, the name of the mixer may be set here."/>
    <ai:i n="Flags" t="SVF" c="Optional flags."/>
    <ai:i n="Channel" t="INT" c="A specific channel to modify (e.g. 0 for left, 1 for right). If -1, all channels are affected."/>
    <ai:i n="Volume" t="DOUBLE" c="The volume to set for the mixer, from 0 to 1.0. If -1, the current volume values are retained."/>
    <ai:e c="Okay"/>
    <ai:e c="Args"/>
    <ai:e c="OutOfRange"/>
    <ai:e c="NullArgs"/>
  </ai:m>
  <ai:f n="BitDepth" c="The bit depth affects the overall quality of audio input and output." t="INT" a="RS"/>
  <ai:f n="Device" c="The name of the audio device used by this audio object." t="STRING" a="GS"/>
  <ai:f n="Flags" c="Special audio flags can be set here." t="ADF" a="RI"/>
  <ai:f n="InputRate" c="Determines the frequency to use when recording audio data." t="INT" a="RI"/>
  <ai:f n="MasterVolume" c="The master volume to use for audio playback." t="DOUBLE" a="GS"/>
  <ai:f n="MixerLag" c="Returns the lag time of the internal mixer, measured in seconds." t="DOUBLE" a="G"/>
  <ai:f n="Mute" c="Mutes all audio output." t="INT" a="GS"/>
  <ai:f n="OutputRate" c="Determines the frequency to use for the output of audio data." t="INT" a="RS"/>
  <ai:f n="PeriodSize" c="Defines the byte size of each period allocated to the internal audio buffer." t="INT" a="RS"/>
  <ai:f n="Periods" c="Defines the number of periods that make up the internal audio buffer." t="INT" a="RS"/>
  <ai:f n="Quality" c="Determines the quality of the audio mixing." t="INT" a="RS"/>
  <ai:f n="Stereo" c="Set to true for stereo output and false for mono output." t="INT" a="GS"/>
</ai:cl>
