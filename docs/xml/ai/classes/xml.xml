<?xml version="1.0" encoding="UTF-8"?>
<ai:cl xmlns:ai="http://parasol-framework.org/ai-docs" n="XML" mod="XML" c="Provides XML data management services for parsing, manipulation and serialisation." cat="Data" id="0b88bfd6" v="1">
  <ai:a n="Clear" c="Completely clears all XML data and resets the object to its initial state." p="ERR acClear(*Object)"/>
  <ai:a n="DataFeed" c="Processes and integrates external XML data into the object's document structure." p="ERR acDataFeed(*Object, OBJECTID Object, DATA Datatype, APTR Buffer, INT Size)">
    <ai:i n="Object" t="OBJECTID" c="Must refer to the unique ID of the object that you represent. If you do not represent an object, set this parameter to the current task ID."/>
    <ai:i n="Datatype" t="DATA" c="The type of data being sent."/>
    <ai:i n="Buffer" t="APTR" c="The data being sent to the target object."/>
    <ai:i n="Size" t="INT" c="The size of the data in Buffer."/>
  </ai:a>
  <ai:a n="GetKey" c="Retrieves data from an xml object." p="ERR acGetKey(*Object, CSTRING Key, STRING Value, INT Size)">
    <ai:i n="Key" t="CSTRING" c="The name of a key value."/>
    <ai:i n="Value" t="STRING" c="Pointer to a buffer space large enough to hold the retrieved value."/>
    <ai:i n="Size" t="INT" c="Indicates the byte size of the Buffer."/>
  </ai:a>
  <ai:a n="Reset" c="Clears the information held in an XML object." p="ERR acRefresh(*Object)"/>
  <ai:a n="SaveToObject" c="Saves XML data to a storage object (e.g. File)." p="ERR acSaveToObject(*Object, OBJECTID Dest, CLASSID ClassID)">
    <ai:i n="Dest" t="OBJECTID" c="Refers to an object that will receive the encoded data."/>
    <ai:i n="ClassID" t="CLASSID" c="Can refer to a sub-class that should be used when encoding the data."/>
  </ai:a>
  <ai:a n="SetKey" c="Sets attributes and content in the XML tree using XPaths." p="ERR acSetKey(*Object, CSTRING Key, CSTRING Value)">
    <ai:i n="Key" t="CSTRING" c="The name of the target key."/>
    <ai:i n="Value" t="CSTRING" c="The string value to associate with Key."/>
    <ai:e c="Okay"/>
    <ai:e c="Search"/>
    <ai:e c="ReadOnly"/>
  </ai:a>
  <ai:m n="Count" c="Count all tags that match a given XPath expression." p="ERR xml::Count(OBJECTPTR Object, CSTRING XPath, INT * Result)">
    <ai:i n="XPath" t="CSTRING" c="A valid XPath expression string defining the elements to count. The expression must conform to XPath 1.0 syntax with Parasol extensions."/>
    <ai:i n="Result" t="INT *" c="Pointer to an integer variable that will receive the total count of matching tags."/>
    <ai:e c="Okay"/>
    <ai:e c="NullArgs"/>
  </ai:m>
  <ai:m n="Filter" c="Filters the XML data structure to retain only a specific tag and its descendants." p="ERR xml::Filter(OBJECTPTR Object, CSTRING XPath)">
    <ai:i n="XPath" t="CSTRING" c="A valid XPath expression string that identifies the target tag to retain. The expression must resolve to exactly one element for successful filtering."/>
    <ai:e c="Okay"/>
    <ai:e c="Search"/>
    <ai:e c="NullArgs"/>
  </ai:m>
  <ai:m n="FindTag" c="Searches for XML elements using XPath expressions with optional callback processing." p="ERR xml::FindTag(OBJECTPTR Object, CSTRING XPath, FUNCTION * Callback, INT * Result)">
    <ai:i n="XPath" t="CSTRING" c="A valid XPath expression string conforming to XPath 1.0 syntax with Parasol extensions. Must not be NULL or empty."/>
    <ai:i n="Callback" t="FUNCTION *" c="Optional pointer to a callback function for processing multiple matches."/>
    <ai:i n="Result" t="INT *" c="Pointer to an integer that will receive the unique ID of the first matching tag. Only valid when no callback is provided."/>
    <ai:e c="Okay"/>
    <ai:e c="Search"/>
    <ai:e c="NoData"/>
    <ai:e c="NullArgs"/>
  </ai:m>
  <ai:m n="GetAttrib" c="Retrieves the value of a specific XML attribute from a tagged element." p="ERR xml::GetAttrib(OBJECTPTR Object, INT Index, CSTRING Attrib, CSTRING * Value)">
    <ai:i n="Index" t="INT" c="The unique identifier of the XML tag to search. This must correspond to a valid tag ID as returned by methods such as FindTag."/>
    <ai:i n="Attrib" t="CSTRING" c="The name of the attribute to retrieve (case insensitive). If NULL or empty, the element's tag name is returned instead."/>
    <ai:i n="Value" t="CSTRING *" c="Pointer to a string pointer that will receive the attribute value. Set to NULL if the specified attribute does not exist."/>
    <ai:e c="Okay"/>
    <ai:e c="NotFound"/>
    <ai:e c="NullArgs"/>
  </ai:m>
  <ai:m n="GetContent" c="Extracts the immediate text content of an XML element, excluding nested tags." p="ERR xml::GetContent(OBJECTPTR Object, INT Index, STRING Buffer, INT Length)">
    <ai:i n="Index" t="INT" c="The unique identifier of the XML element from which to extract content. This must correspond to a valid tag ID as returned by search methods."/>
    <ai:i n="Buffer" t="STRING" c="Pointer to a pre-allocated character buffer that will receive the extracted content string. Must not be NULL."/>
    <ai:i n="Length" t="INT" c="The size of the provided buffer in bytes, including space for null termination. Must be at least 1."/>
    <ai:e c="Okay"/>
    <ai:e c="NotFound"/>
    <ai:e c="Args"/>
    <ai:e c="BufferOverflow"/>
    <ai:e c="NullArgs"/>
  </ai:m>
  <ai:m n="GetTag" c="Returns a pointer to the XMLTag structure for a given tag index." p="ERR xml::GetTag(OBJECTPTR Object, INT Index, struct XMLTag ** Result)">
    <ai:i n="Index" t="INT" c="The index of the tag that is being retrieved."/>
    <ai:i n="Result" t="struct XMLTag **" c="The XMLTag is returned in this parameter."/>
    <ai:e c="Okay"/>
    <ai:e c="NotFound"/>
    <ai:e c="NullArgs"/>
  </ai:m>
  <ai:m n="InsertContent" c="Inserts text content into the XML document structure at specified positions." p="ERR xml::InsertContent(OBJECTPTR Object, INT Index, XMI Where, CSTRING Content, INT * Result)">
    <ai:i n="Index" t="INT" c="The unique identifier of the target XML element that will serve as the reference point for insertion."/>
    <ai:i n="Where" t="XMI" c="Specifies the insertion position relative to the target element. Use PREV or NEXT for sibling insertion, or CHILD for child content insertion."/>
    <ai:i n="Content" t="CSTRING" c="The text content to insert. Special XML characters will be automatically escaped to ensure document validity."/>
    <ai:i n="Result" t="INT *" c="Pointer to an integer that will receive the unique identifier of the newly created content node."/>
    <ai:e c="Okay"/>
    <ai:e c="NotFound"/>
    <ai:e c="ReadOnly"/>
    <ai:e c="NullArgs"/>
  </ai:m>
  <ai:m n="InsertXML" c="Parse an XML string and insert it in the XML tree." p="ERR xml::InsertXML(OBJECTPTR Object, INT Index, XMI Where, CSTRING XML, INT * Result)">
    <ai:i n="Index" t="INT" c="The new data will target the tag specified here."/>
    <ai:i n="Where" t="XMI" c="Use PREV or NEXT to insert behind or ahead of the target tag. Use CHILD or CHILD_END for a child insert."/>
    <ai:i n="XML" t="CSTRING" c="An XML statement to parse."/>
    <ai:i n="Result" t="INT *" c="The resulting tag index."/>
    <ai:e c="Okay"/>
    <ai:e c="Args"/>
    <ai:e c="OutOfRange"/>
    <ai:e c="ReadOnly"/>
    <ai:e c="NullArgs"/>
  </ai:m>
  <ai:m n="InsertXPath" c="Inserts an XML statement in an XML tree." p="ERR xml::InsertXPath(OBJECTPTR Object, CSTRING XPath, XMI Where, CSTRING XML, INT * Result)">
    <ai:i n="XPath" t="CSTRING" c="An XPath string that refers to the target insertion point."/>
    <ai:i n="Where" t="XMI" c="Use PREV or NEXT to insert behind or ahead of the target tag. Use CHILD for a child insert."/>
    <ai:i n="XML" t="CSTRING" c="The statement to process."/>
    <ai:i n="Result" t="INT *" c="The index of the new tag is returned here."/>
    <ai:e c="Okay"/>
    <ai:e c="Search"/>
    <ai:e c="NullArgs"/>
  </ai:m>
  <ai:m n="MoveTags" c="Move an XML tag group to a new position in the XML tree." p="ERR xml::MoveTags(OBJECTPTR Object, INT Index, INT Total, INT DestIndex, XMI Where)">
    <ai:i n="Index" t="INT" c="Index of the source tag to be moved."/>
    <ai:i n="Total" t="INT" c="The total number of sibling tags to be moved from the source index. Minimum value of 1."/>
    <ai:i n="DestIndex" t="INT" c="The destination tag index. If the index exceeds the total number of tags, the value will be automatically limited to the last tag index."/>
    <ai:i n="Where" t="XMI" c="Use PREV or NEXT to insert behind or ahead of the target tag. Use CHILD for a child insert."/>
    <ai:e c="Okay"/>
    <ai:e c="NotFound"/>
    <ai:e c="ReadOnly"/>
    <ai:e c="NullArgs"/>
  </ai:m>
  <ai:m n="RemoveTag" c="Removes tag(s) from the XML structure." p="ERR xml::RemoveTag(OBJECTPTR Object, INT Index, INT Total)">
    <ai:i n="Index" t="INT" c="Reference to the tag that will be removed."/>
    <ai:i n="Total" t="INT" c="The total number of sibling (neighbouring) tags that should also be deleted. A value of one or less will remove only the indicated tag and its children. The total may exceed the number of tags actually available, in which case all tags up to the end of the branch will be affected."/>
    <ai:e c="Okay"/>
    <ai:e c="OutOfRange"/>
    <ai:e c="ReadOnly"/>
    <ai:e c="NullArgs"/>
  </ai:m>
  <ai:m n="RemoveXPath" c="Removes tag(s) from the XML structure, using an xpath lookup." p="ERR xml::RemoveXPath(OBJECTPTR Object, CSTRING XPath, INT Limit)">
    <ai:i n="XPath" t="CSTRING" c="An XML path string."/>
    <ai:i n="Limit" t="INT" c="The maximum number of matching tags that should be deleted. A value of one or less will remove only the indicated tag and its children. The total may exceed the number of tags actually available, in which case all matching tags up to the end of the tree will be affected."/>
    <ai:e c="Okay"/>
    <ai:e c="ReadOnly"/>
    <ai:e c="NullArgs"/>
  </ai:m>
  <ai:m n="Serialise" c="Serialise part of the XML tree to an XML string." p="ERR xml::Serialise(OBJECTPTR Object, INT Index, XMF Flags, STRING * Result)">
    <ai:i n="Index" t="INT" c="Index to a source tag for which serialisation will start. Set to zero to serialise the entire tree."/>
    <ai:i n="Flags" t="XMF" c="Use INCLUDE_SIBLINGS to include siblings of the tag found at Index."/>
    <ai:i n="Result" t="STRING *" c="The resulting string is returned in this parameter."/>
    <ai:e c="Okay"/>
    <ai:e c="Args"/>
    <ai:e c="NoData"/>
    <ai:e c="AllocMemory"/>
  </ai:m>
  <ai:m n="SetAttrib" c="Adds, updates and removes XML attributes." p="ERR xml::SetAttrib(OBJECTPTR Object, INT Index, XMS Attrib, CSTRING Name, CSTRING Value)">
    <ai:i n="Index" t="INT" c="Identifies the tag that is to be updated."/>
    <ai:i n="Attrib" t="XMS" c="Either the index number of the attribute that is to be updated, or set to NEW, UPDATE or UPDATE_ONLY."/>
    <ai:i n="Name" t="CSTRING" c="String containing the new name for the attribute. If NULL, the name will not be changed. If Attrib is UPDATE or UPDATE_ONLY, the Name is used to find the attribute."/>
    <ai:i n="Value" t="CSTRING" c="String containing the new value for the attribute. If NULL, the attribute is removed."/>
    <ai:e c="Okay"/>
    <ai:e c="Search"/>
    <ai:e c="Args"/>
    <ai:e c="OutOfRange"/>
    <ai:e c="ReadOnly"/>
    <ai:e c="NullArgs"/>
  </ai:m>
  <ai:m n="Sort" c="Sorts XML tags to your specifications." p="ERR xml::Sort(OBJECTPTR Object, CSTRING XPath, CSTRING Sort, XSF Flags)">
    <ai:i n="XPath" t="CSTRING" c="Sort everything under the specified tag, or NULL to sort the entire top level."/>
    <ai:i n="Sort" t="CSTRING" c="Pointer to a sorting instruction string."/>
    <ai:i n="Flags" t="XSF" c="Optional flags."/>
    <ai:e c="Okay"/>
    <ai:e c="Search"/>
    <ai:e c="AllocMemory"/>
    <ai:e c="ReadOnly"/>
    <ai:e c="NullArgs"/>
  </ai:m>
  <ai:f n="Flags" c="Controls XML parsing behaviour and processing options." t="XMF" a="RW"/>
  <ai:f n="Modified" c="A timestamp of when the XML data was last modified." t="INT" a="R"/>
  <ai:f n="Path" c="Set this field if the XML document originates from a file source." t="STRING" a="RS"/>
  <ai:f n="ReadOnly" c="Prevents modifications and enables caching for a loaded XML data source." t="INT" a="GS"/>
  <ai:f n="Source" c="Set this field if the XML data is to be sourced from another object." t="OBJECTPTR" a="RI"/>
  <ai:f n="Start" c="Set a starting cursor to affect the starting point for some XML operations." t="INT" a="RW"/>
  <ai:f n="Statement" c="XML data is processed through this field." t="STRING" a="GS"/>
  <ai:f n="Tags" c="Provides direct access to the XML document structure." t="STRUCT []" a="G"/>
</ai:cl>
