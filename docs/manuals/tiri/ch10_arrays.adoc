// VERIFIED: 2026-02-12

[[ch-arrays]]
== Arrays

Arrays are mutable, typed, contiguous sequences of elements.  Each array holds elements of a single declared type, providing efficient storage and direct memory access.  Arrays are a distinct type from tables, purpose-built for sequential data where all elements share a common type.

Arrays are reference types.  Assigning an array to another variable creates a second reference to the same underlying data, not a copy.  Two distinct arrays are never equal, even if they contain identical entries; `is` compares identity, not content.

[source,tiri]
----
nums = array<int> { 10, 20, 30 }
print(nums[0])      -- 10
print(#nums)        -- 3
print(type(nums))   -- 'array'
----

All indexing is zero-based.  The `#` operator returns the element count.  Element access by index is O(1) and is optimised by the JIT compiler in hot paths.  The `ipairs()`, `pairs()`, and `values()` functions work identically on arrays and tables.

[[sec-array-fundamentals]]
=== Array Fundamentals

[discrete]
==== Element Types

Each array declares a fixed element type at creation.  Storing a value of an incompatible type raises an error.

[cols="1,1,3"]
|===
|Type |Size |Description

|`byte`
|1
|Unsigned 8-bit integer (0--255).  Alias: `char`.

|`int16`
|2
|Signed 16-bit integer

|`int`
|4
|Signed 32-bit integer

|`int64`
|8
|Signed 64-bit integer

|`float`
|4
|32-bit floating point

|`double`
|8
|64-bit floating point

|`string`
|8
|String reference (garbage-collected)

|`table`
|8
|Table reference (garbage-collected)

|`object`
|8
|Kōtuku object reference (garbage-collected)

|`array`
|8
|Nested array reference (garbage-collected)

|`any`
|16
|Any Tiri value (mixed types permitted)
|===

[discrete]
==== Type Inspection

[.api]`name = arr:type()`

Returns the element type of the array as a string, e.g. 'char', 'float'.

[source,tiri]
----
array<int>:type()            -- 'int'
array<float>:type()          -- 'float'
array<byte>:type()           -- 'char'
array<array<string>>:type()  -- 'array'
----

[discrete]
==== Read-Only Arrays

[.api]`result = arr:readOnly()`

Returns `true` if the array is read-only.  Read-only arrays are produced by Kōtuku API calls that expose internal buffers.  Mutation methods will raise an error when called on a read-only array.

[discrete]
==== Length and Identity

The `#` operator returns the current element count.  The `is` operator compares identity, not content.

[source,tiri]
----
a = array<int> { 1, 2, 3 }
b = array<int> { 1, 2, 3 }
c = a

a is c   -- true  (same object)
a is b   -- false (distinct objects)
#a       -- 3
----

[[sec-creating-arrays]]
=== Creating Arrays

[discrete]
==== Typed Syntax

The `array<type>` syntax creates arrays with concise, declarative notation:

[source,tiri]
----
arr = array<int>                       -- empty array
arr = array<int, 5>                    -- 5 elements, zero-initialised
arr = array<int> { 10, 20, 30 }        -- 3 elements with values
arr = array<int, 10> { 1, 2, 3 }       -- 10 elements; first 3 set, rest zero
arr = array<string> { 'a', 'b', 'c' }  -- string array with values
----

When both a size and initial values are provided, the array is first populated with the values, then extended to the specified size.  Extended elements are zero-initialised for numeric types or `nil` for reference types.  If the number of values exceeds the size, the values take precedence.

The size expression accepts variables and function calls:

[source,tiri]
----
n = 8
buf = array<int, n>   -- 8 zero-initialised elements
----

==== array.new()

[.api]`arr = array.new(Size, Type)`

Creates an array of `Size` elements with the specified element `Type` string.  Raises an error if `Size` is negative.

[source,tiri]
----
arr = array.new(100, 'int')
arr = array.new(50, 'double')
----

A string argument creates a byte array initialised from the string's bytes:

[source,tiri]
----
arr = array.new('Hello')
arr:type()     -- 'char'
#arr           -- 5
arr[0]         -- 72 (ASCII 'H')
----

==== array.of()

[.api]`arr = array.of(Type, Value, pass:[...])`

Creates an array populated with the given values.  At least one value is required.  Raises an error if any value is incompatible with `Type`.

[source,tiri]
----
arr = array.of('string', 'google.com', 'kotuku.dev')
arr = array.of('int', 1, 2, 3, 4, 5)
----

NOTE: The typed syntax `array<int> { 1, 2, 3 }` is preferred over `array.of()` for readability.

[[sec-element-access]]
[%breakable]
=== Element Access

[discrete]
==== Indexing

Elements are accessed by zero-based integer index.  Out-of-bounds reads and writes raise an error.  Negative indices are not supported.

[source,tiri]
----
arr = array<int> { 10, 20, 30 }
arr[0]    -- 10
arr[2]    -- 30
arr[3]    -- error: index out of bounds
arr[-1]   -- error: negative index
----

[discrete]
==== first() and last()

[.api]`value = arr:first()`

Returns the first element, or `nil` if the array is empty.

[.api]`value = arr:last()`

Returns the last element, or `nil` if the array is empty.

[discrete]
==== Iteration

Arrays support three iteration styles for use in `for` loops.

Direct iteration returns index-value pairs:

[source,tiri]
----
arr = array<int> { 10, 20, 30 }
for i, v in arr do
   print(i, v)
end
----

The `ipairs()`, `pairs()`, and `values()` functions also work on arrays with identical semantics to tables:

[source,tiri]
----
for i, v in ipairs(arr) do pass:[...] end
for i, v in pairs(arr) do pass:[...] end
for v in values(arr) do pass:[...] end
----

TIP: Direct iteration is preferred over the use of `ipairs()` and `pairs()`, which are supported to maintain seamless compatibility with tables.

[discrete]
==== Membership Testing

The `in` operator tests whether a value exists in an array:

[source,tiri]
----
arr = array<string> { 'red', 'green', 'blue' }
'green' in arr       -- true
'yellow' in arr      -- false

if 'red' in arr then
   print('found')
end
----

[[sec-mutation-methods]]
=== Mutation Methods

[discrete]
==== push()

[.api]`length = arr:push(Value, pass:[...])`

Appends one or more values to the end of the array.  Grows the array if necessary.  Returns the new length.  If called with no arguments, returns the current length without modification.

[source,tiri]
----
arr = array<int>
arr:push(10)         -- returns 1
arr:push(20, 30)     -- returns 3
----

[discrete]
==== pop()

[.api]`value = arr:pop([Count])`

Removes and returns elements from the end of the array.  If `Count` is omitted, removes one element.  If `Count` exceeds the array length, removes all elements.  Returns `nil` for each element beyond the array's content.

[source,tiri]
----
arr = array<int> { 10, 20, 30 }
arr:pop()       -- returns 30; #arr is 2
arr:pop()       -- returns 20; #arr is 1

arr = array<int> { 1, 2, 3, 4, 5 }
a, b = arr:pop(2)   -- a=5, b=4; #arr is 3
----

Returns `nil` on an empty array.

[discrete]
==== insert()

[.api]`length = arr:insert(Index, Value, pass:[...])`

Inserts one or more values at `Index`, shifting subsequent elements to the right.  Returns the new length.  Raises an error if `Index` is negative or exceeds the current length.  If no values are provided, the array is unchanged.

[source,tiri]
----
arr = array<int> { 1, 2, 5 }
arr:insert(2, 3, 4)   -- arr = {1, 2, 3, 4, 5}
arr:insert(0, 0)      -- arr = {0, 1, 2, 3, 4, 5}
----

[discrete]
==== remove()

[.api]`length = arr:remove(Index, [Count])`

Removes `Count` elements starting at `Index`, shifting subsequent elements to the left.  `Count` defaults to 1.  If `Count` exceeds the number of elements from `Index` to the end, removes all remaining elements from `Index`.  Returns the new length.  Raises an error if `Index` is negative, at or beyond the current length, or if `Count` is negative.

[source,tiri]
----
arr = array<int> { 1, 2, 3, 4, 5 }
arr:remove(2)       -- arr = {1, 2, 4, 5}
arr:remove(1, 2)    -- arr = {1, 5}
----

[discrete]
==== fill()

[.api]`arr:fill(Value, [Start, Count])` +
[.api]`arr:fill(Value, Range)`

Sets elements to `Value`.  With no additional arguments, fills the entire array.  With `Start` and `Count`, fills `Count` elements beginning at `Start`.  With a range, fills the elements selected by the range (supports exclusive, inclusive, negative, and stepped ranges).

[source,tiri]
----
arr = array<int, 10>
arr:fill(0)             -- zero-fill all elements
arr:fill(99, 2, 3)      -- arr[2..4] = 99
arr:fill(77, {2...5})   -- arr[2..5] = 77 (inclusive)
arr:fill(33, range.new(0, 10, false, 2))   -- every 2nd element
----

[discrete]
==== sort()

[.api]`arr:sort([Descending])` +
[.api]`arr:sort(ComparatorFn)`

Sorts the array in place.  The default order is ascending.  If `Descending` is `true`, sorts in descending order.  Supported for all numeric types, string arrays, and `any` arrays.

Alternatively, a comparator function can be provided.  The function receives two elements `(a, b)` and must return `true` if `a` should come before `b` in the sorted result.  This works for all pushable array types, including `table` and `object` arrays.

[source,tiri]
----
arr = array<int> { 5, 3, 1, 4, 2 }
arr:sort()        -- {1, 2, 3, 4, 5}
arr:sort(true)    -- {5, 4, 3, 2, 1}

-- Custom comparator: sort by absolute value
nums = array<int> { -5, 3, -1, 4, -2 }
nums:sort((a, b) => math.abs(a) < math.abs(b))

-- Sort tables by a field
people = array<table> {
   { name = 'Charlie', age = 35 },
   { name = 'Alice',   age = 28 },
   { name = 'Bob',     age = 31 }
}
people:sort((a, b) => a.age < b.age)  -- sorted by age ascending
----

[discrete]
==== reverse()

[.api]`arr:reverse()`

Reverses the order of all elements in place.

[source,tiri]
----
arr = array<int> { 1, 2, 3, 4, 5 }
arr:reverse()   -- {5, 4, 3, 2, 1}
----

[discrete]
==== clear()

[.api]`arr:clear()`

Resets the array length to zero.  Storage capacity is preserved for reuse.

[source,tiri]
----
arr = array<int> { 1, 2, 3 }
arr:clear()
#arr             -- 0
arr:push(67)    -- reuses existing capacity
----

[discrete]
==== resize()

[.api]`arr:resize(NewSize)`

Changes the array length to `NewSize`.  When growing, new elements are zero-initialised (or `nil` for reference types).  When shrinking, excess elements are discarded.  Raises an error if `NewSize` is negative.

[[sec-search-and-query]]
=== Search & Query

[discrete]
==== find()

[.api]`index = arr:find(Value, [Start])` +
[.api]`index = arr:find(Value, Range)`

Searches for `Value` and returns its zero-based index, or `nil` if not found.  With a numeric `Start`, the search begins at that index.  With a range, the search is restricted to the indices selected by the range (supports exclusive, inclusive, negative, stepped, and reverse ranges).

For `object` arrays, `Value` can be an object or a numeric UID.

[source,tiri]
----
arr = array<int> { 10, 20, 30, 40, 50 }
arr:find(30)           -- 2
arr:find(30, 3)        -- nil (search starts at index 3)
arr:find(30, {0..5})   -- 2
arr:find(99)           -- nil
----

Reverse ranges search from higher to lower indices, finding the last occurrence first:

[source,tiri]
----
arr = array<int> { 10, 20, 30, 20, 40 }
arr:find(20, {4...0})   -- 3 (found searching backwards)
----

[[sec-copying-and-slicing]]
=== Copying & Slicing

[discrete]
==== clone()

[.api]`copy = arr:clone()`

Creates a new array with the same element type and a copy of all elements.  For reference types (tables, objects, arrays), the clone is shallow: the new array holds references to the same underlying objects.

[discrete]
==== slice()

[.api]`result = arr:slice(Range)`

Returns a new array containing the elements selected by `Range`.  The result has the same element type as the source.  Supports exclusive, inclusive, negative, reverse, and stepped ranges.  Out-of-bounds indices are clamped.

[source,tiri]
----
arr = array<int> { 0, 10, 20, 30, 40, 50 }
arr:slice({1..4})       -- array<int> {10, 20, 30}
arr:slice({-2..-1})     -- array<int> {40, 50}
arr:slice({4...2})      -- array<int> {40, 30, 20} (reverse)

arr:slice(range.new(0, 6, false, 2))   -- array<int> {0, 20, 40}
----

[discrete]
==== copy()

[.api]`arr:copy(Source, [DestIndex, SrcIndex, Count])`

Copies data into the array from `Source`.  `Source` can be an array, a string (copied as bytes into a byte array), or a table.

`DestIndex` specifies the starting position in the destination (default: 0).  `SrcIndex` specifies the starting position in the source (default: 0).  `Count` limits the number of elements copied (default: all remaining from `SrcIndex`).

Raises an error if the copy would exceed the destination bounds.  For string sources, the destination must be a byte array.

[source,tiri]
----
dest = array<int, 6>
dest:fill(0)
dest:copy(array<int> { 100, 200, 300 }, 2, 0, 3)
-- dest = {0, 0, 100, 200, 300, 0}

buf = array<byte, 10>
buf:copy('Hello')
buf:getString(0, 5)   -- 'Hello'
----

[discrete]
==== table()

[.api]`t = arr:table()`

Converts the array to a table.  Each element becomes a sequential entry in the returned table.

[source,tiri]
----
arr = array<int> { 10, 20, 30 }
t = arr:table()
t[0]   -- 10
t[1]   -- 20
----

[discrete]
==== Byte Array String Methods

These methods are available only on byte (`char`) arrays.

[.api]`str = arr:getString([Start, Length])`

Extracts a string from the byte array starting at `Start` (default: 0) with the specified `Length` (default: remaining bytes from `Start`).  Raises an error if the range exceeds the array bounds, or if `Start` or `Length` is negative.

[.api]`count = arr:setString(String, [Start])`

Copies the bytes of `String` into the array at `Start` (default: 0).  If the string extends beyond the array bounds, it is clamped.  Returns the number of bytes written.

[source,tiri]
----
arr = array.new('Hello World')
arr:getString(0, 5)   -- 'Hello'
arr:getString(6)      -- 'World'

arr:setString('Greet', 0)
arr:getString(0, 5)   -- 'Greet'
----

[discrete]
==== concat()

[.api]`str = arr:concat(Format, [Separator])`

Concatenates array elements into a string.  `Format` is a C-style format specifier applied to each element (e.g. `'%d'`, `'%.2f'`, `'%s'`).  `Separator` is inserted between formatted elements (default: empty string).

The format string must contain exactly one format specifier.  Raises an error for table, struct, or nested array types.

[source,tiri]
----
arr = array<int> { 10, 20, 30 }
arr:concat('%d', ', ')   -- '10, 20, 30'

arr = array<float> { 1.5, 2.7 }
arr:concat('%.1f', ' | ')   -- '1.5 | 2.7'
----

[discrete]
==== join()

[.api]`str = arr:join([Separator])`

Concatenates array elements into a string, inserting `Separator` between each element (default: empty string).  Simpler and faster than `concat()` for cases that do not require custom formatting.  The complement of `string.split()`.

For non-string arrays, elements are converted to their default string representation.  Table and array elements produce the placeholder strings `'table'` and `'array'`.

[source,tiri]
----
arr = array<string> { 'hello', 'world' }
arr:join(' ')     -- 'hello world'
arr:join()        -- 'helloworld'

arr = array<int> { 1, 2, 3 }
arr:join('-')     -- '1-2-3'
----

[[sec-functional-methods]]
=== Functional Methods

All functional methods in this section accept a callback function that receives `(Value, Index)` as parameters.  The `Index` parameter is optional; callbacks that only need the value can omit it.

[discrete]
==== each()

[.api]`arr:each(Callback)`

Calls `Callback(Value, Index)` for every element.  Returns the array for chaining.

[source,tiri]
----
arr = array<int> { 10, 20, 30 }
arr:each(function(v, i)
   print(i, v)
end)
----

[discrete]
==== map()

[.api]`result = arr:map(Callback)`

Returns a new array where each element is the result of `Callback(Value, Index)`.  The original array is not modified.  The result array preserves the source element type.

[source,tiri]
----
arr = array<int> { 1, 2, 3, 4, 5 }
doubled = arr:map(v => v * 2)
-- doubled = {2, 4, 6, 8, 10}
----

[discrete]
==== filter()

[.api]`result = arr:filter(Predicate)`

Returns a new array containing only the elements for which `Predicate(Value, Index)` returns a truthy value.  The original array is not modified.  The result preserves the source element type.

[source,tiri]
----
arr = array<int> { 1, 2, 3, 4, 5, 6 }
evens = arr:filter(v => v % 2 is 0)
-- evens = {2, 4, 6}
----

[discrete]
==== reduce()

[.api]`result = arr:reduce(Initial, Reducer)`

Applies `Reducer(Accumulator, Value, Index)` to each element, threading the accumulator from left to right.  Returns the final accumulator.  If the array is empty, returns `Initial` unchanged.

[source,tiri]
----
arr = array<int> { 1, 2, 3, 4, 5 }
sum = arr:reduce(0, (acc, v) => acc + v)
-- sum = 15

product = arr:reduce(1, (acc, v) => acc * v)
-- product = 120
----

[discrete]
==== any()

[.api]`result = arr:any(Predicate)`

Returns `true` if `Predicate(Value, Index)` returns a truthy value for at least one element.  Returns `false` on an empty array.

[source,tiri]
----
arr = array<int> { 1, 3, 5, 6, 7 }
arr:any(v => v % 2 is 0)   -- true
----

[discrete]
==== all()

[.api]`result = arr:all(Predicate)`

Returns `true` if `Predicate(Value, Index)` returns a truthy value for every element.  Returns `true` on an empty array (vacuous truth).

[source,tiri]
----
arr = array<int> { 2, 4, 6, 8 }
arr:all(v => v % 2 is 0)   -- true
----

[discrete]
==== Chaining

Functional methods that return arrays can be chained:

[source,tiri]
----
arr = array<int> { 1, 2, 3, 4, 5 }

result = arr:map(v => v * 2):filter(v => v > 5)
-- result = {6, 8, 10}

sum = arr:filter(v => v % 2 is 0)
   :reduce(0, (acc, v) => acc + v)
-- sum = 6
----
