[[ch-threading]]
== Threading

Tiri provides a threading model designed for safety over flexibility, without compromising performance.  Rather than launching raw threads, the programmer submits asynchronous work against a Kōtuku object.  The runtime manages thread creation, queueing, and exclusive locking automatically.  This _barrier model_ eliminates data races by ensuring that no two workers can access the same object concurrently — while the worker has exclusive access, it can safely operate on the object's data without additional synchronisation.

The threading system consists of two interfaces:

* The `thread` interface submits async work to objects and manages worker threads.
* The `processing` interface (<<ch-processing-and-events>>) provides synchronisation through signals and the processing loop.

[[sec-threading-model]]
=== The Barrier Model

Every async action targets a Kōtuku object.  When the action's worker thread starts, it acquires an exclusive lock on that object.  Execution proceeds in two phases:

. **Worker phase** — the worker thread owns the object lock and executes the action.  No other thread may access the object.
. **Callback phase** — on completion, ownership transfers directly to the main thread for callback execution.  The object remains unavailable to other worker threads throughout.

At no point between thread completion and callback return is the object eligible for execution by another worker thread.  The object transitions directly from worker ownership to main-thread ownership.  Only after the callback returns (or immediately after thread completion if no callback was provided) does the object become available for the next queued action.

Each object has an associated FIFO queue of pending async actions, created on demand when the first action is queued and destroyed when the object is freed.  The queue does not outlive the object — if an object is freed while actions are still queued, the remaining entries are drained and their callbacks receive an `ERR_DoesNotExist` error (see <<sec-thread-safety>>).

Consequences of this design:

* An object cannot serve as the target for two concurrent threads.  If an async action is already in-flight for a given object, subsequent requests are placed in a per-object FIFO queue and dispatched sequentially after each callback completes.  Actions targeting _different_ objects execute in parallel.
* The threaded code cannot share Tiri variables with the calling scope.  Communication between the thread and the caller must use Kōtuku objects (e.g. via `obj.find()`).
* Callbacks execute after the thread finishes and the object lock returns to the main thread.  The callback runs in the caller's scope with full access to local variables.  The next queued action for the same object is dispatched only after the callback returns.

NOTE: Thread callbacks always execute during the event processing loop, which requires a call to `processing.sleep()`.

[[sec-thread-creation]]
=== Thread Creation

==== thread.script()

[.api]`thread.script(Script, [Callback])`

Executes a Script object in a separate thread.  `Script` must be a Kōtuku Script object (created with `obj.new('script', { pass:[...] })`).  The script's code runs in its own isolated state — it cannot see local variables from the calling scope.

If `Callback` is provided, it executes on the main thread after the threaded script completes.  The callback receives no arguments.

[source,tiri]
----
script = obj.new('script', {
   statement=[[ msg('Thread is now in session.') ]]
})

thread.script(script, function()
   print('Thread has completed.')
end)
----

The Script object is pinned in the runtime registry for the duration of the thread, preventing the garbage collector from reclaiming it.  This pinning is automatic and requires no action from the programmer.

Exceptions can be raised if:

* The first argument is not a Script object.
* The object lock cannot be acquired.

[discrete]
===== Passing Data to the Thread

Because the threaded script runs in a separate state, it cannot access the caller's variables directly.  Use `setKey()` on the Script object to pass data, and `arg()` inside the thread to retrieve it:

[source,tiri]
----
signal_obj = obj.new('time', { })

script = obj.new('script', {
   statement=[[
      sig = obj.find(arg('SignalID'))
      -- Perform work...
      sig.acSignal()
   ]]
})
script.setKey('SignalID', signal_obj.id)
thread.script(script)
----

[discrete]
===== Reuse of Script Objects

A Script object can be reused for multiple sequential thread invocations, but not in parallel.  The barrier lock prevents a second `thread.script()` call on the same object until the previous thread completes.

[source,tiri]
----
script = obj.new('script', {
   statement=[[ msg('Thread is now in session.') ]]
})

for i in {0..9} do
   thread.script(script, function()
      print(f'Iteration {i} complete.')
   end)

   proc = processing.new({ timeout = 1.0 })
   proc.sleep() <1>
end
----
<1> Each iteration must wait for the thread to complete before launching the next.

[discrete]
===== Garbage Collection Safety

The garbage collector cannot reclaim a Script object while its thread is running, even if all Tiri references to it are released.  The following pattern is safe:

[source,tiri]
----
do
   script = obj.new('script', {
      statement=[[ msg('Working...') ]]
   })
   thread.script(script, callback)
end
processing.collect() <1>
----
<1> The script object remains pinned despite leaving scope and an explicit collection.

[[sec-threaded-actions-and-methods]]
=== Async Actions & Methods

==== thread.action(), thread.method()

[.api]`thread.action(Object, Name, [Callback], [Key], [Argspass:[...]])` +
[.api]`thread.method(Object, Name, [Callback], [Key], [Argspass:[...]])`

Submits an action or method for asynchronous execution against `Object`.  `Name` is the action or method as represented by its string name or numeric `AC` or `MT` ID.  The runtime allocates a worker thread to execute the action; the caller does not manage threads directly.  The optional `Callback` executes on the main thread when the action completes.  `Callback` accepts a function value or a string that names a global function.

Multiple calls targeting the same object are queued automatically and executed in FIFO order — only one worker thread runs per object at any time.  Calls targeting different objects execute in parallel.

The callback receives four arguments:

[cols="1,1,3"]
|===
|Parameter |Type |Description

|`ActionID`
|integer
|The numeric ID of the action that was executed.

|`Object`
|object
|The target object.

|`Error`
|integer
|The `ERR` code returned by the action.

|`Key`
|integer
|The `Key` value passed to `thread.action()`.
|===

`Key` is an optional integer forwarded to the callback.  Use it to identify which thread completed when multiple threads share a callback.  Alternatively, declaring a closure with references to external variables is a viable data referencing strategy.

`Args` is a series of optional action-specific parameters, marshalled according to the action's parameter specification.

An exception is raised if:

* The first argument is not a valid Kōtuku object.
* The action/method name is not recognised.
* The asynchronous action fails to launch.  In this case, the callback is not executed.

In this example, `pictures` is an `array<object>` of pre-configured `Picture` objects that are processed in parallel by firing `Activate` actions in their own threads:

[source,tiri]
----
function picProcessed(ActionID, Pic, Error, Key)
   if Error != ERR_Okay then
      print('Failed to process picture: ' .. mSys.GetErrorMsg(Error))
   end
   glProcessed++
   if glProcessed >= glTotal then
      proc.signal()
   end
end

for v in values(pictures) do
   thread.action(v.pic, 'Activate', picProcessed, v.id)
end

proc = processing.new({ timeout = 5.0 })
proc.sleep()
----

[discrete]
===== Callback Execution

Callbacks for `thread.action()` and `thread.method()` are delivered via the message system.  They execute on the main thread during the event processing loop — this requires an active `processing.sleep()` call to dispatch.

After each callback returns, the next queued action for the same object is dispatched.  This means that a long-running callback will delay the start of subsequent queued actions.  If no callback was provided, the next queued action is dispatched immediately upon completion of the current one.  If thread preparation fails (before the thread starts), an exception is raised immediately and no callback occurs.

Any async actions submitted during callback execution — including actions targeting the same object — are appended to the tail of the object's queue and do not preempt previously queued actions.  This guarantees strict FIFO ordering and prevents starvation.

[[sec-thread-synchronisation]]
=== Thread Synchronisation

Thread synchronisation in Tiri relies on the signal mechanism defined in <<sec-signals>>.  The pattern is:

1. Create one or more objects to act as signal targets.
2. Create a processing object with `processing.new()` that monitors those targets.
3. Launch threads that signal the targets upon completion.
4. Call `proc.sleep()` to block until all signals fire or the timeout elapses.

[discrete]
==== Simple Synchronisation

When threads share a single callback, use `processing.signal()` to wake the main thread once all work is complete:

[source,tiri]
----
proc = processing.new({ timeout = 5.0 })
completed = 0
total = #tasks

for v in values(tasks) do
   thread.action(v.obj, 'Activate', function(ActionID, Obj, Error, Key)
      completed++
      if completed >= total then
         proc.signal()
      end
   end)
end

proc.sleep()
----

[discrete]
==== Multiple Signal Synchronisation

For finer-grained coordination, create dedicated signal objects and pass them to `processing.new()`.  The `sleep()` call returns only when _all_ objects have been signalled:

[source,tiri]
----
signal_a = obj.new('time', { })
signal_b = obj.new('time', { })

thread.script(obj.new('script', { statement=[[ msg('Task A') ]] }),
   function()
      signal_a.acSignal()
   end)

thread.script(obj.new('script', { statement=[[ msg('Task B') ]] }),
   function()
      signal_b.acSignal()
   end)

proc = processing.new({
   timeout = 5.0,
   signals = array<object> { signal_a, signal_b }
})

err = proc.sleep()
----

NOTE: When using a custom `signals` list, `proc.signal()` has no effect because the script object is not in the monitored set.  Signal the listed objects directly with `acSignal()`.

[[sec-thread-safety]]
=== Thread Safety

[discrete]
==== Guarantees

* All Tiri thread callbacks execute on the main thread.  No Tiri code ever runs concurrently with callback code.
* The barrier model prevents concurrent access to the same object from multiple threads.
* Multiple async actions on the same object are queued and dispatched in submission order, guaranteeing deterministic sequential execution per object.
* Garbage collection cannot reclaim objects that are actively participating in a thread.
* All threads are automatically joined when the owning script is destroyed.

[discrete]
==== Restrictions

* A threaded script (`thread.script()`) cannot access local variables from the calling scope.  Use `setKey()` / `arg()` or `obj.find()` to exchange data.
* An object targeted by `thread.action()` or `thread.method()` must not be freed while actions are executing or queued.  If an object is freed while actions remain in the queue, the remaining callbacks will receive an error code of `ERR_DoesNotExist` and a `nil` object reference.  The object reference must remain valid until all callbacks have fired.
* `processing.sleep()` must be called on the main thread.  Calling it from within a threaded script is not supported.

[discrete]
==== Notes

* An object targeted by a thread must not be freed before all queued callbacks have fired.  Releasing it in the final callback guarantees safe ordering.
* A `processing.new()` call without a `timeout` blocks indefinitely if a thread fails to signal.  An explicit timeout converts this scenario into a recoverable `ERR_TimeOut`.

=== See Also

* <<ch-processing-and-events>> — Processing loop, signals, and event handling.
* <<sec-signals>> — Signal mechanism used for thread synchronisation.
