// VERIFIED: 2026-02-10

[[ch-operators]]
== Operators

This chapter defines all operators in Tiri: their syntax, operand types, return values, precedence, associativity, and metamethod support.  Compound assignment is covered in <<sec-compound-assignment>>; the full precedence table appears in <<sec-operator-precedence>>.

[[sec-arithmetic-operators]]
=== Arithmetic Operators

Arithmetic operators accept numeric operands.  The runtime coerces strings that represent valid numbers to numbers automatically.  If an operand is neither numeric nor string-coercible and no metamethod is defined, the runtime raises an error.

[cols="2,3,3,3"]
|===
|Operator |Syntax |Effect |Metamethod
|Addition      |`a + b`  |Sum of `a` and `b`           |`__add`
|Subtraction   |`a - b`  |Difference of `a` and `b`    |`__sub`
|Multiplication|`a * b`  |Product of `a` and `b`       |`__mul`
|Division      |`a / b`  |Quotient of `a` and `b`      |`__div`
|Modulo        |`a % b`  |Remainder of `a / b`         |`__mod`
|Exponentiation|`a pass:[**] b` |`a` raised to the power `b`  |`__pow`
|Unary negation|`-a`     |Negation of `a`              |`__unm`
|===

Division always produces a floating-point result.  Dividing by zero yields `inf` or `-inf`; dividing zero by zero yields `nan`.

Exponentiation is right-associative: `2 pass:[**] 3 pass:[**] 2` evaluates as `2 pass:[**] (3 pass:[**] 2)` = `512`.  All other arithmetic operators are left-associative.

Integer arithmetic does not overflow.  Results that exceed the integer range are promoted to floating-point.

[source,tiri]
----
x = 10 + 3     -- 13
y = 10 / 3     -- 3.3333333333333
z = 10 % 3     -- 1
w = 2 ** 10    -- 1024
n = -42        -- unary negation
----

[[sec-comparison-operators]]
=== Comparison Operators

Comparison operators return a boolean value.  The equality operators (`is`, `!=`) accept operands of any type.  The ordering operators (`<`, `>`, `\<=`, `>=`) accept two numbers or two strings; comparing other types without a metamethod raises an error.

[cols="2,3,3,3"]
|===
|Operator |Syntax |Effect |Metamethod
|Equal             |`a is b`  |`true` if `a` equals `b`              |`__eq`
|Not equal         |`a != b`  |`true` if `a` does not equal `b`      |`__eq` (negated)
|Less than         |`a < b`   |`true` if `a` is less than `b`        |`__lt`
|Greater than      |`a > b`   |`true` if `a` is greater than `b`     |`__lt` (swapped)
|Less than or equal|`a \<= b` |`true` if `a` is at most `b`          |`__le`
|Greater or equal  |`a >= b`  |`true` if `a` is at least `b`         |`__le` (swapped)
|===

==== Equality Semantics

The `is` operator compares by value for numbers, strings, and booleans.  For tables, arrays, functions, and userdata, `is` compares by identity -- two distinct objects are never equal unless a `pass:[__]eq` metamethod overrides this.  The runtime invokes the `pass:[__]eq` metamethod only when both operands share the same metatable.

`nil is nil` evaluates to `true`.  Values of different types are never equal.

==== String Ordering

String comparison is lexicographic and byte-by-byte.  The comparison applies no locale-aware collation.

[source,tiri]
----
print(1 is 1)          -- true
print('abc' is 'abc')  -- true
print({} is {})        -- false (distinct tables)
print(1 < 2)           -- true
print('abc' < 'abd')   -- true
----

[[sec-logical-operators]]
=== Logical Operators

Logical operators use standard falsiness: only `nil` and `false` are falsey.  All other values -- including `0`, `""`, and empty tables -- are truthy.

[cols="2,3,5"]
|===
|Operator |Syntax |Effect
|`and` |`a and b` |Returns `a` if `a` is falsey; otherwise returns `b`
|`or`  |`a or b`  |Returns `a` if `a` is truthy; otherwise returns `b`
|`not` |`not a`   |Returns `true` if `a` is falsey; `false` otherwise
|===

Both `and` and `or` short-circuit: the operator does not evaluate the right operand if the left operand determines the result.  Both return the determining operand, not a boolean coercion.

No metamethods apply to logical operators.

[source,tiri]
----
x = nil and 'hello'    -- nil (short-circuit)
y = 'ok' or 'fallback' -- 'ok' (short-circuit)
z = not false           -- true
----

[[sec-bitwise-operators]]
=== Bitwise Operators

Bitwise operators operate on 32-bit integers using two's-complement representation.  The operator truncates non-integer operands to 32-bit integers before the operation.  The operator masks the shift count to the range 0-31.

[cols="2,3,5"]
|===
|Operator |Syntax |Effect
|AND        |`a & b`  |Bitwise AND
|OR         |`a \| b` |Bitwise OR
|XOR        |`a ^ b`  |Bitwise exclusive OR
|NOT        |`~a`     |Bitwise ones' complement
|Left shift |`a << b` |Shift `a` left by `b` bits
|Right shift|`a >> b` |Logical (unsigned) right shift of `a` by `b` bits
|===

Bitwise operators have no metamethods.

[source,tiri]
----
flags  = 0xFF & 0x0F    -- 0x0F (15)
mask   = 1 << 4         -- 16
bits   = ~0             -- -1 (all bits set)
value  = 0xA0 | 0x0B    -- 0xAB (171)
toggle = flags ^ mask   -- XOR toggle
----

[[sec-string-concatenation]]
=== String Concatenation

The `..` operator concatenates two values into a string.  The operator accepts both strings and numbers; it converts numbers to their string representation automatically.  Other types require a `pass:[__]concat` metamethod.

[source,ebnf]
----
concat_expr = expression ".." expression ;
----

Concatenation is right-associative: `a .. b .. c` evaluates as `a .. (b .. c)`.

If an operand is not a string or number and has no `pass:[__]concat` metamethod, the runtime raises `"attempt to concatenate a <type> value"`.

[source,tiri]
----
greeting = 'Hello, ' .. 'world!'    -- 'Hello, world!'
label = 'Item #' .. 42              -- 'Item #42'
----

[[sec-length-operator]]
=== Length Operator

The unary `#` operator returns the length of a value.

[cols="2,5"]
|===
|Operand type |Result
|String |Byte count
|Table  |Length of the sequential integer-keyed portion (highest integer index `n` where `t[n]` is not `nil`)
|Array  |Element count
|===

The `pass:[__]len` metamethod overrides the default behaviour.  If a non-string, non-table, non-array value lacks a `pass:[__]len` metamethod, the runtime raises an error.

[source,tiri]
----
print(#'hello')              -- 5
print(#{ 'a', 'b', 'c' })   -- 3
----

[[sec-compound-assignment]]
=== Compound Assignment

Compound assignment operators evaluate the right-hand side exactly once and apply the operation to the target.  If the RHS is a function call or vararg, only the first return value is used.  The target must be an assignable location: a local, upvalue, global, field, or index.  Applying compound assignment to a constant or a function call result is a compile-time error.

[cols="2,3,5"]
|===
|Operator |Syntax |Effect
|`+=`  |`x += expr`  |Addition assignment
|`-=`  |`x -= expr`  |Subtraction assignment
|`*=`  |`x *= expr`  |Multiplication assignment
|`/=`  |`x /= expr`  |Division assignment
|`%=`  |`x %= expr`  |Modulo assignment
|`..=` |`s ..= expr` |Concatenation assignment
|`?=`  |`x ?= expr`  |If-nil assignment: assigns only if the current value of `x` is `nil`
|`??=` |`x ??= expr` |If-empty assignment: assigns only if the current value of `x` is falsey under extended semantics (see <<sec-truthiness>>).  Incurs a performance penalty compared to `?=` due to the broader falsiness check.
|===

Compound assignment on an undeclared variable is an error.  The variable must exist before a compound operator can modify it.

Bitwise compound assignment (`&=`, `|=`, `^=`) does not exist.  Use `x = x & y` instead.

[source,tiri]
----
count += 1
name ..= ' Jr.'
config ?= load_defaults()    -- assigns only if config is nil
label ??= 'untitled'         -- assigns only if label is falsey
----

[[sec-postfix-increment]]
=== Postfix Increment

The `++` operator increments a numeric variable by 1.

[source,ebnf]
----
postfix_increment = assignable "++" ;
----

The target must be an assignable numeric location: a local, upvalue, global, field access, or indexed element.  Applying `++` to a constant or non-numeric value is an error.

[source,tiri]
----
count = 0
count++             -- count is now 1
t = { score = 10 }
t.score++           -- t.score is now 11
----

Use `++` only as a statement.  Its return value as an expression is unspecified.

NOTE: There is no `--` decrement operator.  The `--` character sequence begins a comment.  Use `x -= 1` instead.

[[sec-conditional-operators]]
=== Conditional Operators

Conditional operators use extended falsiness: `nil`, `false`, `0` (integer and floating-point zero), `""` (the empty string), and empty arrays (length 0) are all falsey.  All other values are truthy.  See <<sec-truthiness>> for the full definition.

==== If-Empty Binary Operator (`??`)

`result = a ?? b`

Returns `a` if `a` is truthy under extended falsiness; otherwise returns `b`.  The operator does not evaluate the right operand if `a` is truthy (short-circuit evaluation).

The `??` operator differs from `or` in that `or` uses standard falsiness (only `nil` and `false` are falsey), while `??` also treats `0` and `""` as falsey.

[source,tiri]
----
a = 0 or 'default'     -- 0 (zero is truthy under standard rules)
b = 0 ?? 'default'     -- 'default' (zero is falsey under extended rules)
c = '' ?? 'fallback'   -- 'fallback'
d = '' ?? 0 ?? 'final' -- 'final' (both '' and 0 are falsey)
----

The `??` operator also serves as a guard for control flow.  The RHS can be a `return`, `break`, `continue`, `raise`, or `check` statement:

[source,tiri]
----
value ?? raise('Value is empty')
user_input ?? return ERR_InvalidInput
----

Line breaks immediately following `??` are forbidden.  The RHS must appear on the same line as the operator.

==== If-Empty Postfix Operator (`??`)

`x??`

When `??` appears with no right-hand operand, it acts as a postfix presence-check operator.  Returns `false` if the value is falsey under extended semantics; `true` otherwise.

The postfix form binds tightly and evaluates before logical operators.

[source,tiri]
----
if comment?? then
   print('Comment exists')
end

if config.timeout?? then
   apply_timeout(config.timeout)
end
----

[[sec-ternary-operator]]
=== Ternary Operator

[source,ebnf]
----
ternary_expression = expression "?" expression ":>" expression ;
----

Evaluates `condition` using extended falsiness.  If truthy, evaluates and returns `true_expr`; if falsey, evaluates and returns `false_expr`.  Only the selected branch is evaluated (short-circuit).

The ternary is right-associative: `a ? b :> c ? d :> e` parses as `a ? b :> (c ? d :> e)`.

In expression lists, parentheses are required to avoid ambiguity:

[source,tiri]
----
local a, b = (cond ? x :> y), z
----

[source,tiri]
----
status = user ? 'logged in' :> 'guest'
max = a > b ? a :> b
label = count is 0 ? 'none' :> f'{count} items'
----

[[sec-safe-navigation]]
=== Safe Navigation

The safe navigation operators provide nil-safe access to fields, methods, and indices.  If the receiver is `nil`, the expression evaluates to `nil` without raising an error.

[cols="2,3,5"]
|===
|Operator |Syntax |Effect
|Safe field access |`obj?.field`    |Returns `nil` if `obj` is `nil`; otherwise returns `obj.field`
|Safe field call   |`obj?.field()`  |Returns `nil` if `obj` or `field` is `nil`; otherwise calls `obj.field()`
|Safe method call  |`obj?:method()` |Returns `nil` if `obj` is `nil`; otherwise calls `obj:method()`
|Safe index access |`obj?[key]`     |Returns `nil` if `obj` is `nil`; otherwise returns `obj[key]`
|===

Safe navigation checks for `nil` only.  Other falsey values (`false`, `0`, `""`) are treated as valid receivers and access proceeds.

The operators support chaining.  Each operator in the chain independently checks for `nil`:

[source,tiri]
----
city = user?.profile?.address?.city
----

If `user`, `profile`, or `address` is `nil` at any point, the entire expression evaluates to `nil`.

Safe navigation combines naturally with the `??` operator for default values:

[source,tiri]
----
name = user?.name ?? 'Guest'
----

[[sec-membership-operator]]
=== Membership Operator

[source,ebnf]
----
result = value in container
----

Returns `true` if `container` contains `value`; `false` otherwise.  The expression `a in b` is equivalent to `b:contains(a)`.

The `in` operator requires the right-hand operand to provide a `:contains()` method.  The built-in types that define this method are ranges and arrays.  Any user-defined type with a `:contains()` method also supports `in`.  If the right-hand operand lacks a `:contains()` method, the runtime raises an error.

[source,tiri]
----
if x in {0..10} then
   print('x is in range')
end

arr = { 'red', 'green', 'blue' }
if 'green' in arr then
   print('found')
end
----

NOTE: The `in` keyword also appears in `for` loops (`for k, v in pairs(t) do`).  The membership operator is distinguished by appearing outside of a `for` header.

[[sec-pipe-operator]]
=== Pipe Operator

The pipe operator (`|>`) passes the result of the left-hand expression as the first argument(s) to the right-hand function call.

[source,ebnf]
----
pipe_expr = expression "|>" function_call ;
----

The right-hand side must be a function call; `x |> 5` is a syntax error.  When the LHS is a range literal, the RHS accepts a bare function reference without parentheses (see <<sec-pipe-iteration,Pipe Iteration with Ranges>>).

[source,tiri]
----
result = 'hello' |> string.upper()
safe = tonumber(input) |> clamp(0, 100)
----

==== Multi-Value Forwarding

When the LHS returns multiple values, the pipe forwards all values as arguments to the RHS:

[%unbreakable]
[source,tiri]
----
function get_bounds()
   return 10, 20
end

result = get_bounds() |> math.max()  -- math.max(10, 20) = 20
----

==== Result Limiting

The syntax `|N>` limits the number of values forwarded from the LHS:

[source,tiri]
----
function get_many()
   return 1, 2, 3, 4, 5
end

result = get_many() |2> math.max()  -- math.max(1, 2) = 2
----

==== Chaining

Pipes chain for multi-step transformations:

[source,tiri]
----
result = 3 |> double() |> square()  -- square(double(3))
----

[[sec-pipe-iteration]]
==== Pipe Iteration with Ranges

When the LHS is a range literal, the pipe iterates and calls the RHS function for each value in the range:

[source,tiri]
----
{1..5} |> print         -- prints 1, 2, 3, 4
{1...5} |> print        -- prints 1, 2, 3, 4, 5
----

Return `false` from the callback to terminate iteration early:

[source,tiri]
----
{1..1000} |> i => do
   if found_target(i) then
      print('Found at', i)
      return false
   end
end
----

Pipe iteration applies only to range literals.  For ranges stored in variables, use the `:each()` method: `r:each(func)`.

[[sec-operator-precedence]]
=== Operator Precedence

The following table lists all operators from highest to lowest precedence.  Operators on the same row share the same precedence level.

[cols="1,4,2"]
|===
|Level |Operators |Associativity
|10 |`pass:[**]`                                                |Right
|8  |`-` (unary), `not`, `#`, `~` (unary)               |Unary (right)
|7  |`*`, `/`, `%`                                       |Left
|6  |`+`, `-`                                            |Left
|5  |`..`, `<<`, `>>`                                    |`..` right; shifts left
|4  |`&`                                                 |Left
|3  |`^`, `is`, `!=`, `<`, `>`, `\<=`, `>=`, `in` |Left
|2  |`\|`, `and`, `\|>`                                  |Left
|1  |`or`, `??`, `? :>`                                  |Left (`? :>` right)
|===

Postfix operators (`++`, `??` postfix) bind tighter than all binary operators and evaluate immediately after suffix chains (field access, indexing, calls).

Parentheses override precedence: `(a + b) * c` forces addition before multiplication.

See <<appendix-operator-precedence>> for a quick-reference card.

==== Precedence Examples

[source,tiri]
----
2 + 3 * 4           -- 14 (multiplication before addition)
2 ** 3 ** 2         -- 512 (right-associative: 2 ** (3 ** 2))
'a' .. 'b' .. 'c'   -- 'abc' (right-associative)
x > 0 and x < 10    -- comparison before logical
a & 0xFF | 0x100    -- AND before OR (C-style)
----
