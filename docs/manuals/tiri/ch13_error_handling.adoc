// VERIFIED: 2026-02-12

[[ch-error-handling]]
== Error Handling

Tiri provides structured exception handling through the `try-except` statement.  Exceptions unify two distinct error sources into a single mechanism: internal errors generated by the Tiri runtime (nil access, type mismatches, `error()` calls) and external errors returned as error codes by Kōtuku API calls.  All errors propagate as exceptions that can be caught, filtered, and re-thrown.

There is no `finally` block.  Cleanup is handled by `defer` statements and `<close>` variables within the `try` block (see <<ch-resource-management>>).

[[sec-the-exception-model]]
=== The Exception Model

==== Error Sources

Exceptions originate from one of the following:

[cols="1,3"]
|===
|Source |Description

|Runtime errors
|Nil indexing, type mismatches, stack overflow, and other violations detected by the Tiri engine.  These carry the error code `ERR_Exception`.

|`error()`
|Raises an exception with a custom message and the error code `ERR_Exception`.

|`raise`
|Raises an exception with a specific `ERR` code and an optional message.

|`check`
|Evaluates an `ERR` code and raises an exception if the code is at or above the exception threshold.

|`assert()`
|Raises an exception if the condition is false.

|API calls
|Kōtuku functions and object interactions automatically have `check` rules applied when called inside a `try` block's immediate scope.
|===

==== The Exception Table

When an `except` clause declares a variable, the runtime constructs a table describing the caught exception.

[cols="1,1,3"]
|===
|Field |Type |Description

|`code`
|integer
|The `ERR` code.  Defaults to `ERR_Exception` if no code is associated with a runtime or `error()` exception.

|`message`
|string
|Human-readable error description.

|`line`
|integer
|Source line number where the error occurred.

|`trace`
|array
|Array of stack frame tables.  Only present when `try<trace>` is used; `nil` otherwise.

|`stackTrace`
|string
|Pre-formatted traceback string.  Only present when `try<trace>` is used; `nil` otherwise.
|===

Omitting the variable in the `except` clause prevents construction of the table.

==== Error Codes and the Exception Threshold

Error codes are 16-bit integer constants following the `ERR_` naming convention (e.g. `ERR_Okay`, `ERR_Failed`, `ERR_Args`).  A threshold value divides codes into two categories:

Safe codes (below threshold):: `Okay`, `False`, `LimitedSuccess`, `Cancelled`, `NothingDone`, `Continue`, `Skip`, `Retry`, `DirEmpty`.  These do not trigger exceptions via `check` or API call interception.

Exception codes (at or above threshold):: All other error codes.  These are treated as real errors by the `check` statement and by API call interception within `try` blocks.

The `raise` statement bypasses this threshold and raises an exception for any error code, including safe codes.

==== Unhandled Exceptions

An exception with no enclosing `try` block terminates the script with an error message.  The error code and message are reported to the host application through the Script object's `Error` field.

[[sec-try-except-statements]]
=== Try-Except Statements

[discrete]
==== Syntax

A `try` statement begins with the `try` keyword (optionally followed by `<trace>`), contains a body block, zero or more `except` clauses, an optional `success` block, and terminates with `end`.

[source,tiri]
----
try [<trace>]
   body
except [e] [when Code1, Code2, ...]
   handler
except [e]
   catch-all handler
success
   success body
end
----

Each element after the body is optional.  The `try` keyword and `end` are required.  If an exception occurs, execution transfers to the first matching `except` handler.  If no exception occurs, the optional `success` block executes.

[discrete]
==== Basic Form

[source,tiri]
----
try
   risky_operation()
except e
   print('Error: ' .. e.message)
end
----

The variable name after `except` is optional.  Omitting it discards the exception details:

[source,tiri]
----
try
   risky_operation()
except
   print('An error occurred')
end
----

[discrete]
==== Silent Form

A `try` block with no `except` clauses silently discards all exceptions:

[source,tiri]
----
try
   potentially_failing_operation()
end
----

[discrete]
==== Multiple Handlers

Multiple `except` clauses provide specialised handling for different error conditions.  Handlers are evaluated in declaration order; the first match handles the exception.

[source,tiri]
----
try
   raise ERR_Args
except e when ERR_Args
   print('Invalid arguments')
except e when ERR_Read, ERR_Write
   print('I/O error')
except e
   print('Unexpected: ' .. e.message)
end
----

[discrete]
==== Ordering Rules

Filtered handlers (those with `when` clauses) must appear before the catch-all handler.  Only one catch-all handler (an `except` without `when`) is permitted, and it must be the last clause.  Violating either rule produces a parse error.

[source,tiri]
----
-- Valid: filters before catch-all
try
   raise ERR_Failed
except e when ERR_Args
   -- filtered
except e
   -- catch-all (must be last)
end

-- Parse error: catch-all before filter
-- try ... except e ... except e when ERR_Failed ... end
----

[discrete]
==== Re-throwing Exceptions

Call `error()` within an `except` block, passing the exception table, to propagate the exception to an outer handler:

[source,tiri]
----
try
   try
      error('Original error')
   except e
      msg(e.message)
      error(e)   -- re-throw
   end
except e
   print('Caught: ' .. e.message)
end
----

[discrete]
==== API Call Interception

Inside a `try` block's immediate scope, Kōtuku API calls that return error codes at or above the exception threshold will automatically raise exceptions.  This interception applies only to direct calls; calls made inside nested functions are not intercepted.

[source,tiri]
----
try
   mSys.AllocMemory(-1024, MEM_DATA)  -- intercepted: raises exception
except e when ERR_Args
   print(e.message)
end

try
   function internal()
      mSys.AllocMemory(-1024, MEM_DATA)
   end
   internal()  -- NOT intercepted: nested function call
except e
   -- this handler is never reached
end
----

[discrete]
==== Control Flow

`return`, `break`, and `continue` work correctly within `try` blocks, `except` blocks, and `success` blocks.  The exception frame is properly unwound before the control transfer occurs.

[source,tiri]
----
function find_value()
   try
      result = search()
      return result
   except e
      return nil
   end
end

for i in {0..10} do
   try
      if i is 5 then break end
      if i % 2 is 0 then continue end
      process(i)
   except e
      -- handle error and continue loop
   end
end
----

[discrete]
==== Stack Traces

By default, stack trace information is not captured.  The `<trace>` attribute enables stack trace capture when an exception occurs in the associated `try` block:

[source,tiri]
----
try<trace>
   risky_operation()
except e
   print(e.stackTrace)

   for i, frame in e.trace do
      print(f"{frame.source}:{frame.line}: in {frame.func ?? 'anonymous'}")
   end
end
----

The `trace` field contains an array of frame tables:

[cols="1,1,3"]
|===
|Field |Type |Description

|`source`
|string
|Source file name.  May be `nil`.

|`line`
|integer
|Line number.  `0` if unknown.

|`func`
|string
|Function name.  `nil` for anonymous functions.
|===

The `stackTrace` field provides a pre-formatted string in the standard `"stack traceback:\n\t..."` format.

Each `try<trace>` block captures traces independently.  A nested `try` without `<trace>` does not capture trace information, even if an outer `try<trace>` is active:

[source,tiri]
----
try<trace>
   try
      error('Inner error')
   except e
      assert(e.trace is nil)   -- no trace: inner try has no <trace>
      error(e)                 -- re-throw to outer
   end
except e
   assert(e.trace)             -- trace captured by outer try<trace>
end
----

[[sec-filtered-exceptions]]
=== Filtered Exceptions

The `when` clause restricts an `except` handler to specific `ERR` codes.  Each `when` clause accepts up to 4 comma-separated error code expressions.  The codes must be compile-time numeric constants.

[source,tiri]
----
try
   raise ERR_Search
except e when ERR_Args, ERR_Failed, ERR_Read, ERR_Search
   print('Matched: ' .. e.code)
except e
   print('Unmatched: ' .. e.code)
end
----

==== Matching Rules

Handlers are checked in declaration order.  The first handler whose filter contains the exception's error code is selected.  If no filter matches and no catch-all handler exists, the exception propagates to the next enclosing `try` block.

Only error codes at or above the exception threshold match specific filters.  String errors (`error()` and runtime errors) always carry `ERR_Exception`.  A filter for `ERR_Exception` or a catch-all handler catches these exceptions.

==== Custom Error Codes

Error codes are integer constants.  Custom codes are supported and can be thrown with `raise` and caught with `when` filters.  Use codes in the range 8000 to 10000 for client code to avoid conflicts with Kōtuku system codes.

[source,tiri]
----
MY_VALIDATION_ERR <const> = 8001
MY_NETWORK_ERR    <const> = 8002

try
   raise MY_VALIDATION_ERR, 'Invalid input'
except e when MY_VALIDATION_ERR
   print('Validation failed: ' .. e.message)
except e when MY_NETWORK_ERR
   print('Network error')
end
----

[[sec-the-success-block]]
=== The Success Block

The `success` block executes only when no exception occurred in the `try` body.  It runs after all `defer` statements and `<close>` handlers in the `try` scope have completed.

[source,tiri]
----
try
   result = compute()
except e
   print('Failed: ' .. e.message)
success
   print('Result: ' .. result)
end
----

[discrete]
==== Execution Rules

The `success` block does not execute when:

* An exception occurred in the `try` body.
* A `return`, `break`, or `continue` in the `try` body transferred control before reaching the end of the block.

The `success` block does execute when:

* The `try` body completes without exception and without early control transfer.

[discrete]
==== Use without Except Clauses

A `success` block can be used with a silent `try` (no `except` clauses):

[source,tiri]
----
try
   risky_operation()
success
   print('Operation succeeded')
end
----

If an exception occurs, it is silently discarded and the `success` block does not execute.

[discrete]
==== Control Flow in Success

`return`, `break`, and `continue` work correctly within a `success` block:

[source,tiri]
----
for i in {0..10} do
   try
      process(i)
   except e
      -- handle error
   success
      if i is 3 then break end
   end
end
----

[discrete]
==== As an Inverted Assertion

A `success` block combined with `error()` asserts that the `try` body must raise an exception:

[source,tiri]
----
try
   exec('invalid code here %%% $$$')
success
   error('Expected a parse error')
end
----

[[sec-raising-exceptions]]
=== Raising Exceptions

==== error()

[.api]`error(Message, [Level])`

Raises an exception with the error code `ERR_Exception`.  `Message` is a string or exception table.  `Level` (default 1) controls the reported source location: level 1 reports the call site, level 2 reports the caller of the calling function, and so on.  Setting `Level` to 0 suppresses source location information in the error message.

Passing an exception table to `error()` re-throws it to the next enclosing handler:

[source,tiri]
----
try
   operation()
except e
   error(e)   -- re-throw
end
----

==== assert()

[.api]`assert(Condition, [Message])`

Raises an exception if `Condition` is false or nil.  `Message` is an optional error description; if omitted, a default message is used.  The `Message` expression is not evaluated when `Condition` is true, avoiding overhead from expensive string operations.

[source,tiri]
----
assert(x > 0, 'x must be positive')
assert(file, f'Failed to open {path}')
----

TIP: Give preference to using `assert()` over the alternative pattern `if <condition> then error() end`

==== raise

[.api]`raise Code, [Message]`

Raises an exception with the specified `ERR` code.  Unlike `check`, all error codes trigger an exception, including safe codes.  The error code is also propagated to the Script object's `Error` field for reporting back to C/C++ client code.

`Code` is an integer expression.  `Message` is an optional string; if omitted, the default description for the error code is used.

[source,tiri]
----
raise ERR_Failed
raise ERR_Args, 'Expected a positive number'

err_code = ERR_Failed
raise err_code   -- variables are accepted
----

[[sec-the-check-statement]]
=== The Check Statement

[.api]`[results =] check Expression`

Evaluates `Expression` and, if the result is an error code at or above the exception threshold, raises an exception.  Safe error codes pass through without raising.  Return values from the checked expression are forwarded without modification, enabling inline use in assignments.

[source,tiri]
----
check ERR_Failed             -- raises exception
check ERR_Okay               -- no effect (safe code)

-- raises on error; passes results through
err, bytes = check file.acRead(file, buffer)
----

[discrete]
==== Safe Codes

The following `ERR` codes do not raise an exception when passed to `check`: `Okay`, `False`, `LimitedSuccess`, `Cancelled`, `NothingDone`, `Continue`, `Skip`, `Retry`, `DirEmpty`.

[discrete]
==== Comparison with raise

`check` is a conditional assertion on error codes.  `raise` is an unconditional exception.

[cols="1,1,1"]
|===
|Feature |`check` |`raise`

|Safe codes
|No exception
|Exception raised

|Return value forwarding
|Yes
|No (control transfers immediately)

|Typical use
|Wrapping API calls
|Explicit error signalling
|===

[[sec-nesting-and-best-practices]]
=== Nesting and Best Practices

[discrete]
==== Nesting

`try` blocks nest to arbitrary depth.  Each level catches its own exceptions independently.  An exception not matched by any handler in the current `try` block propagates to the next enclosing `try` block.

[source,tiri]
----
try
   try
      try
         error('Deep error')
      except e
         -- caught here
      end
   except e
      -- not reached
   end
except e
   -- not reached
end
----

[discrete]
==== Conditional Raising

The `??` operator can be used as a guard to conditionally raise exceptions.  The right-hand side executes only when the left-hand side is falsey (`nil`, `false`, `0`, or `""`):

[source,tiri]
----
result ?? raise ERR_Failed
----

[discrete]
==== Interaction with defer and <close>

When an exception is caught, `<close>` handlers for variables declared in the `try` scope are called in LIFO order (last declared, first closed).  Each `<close>` handler receives the error as its second argument.  `defer` blocks in the `try` scope execute after the exception frame is unwound but before the `success` block (see <<ch-resource-management>>).

If a `<close>` handler raises an error, it replaces the original exception.  All remaining `<close>` handlers still execute.

[source,tiri]
----
mt = {
   __close = function(self, err)
      print('Closing resource, error: ' .. tostring(err))
   end
}

try
   local resource <close> = setmetatable({}, mt)
   error('Something failed')
except e
   print('Caught: ' .. e.message)
end
-- Output:
-- Closing resource, error: ...Something failed...
-- Caught: Something failed
----

[discrete]
==== Best Practices

Use `check` for API calls:: Wrap Kōtuku API calls with `check` to convert error codes into exceptions.  This avoids manual error code inspection.

Prefer filtered handlers:: Use `when` clauses to handle expected error conditions specifically.  Place a catch-all handler last to log or re-throw unexpected errors.

Keep try blocks narrow:: Place only the code that can fail inside the `try` body.  Post-success logic belongs in the `success` block, not after the `end`.

Use `success` for post-completion logic:: The `success` block guarantees that the `try` body completed without exception.  Placing logic after `end` does not provide this guarantee, as the `except` handler also falls through to the code after `end`.

Use `<trace>` sparingly:: Stack trace capture adds overhead.  Reserve `try<trace>` for debugging and diagnostic contexts.

Avoid silent try for critical code:: The silent form (`try ... end`) discards exceptions without logging or handling.  Use it only when failure is genuinely irrelevant.

[[sec-performance]]
=== Performance

[discrete]
==== Entry and Exit Costs

Entering a `try` block is relatively cheap, with a frame being pushed onto the exception stack via a function call.  Exiting a `try` block on the normal (no-exception) path is almost free.  Both operations are constant-time and do not allocate memory.

Tiri's exception model is considerably more performant than the original Lua `pcall`-based approach, which requires creating a closure and a protected call frame.  It is for this reason that `pcall()` and `xpcall()` are unavailable.

[discrete]
==== Exception Path

When an exception occurs, the runtime searches the handler list, unwinds the stack, calls any `<close>` handlers, optionally builds the exception table, and transfers control.  This path is inherently more expensive than the normal path, but exceptions are expected to be infrequent.  Omitting the exception variable from an `except` clause avoids the cost of constructing the exception table.

TIP: Prefer manual error handling techniques in areas that handle non-catastrophic errors (e.g. network communications).

[discrete]
==== Stack Trace Capture

The `<trace>` attribute adds overhead only when an exception occurs.  On the normal path, `try<trace>` and `try` have identical cost.  When an exception is raised, `try<trace>` captures the call stack by walking stack frames and allocating a trace array, which scales with call depth.  Reserve `<trace>` for diagnostic and debugging contexts where the additional cost is acceptable.
