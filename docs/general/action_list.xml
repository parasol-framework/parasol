<?xml version="1.0"?>

<action private>
  <name>AccessObject</>
  <category>Locking</>
  <short>Used for intercepting exclusive locks.</>
  <support>
    <p>While the object kernel's <function mod="kernel">AccessObject</> function works on all objects regardless of their support for this action, you may want to be informed when an exclusive lock is about to be granted.  By supporting this action, you can take a more active role in your object's locking behaviour.</p>
    <p>When a program calls AccessObject(), a check will be made to see if your class supports the AccessObject action.  If it does, a call will be made to your support routine.  If you do not have a support routine, AccessObject() will assume that you do not wish to be informed, and will proceed to grant the exclusive lock.</p>
    <p>If you return an error code other than ERR_Okay, AccessObject() will abort and return that error code to the program that made the exclusive call.</p>
  </support>
</action>

<action private>
  <name>ActionNotify</>
  <category>Internal</>
  <short>Used for supporting subscriptions originating from the SubscribeAction() function.</>
  <args>
    <arg type="ACTIONID" name="Action">The ID of the action that was called.</>
    <arg type="OBJECTID" name="Object">The ID of the object that received the action call.</>
    <arg type="APTR" name="Args">If arguments were specified, this pointer will refer to them.</>
    <arg type="LONG" name="Size">Indicates the size of the Args structure.</>
    <arg type="ERROR" name="Error">Indicates the error code that was returned from the action support routine.</>
  </args>
  <support>
    <p>This action will need to be supported by your class if you have called the <function mod="kernel">SubscribeAction</> function to monitor the action/s of a foreign object.  By supporting ActionNotify, you will be able to receive action notification messages originating from the subscription service.</p>
    <p>The ActionNotify action is called after or during the execution of a monitored object's support routine.  You will receive information telling you the ID of the object and the action that was called, the arguments that were passed and an error code that indicates whether or not the call was successful.  There are no restrictions on how you should respond to an ActionNotify call.  The error code that you return from this action will be ignored.</p>
    <p>You can terminate an action subscription by calling the <function mod="kernel">UnsubscribeAction</> function.</p>
  </support>
</action>

<action>
  <name>Activate</>
  <category>General</>
  <synopsis>ERROR acActivate(*Object)</>
  <short>Performs the native action of an object.</>
  <description>
    <p>Calling this action causes an object to perform its "native activity". The activity in question can be extremely varied, as the Activate action is intentionally ambiguous.  Here are a few examples of what some existing classes do when their objects are activated:</p>
    <list type="unlisted">
      <li value="Sound">Plays audio data.</>
      <li value="Script">Executes  object script files.</>
      <li value="JoyPort">Reads the current status of the joyport device.</>
    </>
    <p>The only way to  know what may result from calling the Activate action is to check the documentation for the class that the object belongs to.</p>
    <p>Some objects will continue to perform their native activity after they return back to you - for example, activating a Sound object will cause it to  play audio in the background while you continue processing. If for some reason you wish to cancel an Activate action, you can attempt to stop  it with a <action>Deactivate</> call.</p>
  </description>
  <support>
    <p>The Activate action is the most abstract of those that are available, which means that you are free to implement a support routine that does whatever you like (so long as it is in the spirit of the object's context).  For example, a Music class would play audio, a Command class would execute a command and an Effect class would start drawing graphics.</p>
    <p>If your object performs an action that continues in the background after returning to the program, you may also want to support the Deactivate action to provide a cancellation service.</p>
  </support>
</action>

<action>
  <name>Clear</>
  <category>I/O</>
  <synopsis>ERROR acClear(*Object)</>
  <short>Clears an object's data.</>
  <description>
    <p>This action will clear an object of all its data. While it is typically used to clear graphics, it can be used to erase any type of information.  Here some typical examples:</p>
    <types type="Class">
      <type name="File">Clears file data by reducing  the file length down to 0.</>
      <type name="Text">Deletes all lines of text.</>
      <type name="Bitmap">Clears the bitmap of graphics data.</>
    </>
    <p>The state of the object will normally remain intact - so object settings will not be affected by a clear.</p>
  </description>
  <support>
    <p>Clearing is an interesting action as it can have a very different meaning for each object.  Clearing a graphic for example will often leave a black area on the screen, while clearing a File might delete it from the file system. Depending on your object type, you will have to make the most logical decision as to how you might support this action.</p>
  </support>
</action>

<action>
  <name>Clipboard</>
  <category>I/O</>
  <synopsis>ERROR acClipboard(*Object, OBJECTID Clipboard, LONG Mode)</>
  <short>Used to copy and paste information to and from clipboard objects.</>
  <args>
    <arg type="OBJECTID" name="Clipboard">Must refer to a valid clipboard object.</>
    <arg type="LONG" name="Mode">The mode that you want to use in shifting data between the target object and the clipboard system.</>
  </args>
  <description>
    <p>The Clipboard action is used on objects for the purpose of shifting data between them and the standard clipboard system.  Generally, you should only use this action when the user has done something that requires it to be called, for instance, holding the CTRL+C keys to make a copy operation.</p>
    <p>You will need to supply a reference to a valid clipboard object and indicate the operation mode when using this action.  The easiest way to find a valid clipboard object is to search the system for the 'SystemClipboard' object, which is automatically created when a UI object is created.  If this object does not exist, you have the option of creating a new clipboard object from scratch.  Please refer to the clipboard documentation for information on how the clipboard class works.</p>
    <p>Three modes are currently available for performing clip operations, as illustrated in the following table:</p>
    <types type="Mode">
      <type name="CLIP_CUT">Cut (copy and delete) the currently selected data from the target object and copy it into the clipboard.</>
      <type name="CLIP_COPY">Copy the currently selected data from the target object into the clipboard.</>
      <type name="CLIP_PASTE">Paste the most recent data from the clipboard into the target object.</>
    </>
    <p>The specifics of how a target object interacts with a clipboard is down to the developer of the object's class.  If you need more information on how an object might interface with the clipboard system, check its class documentation.</p>
  </description>
  <support>
    <p>If you want to provide support for the system-wide clipboard service then you will need to write code for the Clipboard action.  This action is closely related to the Clipboard class, as you will be passed a clipboard object in the ClipboardID argument and will be expected to interact with that object. The Mode reflects the type of action that you should perform.  Available Mode types are listed in the following table:</p>
    <types type="Mode">
      <type name="CLIP_CUT">Cut (copy and delete) the currently selected data from the target object and copy it into the clipboard.</>
      <type name="CLIP_COPY">Copy the currently selected data from the target object into the clipboard.</>
      <type name="CLIP_PASTE">Paste the most recent data from the clipboard into the target object.</>
    </>
    <p>Copy and cut operations are identical apart from the fact that cutting data will require you to delete the information after pasting it into the clipboard. To paste data into a clipboard, you can use any of the mechanisms supported by the Clipboard class, such as the DataChannel action.  Please refer to the documentation for the Clipboard class for more information.</p>
    <p>To paste data from a clipboard into one of your objects, you need to scan the clipboard object's data store and load the data off the file system in order to retrieve it.  You may be 'selective' in the data that you retrieve from the clipboard, for instance, if the next clip is an image and your class only supports text data, you can ignore the image and extract the text data instead.  The documentation for the Clipboard class has more information on how to scan the data store.</p>
  </support>
</action>

<action>
  <name>ClosingTag</>
  <category>General</>
  <synopsis>ERROR acClosingTag(*Object)</>
  <short>The ClosingTag action is reserved for the use of  script-based classes.</>
  <description>
    <p>The ClosingTag action complements the <action>OpeningTag</> action.  Although specifically designed for classes that process object scripts, there can be occasions where you may need to call it if you want to emulate the execution process that scripting normally follows.  For more information, refer to the <action>OpeningTag</> action.</p>
  </description>
  <support>
    <p>If you are developing a class that is designed for use in object scripts, or potentially could be used in an object script, then you should support the ClosingTag action.</p>
    <p>The ClosingTag action is called just after a script interpreter has created an object, set its fields, initialised it and attached children to that object.  By calling the ClosingTag action the process is basically telling you that "You've been completely initialised, so if you need to do something important, do it now".</p>
    <p>You can use this as an opportunity to <action>Activate</> the object's native functionality and if necessary, you can destroy the object if it serves no further purpose after being activated.  This type of behaviour is particularly common for members of the Command category.  On the other hand, classes in the GUI category will typically draw themselves to the display after receiving a ClosingTag action and remain in memory until they are destroyed.</p>
  </support>
</action>

<action>
  <name>CopyData</>
  <category>I/O</>
  <synopsis>ERROR acActivate(*Object, OBJECTID Dest)</>
  <short>Copies one object's data to another.</>
  <args>
    <arg type="OBJECTID" name="Dest">The unique ID of the destination object.</>
  </args>
  <description>
    <p>The CopyData action is used to copy data between objects.  To execute the copy process, call the CopyData action on the source object, and set the Dest to  the object that you are copying the data to.  If the  source object does not recognise the destination object type, it will make calls to the <action>Write</> action to copy the data across.  If it does understand the destination object type, it may make an 'intelligent' copy.  For instance, if you copy the data from one <class>Bitmap</> to another Bitmap, the image data of the source will be drawn to the destination, thus avoiding a raw data copy.</p>
    <p>Check the documentation for the source object's class if you need to be sure as to whether or not it features special functionality for the CopyData action.</p>
  </description>
  <support>
    <p>The CopyData action is provided so that data in one object can be copied across to another.  This may or may not involve data conversion.  For example, copying data between files is a very straight forward process.  However, copying data between two Bitmap's would be more complicated, because we need to consider clipping and type conversion issues. Copying between different classes is also permitted, for example copying a Picture to a File could output the image as raw data.</p>
    <p>If you wish to write your routine so that it only supports a limited number of object types, return ERR_NoSupport when you detect a destination object that does not belong to a supported class.  If you wish to support all object types, use the <action>Write</> action to feed data to the destination object.</p>
  </support>
</action>

<action>
  <name>DataChannel</>
  <category>I/O</>
  <synopsis>ERROR acDataChannel(*Object, OBJECTID Object, LONG Datatype, APTR Buffer, LONG Size)</>
  <synopsis>ERROR acDataXML(*Object, STRING Buffer)</>
  <synopsis>ERROR acDataContent(*Object, STRING Buffer)</>
  <synopsis>ERROR acDataText(*Object, STRING Buffer)</>
  <short>Provides a mechanism for sending formatted data to objects.</>
  <args>
    <arg type="OBJECTID" name="Object">Must refer to the unique ID of the object that you represent.  If you do not represent an object, set this argument to the current task ID.</>
    <arg type="LONG" name="Datatype">The type of data that you are sending.  Options include DATA_TEXT, DATA_KEYPRESS, DATA_RAW, DATA_JOYPORT and DATA_XML.</>
    <arg type="APTR" name="Buffer">The data that you are sending to the target object.</>
    <arg type="LONG" name="Size">The size of the buffered data must be specified here if making the DataChannel call via ActionMsg().  Otherwise set this parameter to zero.</>
  </args>
  <description>
    <p>The DataChannel action provides a simple  mechanism for sending "described data"  to objects.  Currently it can send text, keypresses, raw data, joyport instructions and XML information.  Sending information to an object is as simple as setting up the DataChannel argument structure and calling the DataChannel action on the target object.  The target object  will analyse the information to see if it can support it, and if so, will process the data according to what is appropriate for the object's class.</p>
    <p>The most commonly supported data type is DATA_TEXT, which is used for sending  text information.  Support for raw data, keyboard instructions, joyport instructions and XML data is included.  How you set up the argument structure is dependent on what type of data you are sending to the target object, so we will briefly explain what each data type is for and how the argument structure should be set up for them.</p>

<indent>
    <h3>DATA_TEXT</h3>
    <p>Use the text data type when you are sending printable text to an object.  This is one of the easier types to set-up - simply set the Buffer argument to point to the text, set the Size to the total length of the buffer, and the TotalEntries argument to 1.  The text data that is being sent to the object should not include any zero byte values.</p>

    <h3>DATA_CONTENT</>
    <p>This is a special data type used by the <class>Document</> class to pass XML content to embedded objects.  Although this duplicates the DATA_XML type, it may be desirable to parse such data differently to DATA_XML due to nature of the content.</p>

   <h3>DATA_FILE</>
   <p>This format is used to declare file paths that contain data intended to be transferred between objects.  It is frequently used to speed up data transfers where loading file data into a buffer and passing it through the data channel system would be cumbersome.</p>

    <h3>DATA_JOYPORT</h3>
    <p>The joyport data type is used to send simulated joyport activity to objects.  For instance, you can use it to send  mouse activity to the SystemMouse object to forcibly move the mouse pointer around the display.  The <class>Joyport</> class also uses this data type to send  information to objects that want to receive raw joyport data.</p>
    <p>To send joyport data, you need to create an array using the dcJoyEntry structure and write a value to every field in the array.  The dcJoyEntry structure is defined as follows:</p>

<fields struct="dcJoyEntry">
<fld type="DOUBLE" name="DeltaX">The amount of units moved horizontally by the virtual joyport device.</>
<fld type="DOUBLE" name="DeltaY">The amount of units moved vertically by the virtual joyport device.</>
<fld type="DOUBLE" name="DeltaZ">The amount of units moved on the Z axis by the virtual joyport device.</>
<fld type="DOUBLE" name="AbsX">The absolute X coordinate of the pointing device.</>
<fld type="DOUBLE" name="AbsY">The absolute Y coordinate of the pointing device.</>
<fld type="DOUBLE" name="AbsZ">The absolute Z coordinate of the pointing device.</>
<fld type="LONG" name="ButtonPressFlags">Indicates currently held buttons.  A maximum of 32 buttons are supported, with (from right) bit 1 supporting the left mouse button, bit 2 the right mouse button and bit 3 the middle mouse button.  Refer to the "input/joyport.h" include file for a list of pre-defined button definitions.</>
<fld type="LONG" name="ButtonReleaseFlags">Button flags previously set in ButtonPressFlags and now released.  If you are not going to send a follow-up message for earlier ButtonPressFlags settings, set the ButtonReleaseFlags to the same flag values that you set for the ButtonPressFlags field.</>
</>

    <p>If the DeltaX, DeltaY and DeltaZ fields are set to zero, then the AbsX, AbsY and AbsZ fields can be set to the absolute coordinates  of the pointing device represented by the virtual joyport.  Otherwise, the absolute coordinate values should all be set to a value of -1.</p>

    <h3>DATA_KEYPRESS</h3>
    <p>The keypress data type is used to send simulated key-presses to  objects.  It can  be useful for sending key-presses to the SystemKeyboard object, to make it look as if the user is typing at the keyboard.  To send keypress information, you need to create an array using the dcKeyEntry structure and specify the keypress values for each array entry.  The dcKeyEntry structure is defined as follows:</p>

<fields struct="dcKeyEntry">
<fld type="WORD" name="Flags">Key Qualifiers.</>
<fld type="WORD" name="Value">ASCII Key Value.</>
</>

    <p>Setting the correct qualifiers in the Flags field  is vital - each keypress must be represented by a KQ_PRESSED flag the first time that a given key  is pressed and each keypress must be followed up with a  KQ_RELEASED flag to indicate that it is no longer being held.  Repeated key-presses should be qualified with KQ_PRESSED|KQ_REPEATED.  If necessary, a combination of KQ_PRESSED|KQ_RELEASED  can be used to simplify singular key-presses.</p>
    <p>The TotalEntries  argument must be set to the total number of key entries used in the array, and the Size argument must be calculated using the formula "sizeof(struct dcKeyEntry) * TotalEntries".</p>
    <p>Refer to the "input/keyboard.h" include file for a complete list of keyboard qualifier flags, as well as the <class>Keyboard</> class for keyboard related documentation.</p>

    <h3>DATA_NETWORK</>

    <p>The <class>NetSocket</> class uses the NETWORK datatype to pass networking information to an elected subscriber (refer to the Subscriber field of the NetSocket class).  The required dcNetwork structure is configured as follows:</p>

<fields struct="dcNetwork">
<fld type="WORD" name="Operation">Network operation code (NOP)</>
<fld type="WORD" name="Size">Size of the dcNetwork structure.</>
<fld type="ERROR" name="Error">Error for the operation (if relevant).</>
<fld type="struct ClientSocket *" name="Socket">Set if the NetSocket is a server and a client is involved.</>
</>

<p>Available network operation codes are as follows:</p>

<types>
<type name="NOP_INCOMING">Data is incoming and ready to read from the NetSocket object.</>
<type name="NOP_SOCKET_CONNECTED">Server socket has received a new client connection.</>
<type name="NOP_SOCKET_DISCONNECTED">Server socket has had a client disconnect.</>
<type name="NOP_DISCONNECTED">Socket has been disconnected from the remote host.</>
<type name="NOP_CONNECTED">Socket has connected to a remote host.</>
<type name="NOP_CONNECT_FAILED">A connection attempt has failed.</>
<type name="NOP_OUTGOING">Outgoing data buffer exhausted - please add new data by writing to the network socket.</>
<type name="NOP_CONNECTING">The socket is initiating a connection.</>
</>

    <h3>DATA_RAW</h3>
    <p>Sending raw data to an object is the data channel's equivalent of calling the <action>Write</> action.  To send raw data, set the Size to the byte length of the data and the TotalEntries argument to 1.</p>

    <h3>DATA_RECEIPT</h3>
    <p>In response to a DATA_REQUEST from an object, a RECEIPT will be sent to the requesting object via the data channel system.  The receipt will contain a null-terminated XML string with the data that has been requested.  Please refer to the documentation for the DragDrop action for further information.</p>

    <h3>DATA_REQUEST</h3>
    <p>The REQUEST data type is primarily designed for drag and drop operations, but theoretically can be used for any type of data transfer between objects where uniquely numbered items may be prevalent.  A data request is made to another object by passing it a unique item ID and indicating up to 3 types of supported data formats that would be accepted from the source.  The structure for managing the request is configured as follows:</p>

<fields struct="dcRequest">
<fld type="LONG" name="Item">Item to retrieve from the source.</>
<fld type="UBYTE [4]" name="Preference">Data preferences for the returned item(s).</>
</>

    <p>The data types indicated in the Preference field can be any of the pure data types supported by the DataChannel action, for example DATA_TEXT or DATA_XML.  Any unused elements of the Preference array must be driven to zero, including the 4th.</p>

    <h3>DATA_XML</h3>
    <p>The XML data type has the same attributes as the DATA_TEXT type, except it represents text that has been structured using XML formatting.  How the information is interpreted by the object receiving the data is dependent on  how that class has been  designed to process XML information.  It is recommended that you check the class' documentation to see if and in what way XML data is supported.</p>
</indent>
  </description>
  <support>
    <p>The DataChannel action is available for classes that need to have an open port for receiving various types of data from other objects.  It can be extremely useful in cases where you want your class to be able to receive miscellaneous commands or formatted information for internal processing.  For example, the Keyboard class supports the DataChannel action so that it can receive virtual keypresses from software, rather than being restricted to hardware input.</p>
    <p>The DataChannel action is closely linked to the <function mod="kernel">SubscribeChannel</> and <function mod="kernel">UnsubscribeChannel</> functions.  If you want to set up an object so that it can receive data from a remote object, then you must first subscribe to it with the SubscribeChannel() function. The remote object will then start sending information through to the DataChannel action, which you can intercept with your support routine.  When you no longer want to receive data, the channel can be closed with a call to <function mod="kernel">UnsubscribeChannel</>.</p>
    <p>Descriptions of the data formats that can be sent through this action are described in the DataChannel section of the Action User Guide.</p>
  </support>
</action>

<action>
  <name>Custom</>
  <category>General</>
  <synopsis>ERROR acCustom(*Object, LONG Number, STRING String)</>
  <short>Allows customised messages to be passed through the action system.</>
  <args>
    <arg type="LONG" name="Number">A numeric ID that has meaning to the support code can be set here.</>
    <arg type="STRING" name="String">A custom string that has meaning to the support code can be set here.</>
  </args>
  <description>
    <p>The Custom action is provided to simplify the passing of custom messages through the action system.  Calls to the Custom action need to be monitored by a listener that checks the Number and String values for a meaningful message.  If no listener has subscribed to the Custom action then no activity will occur (classes do not apply any support of their own to this action).</p>
    <p>In summary, through the use of the Custom action you can effectively add actions to your program in a way that is meaningful to specific objects.  For more information on how to listen to an action, refer to the <class>Action</> class' monitoring capabilities or read the documentation to the <function mod="kernel">SubscribeAction</> function.</p>
  </description>
  <support>
    <p>It is recommended that no class should support the Custom action directly as its purpose is undefined (we would suggest that you create a new method or field rather than support this action).</>
  </support>
</action>

<action>
  <name>Deactivate</>
  <category>General</>
  <synopsis>ERROR acDeactivate(*Object)</>
  <short>Stops an object from performing its native activities.</>
  <description>
    <p>Deactivating an object that has recently been activated through the <action>Activate</> action will cause it to halt the execution of its native activity.  If the object is not performing any activity, then this action will do nothing.</p>
  </description>
  <support>
    <p>If your class supports the Activate action then you may also want to write support code to deactivate an object.  In most cases this only applies to objects that support background processing.  For example, after activating a Sound object an audio sample will play in the background.  Because the Sound class supports the Deactivate action, it is possible for a program to cut the audio short whenever it wants to.</p>
  </support>
</action>

<action>
  <name>Disable</>
  <category>General</>
  <synopsis>ERROR acDisable(*Object)</>
  <short>Disables an object.</>
  <description>
    <p>The Disable action is used to put an object into a state where it can no longer respond adequately to outside interaction.  It is typically used to temporarily "turn off" objects in the interface.  For instance, disabling a <class>Surface</> object will cause it to drop user events coming from mouse clicks and pointer movement.  An object will remain in a disabled state until you enable it again with the <action>Enable</> action.</p>
    <p>Multiple calls to the Disable action will not nest unless the documentation for the object's class states otherwise.</p>
  </description>
  <support>
    <p>The Disable action is provided for the purposes of disabling the interactive elements of an object.  It is typically supported by classes that have an impact on the creation of the graphical user interface, or those that have a close proximity to the actions performed by the user.</p>
    <p>You need to make a judgment as to what support areas will be deactivated when a Disable call is made to one of your objects.  Generally you should not deactivate all areas of an object as the point is not to render it useless. Only the interactive elements of the object should be disabled (your interpretation of what is interactive will depend on the type of class being developed).</p>
    <p>If necessary you can write your own code to nest any multiple calls to the Disable action, although this would be considered to be the exception to the rule.  If you are going to support nesting, you must document this fact in the documentation for your class.</p>
    <p>Support for the Disable action should also be matched with support for the Enable action.  This will allow your disabled objects to return to a normal state, as disablement is usually only a temporary measure.</p>
  </support>
</action>

<action>
  <name>DragDrop</>
  <category>GUI</>
  <synopsis>ERROR acDragDrop(*Object, OBJECTID Source, LONG Item, LONG Datatype)</>
  <short>Manages drag and drop from one object to another.</>
  <args>
    <arg type="OBJECTID" name="Source">Refers to the object containing the source data.</>
    <arg type="LONG" name="Item">An item ID, relevant to the source object.</>
    <arg type="LONG" name="Datatype">The type of data represented by the source item.</>
  </args>
  <description>
    <p>The DragDrop action provides the core functionality of a universal drag and drop system.  The process of drag and drop works as follows:</p>
    <list type="sorted">
      <li>The user initiates a drag and drop operation by clicking and holding the mouse button on an interface item.</li>
      <li>An object that owns that item will be monitoring the surface containing the item for UserClick and UserMovement actions.</li>
      <li>On detecting the initial stages of the drag and drop operation, the object will create a new surface with the COMPOSITE and STICKTOFRONT flags set to represent the dragged items graphically.  The <function mod="display">StartCursorDrag</> function in the Display module is then called to link this surface to the mouse pointer.  No further action needs to be taken until the mouse button is released.</li>
    </list>
    <p>When the item is dropped by releasing the mouse button over a surface, the following occurs:</p>
    <list type="sorted">
      <li>The mouse pointer will hide the draggable surface that was attached to it.</li>
      <li>The DragDrop action will be called on the surface that is under the pointer's hot spot.  The source, item number and datatype originally passed to <function mod="display">StartCursorDrag</> will be included in this action call.</li>
      <li>If a listener is subscribed to the DragDrop action of the targeted surface, it will be able to respond to the drag and drop operation.  The listener will need to send a DATA_REQUEST via the <action>DataChannel</> action to the object that is referenced in the Source parameter.  The listener can indicate supported data types that it will accept from the source (see the DataChannel action for further information) and the Item number received from the DragDrop action.</li>
      <li>The source object will respond by sending a DATA_RECEIPT message via the <action>DataChannel</> action.  This contains the item data in one of the requested formats.</li>
    </list>

    <p>Data for drag and drop activity is defined in XML format.  The following skeletal structure must be adhered to:</p>

    <indent><code>
&lt;receipt id="[SourceID]" totalitems="[Total]&gt;
  ...list of items...
&lt;/receipt&gt;
    </code></indent>

    <p>The official list of items that can be contained in the receipt are as follows:</p>
    <indent>
    <p><code>DATA_AUDIO: &lt;audio path="[FilePath]" object="[SoundObject]"/&gt;</code><br/>Either path or object may be set.  The object must belong to the Sound class.</p>
    <p><code>DATA_FILE: &lt;file path="[FilePath]"/&gt;</code></p>
    <p><code>DATA_IMAGE: &lt;audio path="[FilePath]" object="[Object]"/&gt;</code><br/>Either path or object may be set.  The object must belong to either the Picture or Bitmap classes.</p>
    <p><code>DATA_RAW: &lt;raw path="[FilePath]" object="[Object]"/&gt;</code><br/>Either path or object may be set.  The object must support the Read action for reading the data.</p>
    <p><code>DATA_TEXT: &lt;text&gt;[UTF8Content]&lt;/text&gt;</code></p>
    <p><code>DATA_XML: &lt;xml&gt;[XMLContent]&lt;/xml&gt;</code></p>
    </indent>
    <p>Custom data that does not fit the above formats is permitted, but must be declared with the 'custom:' prefix prior to the name of the element.</p>

  </description>
  <support>
    <p>To support drag and drop, do not write a routine specifically targeting the DragDrop action.  Instead, use SubscribeAction() to listen to the DragDrop action of the surface that is used by your object.  In response to the receipt of a DragDrop action you should send a DATA_REQUEST (via data channels) to the indicated Source object.  The rest of your support code for drag and drop will need to be written in your <action>DataChannel</> support routine.</p>
  </support>
</action>

<action>
  <name>Draw</>
  <category>GUI</>
  <synopsis>ERROR acDrawArea(*Object, LONG X, LONG Y, LONG Width, LONG Height)</>
  <synopsis>ERROR acDraw(*Object)</>
  <short>Draws object graphics to drawable areas.</>
  <args>
    <arg type="LONG" name="X">The horizontal coordinate of the region to be drawn.</>
    <arg type="LONG" name="Y">The vertical coordinate of the region to be drawn.</>
    <arg type="LONG" name="Width">The width of the region to be drawn.</>
    <arg type="LONG" name="Height">The height of the region to be drawn.</>
  </args>
  <description>
    <p>This action will draw an object's graphic, either to the video display or to a virtual drawing space, according to the object type and your specifications.  If the object is not linked to a drawable area, or if the object belongs to a non-graphical class,   calling this action will usually have no effect and an error code will be returned.</p>
    <p>The dimension arguments specify the size of the region that you want to draw.  If you wish, you may choose not to supply these arguments if the entire region of the object should be drawn.</p>
    <p>To draw graphics, the Draw action is usually called on <class>Surface</> objects to update the video display.  Refer to the <class>Surface</> class for more information on interface-based drawing.  For information on drawing primitive graphics to drawable areas, refer to the <bitmap>Bitmap</> class.</p>
  </description>
  <support>
    <p>The Draw action is provided for classes that need graphical support.  A programmer will typically set up an object so that it can be drawn according to your specifications, then call the Draw action with the expectation that the object will be drawn to a graphical object (such as a Bitmap).  The exact technical details of the process are for you to define.</p>
    <p>The dimension arguments are provided so that the programmer can declare the precise region that needs to be drawn.  Your support of these arguments is entirely optional, so if they are not appropriate for your class, just ignore them.</p>
    <p>Note that if you are writing a GUI based class then you will probably want to use an action subscription to listen to Draw action activity, rather than supporting the Draw action directly.  This is best observed by looking at the source code to one of the existing graphical classes.</p>
  </support>
</action>

<action>
  <name>Enable</>
  <category>General</>
  <synopsis>ERROR acEnable(*Object)</>
  <short>Enables a disabled object.</>
  <description>
    <p>The Enable action is provided for the purposes of reactivating objects that have been disabled with the <action>Disable</> action.  When an object is enabled, all the changes caused by disablement are undone.</p>
  </description>
  <support>
    <p>The Enable action must be supported in situations where you have decided to include support for the Disable action in your class.  The code that you write for this action must be able to undo all the changes made in your support for the Disable action.  If your Disable code includes support for nesting then you will also need to take this into consideration.</p>
    <p>If a call is made to this action on an object which is not disabled, you should do nothing apart from returning ERR_Okay to indicate that the object is already enabled.</p>
  </support>
</action>

<action private>
  <name>EventMessage</>
  <category>Internal</>
  <short>Used for supporting event subscriptions originating from the Broadcast class.</>
  <args>
    <arg type="LONG" name="Event">The ID of the event that is sending you notification.</>
    <arg type="OBJECTID" name="Object">The ID of the object related to the event, if applicable.</>
    <arg type="LARGE" name="Integer">A 64-bit integer that may have meaning according to the event ID.</>
    <arg type="APTR" name="Buffer">Points to a data buffer, if applicable to the event.</>
    <arg type="LONG" name="Size">The byte size of the data buffer, if applicable.</>
  </args>
  <support>
    <p>If you have called the <method class="Broadcast">SubscribeEvent</> method of a Broadcast object to force some of your objects to listen to a particular event, your class will need to support this action so that event messages can be received and interpreted.</p>
    <p>The event information will be returned to you with a description of the event ID, followed by a set of optional information that will only be set if it is relevant to the event.  The data format of the various event types is described in the <class>Broadcast</> class manual.</p>
    <p>You can terminate an event subscription by calling the <method class="Broadcast">UnsubscribeEvent</> method of the Broadcast object that you originally subscribed to.</p>
  </support>
</action>

<action private>
  <name>FieldNotify</>
  <category>Internal</>
  <short>Used for supporting subscriptions originating from the SubscribeField() function.</>
  <args>
  <arg type="FIELD" name="Field">The unique ID of the field that is reporting the event.</>
  <arg type="OBJECTID" name="Object">The unique ID of the object that is reporting the event.</>
  </args>
  <support>
    <p>If you have called the <function mod="kernel">SubscribeField</> function to force some of your objects to monitor the field/s of another object, you will need to support this action so that field messages can be received and interpreted.</p>
    <p>In supporting this action you will receive information that tells you the ID of the object and the field ID whenever the value of the monitored field has been altered.  There are no restrictions on how you respond to this in your routine.  If you need to know the new value of the field, you can retrieve it using conventional means.</p>
    <p>You can terminate a field subscription by calling the <function mod="kernel">UnsubscribeField</> function.</p>
  </support>
</action>

<action>
  <name>Flush</>
  <category>I/O</>
  <synopsis>ERROR acFlush(*Object)</>
  <short>Flush buffered data from an object.</>
  <description>
    <p>This action will flush all buffered data from an object. Flushing can be useful when applied to I/O based objects  that  buffer data to speed up processing times. As a result of flushing,  unwritten data will either be dumped to its  physical location or  related output device, depending on the object specifications.</p>
    <p>Note that any object using a buffering technique will automatically flush its data when you <action>Free</> it.</p>
  </description>
  <support>
    <p>Flush is a useful action for buffered objects such as files.  The concept of buffering is often used to speed up data processing, for example reading and writing to memory is a lot faster than to a hard drive or floppy disk.  However, it can sometimes be important for the physical data to represent the data as if it were not buffered.  By supporting the Flush action, you can ensure that this is possible if your class buffers information.</p>
    <p>When Flush is called on one of your objects, you will be expected to dump all of the buffered data to its 'physical' location, then you should clear your buffer of its contents.</p>
  </support>
</action>

<action>
  <name>Focus</>
  <category>GUI</>
  <synopsis>ERROR acFocus(*Object)</>
  <short>The Focus action is used to focus on objects within the user interface.</>
  <description>
    <p>The Focus action is primarily used within the UI for focussing on areas of the graphical user interface.  Objects supporting the Focus action are typically members of the Drawable category,  of which only the <class>Surface</> class currently qualifies.</p>
    <p>When a drawable object receives the focus it will usually do very little, but external objects that are listening for focus activity will respond to the change accordingly.  For instance, input based objects within surface areas often listen to Focus activity so that they know when to start responding to  keyboard input.</p>
  </description>
  <support>
    <p>This action is usually called on drawable objects (e.g. Render objects) when the user interacts with them.  Your class should only support this action if it is used in an area that is in close proximity to the user's actions.</p>
    <p>If your class requires notification when a drawable object has received the focus, do not write support for the Focus action.  You should instead use the <function mod="kernel">SubscribeAction</> function to listen to the Focus action of the drawable object that you are interested in.</p>
    <p>If your class needs to be informed when one of its objects has lost the focus, you will need to support the <action>LostFocus</> action.</p>
  </support>
</action>

<action>
  <name>Free</>
  <category>General</>
  <synopsis>ERROR acFree(*Object)</>
  <short>Frees an object and any of its associated resources.</>
  <description>
    <p>After you have finished working with an object, you will need to free it from the system to stop its use of memory and other resources. If the object has one or more child objects attached to it, they will also be removed as a result of calling this action.  Once the object has been freed from the system, you should proceed to drive  all unique ID or pointer variables  that reference  the object to NULL, in order to prevent subtle bugs  from appearing in your program.</p>
    <p>It is important to note  that if you have an exclusive lock on the object from <function mod="kernel">AccessObject</> at the time of calling the Free action,  the object will only be marked for deletion.  This means that the object will continue to remain in memory until  the last lock is removed with a matching <function mod="kernel">ReleaseObject</> function call.</p>
  </description>
  <support>
    <p>This function is called whenever the programmer wants to free one of your objects from the system.  If you have written a base class, you must undo all of the allocations that belong to the object at the time of its destruction.  If you have written a sub-class, you only need to support this action if your code makes extra allocations on top of those made by the base class.</p>
    <p>To prevent allocations between a base class and sub-class from being confused, if you free any fields make sure that you drive them to NULL afterwards.  Remember that if your sub-class requires its own private data fields, there is a MID_ChildPrivate field for this purpose in every objects' Stats structure.</p>
  </support>
</action>

<action private>
  <name>FreeWarning</>
  <category>Internal</>
  <short>Used for receiving an early warning before an object is freed.</>
  <support>
    <p>This action can be useful in rare circumstances where you might want to prevent an object from being freed from the system.  Usually when an object has the Free action called upon it then the situation is terminal, but you can circumvent this by creating a FreeWarning support routine.</p>
    <p>If you support the FreeWarning action then the termination process will call your routine to check if it is possible to free the object.  If you return an error code of ERR_InUse, then the object's termination will be aborted.  Any other error code that you return will cause the object to be removed as normal.</p>
  </support>
</action>

<action>
  <name>GetVar</>
  <category>General</>
  <synopsis>ERROR acGetVar(*Object, STRING Field, STRING Buffer, LONG Size)</>
  <short>This action retrieves field values that are not defined by an object's structure.</>
  <args>
    <arg type="STRING" name="Field">The name of the field value that is to be obtained.</>
    <arg type="STRING" name="Buffer">Pointer to a buffer space large enough to hold the retrieved value.</>
    <arg type="LONG" name="Size">Indicates the byte size of the Buffer.</>
  </args>
  <description>
    <p>The GetVar action is used to retrieve object fields that are not officially listed as part of an object's structure.  Generally the objects that are created by the Core will have all of their fields defined by the class specification that they originate from, allowing you to access them through <function mod="kernel">GetField</> and <function mod="kernel">SetField</> functionality.  However,  there are cases where  dynamic field manipulation is required, and this is what both the GetVar and <action>SetVar</> actions are for.</p>
    <p>Unless an object has specially documented behaviour for GetVar support, this action is only able to retrieve fields that have previously been set through a call to <action>SetVar</>.  Variable fields are always handled as strings for ease of use, so if you need to store integers or floating point numbers you will need to convert them to and from   their equivalent string values (the <module>Strings</> module provides various functions for this purpose).</p>
    <p>To retrieve a variable field, set the Field, then  the Buffer argument to point to an area of reserved space that is large enough to hold the string that you expect to receive.  The Size argument must be set to the total size of the provided buffer in order to prevent an overflow from occurring.</p>
    <p>If the requested field does not exist, the ERR_UnsupportedField error code will usually be returned from the object's class.</p>
  </description>
  <support>
    <p>If your class design allows for variable fields then you will need to support this action.  A 'variable field' is a field that is not officially listed as part of an object's structure.  This provides a great way of being able to store miscellaneous data through the standard field mechanisms, or for supporting special field descriptors.  The GetVar action is specifically used for the retrieval of variable field data, while the SetVar action is used for creating and setting variable fields.</p>
    <p>If this action is called then you will be provided with information on the field name and a string Buffer that you need to write the data to.  The Size argument defines the length of the Buffer - you must be careful not to write out more data than the Buffer can hold or you can crash the process.  If you do not have any record of the specified Field, return an error code of ERR_UnsupportedField. Otherwise, write the field data to the buffer and return ERR_Okay.  If there is not enough buffer space to write out the value, just make do with the space that is available and return ERR_Okay anyway (if necessary, you can print a warning to the debugger).</p>
    <p>Please note that if you support this action then it is recommended that you provide a reasonable amount of documentation so that the developer knows just how your class supports variable fields.</p>
  </support>
</action>

<action>
  <name>HealthCheck</>
  <category>General</>
  <synopsis>ERROR acHealthCheck(*Object)</>
  <short>Objects that are suspected to be damaged can sometimes be repaired by making a health-check.</>
  <description>
    <p>Some object classes support the HealthCheck action to recover from data corruption.  This action is usually called in dire situations  detected by the system management routines, but can also be used as part of regular processing to  check up on an object's  integrity.</p>
    <p>Any object passing a health-check will  return an ERR_Okay error code.  If serious problems were detected that could not be repaired,  ERR_ObjectCorrupt will be returned.</p>
  </description>
  <support>
    <p>The HealthCheck action is provided for classes that wish to protect the integrity of their objects in cases where an object's structure and/or data has been compromised.  This action is usually called when the system runs a health check, or when the object kernel suspects that there may be something wrong with an object.</p>
    <p>When writing a support routine for this action, your goal is to check the object structure and fix any problems that you find along the way.  If you encounter a terminal issue that is impossible for you to fix, return an error code of ERR_ObjectCorrupt.  This will cause the system to flag the object as being terminally ill.</p>
  </support>
</action>

<action>
  <name>Hide</>
  <category>GUI</>
  <synopsis>ERROR acHide(*Object)</>
  <short>Hides a visible object from the view of the user.</>
  <description>
    <p>Hiding is an action that is used to remove objects from the sight of the user. Examples of this include hiding Screen and File objects. After you have hidden an object, call the <action>Show</> action if you need to make it visible again.</p>
  </description>
  <support>
    <p>If your class is designed to create objects that are 'visible' to the user (for example, a GUI class) then you may also want to provide a way to make it invisible.  You can do this by providing support for the Hide action.  It is recommended that you also support the Show action so that it is possible to make a hidden object visible again.</p>
  </support>
</action>

<action>
  <name>Init</>
  <category>General</>
  <synopsis>ERROR acInit(*Object)</>
  <short>Initialises an object so that it is ready for active use.</>
  <description>
    <p>This action  initialises objects so that they can be used for their intended purpose. The process of initialisation is   compulsory, and  <i>you may not use any other actions on an object until it has been initialised</i>.  Exceptions to this rule only apply to the <action>Free</>, <action>GetVar</> and <action>SetVar</> actions.</p>
    <p>If the initialisation of an object fails due to a support problem (for example, if you ask a <class>Picture</> object to load a JPEG file when it only supports IFF), the Init action will look for a sub-class that can handle the data. If a sub-class that can provide ample support exists, a partial transfer of ownership will occur and the object's management will be shared between both the base class and the sub-class.</p>
    <p>If an object does not support the data or specifications that have been set for it,  an error code of ERR_NoSupport will be returned to indicate that the base class does not support the object data.</p>
  </description>
  <support>
    <p>This action is called when a program initialises an object that belongs to your class.  The purpose of this action is to prepare the object for the necessary handling for other actions such as Draw, Activate, Show etc.</p>
    <p>If your class is data-centric, then in cases where you cannot handle the data (e.g. an IFF class tries to interpret a JPEG file) then your routine must undo any changes it has made to the object's structure.  You must then return an error code of ERR_NoSupport. This will cause the initialisation management routine to look for a sub-class that can support the object correctly.  If the object was recognised but initialisation fails due to a system  error or similar, then any error-code can be returned (except for ERR_NoSupport and ERR_Okay). This will cause the initialisation action to fail immediately and return to the program.</p>
    <p>It is highly recommended that before proceeding with full initialisation of an object, you always check the data sources and ensure that you understand them. If you check the data near the middle or end of your routine, you may make things difficult to undo if you find that you need to return ERR_NoSupport.</p>
    <p>You must never free your object while inside the initialisation routine. If your routine fails then the object will be freed at a time when it is appropriate to do so.</p>
  </support>
</action>

<action private>
  <name>Layout</>
  <category>GUI</>
  <short>Assists in the layout of embedded objects in documents.</>
  <args>
    <arg type="LONG" name="CursorX">The current location of the document cursor (horizontal).</>
    <arg type="LONG" name="CursorY">The current location of the document cursor (veritcal).</>
    <arg type="LONG" name="LeftMargin">The left-hand margin for the page.</>
    <arg type="LONG" name="RightMargin">The right-hand margin for the page.</>
    <arg type="LONG" name="TopMargin">The top margin for the page.</>
    <arg type="LONG" name="LineHeight">The current height of the line that the cursor is positioned on.</>
    <arg type="LONG" name="Align">Alignment flags that can be applied to the object.</>
    <arg type="struct SurfaceClip *" name="Clip">Clipping dimensions indicate the boundaries of the available page area.</>
    <arg type="LONG" name="Dimensions">The dimension flags used by the object must be returned in this parameter.</>
  </args>
  <description>
    <p>This is an internal function that can only be called by the Document class.  Class developers should refer to the supporting documentation for this action in order to write supporting code for it.</p>
  </description>
  <support>

  </support>
</action>

<action>
  <name>Lock</>
  <category>Locking</>
  <synopsis>ERROR acLock(*Object)</>
  <short>Locks an object's 'physical' position and other attributes.</>
  <description>
    <p>The Lock action can be used on an object when you don't want it to be physically moved or deleted for a short period of time.  The most common example of locking under any system is in the file system. For instance, locking a file prevents it from being deleted or moved to a new location, which is useful if you want it to stay in one place while you are reading or writing to it.</p>
    <p>The original and any subsequent calls to  Lock must be matched with  calls to the <action>Unlock</> action, because locks will nest.  Once all locks have been removed,  the ability to physically manipulate the object  becomes available again.  The following conditions apply to locking behaviour:</p>
    <list type="unlisted">
      <li>Other tasks <i>may</i> be able to gain limited access to the object's data after you have locked it (e.g. locking a file may prevent writing, but other tasks could still read the file). The object you are attempting to lock should have specific documentation on this. If it doesn't, work on  the assumption that other tasks will have some limited access to the object's data.</>
      <li>The object will be fixed in place and cannot be moved or deleted, even by your own task, until it is unlocked.</>
      <li>If you <action>Free</> a locked object, its class will  automatically reverse all locks that exist at the time of termination.</>
    </ul>
    <p>Please be aware that locking an object and gaining exclusive access to an object are not the same thing.  To clarify, the <function mod="kernel">AccessObject</> function is  used on public and shared objects to gain temporary access.  On the other hand, an object's locking behaviour is always defined by the controlling class,  which does not affect access to the object itself, although it can affect access to the physical data or equivalent representation of the object.</p>
  </description>
  <support>
    <p>Locking is provided for developers that want to prevent objects from physically moving position (e.g. files and directories) and prevents tasks from performing certain actions and changes to an object. Locks can either be shared or exclusive to tasks, depending on what is suitable for the object.</p>
    <p>As a result of locking, the object will be fixed in place and cannot be moved or deleted, even by the task that holds the lock, until the object is unlocked with the Unlock action.  As the class programmer, you have a responsibility to enforce  your own rules to support locks.  Feel free to place other restrictions on the object where appropriate.</p>
    <p>It is extremely important that you document the behaviour of locking for your particular object. The issue of shared/exclusive locking on public objects is an important issue for you to consider.</p>
    <p>You must also support the <action>Unlock</> action, this is the only way that you can receive information on the unlocking of an object.</p>
  </support>
</action>

<action private>
  <name>LostFocus</>
  <category>GUI</>
  <short>This action is called when an object loses the user focus.</>
  <description>
    <p>This is an internal action managed by the <class>Surface</> class.</p>
  </>
  <support>
    <p>This action is usually called on drawable objects (e.g. Render objects) when the user stops interacting with them and takes an interest in other objects.  Your class should only support this action if it is used in an area that is in close proximity to the user's actions.</p>
    <p>If your class requires notification when a drawable object has lost the focus, do not write support for the LostFocus action.  You should instead use the <function mod="kernel">SubscribeAction</> function to listen to the LostFocus action of the drawable object that you are interested in.</p>
  </support>
</action>

<action>
  <name>Move</>
  <category>GUI</>
  <synopsis>ERROR acMove(*Object, DOUBLE DeltaX, DOUBLE DeltaY, DOUBLE DeltaZ)</>
  <short>Moves the physical representation of an object to a new location.</>
  <args>
    <arg type="DOUBLE" name="DeltaX">The amount of units  to move along the horizontal axis.</>
    <arg type="DOUBLE" name="DeltaY">The amount of units to move along the vertical axis.</>
    <arg type="DOUBLE" name="DeltaZ">The amount of units to move along the Z axis.</>
  </args>
  <description>
    <p>The Move action is  provided to move graphical objects to new coordinates within drawable areas.  The result of moving an object is determined by the object's current coordinates in combination with the unit changes that you want to apply.  For instance, if the object is at position (43x, 95y) and you apply movement arguments of (-3x, 2y, 0) then the object will be moved to position (40x, 97y).  If you need to know the current coordinates of an object in order to move it to a specific location, read its X and Y fields to determine its current position.</p>
    <p>Please note that while most graphical objects will support the ability to be moved on the X and Y axis, the DeltaZ argument is ignored unless the object supports 3 dimensional space.</p>
  </description>
  <support>
    <p>If your class supports a coordinate system (this is typically the case for all graphical classes) then you should support the Move action.  Movement originating from this action is relevant to the current position of the object, rather than being based on absolute coordinates.  If for example a program wishes to move your object 5 units to the left, it will set the DeltaX argument to -5 and the other arguments to zero.</p>
    <p>If there is a limit as to how far an object can move in any direction, you can limit its movement by reducing the number of units if they would place the object in an out-of-bounds position.  For example, if an object is at position (15,18) and a program wants to move it 40 units upwards, you could reduce that value to 18 units if you wanted to prevent the object moving into negative space.  You should still return an error code of ERR_Okay in such a case.</p>
    <p>In conjunction with your support of the Move action, your class definition should define X and Y fields if it is 2-dimensional and a Z field if it is 3-dimensional.  If you do not support these standard fields then it will be difficult for a program to determine the position of your objects.</p>
  </support>
</action>

<action>
  <name>MoveToBack</>
  <category>GUI</>
  <synopsis>ERROR acMoveToBack(*Object)</>
  <short>Move an object to the back of its current location.</>
  <description>
    <p>The MoveToBack and MoveToFront actions are used for shuffling objects to the back or front of their containers. Generally this is applied to graphical classes, but  other class types can support these actions for  more obscure purposes  (sorting for example).</p>
    <p>In some instances it may not be possible for an object to be moved completely to the front or back, in which case the object can only move as close to the requested position as possible.  This situation will often occur when  groups of  objects are locked at specific positions, preventing others from getting ahead of them.</p>
  </description>
  <support>
    <p>In many instances where displayable objects are on screen, the graphics will inevitably overlap each other.  If you support the MoveToBack and MoveToFront actions, you can provide the developer with some assistance in the arrangement of an object in relation to other objects.</p>
    <p>If your class supports the Lock action, it may be best for a locked object to hold its position when the MoveToBack action is called.  Whether you decide to do this or not is up to you, so document the class' behaviour in this area.</p>
  </support>
</action>

<action>
  <name>MoveToFront</>
  <category>GUI</>
  <synopsis>ERROR acMoveToFront(*Object)</>
  <short>Move an object to the front of its current location.</>
  <description>
    <p>The MoveToBack and MoveToFront actions are used for shuffling objects to the back or front of their containers. Generally this is applied to graphical classes, but  other class types can support these actions for  more obscure purposes  (sorting for example).</p>
    <p>In some instances it may not be possible for an object to be moved completely to the front or back, in which case the object can only move as close to the requested position as possible.  This situation will often occur when  groups of  objects are locked at specific positions, preventing others from getting ahead of them.</p>
  </description>
  <support>
    <p>In many instances where displayable objects are on screen, the graphics will inevitably overlap each other.  If you support the MoveToBack and MoveToFront actions, you can provide the developer with some assistance in the arrangement of an object in relation to other objects.</p>
    <p>If your class supports the Lock action, it may be best for a locked object to hold its position when the MoveToFront action is called.  Whether you decide to do this or not is up to you, so document the class' behaviour in this area.</p>
  </support>
</action>

<action>
  <name>MoveToPoint</>
  <category>GUI</>
  <synopsis>ERROR acMoveToPoint(*Object, DOUBLE X, DOUBLE Y, DOUBLE Z, LONG Flags)</>
  <short>Moves the physical representation of an object to a new location.</>
  <args>
    <arg type="DOUBLE" name="X">The horizontal coordinate to move the object to.</>
    <arg type="DOUBLE" name="Y">The vertical coordinate to move the object to.</>
    <arg type="DOUBLE" name="Z">The depth position to move the object to.</>
    <arg type="LONG Flags">Flags that indicate the parameters that you have specified.  (MTF_X, MTF_Y and MTF_Z respectively).</>
  </args>
  <description>
    <p>The MoveToPoint action is provided to move graphical objects to new coordinates within drawable areas.  The shift to that position is immediate, but may be subject to certain conditions - for instance it may not be possible to move to negative coordinates.  Limitations may be imposed depending on the circumstances and are subject to class specifications.  An Okay error code will be returned irrespective of whether or not movement to the requested location was succesful.  If you need to determine the coordinates of the object after calling for a move, read the X and Y fields to determine the current position of the object.</p>
    <p>You are required to set the MTF_X, MTF_Y and/or MTF_Z flags according to the parameters that you have specified.  This feature allows you to move the object to a specific horizontal coordinate without altering the vertical position, for example.</p>
  </description>
</action>

<action private>
  <name>NewChild</>
  <category>Internal</>
  <short>Used by classes that need to be alerted when an object receives a new child.</>
  <args>
    <arg type="OBJECTID" name="NewChild">Indicates the unique ID of the new child.</>
  </args>
  <support>
    <p>If you need to be aware of occasions where an object has inherited a new child object from the <function mod="kernel">SetOwner</> function, you should support the NewChild action.  By supporting this action you can respond to the arrival of new children, as well as preventing objects from forming direct attachments if they do not meet your criteria (simply by returning an error code).</p>
    <p>In some rare circumstances it may be necessary for a new child to be automatically 'passed through' to another object that would be better suited as an owner.  If you want to do this, your support routine should call the SetOwner() function to pass the child through to another object, then you should return an ERR_OwnerPassThrough error code to indicate that a pass-through has occurred.  Any other error code will be interpreted as failure, which would cause the process to abort.</p>
  </support>
</action>

<action private>
  <name>NewOwner</>
  <category>Internal</>
  <short>Called when the owner of an object is about to change.</>
  <args>
    <arg type="OBJECTID" name="NewOwner">The unique ID of the new owner.</>
    <arg type="CLASSID" name="Class">The class ID of the new owner.</>
  </args>
  <support>
    <p>If you need to be aware of occasions where a program is changing the owner of an object with the <function mod="kernel">SetOwner</> function, you should support the NewOwner action.  This will allow you to respond to the alteration of an object's owner as you see fit.</p>
    <p>The error code that you return will not have an impact on the <function mod="kernel">SetOwner</> process.</p>
  </support>
</action>

<action private>
  <name>NewObject</>
  <category>Internal</>
  <short>Called when a new object has been created from a base class.</>
  <support>
    <p>This action is called whenever a new instance of an object belonging to your class has been created.  The routine that you place here should be fairly simple as the object kernel will take care of the creation process - all you need to do is take care of any extra resource allocations.  Some classes also like to write default values to their objects as a pre-initialisation process.</p>
    <p>If you return an error code then the object creation process will fail.</p>
  </support>
</action>

<action>
  <name>OpeningTag</>
  <category>General</>
  <synopsis>ERROR acOpeningTag(*Object)</>
  <short>The OpeningTag action is used to 'execute' objects.</>
  <description>
    <p>The OpeningTag action is typically used by classes that perform object execution processing, as in the <class>Script</> and <class>CommandLine</a> classes.  If you want to emulate the execution process for objects, follow this procedure:</p>
    <list type="ordered">
      <li>Create the object using the <function mod="kernel">NewObject</> function.</>
      <li>Set the object fields.</>
      <li>Call the Init action on the target object.</>
      <li>Call the OpeningTag action on the target object.</>
      <li>If the object will contain children, create and initialise them to the parent object using this same procedure.</>
      <li>Call the ClosingTag action on the target object.</>
    </>
    <p>The effect of calling the OpeningTag action is extremely similar to calling the <action>Activate</> action - in fact, for some objects the result is identical.  For this reason, do not follow-up an OpeningTag action with an <action>Activate</> call, or you could end up activating the object twice.</p>
    <p>If you are not performing batch-style processing it is often a better idea to use an <action>Activate</> call, as it can be quicker and achieve the same result in most cases.</p>
  </description>
  <support>
    <p>If you are developing a class that is designed for use in object scripts, or potentially could be used in an object script, then you may want to support the OpeningTag action.</p>
    <p>The OpeningTag action is used just after a script interpreter has created an object, set its fields and initialised it.  This provides you with an indication that the object has gone through significant preparation but has not yet had any children initialised to it.  If you would rather wait until the object has been fully prepared, you should support the ClosingTag action instead.</p>
  </support>
</action>

<action private>
  <name>OwnerDestroyed</>
  <category>Internal</>
  <short>Called by the object kernel when the owner of an object is removed.</>
  <description>
    <p>This action is provided for resource management purposes.  It is also makes it possible to detect that an object will be destroyed due to the destruction of its owner.</p>
    <p>This action is called by the object kernel on the termination of all objects going through the free process.</p>
  </description>
  <support>
    <p>It is not possible to write support code for this action as it is managed internally.</p>
  </support>
</action>

<action>
  <name>Query</>
  <category>General</>
  <synopsis>ERROR acQuery(*Object)</>
  <short>Retrieves the latest information from an object.</>
  <description>
    <p>Calling the Query action will update the target object so that it reflects all changes in status  since the last Query or <action>Init</> call.  Querying is typically used  to get information on  object data and for analysing objects that have constant status updates originating from an external source.</p>
    <p>It is recommended that you check the documentation for the target object before calling the Query action, as there is no clear-cut procedure for classes to follow in supporting this action.</p>
  </description>
  <support>
    <p>Query is a commonly supported action that programs can use to get updated information on an object.  It is commonly supported by data-centric objects as well as objects that support dynamic hardware values originating from devices such as keyboards and joyports.  If you want to support the Query action, then you will need to decide what fields you are going to update in your support routine, then document this behaviour accordingly.</p>
  </support>
</action>

<action>
  <category>File</>
  <name>Read</>
  <synopsis>ERROR acRead(*Object, APTR Buffer, LONG Length, LONG *Result)</>
  <short>Reads raw data information from objects.</>
  <args>
    <arg type="APTR" name="Buffer">Points a buffer that will receive the data.</>
    <arg type="LONG" name="Length">The total number of bytes to read from the object.  This value cannot exceed the size of the Buffer.</>
    <arg type="LONG" name="Result" result>The Read action will write this parameter with the total number of bytes read into the Buffer.</>
  </args>
  <description>
    <p>Use the Read action to read data from an object and into a supplied memory buffer.  While the most obvious use for this action  is in <class>File</> I/O, it can be supported by any class that can store data or retrieve it from an external source.</p>
    <p>Making a Read call will result in the object reading the total amount of bytes defined by Length,  into the  memory area pointed to by the Buffer argument. If positioning is supported,  the object will start reading from the point defined  in its Position field. The Position field will be incremented by the amount of bytes read  if the call succeeds.  This means that further calls to Read will  begin from the  position set by the last Read call.  If you need to alter the current data position of an object, make a call to the <action>Seek</> action.</p>
    <p>If the Length exceeds the total amount of data left in the object, the Read action will only read as many bytes as there are left in the object. If you want to know how many bytes are left to read, get the Position and Size field values from the object and subtract the Position from the Size to get the amount of bytes left.</p>
    <p>Make sure that the Length value that you specify is not larger than the size of your Buffer, or an overflow will occur that could potentially crash your program.</p>
    <p>The Result parameter will be updated to reflect the total  amount of data that was read into the supplied Buffer.   If an error occurred, or if no data is left to read, the Result parameter will be set to zero.</p>
  </description>
  <support>
    <p>The Read action was initially provided in order to support reading and writing data to Files.  Despite this intention, a class which supports a data storage area should support the Read action for managing raw data.</p>
    <p>The Buffer argument points directly to the area that will receive data from your Object.  The Length will indicate the amount of bytes that a program wants to retrieve from your object.  If the Length is larger than the amount of data that is actually available, just write out the maximum amount of bytes that are in the object.</p>
    <p>Your class should support a Position field in its structure to indicate the byte position from which the Read action will start reading data. After the Read operation, you must increment the Position field by the amount of bytes that were read from the object's data store.  This will provide the developer with more versatility when it comes to reading and writing data.  You should also consider supporting the <action>Seek</> action to manipulate the Position field.</p>
    <p>Before returning, your support routine must set the Result parameter to indicate the total amount of bytes that were read from the object.  If no bytes were read, you should still return ERR_Okay but make sure that the Result is set to zero.</p>
  </support>
</action>

<action>
  <name>Redimension</>
  <category>GUI</>
  <synopsis>ERROR acRedimension(*Object, DOUBLE X, DOUBLE Y, DOUBLE Z, DOUBLE Width, DOUBLE Height, DOUBLE Depth)</>
  <short>Repositions and resizes the target object.</>
  <args>
    <arg type="DOUBLE" name="X">The new horizontal coordinate to apply to the target object.</>
    <arg type="DOUBLE" name="Y">The new vertical coordinate to apply to the target object.</>
    <arg type="DOUBLE" name="Z">The new Z coordinate (or zoom factor) to apply to the target object.</>
    <arg type="DOUBLE" name="Width">The new width.</>
    <arg type="DOUBLE" name="Height">The new height.</>
    <arg type="DOUBLE" name="Depth">The new depth.</>
  </args>
  <description>
    <p>Use Redimension to reposition and resize an object in a single action call.  This is considered to be more optimal than moving and resizing an object with sequential calls to the Move and Resize actions.  By default, the target object will be redrawn automatically as a result of calling this action.</p>
    <p>If the target object contains other drawable objects, they will often respond by adjusting their dimensions to the new size.  The exact result will depend on what children are contained by the target object  and how they are programmed.</p>
    <p>If you need to resize only one area dimension (for example if you want to resize the Width and leave the Depth and Height "as is"),  set the other arguments to zero.  The Depth argument is only used for 3-Dimensional objects - set it to zero if you know that the object is represented in 2D only.  If the Z coordinate represents a zoom factor, a setting of 1.0 would represent the normal size of the target object.</p>
    </description>
  <support>

  </support>
</action>

<action>
  <name>Redo</>
  <category>I/O</>
  <synopsis>ERROR acRedo(*Object)</>
  <short>Reverse a previous call to the Undo action.</>
  <description>
    <p>Calling Redo will reverse previous calls to the <action>Undo</> action.  This action can be called once for every previous call to Undo.  If there is nothing to undo, ERR_NothingDone will be returned.</p>
  </description>
  <support>

  </support>
</action>

<action>
  <name>Refresh</>
  <category>General</>
  <synopsis>ERROR acRefresh(*Object)</>
  <short>Refreshes the state of an object.</>
  <description>
    <p>Some classes support the Refresh action if their objects represent external data sources.  For example, the FileView class represents a view of the file system, which is external to a FileView object.  If the file system changes, manually refreshing the FileView will update it to reflect those changes.</p>
    <p>If a Refresh action fails, the object should remain in its original state unless the documentation for the object class states otherwise.</p>
  </description>
  <support>
    <p>If your class represents a view of an 'external' data source, you may need to support the Refresh action.  The purpose of a refresh is to re-read the origins of an object's data and then update the object to reflect any differences between the object and its data source.</p>
    <p>If your Refresh support code fails, it is recommended that you leave the object in its original state when returning a fail code.</p>
  </support>
</action>

<action private>
  <name>ReleaseObject</>
  <category>Locking</>
  <short>Used for intercepting the release of exclusive locks.</>
  <support>
    <p>If you wish to be informed when a program is releasing an exclusive lock from an object, you may write a support routine for this action.  This is entirely optional, and the <function mod="kernel">ReleaseObject</> function does not depend on your support for this.</p>
    <p>The error code that you return from your support routine will be ignored.</p>
  </support>
</action>

<action>
  <name>Rename</>
  <category>General</>
  <synopsis>ERROR acRename(*Object, STRING Name)</>
  <short>Renames an object.</>
  <args>
    <arg type="STRING" name="Name">The new name for the object.</>
  </args>
  <description>
    <p>Objects that support naming conventions will typically support renaming through the Rename action.   The <class>File</> class is a typical example of a class that provides this kind of support.  Although Rename does not impose limits on the length of the supplied name, you should read the object's documentation for what limits might be imposed.</p>
  </description>
  <support>
    <p>If your class supports naming (e.g. for the purpose of representing a data location such as a file name) then you may want to support the Rename action.  How you support this action is entirely dependent on the focus of the class, as this action does not require you to adhere to any restrictions.  If there is a limit on the amount of characters that are supported by your routine, you should document this fact in the class manual.</p>
    <p>Please note that an internal name as defined by your class is not the same as a public object name, as defined by the <function mod="kernel">SetName</> function.</p>
  </support>
</action>

<action>
  <name>Reset</>
  <category>General</>
  <synopsis>ERROR acReset(*Object)</>
  <short>Resets an object to its original state.</>
  <description>
    <p>This action will reset an object to a state that is similar to when the object was first initialised. The resulting  behaviour depends greatly on the object that you are trying to reset, but as a rule, object data will not be destroyed as a result of calling this action (the <action>Clear</> action is typically used for this purpose). A common response to resetting is to <action>Seek</> back to a position of zero, stop any currently running activity, then reset the object state back to normal.</p>
    <p>Resetting an object  is not the same as using the <action>Flush</> action.   Some objects will flush themselves automatically on receiving a Reset action, others may not. It depends on the circumstances, but if you want the data flushed then use the <action>Flush</a> action instead.</p>
  </description>
  <support>
    <p>The most common reason for supporting the Reset action is to allow an object to get itself back to a refreshed state, similar to when the object was first initialised.  Examples could be resetting a file position back to the beginning, or restarting a running procedure from scratch.  It is recommended that you do not actually destroy any data in your Reset support routine, although you may manipulate it as much as necessary.</p>
  </support>
</action>

<action>
  <name>Resize</>
  <category>GUI</>
  <synopsis>ERROR acResize(*Object, DOUBLE Width, DOUBLE Height, DOUBLE Depth)</>
  <short>Resizes objects that are represented by  two or three dimensional graphics.</>
  <args>
    <arg type="DOUBLE" name="Width">The new width for the object.</>
    <arg type="DOUBLE" name="Height">The new height for the object.</>
    <arg type="DOUBLE" name="Depth">The new depth for the object.</>
  </args>
  <description>
    <p>The Resize action is used to alter the width, height and depth of an object with a single action call.  Resizing is commonly used in the UI for manipulating  drawable areas that represent gadgets like windows, buttons and scrollbars.  This means that it is typically applied to <class>Surface</> objects, but it can also be useful for quickly adjusting the dimensions of graphical objects  like boxes and ellipses.</p>
    <p>If a resized object contains other drawable objects, they will often respond to the resize by adjusting their dimensions to the new size.  The exact result will depend on what children are contained by the target object  and how you have programmed them.</p>
    <p>If you only want to resize a particular dimension (for example if you want to resize the Width and leave the Depth and Height "as is"),  set the other arguments to zero.  The Depth argument is only used for 3-Dimensional objects - set it to zero if you know that the object is represented in 2D only.</p>
  </description>
  <support>
    <p>If a class is designed to represent a 2-dimensional or 3-dimensional space then it should support the Resize action if that space is intended to be adjustable.  In conjunction with this action the class must support Width and Height fields, as well as a Depth field if the object is 3-dimensional. After a successful resize has taken place, these fields must be updated to reflect the object's new dimensions.</p>
    <p>If the developer only wants to resize a particular dimension such as the Width, then only the Width argument will be set and the others will be driven to zero.</p>
  </support>
</action>

<action>
  <name>SaveImage</>
  <category>File</>
  <synopsis>ERROR acSaveImage(*Object, OBJECTID Dest)</>
  <short>Saves an object's image to a destination object.</>
  <args>
    <arg type="OBJECTID" name="Dest">Must refer to an initialised object that the class should save the image data to.</>
  </args>
  <description>
    <p>The SaveImage action is used to save the visual representation of an object to a storage object of your choosing.    The image will be saved in a file format that can be reloaded using the <class>Picture</a> class.  In most cases the object that you specify in the DestID argument should  be a <class>File</> object, although you can use any object type that you wish if its class supports the <action>Write</> action and the concept of data storage.</p>
    <p>In some cases, the SaveImage and <action>SaveToObject</> actions will both save image information (for example the <class>Picture</> and <class>Bitmap</> classes will do this) but objects that can be represented as an image and in a native data format will make a clear distinction between the two.</p>
  </description>
  <support>
    <p>This action is provided for classes that wish to make a distinction between the image of an object and the data of an object.  For instance, saving a GUI object could store information on the object's construction, while saving its image would store the object as a graphic (like a camera snapshot).</p>
    <p>When supporting this action you should store the image using the Picture or Bitmap class so that the data can be saved in the user's preferred format. Otherwise, you should <action>Write</> the image to the Destination using a widely recognised image format.</p>
  </support>
</action>

<action>
  <name>SaveSettings</>
  <category>File</>
  <synopsis>ERROR acSaveSettings(*Object)</>
  <short>Saves object settings to a physical storage location.</>
  <description>
    <p>The SaveSettings action exists to simplify the saving of configuration information to a default file path.  In some classes it can also save altered object data back to its origin file.</p>
  </description>
  <support>

  </support>
</action>

<action>
  <name>SaveToObject</>
  <category>File</>
  <synopsis>ERROR acSaveToObject(*Object, OBJECTID Dest)</>
  <short>Saves an object's data to a destination object.</>
  <args>
    <arg type="OBJECTID" name="Dest">Must refer to an initialised object that the class should save data to.</>
  </args>
  <description>
    <p>This action will save an object's data to a storage object of your choosing.  The data will be saved in a file format that can be re-loaded at a later time using the object's documented mechanism for loading data.  In most cases the object that you specify in the DestID argument should  be a <class>File</> object, although you can use any object type that you wish if its class supports the <action>Write</> action and the concept of data storage.</p>
  </description>
  <support>
    <p>By supporting the SaveToObject action, you can make it possible to save an object's data to a File or other data storage object. This action is considered to be extremely important in creating functional data-centric objects based on pictures, sounds, documents and so forth.</p>
    <p>When your SaveToObject support routine is called, you will be sent a Destination object which is initialised and is supportive of Write calls.  All you are required to do is Write your data to the given object.  You must save your file information in a format that is recognised by your class, so that it can be loaded back at a later time.</p>
  </support>
</action>

<action>
  <name>Scroll</>
  <category>GUI</>
  <synopsis>ERROR acScroll(*Object, DOUBLE DeltaX, DOUBLE DeltaY, DOUBLE DeltaZ)</>
  <short>Scroll the contents of a container.</>
  <args>
    <arg type="DOUBLE" name="DeltaX">The amount of units to scroll along the horizontal axis.</>
    <arg type="DOUBLE" name="DeltaY">The amount of units to scroll along the vertical axis.</>
    <arg type="DOUBLE" name="DeltaZ">The amount of units to scroll along the Z axis.</>
  </args>
  <description>
    <p>The Scroll action is used to scroll the graphical contents of drawable objects.  Simply provide the necessary values to indicate the shift in direction and apply the action to the target object to scroll its contents.</p>
    <p>Sending a Scroll action to a drawable object will always succeed, because the object itself will not  respond to scrolling  activity.    However,   objects that are listening for scroll requests will detect the action call and respond accordingly.  The <class>Text</> class is a good example of a class that has extensive support for scrolling activity.  Whether or not a foreign object succeeds in its  processing is not reflected in the returned error-code.</p>
    <p>The  interpretation of the parameters that you supply are relative to the object you are scrolling.  In most cases the scroll direction will be measured in  pixels, but not always.  The documentation for the object you are trying to scroll will specify how it interprets the scrolling distance if it is not pixel based.</p>
  </description>
  <support>
    <p>This action is typically supported by GUI components that have scrollable contents.  The coordinate parameters can be interpreted as you wish - usually in pixels, but the exact details are up to you.  Make sure that you document how coordinate alterations are interpreted by your class.</p>
  </support>
</action>

<action>
  <name>ScrollToPoint</>
  <category>GUI</>
  <short>Scrolls the graphics of the targetted object to a specific point inside the parent view.</>
  <synopsis>ERROR acScrollToPoint(*Object, DOUBLE X, DOUBLE Y, DOUBLE Z, LONG Flags)</>
  <args>
    <arg type="DOUBLE" name="X">The horizontal coordinate to scroll to.</>
    <arg type="DOUBLE" name="Y">The vertical coordiante to scroll to.</>
    <arg type="DOUBLE" name="Z">The Z coordinate to scroll to (zoom factor).</>
    <arg type="LONG" name="Flags">Accepts STF_X, STF_Y and STF_Z for determining which of the X, Y and Z parameters are defined.</>
  </args>
  <description>
    <p>The ScrollToPoint action allows graphical objects to be scrolled to new coordinates within their viewing area.  The shift to the requested position is usually immediate and causes a redraw.  Scrolling may be subject to limitations, for instance, it may not be possible to scroll to coordinates that would place part of the object outside of the visible page space.  The support routine can still succeed if it was not possible to scroll to the exact coordinates given, but to the nearest approximation.  If you need to determine the coordinates of the object after scrolling, read the X and Y fields to determine the current position of the object.</p>
    <p>The coordinate values that you provide will almost always need to be equal or less than zero if the top-left origin of the object is (0,0).</p>
    <p>You are required to set the STF_X, STF_Y and/or STF_Z flags according to the parameters that you have specified.  This feature allows you to scroll the object along a single axis for example.</p>
      </description>
  <support>

  </support>
</action>

<action>
  <name>Seek</>
  <category>File</>
  <synopsis>ERROR acSeek(*Object, DOUBLE Offset, LONG Position)</>
  <synopsis>ERROR acSeekStart(*Object, DOUBLE Offset)</>
  <synopsis>ERROR acSeekEnd(*Object, DOUBLE Offset)</>
  <synopsis>ERROR acSeekCurrent(*Object, DOUBLE Offset)</>
  <short>Seek to a new position in an object.</>
  <args>
    <arg type="DOUBLE" name="Offset">The  position that you want to seek to, relative to the Position argument.</>
    <arg type="LONG" name="Position">Either POS_START, POS_CURRENT or POS_END.</>
  </args>
  <description>
    <p>The Seek action sets the read/write position for the target object.  This position is used by both the Read and Write actions as a place to start reading or writing.  In some cases it can also affect other areas of object behaviour, for instance seeking to a new position of an audio based object can affect the point at which it will play-back the audio.</p>
    <p>The Position can be set to  POS_START, POS_CURRENT or POS_END to indicate the  relative start position. For example, +20 from POS_CURRENT is 20 bytes from the current position, while -20 would be 20 bytes back from the current position.</p>
    <p>You cannot seek beyond the 'end' of an object, nor can you seek  to a position less than zero.</p>
    <p>To get the current position of an object, read its Position field.</p>
  </description>
  <support>
    <p>If your object supports the Read and Write actions, you will most probably want to support Seek as well.  Seeking is used to position the 'read/write head' so that the next time some I/O occurs, it will start at the seeked position.</p>
    <p>Your class is required to define a Position field that always reflects the current byte position in your object's data.  When the Seek action is called, the Position must be altered to reflect the absolute byte position that the program has seeked to.</p>
    <p>When writing your support routine, you must write code for each of the three different modes - POS_START, POS_CURRENT and POS_END.  POS_START refers to the beginning of the data, POS_CURRENT refers to the current byte position and POS_END refers to the end of the data.  The Position argument can be set to both negative and positive values when the POS_CURRENT mode is used, but in the POS_START and POS_END modes the sign of the Position is not relevant (for this reason, it is recommended that you ensure that the Position is interpreted as an absolute value that is offset in the appropriate direction according to the Mode).</p>
    <p>Seeking beyond the boundaries of an object's data is not permitted.  In other words, the resulting byte position from a Seek action cannot be less than zero, and cannot be greater than the data size.  If the boundary will be broken, you should restrict the Position field to the appropriate boundary value.</p>
  </support>
</action>

<action>
  <name>SelectArea</>
  <category>GUI</>
  <synopsis>ERROR acSelectArea(*Object, DOUBLE X, DOUBLE Y, DOUBLE Width, DOUBLE Height)</>
  <short>Selects a specific region within an object's graphical area</>
  <args>
    <arg type="DOUBLE" name="X">Horizontal coordinate of the target area.</>
    <arg type="DOUBLE" name="Y">Vertical coordinate of the target area.</>
    <arg type="DOUBLE" name="Width">Width of the target area.</>
    <arg type="DOUBLE" name="Height">Height of the target area.</>
  </args>
  <description>


  </description>
  <support>


  </support>
</action>

<action>
  <name>SetVar</>
  <category>General</>
  <synopsis>ERROR acSetVar(*Object, STRING Field, STRING Value)</>
  <short>This action sets field values that are not defined by an object's structure.</>
  <args>
    <arg type="STRING" name="Field">The name of the field that you want to set.</>
    <arg type="STRING" name="Value">The value that will be written to the variable field, specified in string format.</>
  </args>
  <description>
    <p>The SetVar action is used to set object fields that are not officially listed as part of an object's structure.  Most class definitions will declare their supported fields, allowing you to access them through <function mod="kernel">GetField</>, <function mod="kernel">SetField</> and similar functions.  However,  there are cases where  dynamic field manipulation is required and this is catered for by <action>GetVar</> and SetVar.</p>
    <p>Variable fields are always handled in string format, so if you need to store integers or floating point numbers, you will need to convert the values to their equivalent string format first (the <module>Strings</> module provides various functions for this purpose).</p>
    <p>Please note that the SetVar action can only be used on objects that specifically offer support for variable fields.</p>
  </description>
  <support>
    <p>If your class design allows for variable fields then you will need to support this action.  A 'variable field' is a field that is not officially listed as part of an object's structure.  This provides a way of being able to store miscellaneous data through the standard field mechanisms, or for supporting special field descriptors.  The SetVar action is specifically used for storing variable field names and data, while the GetVar action is used for retrieving variable field values.</p>
    <p>If this action is called then you will be provided with information on the field name and a string Value that contains the field data.  Unless you are going to dynamically interpret the field value in your routine, you will have to store the field value in the object.  To do this you should come up with a simple mechanism to store multiple field names and values in a buffer that belongs to the object.  You should also develop your routine so that it checks whether or not a value for the Field already exists at the time of calling. If the Field exists, then your routine should delete the existing value and replace it with the new Value that has been provided.</p>
    <p>Please note that if you support this action then it is recommended that you provide a reasonable amount of documentation so that the developer knows just how your class supports variable fields.</p>
  </support>
</action>

<action>
  <name>Show</>
  <category>GUI</>
  <synopsis>ERROR acShow(*Object)</>
  <short>Makes an object visible to the user.</>
  <description>
    <p>Calling this action will make the target object visible to the user.  If the object is represented visually then it will usually appear on the video display. Non-visual objects such as files may simply have a permission switch changed. If you show an object that is already visible, there will be no effect.</p>
    <p>If you want to make the target object invisible, call the <action>Hide</> action.</p>
  </description>
  <support>
    <p>If your class is designed to create objects that are 'visible' to the user (for example, a GUI class) then you may want to provide support for the Show and Hide actions to manage object visibility.  Generally you should automatically show an object to the user on its initialisation, but by supporting the Show and Hide actions you can provide the developer with a little extra flexibility in this area after initialisation has taken place.</p>
  </support>
</action>

<action>
  <name>Sort</>
  <category>General</>
  <synopsis>ERROR acSort(*Object)</>
  <short>Sorts object content into ascending order (by default).</>
  <description>
    <p>Objects that contain multiple items can be sorted with this action.  The sort will be in ascending order (A - Z or 0 - 9) unless the object is configured for a descending sort.  The sort will be based on the default value elected for the items - this will typically be an ID value if available, or the name of each item.</p>
  </description>
  <support>


  </support>
</action>

<action private>
  <name>Timer</>
  <category>Internal</>
  <short>This action must be supported if the class requires regular timing messages.</>
  <args>
    <arg type="LONG" name="MilliSeconds">The number of milliseconds (1/1000th of a second) that have passed since the last Timer call.</>
  </args>
  <support>
    <p>If you have called the <function mod="kernel">SubscribeTimer</> function to force some of your objects to receive regularly timed processor calls, you will need to support this action so that the timer messages can be received and interpreted.</p>
    <p>In supporting this action you will receive the number of milliseconds that have passed since the last Timer call.  There are no restrictions on how you write your routine to respond to Timer notifications.  The error code that you return will be ignored.</p>
    <p>You can terminate a timer subscription by calling the <function mod="kernel">UnsubscribeTimer</> function.</p>
  </support>
</action>

<action>
  <name>Undo</>
  <category>I/O</>
  <synopsis>ERROR acUndo(*Object)</>
  <short>Reverses the last operation.</>
  <description>
    <p>The Undo action reverses the last data process performed by the object.  Objects that support this action maintain an internal stack of all data operations that have been performed since the creation of the object (subject to undo buffer limits).  You may call Undo for as many operations as have been recorded on the stack.</p>
<p>There is no distinction between user and automated operations performed against the object's data - both are treated equally.</p>
<p>Some class types may need to be configured before they will initialise an undo buffer that can be utilised by this action.</p>
  </description>
  <support>


  </support>
</action>

<action>
  <name>Unlock</>
  <category>Locking</>
  <synopsis>ERROR acUnlock(*Object)</>
  <short>Remove a lock from an object.</>
  <description>
    <p>The Unlock action complements the <action>Lock</> action in order to provide the necessary means for  releasing locks.   Once you have unlocked an object, all of the locking conditions placed on that object will be removed (although  locks will nest, so you will need to call Unlock for every Lock that is still waiting to be freed).</p>
    <p>If you <action>Free</> an object with locks that are still waiting to be unlocked, the object will automatically undo  <action>Free</> action will automatically Unlock them for you.</p>
  </description>
  <support>
    <p>This action serves as an accompanient to the Lock action.  It is not compulsory to support Unlock if you have written a Lock routine, but it would be an unusual case if you were not to write a support routine for this action.</p>
    <p>What you do for your Unlock support is entirely up to you, so long as you do not allocate any resources in the routine.</p>
  </support>
</action>

<action>
  <name>UserClick</>
  <category>GUI</>
  <synopsis>ERROR acUserClick(*Object, OBJECTID OverObject, LONG Buttons, LONG X, LONG Y, LONG Z)</>
  <short>Use this action to inform drawable objects that a user click has occurred.</>
  <args>
    <arg type="OBJECTID" name="OverObject">The ID of the object that the pointer is positioned over.</>
    <arg type="LONG" name="Buttons">Associated flags for the user click should be specified here.  Available flags are based on joyport standards, e.g. JD_LMB, JD_MMB, JD_RMB.  Refer to the "input/joyport.h" include file for a list of all available flags.</>
    <arg type="LONG" name="X">The horizontal coordinate of the user click, relative to the object's top left corner.</>
    <arg type="LONG" name="Y">The vertical coordinate of the user click, relative to the object's top left corner.</>
    <arg type="LONG" name="Z">The Z coordinate of the user click, relative to the object's top left corner.</>
  </args>
  <description>
    <p>The UserClick action is used to tell drawable objects that the user is attempting to interact with them through a pointing device.  A "user click" is typically defined as a user hitting a mouse button, or touching an area on a touch screen.  Classes such as the <class>Pointer</> are typically responsible for sending UserClick actions to drawable objects when buttons have been clicked using external devices.</p>
    <p>The Buttons argument must be set in accordance with one or more of the bit-flags listed in the "input/joyport.h" file.  Bit 1, also known as  JD_LMB is the most common flag setting as it represents the primary button (the left-hand button on the mouse).</p>
    <p>The coordinates supplied to the object must be relative to the object's graphical representation, for instance if the mouse pointer is centered over position (16,4) of a Surface object, the X and Y parameters will be set to those values respectively.</p>
    <p>Sending a UserClick action to a drawable object will always succeed, because they  themselves do not respond to user activity.    However,   objects that are listening to user activity will detect the action call, and respond accordingly.  Objects belonging to the <class>OnClick</> class are the most obvious example.  Whether or not these external objects succeed in their processing is not reflected in the returned error-code.</p>
    <p>Most classes expect a UserClick action to be followed by a <action>UserClickRelease</>, so for this reason you must call the <action>UserClickRelease</> action at some point after making a UserClick call.  It is illegal to call UserClick using the same Buttons more than once without a matching <action>UserClickRelease</>.  It is possible to call UserClick consecutively  in situations where the user was to hold the left mouse button, then the right mouse button, then release the left mouse button for example.  However, you will still need to make  two calls to <action>UserClickRelease</> in such a situation, or set both bit-flags in a single release call.</p>
  </description>
  <support>
    <p>If your class requires graphical user interaction, you need to support this action.  You will normally receive UserClick actions from the Pointer class, but they can of course come from anywhere.  After receiving a UserClick, you can typically expect to receive a UserClickRelease shortly thereafter.</p>
    <p>The coordinates supplied to your object are relative to the top left corner of the object.  The purpose of the coordinates is to tell you where  the user click occurred.  If there is no exact coordinate, the coordinates will be driven to zero.</p>
  </support>
</action>

<action>
  <name>UserClickRelease</>
  <category>GUI</>
  <synopsis>ERROR acUserClickRelease(*Object, OBJECTID OverObject, LONG X, LONG Y, LONG Z, LONG DeltaX, LONG DeltaY, LONG DeltaZ)</>
  <short>Informs an object that a user click has been released.</>
  <args>
    <arg type="OBJECTID" name="OverObject">The ID of the object that the pointer is currently positioned over.</>
    <arg type="LONG" name="X">The current horizontal coordinate in relation to the target object.</>
    <arg type="LONG" name="Y">The current vertical coordinate in relation to the target object.</>
    <arg type="LONG" name="Z">The current Z coordinate in relation to the target object.</>
    <arg type="LONG" name="DeltaX">The change in direction from the user's position since the previous call to UserClick.</>
    <arg type="LONG" name="DeltaY">The change in direction from the user's position since the previous call to UserClick.</>
    <arg type="LONG" name="DeltaZ">The change in direction from the user's position since the previous call to UserClick.</>
    <arg type="LONG" name="Buttons">The flags used in the matching UserClick call must be specified here.</>
  </args>
  <description>
    <p>The UserClickRelease action complements the <action>UserClick</> action in order to provide a means of indicating the release of a clicked button.  There are many circumstances where a component needs to be informed of the user clicking and then releasing that click - which is something that can happen instantly, or over a period of seconds.  For example, when a button is clicked, it may change its graphical look to show that it has been selected.  The selection state may remain until the click is released, whereupon the graphics return to normal.  The only way for the button to detect a click release is for the sender of the original UserClick to return a corresponding UserClickRelease action.</p>
    <p>Because it is possible for the user to move the focus while holding down a clicked button (common usage for drag and drop), the OverObject argument specifies where the user has shifted the focus to while holding down one or more buttons.  Objects that support drag and drop may use the OverObject argument to identify the new container.  In relation to this, the DeltaX, DeltaY and DeltaZ arguments specify the shift in position from the point where the original UserClick action was called.</p>
  </description>
  <support>
    <p>If you need to be informed when the user has clicked and then released a button on one of your objects, you must support UserClickRelease. This action is commonly supported for achieving drag and drop functionality. If the user is trying to drag an object somewhere, you can find out where that is by checking the OverObject argument.  Note that the DeltaX, DeltaY and DeltaZ arguments specify the shift in position from the point where the original UserClick action was called.</p>
  </support>
</action>

<action>
  <name>UserClickRepeat</>
  <category>GUI</>
  <short>Sent repeatedly when the user is holding a mouse button for an extended period of time.</>
  <synopsis>ERROR acUserClickRepeat(*Object, OBJECTID OverObject, LONG X, LONG Y, LONG Z, LONG Buttons)</>
  <args>
    <arg type="OBJECTID" name="OverObject">The ID of the object that the pointer is currently positioned over.</>
    <arg type="LONG" name="X">The current horizontal coordinate in relation to the target object.</>
    <arg type="LONG" name="Y">The current vertical coordinate in relation to the target object.</>
    <arg type="LONG" name="Z">The current Z coordinate in relation to the target object.</>
    <arg type="LONG" name="Buttons">Button flags.</>
  </args>
  <description>
    <p>The UserClickRepeat action extends on the <action>UserClick</> action by allowing objects to detect prolonged holding of the mouse buttons.  This action can be called only when following a UserClick and can then be called on an intermittent basis before a final call to UserClickRelease.</p>
    <p>You will need to check the position of the mouse pointer to calculate the X, Y and Z coordinates in relation to the target object, as well as determining the object that the pointer is positioned over.  The Buttons parameter should reflect the button state of the pointing device at the time the call is made.</p>
    <p>The required repeat rate for calls made to UserClickRepeat is undefined.  However we do recommend that a rate of 50 calls per second is used so that the timing matches regular display and animation frequencies.</p>
  </description>
  <support>


  </support>
</action>

<action>
  <name>UserMovement</>
  <category>GUI</>
  <synopsis>ERROR acUserMovement(OBJECTID OverObject, LONG X, LONG Y, LONG Z, LONG DeltaX, LONG DeltaY, LONG DeltaZ)</>
  <short>Used to inform components of user movement.</>
  <args>
    <arg type="OBJECTID" name="OverObject">The object that the user is currently positioned over.</>
    <arg type="LONG" name="X">The current position of the pointer in relation to the target object's top left corner.</>
    <arg type="LONG" name="Y">The current position of the pointer in relation to the target object's top left corner.</>
    <arg type="LONG" name="Z">The current position of the pointer in relation to the target object's top left corner.</>
    <arg type="LONG" name="DeltaX">The change in direction since the last UserMovement call.</>
    <arg type="LONG" name="DeltaY">The change in direction since the last UserMovement call.</>
    <arg type="LONG" name="DeltaZ">The change in direction since the last UserMovement call.</>
  </args>
  <description>
    <p>The UserMovement action controls the heart of user interactivity.  It is typically used to reflect incoming movement from user devices like mouse pointers, graphics tablets and touch-screens.  This action allows objects participating in the user interface to detect the current focus as the user moves the pointing device over them.</p>
    <p>There are two types of user movement that can detected by objects:</p>
    <list type="ordered">
      <li>Basic movement within a drawable object.</>
      <li>Movement from one drawable object to another.  In a case such as this, it is necessary to make two UserMovement action calls - one to tell the previous object that the user has moved away, and another to the new object so that it knows that the user has moved into its region.</>
    </>
    <p>The OverObject argument is used to indicate what object  the pointing device is currently positioned over.  Objects that detect user movement will check this argument to see if it refers back to themselves.  If it it doesn't, they know that the user has moved out of their graphical region and into the region of the indicated object.</p>
    <p>The coordinate values must reflect the position of the pointing device in relation to the target object.  If the user is positioned 10 pixels left and 40 pixels above the top left corner of the target object, the correct coordinate values will be (-10, -40, 0).  The DeltaX, DeltaY and DeltaZ values must reflect the change in direction since the last time that the pointing device was moved.</p>
  </description>
  <support>
    <p>To detect the movement of the user when he/she moves a pointing device over your object, add support for this action.  There are two cases for when you might be called by this action:</p>
    <list type="ordered">
      <li>Movement has occurred within one of your objects.  This is the most simple type of user movement.</>
      <li>Movement has occurred from one object to another.  In this case, two calls to UserMovement are used - one to tell the previous object that the user has moved away, and another to the new object to inform it that the user has moved into it.  You need to cater for both types of movement in this case.</>
    </>
    <p>You can tell what type of movement is occurring by checking the OverObject argument - if it is equal to your object, then movement is occurring within your object.  If the OverObject is some other object pointer, the user has moved away from your object.</p>
  </support>
</action>

<action>
  <name>Write</>
  <category>GUI</>
  <short>Writes data to objects that provide  storage or output services.</>
  <synopsis>ERROR acWrite(*Object, APTR Buffer, LONG Length, LONG Result)</>
  <args>
    <arg type="APTR" name="Buffer">Points to a buffer containing the data that will be written to the object.</>
    <arg type="LONG" name="Length">The total amount of bytes to write to the object.</>
    <arg type="LONG" name="Result" result>The Write action will update this parameter with the total number of bytes written from the buffer.</>
  </args>
  <description>
    <p>The Write  action is used to write buffered data  directly to an object's data storage area.   Objects that support the Write action are typically developed to provide data storage or data output services.  This normally involves use of the local file-system, but memory  and other storage or output  mediums can  be employed by some objects.  You could for instance, write data to a printer, a command line, or an audio output device.</p>
    <p>Making a Write call will result in the object reading the  total amount of bytes from the provided Buffer, as indicated by the Length argument. If positioning is supported by the object, it will start the write operation from the  point determined by its Position field. The Position field will be incremented to "Position + Length" if the Write call succeeds.  Further calls to Write will typically begin from the  position set by previous Write calls.  If you need to alter the current data position of an object, make a call to the <action>Seek</> action.</p>
    <p>If the object is at capacity (i.e. it cannot store or output any more data) then it may attempt to increase its data space to write out the entire buffer that you have provided.  If it cannot do this, it will try to write out as much information as it can and return an ERR_Okay error code.  If it cannot write out any data, it will return a fail code.</p>
    <p>To check how much data was written during  a Write call, check the Result parameter to see if it matches the Length value that you originally supplied.</p>
  </description>
  <support>
    <p>The Write action was initially provided in order to support the writing of data to Files.  Despite this intention, any class that supports a data storage area should support the Write action for managing raw data.</p>
    <p>The Buffer argument points directly to the area that contains the data that should be written to your object.  The Length argument indicates the byte size of the Buffer.  If the Length exceeds the total amount of space available for writing data, return an error code of ERR_LowCapacity.</p>
    <p>Your class should support a Position field in its structure to indicate the byte position from which the Write action will start writing data. After the Write operation, you must increment the Position field by the amount of bytes that were written to the object's data store.  This will provide the developer more versatility when it comes to reading and writing data.  You should also consider supporting the Seek action to manipulate the Position field.</p>
    <p>Before returning, your support routine must set the Result parameter to indicate the total amount of bytes that were written to the object.</p>
  </support>
</action>
