<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="class.xsl"?>

<book>
  <info>
    <name>File</name>
    <type>class</type>
    <module>Core</module>
    <comment>Enables access to the file system.</comment>
    <version>1.2</version>
    <id>7c96cb25</id>
    <idstring>ID_FILE</idstring>
    <category>System</category>
    <include>modules/file.h</include>
    <copyright>Paul Manias 1996-2020</copyright>
    <description>
<p>The File class provides extensive support for file management and I/O.  The class supports the notion of individual file compression and file finding capabilities.  Since all File objects are tracked, there is no chance of the system leaving locked files behind after a program exits.  Folder management is also integrated into this class to ease the management of both file types.</p>
<p>To read or write to a file, set the <field>Path</field> of the file as well as the correct I/O file flags before initialisation. See the <field>Flags</field> field for information on the available I/O flags.  Functionality for read and write operations is provided through the <action>Read</action> and <action>Write</action> actions.  The <action>Seek</action> action can be used to change the read/write position in a file.</p></description>
    <source>
      <file path="src/classes/">class_file.c</file>
    </source>
  </info>

  <actions>
    <action>
      <name>Activate</name>
      <comment>Opens the file.  Performed automatically if NEW, READ or WRITE flags were specified on initialisation.</comment>
    </action>

    <action>
      <name>DataFeed</name>
      <comment>Data can be streamed to any file as a method of writing content.</comment>
      <description>
<p>Streaming data of any type to a file will result in the content being written to the file at the current seek <field>Position</field>.</p>
      </description>
    </action>

    <action>
      <name>Init</name>
      <comment>Initialises a file.</comment>
      <description>
<p>This action will prepare a file or folder at the given <field>Path</field> for use.</p>
<p>To create a new file from scratch, specify the NEW flag.  This will overwrite any file that exists at the target path.</p>
<p>To read and write data to the file, specify the READ and/or WRITE modes in the <field>Flags</field> field prior to initialisation. If a file is read-only and the WRITE and READ flags are set in combination, the WRITE flag will be dropped and initialisation will continue as normal.</p>
<p>If neither of the NEW, READ or WRITE flags are specified, the file object is prepared and queried from disk (if it exists), but will not be opened.  It will be necessary to <action>Activate</action> the file in order to open it.</p>
<p>The File class supports RAM based file buffering - this is activated by using the BUFFER flag and setting the Size field to the desired buffer size.  A file path is not required unless the buffer needs to be filled with content on initialisation.  Because buffered files exist virtually, their functionality is restricted to read/write access.</p>
<p>Strings can also be loaded into file buffers for read/write access.  This is achieved by specifying the <field>Path</field> <code>string:Data\0</code>, where Data is a sequence of characters to be loaded into a virtual memory space.</p>
      </description>
      <result>
        <error code="ResolvePath">A volume could not be resolved.</error>
        <error code="MissingPath">The object is missing a setting in the Path or Location field.</error>
        <error code="Search">The file could not be found.</error>
        <error code="NoPermission">Permission was denied when accessing or creating the file.</error>
        <error code="FileNotFound">File not found.</error>
        <error code="SetField">An error occurred while updating the Path field.</error>
        <error code="Okay">Operation successful.</error>
      </result>
    </action>

    <action>
      <name>Query</name>
      <comment>Read a file's meta information from source.</comment>
    </action>

    <action>
      <name>Read</name>
      <comment>Reads data from a file.</comment>
      <description>
<p>Reads data from a file into the given buffer.  Increases the value in the <field>Position</field> field by the amount of bytes read from the file data.  The FL_READ bit in the <field>Flags</field> field must have been set on file initialisation, or the call will fail.</p>
<p>It is possible for this call to report success even in the event that no data has been read from the file.  This is typical when reading from streamed file sources.</p>
      </description>
      <result>
        <error code="Args">Invalid arguments passed to function.</error>
        <error code="NullArgs">Function call missing argument value(s)</error>
        <error code="Failed">The file object refers to a folder, or the object is corrupt.</error>
        <error code="FileReadFlag">The FL_READ flag was not specified on initialisation.</error>
        <error code="Okay">The file information was read into the buffer.</error>
      </result>
    </action>

    <action>
      <name>Rename</name>
      <comment>Changes the name of a file.</comment>
    </action>

    <action>
      <name>Reset</name>
      <comment>If the file represents a folder, the file list index is reset by this action.</comment>
    </action>

    <action>
      <name>Seek</name>
      <comment>Seeks to a new read/write position within a file.</comment>
    </action>

    <action>
      <name>Write</name>
      <comment>Writes data to a file.</comment>
      <description>
<p>Writes data from the provided buffer into the file, then updates the <field>Position</field> field to reflect the new read/write position.  You must have set the FL_WRITE bit in the <field>Flags</field> field when you initialised the file, or the call will fail.</p>
      </description>
      <result>
        <error code="LimitedSuccess">Only some of the data was written to the file.  Check the Result parameter to see how much data was written.</error>
        <error code="ExpectedFile">The operation expected a path to a file.</error>
        <error code="ObjectCorrupt">The object structure is corrupt or has not been initialised.</error>
        <error code="Args">Invalid arguments passed to function.</error>
        <error code="NullArgs">Function call missing argument value(s)</error>
        <error code="FileWriteFlag">The FL_WRITE flag was not specified when initialising the file.</error>
        <error code="Okay">All of the data was written to the file.</error>
        <error code="ReallocMemory">The reallocation of a memory block failed.</error>
      </result>
    </action>

  </actions>

  <methods>
    <method>
      <name>BufferContent</name>
      <comment>Reads all file content into a local memory buffer.</comment>
      <prototype>ERROR flBufferContent(OBJECTPTR Object)</prototype>
      <description>
<p>File content may be buffered at any time by calling the BufferContent method.  This will allocate a buffer that matches the current file size and the file's content will be read into that buffer.  The BUFFER flag is set in the file object and a pointer to the content is referenced in the file's Buffer field.  Standard file operations such as read, write and seek have the same effect when a file is in buffer mode.</p>
<p>Once a file has been buffered, the original file handle and any locks on that file are returned to the system. Physical operations on the file object such as delete, rename and attribute settings no longer have meaning when applied to a buffered file.  It is not possible to drop the buffer and return the file object to its original state once buffering has been enabled.</p>
      </description>
      <result>
        <error code="AllocMemory">A call to AllocMemory() failed to create a new memory block.</error>
        <error code="Read">Failed to read the file content.</error>
        <error code="Okay">The file content was successfully buffered.</error>
      </result>
    </method>

    <method>
      <name>Copy</name>
      <comment>Copies the data of a file to another location.</comment>
      <prototype>ERROR flCopy(OBJECTPTR Object, CSTRING Dest, FUNCTION * Callback)</prototype>
      <input>
        <param type="CSTRING" name="Dest">The destination file path for the copy operation.</param>
        <param type="FUNCTION *" name="Callback">Optional callback for receiving feedback during the operation.</param>
      </input>
      <description>
<p>This method is used to copy the data of a file object to another location.  All of the data will be copied, effectively creating a clone of the original file information.  The file object must have been initialised with the FL_READ flag, or the copy operation will not work (this restriction does not apply to directories).  If a matching file name already exists at the destination path, it will be over-written with the new data.</p>
<p>The <field>Position</field> field will be reset as a result of calling this method.</p>
<p>When copying directories with this method, the entire folder structure (i.e. all of the folder contents) will be copied to the new location.  If an error occurs when copying a sub-folder or file, the procedure will be aborted and an error code will be returned.</p>
      </description>
      <result>
        <error code="AllocMemory">A call to AllocMemory() failed to create a new memory block.</error>
        <error code="ResolvePath">A volume could not be resolved.</error>
        <error code="Write">Data could not be written to the destination path.</error>
        <error code="Failed">General failure.</error>
        <error code="Loop">Performing the copy would cause infinite recursion.</error>
        <error code="Args">Invalid arguments passed to function.</error>
        <error code="NullArgs">Function call missing argument value(s)</error>
        <error code="FieldNotSet">The Path field has not been set in the file object.</error>
        <error code="Read">Data could not be read from the source path.</error>
        <error code="Okay">The file data was copied successfully.</error>
      </result>
    </method>

    <method>
      <name>Delete</name>
      <comment>Deletes a file from its source location.</comment>
      <prototype>ERROR flDelete(OBJECTPTR Object, FUNCTION * Callback)</prototype>
      <input>
        <param type="FUNCTION *" name="Callback">Optional callback for receiving feedback during the operation.</param>
      </input>
      <description>
<p>This method is used to delete files from their source location.  If used on a folder, all of the folder's contents will be deleted in the call.   Once a file is deleted, the object effectively becomes unusable.  For this reason, file deletion should normally be followed up with a call to the Free action.</p>
      </description>
      <result>
        <error code="ReadOnly">The file is on a read-only filesystem.</error>
        <error code="ResolvePath">A volume could not be resolved.</error>
        <error code="Okay">File deleted successfully.</error>
        <error code="BufferOverflow">The file path string is too long.</error>
        <error code="NoPermission">The user does not have the necessary permissions to delete the file.</error>
        <error code="Failed">The deletion attempt failed (specific condition not available).</error>
        <error code="Locked">The file is in use.</error>
        <error code="MissingPath">The object is missing a setting in the Path or Location field.</error>
      </result>
    </method>

    <method>
      <name>Move</name>
      <comment>Moves a file to a new location.</comment>
      <prototype>ERROR flMove(OBJECTPTR Object, CSTRING Dest, FUNCTION * Callback)</prototype>
      <input>
        <param type="CSTRING" name="Dest">The desired path for the file.</param>
        <param type="FUNCTION *" name="Callback">Optional callback for receiving feedback during the operation.</param>
      </input>
      <description>
<p>This method is used to move the data of a file to another location.  If the file object represents a folder, then the folder and all of its contents will be moved.  The file object must have been initialised with the FL_READ flag, or the move operation will not work (this restriction does not apply to directories).  If a file already exists at the destination path then it will be over-written with the new data.</p>
<p>The <field>Position</field> field will be reset as a result of calling this method.</p>
      </description>
      <result>
        <error code="FieldNotSet">The Path field has not been set in the file object.</error>
        <error code="Args">Invalid arguments passed to function.</error>
        <error code="NullArgs">Function call missing argument value(s)</error>
        <error code="Failed">General failure.</error>
        <error code="Okay">The File was moved successfully.</error>
      </result>
    </method>

    <method>
      <name>Next</name>
      <comment>Retrieve meta information describing the next indexed file in the folder list.</comment>
      <prototype>ERROR flNext(OBJECTPTR Object, struct rkFile ** File)</prototype>
      <input>
        <param type="struct rkFile **" name="File">A pointer to a new File object will be returned in this parameter if the call is successful.</param>
      </input>
      <description>
<p>If a file object represents a folder, calling the Next() method will retrieve meta information about the next file in the folder's index.  This information will be returned as a new File object that is partially initialised (the file will not be opened, but information such as size, timestamps and permissions will be retrievable).</p>
<p>If desired, the resulting file object can be opened by setting the READ or WRITE bits in <field>Flags</field> and then calling the <action>Activate</action> action.</p>
<p>It is the responsibility of the caller to free the resulting File object once it is no longer required.</p>
<p>The file index can be reset by calling the <action>Reset</action> action.</p>
      </description>
      <result>
        <error code="NullArgs">Function call missing argument value(s)</error>
        <error code="DirEmpty">The index has reached the end of the file list.</error>
        <error code="Okay">Operation successful.</error>
        <error code="Args">Invalid arguments passed to function.</error>
      </result>
    </method>

    <method>
      <name>ReadLine</name>
      <comment>Reads the next line from the file.</comment>
      <prototype>ERROR flReadLine(OBJECTPTR Object, STRING * Result)</prototype>
      <input>
        <param type="STRING *" name="Result">The resulting string is returned in this parameter.</param>
      </input>
      <description>
<p>Reads one line from the file into an internal buffer, which is returned in the Result argument.  Reading a line will increase the <field>Position</field> field by the amount of bytes read from the file.  You must have set the FL_READ bit in the <field>Flags</field> field when you initialised the file, or the call will fail.</p>
<p>The line buffer is managed internally, so there is no need for you to free the result string.  This method returns ERR_NoData when it runs out of information to read from the file.</p>
      </description>
      <result>
        <error code="NoData">There is no more data left to read.</error>
        <error code="ObjectCorrupt">The internal file handle is missing.</error>
        <error code="Args">Invalid arguments passed to function.</error>
        <error code="BufferOverflow">The line is too long for the read routine (4096 byte limit).</error>
        <error code="Failed">The file object refers to a folder.</error>
        <error code="FileReadFlag">The FL_READ flag was not specified on initialisation.</error>
        <error code="Okay">The file information was read into the buffer.</error>
      </result>
    </method>

    <method>
      <name>SetDate</name>
      <comment>Sets the date on a file.</comment>
      <prototype>ERROR flSetDate(OBJECTPTR Object, LONG Year, LONG Month, LONG Day, LONG Hour, LONG Minute, LONG Second, LONG Type)</prototype>
      <input>
        <param type="LONG" name="Year">Year (-ve for BC, +ve for AD).</param>
        <param type="LONG" name="Month">Month (1 - 12)</param>
        <param type="LONG" name="Day">Day (1 - 31)</param>
        <param type="LONG" name="Hour">Hour (0 - 23</param>
        <param type="LONG" name="Minute">Minute (0 - 59)</param>
        <param type="LONG" name="Second">Second (0 - 59)</param>
        <param type="LONG" name="Type" lookup="FDT">The type of date to set (filesystem dependent).</param>
      </input>
      <description>
<p>The SetDate method provides a convenient way to set the date and time information for a file object.  Date information is set in a human readable year, month, day, hour, minute and second format for your convenience.</p>
<p>Depending on the filesystem type, multiple forms of datestamp may be supported.  The default datestamp, FDT_MODIFIED defines the time at which the file data was last altered.  Other types include the date on which the file was created and the date it was last archived (backed up).  The following types are supported by the Type argument:</p>
<types lookup="FDT"/>
<p>If the specified datestamp is not supported by the filesystem, ERR_NoSupport is returned by this method.</p>
      </description>
      <result>
        <error code="SystemCall">A call to the underlying system's native functions has failed.</error>
        <error code="ResolvePath">A volume could not be resolved.</error>
        <error code="NullArgs">Function call missing argument value(s)</error>
        <error code="NoSupport">The platform does not support file date setting.</error>
        <error code="Okay">Operation successful.</error>
      </result>
    </method>

    <method>
      <name>StartStream</name>
      <comment>Starts streaming data from a file source.</comment>
      <prototype>ERROR flStartStream(OBJECTPTR Object, OBJECTID Subscriber, LONG Flags, LONG Length)</prototype>
      <input>
        <param type="OBJECTID" name="Subscriber">Reference to an object that will receive streamed data notifications.</param>
        <param type="LONG" name="Flags" lookup="FL">Use FL_READ for incoming data, FL_WRITE for outgoing data.</param>
        <param type="LONG" name="Length">Limits the total amount of data to be streamed.</param>
      </input>
      <description>
<p>If a file object is a stream (indicated by the STREAM flag), the StartStream method should be used for reading or writing data to the file object.  Although it is possible to call the Read and Write actions on streamed files, they will be limited to returning only the amount of data that is cached locally (if any), or writing as much as buffers will allow in software.</p>
<p>A single file object can support read or write streams (pass FL_READ or FL_WRITE in the Flags parameter).  However, only one of the two can be active at any time.  To switch between read and write modes, the stream must be stopped with the <method>StopStream</method> method and then restarted with StartStream.</p>
<p>A stream can be limited by setting the Length parameter to a non-zero value.</p>
<p>If the StartStream request is successful, the file object will return action notifications to the Subscriber to indicate activity on the file stream.  When reading from a stream, AC_Write notifications will be received to indicate that new data has been written to the file cache.  The Buffer parameter of the reported acWrite structure may refer to a private address that contains the data that was received from the stream and the Result indicates the amount of new data available.</p>
<p>When writing to a stream, AC_Read notifications will be received to indicate that the stream is ready to accept more data.  The Result parameter will indicate the maximum amount of data that should be written to the stream using the <action>Write</action> action.</p>
<p>A stream can be cancelled at any time by calling <method>StopStream</method>.</p>
      </description>
      <result>
        <error code="NoSupport">The file is not streamed.</error>
        <error code="Okay">Operation successful.</error>
        <error code="Args">Invalid arguments passed to function.</error>
      </result>
    </method>

    <method>
      <name>StopStream</name>
      <comment>Stops streaming data from a file source.</comment>
      <prototype>ERROR flStopStream(OBJECTPTR Object)</prototype>
      <description>
<p>This method terminates data streaming from a file (instantiated by the <method>StartStream</method> method).  Any resources related to the streaming process will be deallocated.</p>
      </description>
      <result>
        <error code="NoSupport">The file is not streamed.</error>
        <error code="Okay">Operation successful.</error>
        <error code="Args">Invalid arguments passed to function.</error>
      </result>
    </method>

    <method>
      <name>Watch</name>
      <comment>Monitors files and folders for file system events.</comment>
      <prototype>ERROR flWatch(OBJECTPTR Object, FUNCTION * Callback, LARGE Custom, LONG Flags)</prototype>
      <input>
        <param type="FUNCTION *" name="Callback">The routine that will be called when a file change is triggered by the system.</param>
        <param type="LARGE" name="Custom">A custom 64-bit value that will passed to the Callback routine as a parameter.</param>
        <param type="LONG" name="Flags" lookup="MFF">Filter events to those indicated in these flags.</param>
      </input>
      <description>
<p>The WatchFile() function configures event based reporting for changes to any file or folder in the file system. The capabilities of this method are dependent on the host platform, with Windows and Linux systems being able to support most of the current feature set.</p>
<p>The path that will be monitored is determined by the File object's <field>Path</field> field.  Both files and folders are supported as targets.</p>
<p>The optional MFF Flags are used to filter events to those that are desired for monitoring.</p>
<p>The client must provide a Callback that will be triggered when a monitored event is triggered.  The Callback must follow the format <code>ERROR Routine(*File, STRING Path, LARGE Custom, LONG Flags)</code></p>
<p>Each event will be delivered in the sequence that they are originally raised.  The Flags parameter will reflect the specific event that has occurred.  The Custom parameter is identical to the Custom argument originally passed to this method.  The Path is a string that is relative to the File's <field>Path</field> field.</p>
<p>If the callback routine returns ERR_Terminate, the watch will be disabled.  It is also possible to disable an existing watch by calling this method with no parameters, or by setting the Flags parameter to 0.</p>
      </description>
      <result>
        <error code="NullArgs">Function call missing argument value(s)</error>
        <error code="Okay">Operation successful.</error>
        <error code="Args">Invalid arguments passed to function.</error>
      </result>
    </method>

  </methods>

  <fields>
    <field>
      <name>Buffer</name>
      <comment>Points to the internal data buffer if the file content is held in memory.</comment>
      <access read="G">Get</access>
      <type>BYTE *</type>
      <description>
<p>If a file has been created with an internal buffer (by setting the BUFFER flag on creation), this field will point to the address of that buffer.  The size of the buffer will match the <field>Size</field> field.</p>
      </description>
    </field>

    <field>
      <name>Created</name>
      <comment>The creation date stamp of the file.</comment>
      <access read="G" write="W">Get/Write</access>
      <type>APTR</type>
      <description>
<p>The Date field allows you to obtain the time at which the file was last date-stamped, or you can use it to set a new file date.  By default, the 'modification date' is targeted by this field's support routine.  Please note that if the file is open for writing, then date-stamped, then written; the file system driver will normally change the date stamp to the time at which the file was last modified.</p>
<p>To simplify time management, information is read and set via a <struct>DateTime</struct> structure.</p>
      </description>
    </field>

    <field>
      <name>Date</name>
      <comment>The 'last modified' date stamp on the file.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>APTR</type>
      <description>
<p>The Date field reflects the time at which the file was last modified.  It can also be used to set a new modification date.  Please note that if the file is open for writing, then date-stamped, then modified; the file system driver will overwrite the previously defined date stamp with the time at which the file was last written.</p>
<p>Information is read and set using a standard <struct>DateTime</struct> structure.</p>
      </description>
    </field>

    <field>
      <name>Flags</name>
      <comment>File flags and options.</comment>
      <access read="R" write="I">Read/Init</access>
      <type lookup="FL">INT</type>
      <description>
<types lookup="FL"/>
      </description>
    </field>

    <field>
      <name>Group</name>
      <comment>Retrieve or change the group ID of a file.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>INT</type>
      <description>
<p>The group ID assigned to a file can be read from this field.  The ID is retrieved from the file system in real time in case the ID has been changed after initialisation of the file object.</p>
<p>You can also change the group ID of a file by writing an integer value to this field.</p>
<p>If the file system does not support group ID's, ERR_NoSupport is returned.</p>
      </description>
    </field>

    <field>
      <name>Handle</name>
      <comment>The native system handle for the file opened by the file object.</comment>
      <access read="G">Get</access>
      <type>BIGINT</type>
      <description>
<p>This field returns the native file system handle for the file opened by the file object.  The native handle may be an integer or pointer value in 32 or 64-bit format.  In order to manage this issue in a multi-platform manner, the value is returned as a 64-bit integer.</p>
      </description>
    </field>

    <field>
      <name>Icon</name>
      <comment>A path to an icon image that is suitable for representing the file in a user interface.</comment>
      <access read="G">Get</access>
      <type>STRING</type>
      <description>
<p>This field returns the name of the best icon to use when representing the file to the user, for instance in a file list.  The icon style is determined by analysing the File's <field>Path</field>.</p>
<p>The resulting string is returned in the format <code>icons:category/name</code> and can be opened with the <class name="Picture">Picture</class> class.</p>
      </description>
    </field>

    <field>
      <name>Link</name>
      <comment>Returns the link path for symbolically linked files.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>STRING</type>
      <description>
<p>If a file represents a symbolic link (indicated by the SYMLINK flag setting) then reading the Link field will return the link path.  No assurance is made as to the validity of the path.  If the path is not absolute, then the parent folder containing the link will need to be taken into consideration when calculating the path that the link refers to.</p>
      </description>
    </field>

    <field>
      <name>Path</name>
      <comment>Specifies the location of a file or folder.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>STRING</type>
      <description>
<p>This field is required for initialisation and must either be in the format of a universal path string, or a path that is compatible with the host system.  The standard format for a universal path is <code>volume:folder/file</code>, for instance <code>parasol:system/classes.bin</code>.</p>
<p>To reference a folder in a way that is distinct from a file, use a trailing slash as in <code>volume:folder/</code>.</p>
<p>Referencing a <code>volume:</code> is optional.  In the event that a volume is not defined, the current working path is used as the point of origin.</p>
<p>The accepted method for referencing parent folders is <code>../</code>, which can be repeated for as many parent folders as needed to traverse the folder hierarchy.</p>
      </description>
    </field>

    <field>
      <name>Permissions</name>
      <comment>Manages the permissions of a file.</comment>
      <access read="G" write="S">Get/Set</access>
      <type lookup="PERMIT">INT</type>
      <description>
<types lookup="PERMIT"/>
      </description>
    </field>

    <field>
      <name>Position</name>
      <comment>The current read/write byte position in a file.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>BIGINT</type>
      <description>
<p>This field indicates the current byte position of an open file (this affects read and write operations).  Writing to this field performs a <action>Seek</action> operation.</p>
<p>The Position will always remain at zero if the file object represents a folder.</p>
      </description>
    </field>

    <field>
      <name>ResolvedPath</name>
      <comment>Returns a resolved copy of the Path string.</comment>
      <access read="G">Get</access>
      <type>STRING</type>
      <description>
<p>The ResolvedPath will return a resolved copy of the <field>Path</field> string.  The resolved path will be in a format that is native to the host platform.  Please refer to the <function module="Core">ResolvePath</function> function for further information.</p>
      </description>
    </field>

    <field>
      <name>Size</name>
      <comment>The byte size of a file.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>BIGINT</type>
      <description>
<p>The current byte size of a file is indicated by this field.  If the file object represents a folder, the Size value will be set to zero.  You can also truncate a file by setting the Size; this will result in the current read/write position being set to the end of the file.</p>
      </description>
    </field>

    <field>
      <name>Static</name>
      <comment>Set to TRUE if a file object should be static.</comment>
      <access read="R" write="I">Read/Init</access>
      <type>INT</type>
      <description>
<p>This field applies when a file object has been created in an object script.  By default, a file object will auto-terminate when a closing tag is received.  If the object must remain live, set this field to TRUE.</p>
      </description>
    </field>

    <field>
      <name>Target</name>
      <comment>Specifies a surface ID to target for user feedback and dialog boxes.</comment>
      <access read="R" write="W">Read/Write</access>
      <type>OBJECTID</type>
      <description>
<p>User feedback can be enabled for certain file operations by setting the Target field to a valid surface ID (for example, the Desktop object) or zero for the default target for new windows.  This field is set to -1 by default, in order to disable this feature.</p>
<p>If set correctly, operations such as file deletion or copying will pop-up a progress box after a certain amount of time has elapsed during the operation.  The dialog box will also provide the user with a Cancel option to terminate the process early.</p>
      </description>
    </field>

    <field>
      <name>TimeStamp</name>
      <comment>The last modification time set on a file, represented as a 64-bit integer.</comment>
      <access read="G">Get</access>
      <type>BIGINT</type>
      <description>
<p>The TimeStamp field is a 64-bit representation of the last modification date/time set on a file.  It is not guaranteed that the value represents seconds from the epoch, so it should only be used for purposes such as sorting, or for comparison to the time stamps of other files.  For a parsed time structure, refer to the <field>Date</field> field.</p>
      </description>
    </field>

    <field>
      <name>User</name>
      <comment>Retrieve or change the user ID of a file.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>INT</type>
      <description>
<p>The user ID assigned to a file can be read from this field.  The ID is retrieved from the file system in real time in case the ID has been changed after initialisation of the file object.</p>
<p>You can also change the user ID of a file by writing an integer value to this field.  This can only be done post-initialisation or an error code will be returned.</p>
<p>If the filesystem does not support user ID's, ERR_NoSupport is returned.</p>
      </description>
    </field>

  </fields>
  <types>
    <constants lookup="FDB" comment="Feedback event indicators.">
      <const name="DECOMPRESS_FILE"/>
      <const name="COMPRESS_FILE"/>
      <const name="REMOVE_FILE"/>
      <const name="DECOMPRESS_OBJECT"/>
    </constants>

    <constants lookup="VLF" comment="VlogF flags">
      <const name="ERROR"/>
      <const name="WARNING"/>
      <const name="DEBUG"/>
      <const name="FUNCTION"/>
      <const name="TRACE"/>
      <const name="CRITICAL"/>
      <const name="BRANCH"/>
    </constants>

    <constants lookup="MOF" comment="Module flags">
      <const name="LINK_LIBRARY">Module refers to a symbolic link library (e.g. libz DLL or SO)</const>
      <const name="STATIC">This flag prevents the loaded module code from being unloaded when the module object is freed.  This may be needed in cases where a module is designed with the presumption that it will remain in memory after being loaded by the developer.</const>
      <const name="SYSTEM_PROBE">Indicates that the module is being probed.  Do not use outside of the core library.</const>
    </constants>

    <constants lookup="CNF" comment="Flags for the Config class.">
      <const name="STRIP_QUOTES">Removes quotes from key values that are quote-encapsulated.</const>
      <const name="LOCK_RECORDS">Locks existing keys so that they can't be overwritten.  It will still be possible to add new keys to the config object.</const>
      <const name="NEW">On initialisation, do not load any data from the referenced configuration file.</const>
      <const name="FILE_EXISTS">Setting this flag will force the config class to fail if the source file defined in Path does not exist.</const>
      <const name="AUTO_SAVE">When the configuration object is freed, automatically save the configuration data back to the original file source.</const>
    </constants>

    <constants lookup="EVG" comment="Event categories.">
      <const name="FILESYSTEM">File system events.</const>
      <const name="NETWORK">Network events.</const>
      <const name="SYSTEM">System-wide events</const>
      <const name="GUI">Events generated by the Graphical User Interface.</const>
      <const name="DISPLAY">Video display events.</const>
      <const name="IO">Input/Output events.</const>
      <const name="HARDWARE">Hardware device events that are not covered by other types.</const>
      <const name="AUDIO">Audio system events.</const>
      <const name="USER">User activity events (such as user login).</const>
      <const name="POWER">Power Management - can also include app-specific events relating to resource management.</const>
      <const name="CLASS">Custom event dispatched from a class that doesn't fit within the rest of the event framework</const>
      <const name="APP">Custom event dispatched from an application</const>
      <const name="ANDROID">Android specific events that do not already fit existing categories.</const>
    </constants>

    <constants lookup="SCF" comment="Script flags">
      <const name="DEBUG">Enables execution debugging.  More information will be printed to the console in this mode.</const>
      <const name="EXIT_ON_ERROR">The script will automatically terminate its execution process if an error is detected.</const>
    </constants>

    <constants lookup="LTF" comment="Flags for ListTasks()">
      <const name="CURRENT_PROCESS"/>
    </constants>

    <constants lookup="SBF" comment="Flags for StrBuildArray()">
      <const name="NO_DUPLICATES">Sort the resulting list and remove duplicated strings.</const>
      <const name="SORT">Sort the resulting list.</const>
      <const name="CSV">The list is in CSV format and the Size and Total parameters should be ignored. Note that the source string will be modified in this mode.</const>
      <const name="DESC">Sort in descending order.</const>
      <const name="CASE">Use case-sensitivity when comparing strings in the list.</const>
    </constants>

    <constants lookup="STT" comment="Types for StrDatatype().">
      <const name="NUMBER">The string represents a whole number.</const>
      <const name="FLOAT">The string represents a floating point number.</const>
      <const name="HEX">The string represents a hexadecimal number.</const>
      <const name="STRING">The string represents plain-text.</const>
    </constants>

    <constants lookup="IDTYPE" comment="Types for AllocateID()">
      <const name="MESSAGE">Message ID's are allocated for the purpose of sending uniquely identifiable messages between tasks.</const>
      <const name="GLOBAL">Global ID's have no specific association with anything.</const>
      <const name="FUNCTION">Function ID's are used to track FUNCTION types and are assigned to the function ID field.</const>
    </constants>

    <constants lookup="THF" comment="Thread flags">
      <const name="AUTO_FREE">Automatically destroy the Thread object when the user routine has completed.</const>
      <const name="MSG_HANDLER">Allow the thread to handle messages that target objects that it has created.</const>
    </constants>

    <constants lookup="DEVICE">
      <const name="TEMPORARY">All storage is temporary</const>
      <const name="MEMORY">Device is RAM, ROM, WORM, NVRAM, flashdisk or other form of memory.  Does not guarantee a fast connection as it could be over a slow USB 1.1 connection for example</const>
      <const name="REMOVABLE">Device media is removable from the hardware</const>
      <const name="SCANNER">Device is a two dimensional scanner.</const>
      <const name="MODEM">Device is a modem.</const>
      <const name="WRITE">Device is writeable</const>
      <const name="PRINTER_3D">Device is a three dimensional printer.</const>
      <const name="READ">Device is readable</const>
      <const name="COMPACT_DISC">Compact disc style device</const>
      <const name="PRINTER">Device is a paper-based printer.</const>
      <const name="TAPE">Tape/Stream style device</const>
      <const name="SCANNER_3D">Device is a three dimensional scanner.</const>
      <const name="NETWORK">Device represents a network link</const>
      <const name="HARD_DISK">Hard disk style device</const>
      <const name="USB">Removable USB storage device.  May be further qualified by DEVICE_HARDDISK, DEVICE_FLOPPYDISK etc</const>
      <const name="REMOVEABLE">Device media is removable from the hardware</const>
      <const name="SOFTWARE">Device is virtual/software defined</const>
      <const name="FLOPPY_DISK">Floppy disk style device</const>
    </constants>

    <constants lookup="SEF" comment="Optional flags for StrEvaluate()">
      <const name="KEEP_ESCAPE">Escaped string symbols will not be altered if this flag is used.</const>
      <const name="NO_SCRIPT">Turns off the embedded script feature.  An error code is returned if an attempt to embed a script is made.</const>
      <const name="IGNORE_QUOTES">Areas marked with double-quotes will not be translated.  The quote characters will also not be removed.</const>
      <const name="STRICT">Enforces strict processing.  An error code will always be returned if at least one of the translation attempts failed.  Failed translations will be unprocessed (normally they are removed from the resulting string).</const>
    </constants>

    <constants lookup="MSF" comment="Message flags.">
      <const name="MESSAGE_ID">The Type parameter refers to a unique message ID rather than a message type for this call.</const>
      <const name="WAIT">Wait before inserting the message if the queue is at maximum capacity.</const>
      <const name="ADD">The default behaviour - this will add the message to the end of the queue.</const>
      <const name="NO_DUPLICATE">If the Type parameter matches a message already inside the queue, the new message will not be added and the function will immediately return with ERR_Okay.</const>
      <const name="UPDATE">If the Type parameter matches a message already inside the queue, the data for that message will be deleted, then the new message will be added to the end of the queue.</const>
    </constants>

    <constants lookup="STR">
      <const name="WILDCARD">Allow the use of wildcard characters '|', '?' and '*'.</const>
      <const name="MATCH_LEN">The strings must be of equal length to be matched.</const>
      <const name="MATCH_CASE">Perform a case-sensitive match.</const>
      <const name="CASE">Perform a case-sensitive match.</const>
    </constants>

    <constants lookup="NSF" comment="Flags for NotifySubscribers">
      <const name="LOCAL">Only send messages to objects that are owned by the current process.</const>
      <const name="DELAY">Place all notifications on the message queue.</const>
      <const name="FORCE_DELAY">Place all notifications on the message queue.</const>
      <const name="OTHER_TASKS">Only send messages to objects that are owned by other processes.</const>
      <const name="EXCLUSIVE">Instead of messaging each object, the function will attempt to gain exclusive access to each of the subscribed objects and send the notification directly.</const>
      <const name="LOCAL_TASK">Only send messages to objects that are owned by the current process.</const>
    </constants>

    <constants lookup="AC" comment="Action identifiers.">
      <const name="ActionNotify"/>
      <const name="Activate"/>
      <const name="AccessObject"/>
      <const name="Clear"/>
      <const name="FreeWarning"/>
      <const name="OwnerDestroyed"/>
      <const name="CopyData"/>
      <const name="DataFeed"/>
      <const name="Deactivate"/>
      <const name="Draw"/>
      <const name="Flush"/>
      <const name="Focus"/>
      <const name="Free"/>
      <const name="ReleaseObject"/>
      <const name="GetVar"/>
      <const name="DragDrop"/>
      <const name="Hide"/>
      <const name="Init"/>
      <const name="Lock"/>
      <const name="LostFocus"/>
      <const name="Move"/>
      <const name="MoveToBack"/>
      <const name="MoveToFront"/>
      <const name="NewChild"/>
      <const name="NewOwner"/>
      <const name="NewObject"/>
      <const name="Redo"/>
      <const name="Query"/>
      <const name="Read"/>
      <const name="Rename"/>
      <const name="Reset"/>
      <const name="Resize"/>
      <const name="SaveImage"/>
      <const name="SaveToObject"/>
      <const name="Scroll"/>
      <const name="Seek"/>
      <const name="SetVar"/>
      <const name="Show"/>
      <const name="Undo"/>
      <const name="Unlock"/>
      <const name="Next"/>
      <const name="Prev"/>
      <const name="Write"/>
      <const name="SetField"/>
      <const name="Clipboard"/>
      <const name="Refresh"/>
      <const name="Disable"/>
      <const name="Enable"/>
      <const name="Redimension"/>
      <const name="MoveToPoint"/>
      <const name="ScrollToPoint"/>
      <const name="Custom"/>
      <const name="Sort"/>
      <const name="SaveSettings"/>
      <const name="SelectArea"/>
      <const name="END"/>
    </constants>

    <constants lookup="KSF" comment="Flags for VarNew()">
      <const name="THREAD_SAFE">Enable thread safety for a small performance penalty.</const>
      <const name="UNTRACKED">Do not track the key-store to the object with the current context.</const>
      <const name="CASE">Enable case-sensitive keys.</const>
      <const name="AUTO_REMOVE">Automatically call FreeResource() on remaining key values when FreeResource() is called for the key-store.</const>
    </constants>

    <constants lookup="CLF" comment="Flags for the MetaClass.">
      <const name="XML_CONTENT">Script processing should treat any object content as XML.</const>
      <const name="SHARED_ONLY">Forces all objects of this class to be shared.</const>
      <const name="PUBLIC_OBJECTS">Forces all class objects to be allocated in public memory.</const>
      <const name="SHARED_OBJECTS">Forces all objects of this class to be shared.</const>
      <const name="PROMOTE_INTEGRAL">Promote class support for any integral object defined in the class definition structure.</const>
      <const name="NO_OWNERSHIP">Objects created will not be tracked to the creating process, nor any parent object (SetOwner() will not work either).</const>
      <const name="PRIVATE_ONLY">Do not allow public-memory instances of the class (private-shared objects will still be possible).</const>
    </constants>

    <constants lookup="RFD" comment="Flags for RegisterFD()">
      <const name="WRITE">Activate the callback if there is room to write to the FD's buffer.</const>
      <const name="REMOVE">Stop monitoring this file descriptor.</const>
      <const name="SOCKET">Identifies the file descriptor as a socket (Linux systems only).</const>
      <const name="READ">Activate the callback if there is data available to read.</const>
      <const name="EXCEPT">Activate the callback if error conditions are pending.</const>
      <const name="RECALL">Set if the subscriber needs to manually check for incoming/outgoing data.  This is supported as a one-off check, so the flag will be disabled automatically when the subscriber is called.</const>
    </constants>

    <constants lookup="RP" comment="Path types for SetResourcePath()">
      <const name="MODULE_PATH">An alternative path leading to the system modules (normally 'system:modules/').  Introduced for platforms such as Android, where modules are stored in asset folders.</const>
      <const name="SYSTEM_PATH">The path of the 'system:' volume, which otherwise defaults to '[root]:system/'.</const>
      <const name="ROOT_PATH">Overrides the root path, which defaults to the location at which Parasol is installed.</const>
    </constants>

    <constants lookup="RES">
      <const name="MESSAGE_QUEUE">Use this resource to retrieve the message queue ID of the current task.</const>
      <const name="GLOBAL_INSTANCE">If a global instance is active, this resource holds the instance ID.  Otherwise the value is 0.</const>
      <const name="PRIVILEGED_USER">If this value is set to 1, the process will operate in privileged mode (typically this enables full administrator rights).  This feature will only work for Unix processes that are granted admin rights when launched.  Setting the Value to 0 reverts to the user's permission settings.  SetResource() will return an error code indicating the level of success.</const>
      <const name="PRIVILEGED">This is set to TRUE if the process has elevated privileges (such as superuser or administrative rights).</const>
      <const name="RANDOM_SEED">Changes the PRNG seed value for RandomNumber().</const>
      <const name="PARENT_CONTEXT">Read-only pointer to the parent object of the current context.</const>
      <const name="LOG_LEVEL">The current level of log detail (larger numbers indicate more detail).</const>
      <const name="TOTAL_SHARED_MEMORY">The total amount of shared memory in use.</const>
      <const name="MAX_PROCESSES">The maximum number of processes that can be supported at any time.</const>
      <const name="LOG_DEPTH">The current depth of log messages.</const>
      <const name="JNI_ENV">Return the current JNI environment string.</const>
      <const name="THREAD_ID">Return the ID of the current thread.</const>
      <const name="CURRENT_MSG">Returns a Message structure if the program is currently processing a message - otherwise returns NULL.  This resource type is meaningful only during a ProcessMessages call.</const>
      <const name="OPEN_INFO">Pointer to the OpenInfo structure originally used to initialise the system.</const>
      <const name="PROCESS_STATE">Life-cycle stage of the running process</const>
      <const name="TOTAL_MEMORY">The total amount of installed memory.</const>
      <const name="TOTAL_SWAP">The total amount of available swap space.</const>
      <const name="CPU_SPEED">The average top-speed of all CPU cores in Mhz.</const>
      <const name="FREE_MEMORY">The total amount of free memory.</const>
      <const name="FREE_SWAP">The total amount of free swap memory.</const>
      <const name="KEY_STATE">Maintains the state of key qualifiers such as caps-lock and the shift keys.</const>
      <const name="CORE_IDL">Refers to the Core module's compressed IDL string.</const>
    </constants>

    <constants lookup="CF" comment="Compression stream formats">
      <const name="GZIP">The 'gzip' format</const>
      <const name="ZLIB">The 'zlib' format</const>
      <const name="DEFLATE">The 'deflate' format</const>
    </constants>

    <constants lookup="CMF" comment="Compression flags">
      <const name="READ_ONLY">Forces read-only access, which is strongly recommended if an existing archive is being opened with no modifications intended.  If this flag is not set, initialisation can fail if the user does not have write access to the source file.</const>
      <const name="NEW">Force the creation of a new file archive.  Any existing file data at the target location will be destroyed.</const>
      <const name="APPLY_SECURITY">When decompressing, apply individual file permissions if they are available in the compression file.</const>
      <const name="NO_LINKS">Treat symbolic links as normal files/folders.</const>
      <const name="CREATE_FILE">Create a new archive only if the source file does not already exist.</const>
      <const name="PASSWORD">A password has been set on the object.</const>
    </constants>

    <constants lookup="PERMIT" comment="Permission flags">
      <const name="USER_EXEC">Synonym for EXEC</const>
      <const name="GROUP_WRITE">Group members can write.</const>
      <const name="GROUP">Synonym for GROUP_READ | GROUP_WRITE | GROUP_EXEC | GROUP_DELETE</const>
      <const name="GROUP_DELETE">Group members can delete.</const>
      <const name="ALL_EXEC">Synonym for EVERYONE_EXEC</const>
      <const name="OTHERS_EXEC">Others can execute.</const>
      <const name="OTHERS">Synonym for OTHERS_READ | OTHERS_WRITE | OTHERS_EXEC | OTHERS_DELETE</const>
      <const name="ALL_WRITE">Synonym for EVERYONE_WRITE</const>
      <const name="OTHERS_READ">Others can read.</const>
      <const name="OTHERS_DELETE">Others can delete.</const>
      <const name="EVERYONE_EXEC">Synonym for EXEC | GROUP_EXEC | OTHERS_EXEC</const>
      <const name="GROUP_READ">Group members can read.</const>
      <const name="GROUP_EXEC">Group members can execute.</const>
      <const name="ARCHIVE">Marks the file for future backup.  The flag should be cleared after the backup has succeeded.</const>
      <const name="OTHERS_WRITE">Others can write.</const>
      <const name="WRITE">User/Owner can write.</const>
      <const name="USER">Synonym for READ | WRITE | EXEC | DELETE</const>
      <const name="READ">User/Owner has read access.  This will not allow compiled code to be executed.</const>
      <const name="OFFLINE">File content for this networked file has not been cached on the local PC.</const>
      <const name="INHERIT">Inherit permissions from parent folder and logical OR them with preset permission flags.</const>
      <const name="PASSWORD">File is password protected.</const>
      <const name="DELETE">Owner can delete.  If the file system does not support this, deletion is enabled via the WRITE flag.</const>
      <const name="ALL_READ">Synonym for EVERYONE_READ</const>
      <const name="EVERYONE_READ">Synonym for READ | GROUP_READ | OTHERS_READ</const>
      <const name="NETWORK">File is hosted on another machine.</const>
      <const name="EVERYONE_READWRITE">Synonym for EVERYONE_READ | EVERYONE_WRITE</const>
      <const name="EVERYONE_WRITE">Synonym for WRITE | GROUP_WRITE | OTHERS_WRITE</const>
      <const name="USER_WRITE">Synonym for WRITE</const>
      <const name="EVERYONE_DELETE">Synonym for DELETE | GROUP_DELETE | OTHERS_DELETE</const>
      <const name="EVERYONE_ACCESS">Synonym for EVERYONE_READ | EVERYONE_WRITE | EVERYONE_EXEC | EVERYONE_DELETE</const>
      <const name="GROUPID">Allows executables to run with a set group id.</const>
      <const name="HIDDEN">Recommends that the file is hidden from view by default.</const>
      <const name="EXEC">User/Owner can execute.</const>
      <const name="ALL_DELETE">Synonym for EVERYONE_DELETE</const>
      <const name="USERID">Allows executables to run with a set user id.</const>
      <const name="USER_READ">Synonym for READ</const>
    </constants>

    <constants lookup="NF" comment="Flags that can be passed to NewObject().  If a flag needs to be stored with the object, it must be specified in the lower word.">
      <const name="PRIVATE"/>
      <const name="NAME">Use the Name parameter to name the created object.  This flag is not required if using NF_UNIQUE.</const>
      <const name="INTEGRAL">Integral objects can only be allocated by classes that need to adopt the functionality of said object.  Integral objects do not appear in the object tree, effectively making them hidden from view.</const>
      <const name="UNTRACKED">An object created with this flag will not be tracked back to the object that created it.  If combined with the NF_PUBLIC flag, the object can also remain in memory when the object's related task is terminated.</const>
      <const name="NO_TRACK">An object created with this flag will not be tracked back to the object that created it.  If combined with the NF_PUBLIC flag, the object can also remain in memory when the object's related task is terminated.</const>
      <const name="TIMER_SUB">Indicates that the object is subscribed to a timer Zinterval.</const>
      <const name="PUBLIC">Allocates a public object using shareable resources, allowing it to be accessed directly by any process.  Access is granted via exclusive access locks  - refer to the AccessObject() and ReleaseObject() functions.</const>
      <const name="RECLASSED">The object switched from the base-class to a sub-class during initialisation.</const>
      <const name="INITIALISED">Read-only indicator if the object has been initialised.</const>
      <const name="UNIQUE">Use to allocate an object that has a guaranteed unique name.  This will prevent code from shadowing any object that exists with the same name, which can be imperative when creating public objects.  If it is discovered that an identically named object exists, NewObject() will return ERR_ObjectExists.  This flag works in conjunction with the Name argument.</const>
      <const name="UNLOCK_FREE">Read-only indicator for when the object is marked for deletion.</const>
      <const name="MESSAGE">Action has been called against the object through the message system (managed by ProcessMessages()).</const>
      <const name="FOREIGN_OWNER">Read-only indicator for when an object's parent is in a foreign process.</const>
      <const name="FREE">Read-only indicator for when the object is being freed.</const>
    </constants>

    <constants lookup="CCF" comment="Class categories">
      <const name="IO">IO classes manage hardware and software based input and output.</const>
      <const name="SYSTEM">System classes are designed to provide low-level services related to system management.</const>
      <const name="MISC">Miscellaneous classes do not fit into any of the other available categories.</const>
      <const name="NETWORK">Network classes interface with network drivers to simplify network communications for the developer.</const>
      <const name="AUDIO">Audio classes interface with audio hardware and drivers for audio playback and recording purposes.</const>
      <const name="EFFECT">Effect classes draw graphics and/or play audio for non-productive demonstration purposes.</const>
      <const name="DRAWABLE">Drawable classes provide graphical areas that are designed to be drawn to.</const>
      <const name="MULTIMEDIA"/>
      <const name="DATA">Data classes parse, query and manipulate data.</const>
      <const name="TOOL">Tool classes are focussed on providing interactive services to the user.</const>
      <const name="FILESYSTEM">FileSystem classes are based on file management and interaction with file based data.</const>
      <const name="COMMAND">Command classes perform specific procedures, like copying or moving a file, managing volumes or executing a program.</const>
      <const name="GUI">GUI classes are used in the development of graphical user interfaces.</const>
      <const name="GRAPHICS">Graphics classes provide graphical manipulation and drawing services to developers.</const>
    </constants>

    <constants lookup="IDF" comment="IdentifyFile() values">
      <const name="SECTION">Return the name of the Config section that supports the file association, rather than an executable command.</const>
      <const name="IGNORE_HOST">Ignore the host platform's file assocations.</const>
      <const name="HOST">Query the host platform's file associations only.</const>
    </constants>

    <constants lookup="MEM" comment="Memory types used by AllocMemory().  The lower 16 bits are stored with allocated blocks, the upper 16 bits are function-relative only.">
      <const name="NO_BLOCK">If this flag is set against a public memory block then the access blocking mechanism will be permanently turned off for all accesses to that particular memory block.  This means that multiple tasks can have full read/write access to the memory block at once regardless of the flags passed to AccessMemory().</const>
      <const name="FIXED">This flag can be applied to public memory blocks that need to be mapped to a fixed address that is common to all tasks.  For instance, if the system locks the memory block to address 0x56084000 for your task, then all other tasks that map the memory block will also see it at that address.  This flag is typically used for supporting absolute code execution.</const>
      <const name="READ_WRITE">Synonym for READ | WRITE</const>
      <const name="WRITE">The memory is explicitly marked as writeable.</const>
      <const name="NO_BLOCKING">If this flag is set against a public memory block then the access blocking mechanism will be permanently turned off for all accesses to that particular memory block.  This means that multiple tasks can have full read/write access to the memory block at once regardless of the flags passed to AccessMemory().</const>
      <const name="CALLER">This flag is usable only in routines that are supporting a class method.  It forces the memory allocation to be tracked to the object that made the method call.  This is particularly important in methods that return memory blocks that do not form a part of the object itself.</const>
      <const name="UNTRACKED">Allocating an untracked memory block will prevent the memory block from being tracked back to the object holding the current context.</const>
      <const name="MANAGED">Enables custom resource management for the memory block.  The start of the block will need to be reserved with a pointer to a ResourceManager structure, which is included as part of the block's declared Size.  The Free() callback will be called when the block is removed.</const>
      <const name="NO_LOCK">For AllocMemory() only, indicates that the (private) memory block should not be locked on return.</const>
      <const name="TASK">Track the memory block to the current process, as opposed to the current object.</const>
      <const name="SHARED">Public memory can be allocated by specifying this flag.  Public memory blocks are accessible by all tasks, but access can only be gained by knowing the unique memory ID and utilising the AccessMemory() function.</const>
      <const name="RESERVED">This special flag is used to allocate shared memory blocks that require reserved ID numbers.  When using the MEM_RESERVED flag, you are required to set the longword pointed to by the ID argument to the ID that you wish to reserve.  If that memory ID is already taken, the AllocMemory() call will fail.</const>
      <const name="DATA">The default type, MEM_DATA, is used to indicate a standard memory allocation from system RAM.</const>
      <const name="PUBLIC">Public memory can be allocated by specifying this flag.  Public memory blocks are accessible by all tasks, but access can only be gained by knowing the unique memory ID and utilising the AccessMemory() function.</const>
      <const name="AUDIO">Identifies the memory space as being reserved by an audio device such as a sound card.</const>
      <const name="NO_POOL">Gives a hint to the allocator to allocate the block outside of the memory pool.</const>
      <const name="READ">The memory is explicitly marked as readable.</const>
      <const name="NO_CLEAR">Do not clear the memory on allocation (saves time).</const>
      <const name="CODE">Indicates that the memory will contain executable program code.</const>
      <const name="HIDDEN">Hidden blocks are not recorded and are excluded from resource tracking.</const>
      <const name="TMP_LOCK">Enables temporary locking restrictions.  Prevents processes from sleeping while holding a lock on the memory block.</const>
      <const name="STRING">Identifies the memory content as a null terminated string. Useful for debugging and run-time type identification in scripts.</const>
      <const name="TEXTURE">The memory space is reserved by a video driver for hosting texture graphics.</const>
      <const name="VIDEO">The memory space is reserved by a video device such as a graphics card for display purposes, e.g. framebuffer.</const>
    </constants>

    <constants lookup="ALF">
      <const name="SHARED">The lock will be shared between foreign processes.</const>
      <const name="RECURSIVE">Set if support for recursive locking within the same thread is required.</const>
    </constants>

    <constants lookup="RSF" comment="Flags for ResolvePath()">
      <const name="PATH">Use the PATH environment variable to resolve the file name in the Path parameter.</const>
      <const name="NO_FILE_CHECK">Do not test for the existence of the targeted file or folder during the resolution process.</const>
      <const name="APPROXIMATE">Ignores file extensions for the purpose of file name matching.</const>
      <const name="CHECK_VIRTUAL">If the volume referenced by Path is traced to another volume that is reserved by a virtual file system driver, ERR_VirtualVolume is returned. The volume is still resolved as far as possible and the resulting path will be returned by this function.</const>
      <const name="CASE_SENSITIVE">For use on host systems that use case-insensitive file systems such as Windows; this option checks that the discovered file is a case-sensitive match to the Path.</const>
      <const name="NO_DEEP_SCAN">Do not perform more than one iteration when resolving the source file path.</const>
    </constants>

    <constants lookup="RDF" comment="Flags for the OpenDir() function.">
      <const name="LINK">Feedback only - file/folder is actually a link to another location.</const>
      <const name="ARCHIVE">Feedback only - archive bit is set.</const>
      <const name="QUALIFIED">Return fully qualified folder names (i.e. trailing slash or colon for each name).</const>
      <const name="QUALIFY">Return fully qualified folder names (i.e. trailing slash or colon for each name).</const>
      <const name="VIRTUAL">Path is to a virtual device.</const>
      <const name="READ_ALL">Synonym for SIZE | DATE | PERMISSIONS | FILES | FOLDERS</const>
      <const name="READ_ONLY">Read-only (not permissions related and might indicate read-only media).</const>
      <const name="SIZE">Retrieve the byte size of each file.</const>
      <const name="PERMISSIONS">Get permission/security information.</const>
      <const name="FILES">Read all files in the folder.</const>
      <const name="STREAM">Path is connected via a stream, e.g. network connection.</const>
      <const name="DATE">Retrieve the date stamp of each file.</const>
      <const name="FOLDER">Read all folders/volumes in the folder.</const>
      <const name="VOLUME">Feedback only - indicates a volume.</const>
      <const name="HIDDEN">Feedback only - file/folder is hidden.</const>
      <const name="FILE">Read all files in the folder.</const>
      <const name="TAGS">Receive additional information for each file, such as comments, author and copyright.  The results are stored in the Tags field of each file.</const>
      <const name="TIME">Retrieve the date stamp of each file.</const>
      <const name="FOLDERS">Read all folders/volumes in the folder.</const>
    </constants>

    <constants lookup="MFF" comment="Flags for the File Watch() method.">
      <const name="MOVED">Existing file moved or renamed.</const>
      <const name="UNMOUNT">Host filesystem was unmounted.</const>
      <const name="ATTRIB">File permissions or datestamp changed.</const>
      <const name="DEEP">Receive notifications from sub-folders (Windows only).</const>
      <const name="CLOSED">An opened file has been closed.</const>
      <const name="FILE">File identifier; if passed to Watch() then indicates a preference for file events only.</const>
      <const name="FOLDER">Folder identifier; if passed to Watch() then indicates a preference for folder events only.</const>
      <const name="WRITE">File modified via write or truncation.</const>
      <const name="SELF">Event applies to the monitored folder and not a contained item</const>
      <const name="OPENED">Existing file was opened.</const>
      <const name="RENAME">Existing file moved or renamed.</const>
      <const name="READ">File was accessed (read).</const>
      <const name="CREATE">New file/link created or renamed in folder.</const>
      <const name="DELETE">Existing file deleted</const>
      <const name="MODIFY">File modified via write or truncation.</const>
    </constants>

    <constants lookup="LOC" comment="AnalysePath() values">
      <const name="DIRECTORY">The path refers to a folder.</const>
      <const name="VOLUME">The path refers to a volume name.</const>
      <const name="FILE">The path refers to a file.</const>
    </constants>

    <constants lookup="ACF" comment="AssociateCmd() values">
      <const name="ALL_USERS">Apply the command link to all users for that file type.  This will cause an error if sufficient privileges are not available to the logged-in user.</const>
    </constants>

    <constants lookup="TSF" comment="Task flags">
      <const name="PIPE">Enable the output pipe to the launched process so that it can read data.</const>
      <const name="SHELL">Enables shell mode.  On Unix systems, this means that a shell (usually BASH) will be used to launch the process.</const>
      <const name="DEBUG">Additional debug messages will be printed during normal usage of the task class when this flag is set.</const>
      <const name="WAIT">This flag will cause the parent process to halt when the task is activated.  Control is returned to the parent process once the child process terminates.</const>
      <const name="QUIET">Setting this flag will divert all process output to /dev/null or the nearest equivalent for non-Unix systems.</const>
      <const name="RESET_PATH">If set, the executed process will start in its own folder rather than the folder of the parent process.</const>
      <const name="FOREIGN">Set this flag when using the task object to execute a foreign process - that is an executable that does not use the Parasol API.</const>
      <const name="ATTACHED">Forces new task to be attached to the parent (child will close when parent closes).</const>
      <const name="DETACHED">Forces new task to be detached from the parent.</const>
      <const name="PRIVILEGED">During a normal execution process, any privileges of the parent process will be dropped so that the child process runs unprivileged.  This behaviour can be reversed if he PRIVILEGED flag is set, in which case the child process has the same privileges as the parent.</const>
    </constants>

    <constants lookup="FDT" comment="Flags for the SetDate() file method.">
      <const name="MODIFIED">The date on which the file was last modified.</const>
      <const name="CREATED">The date on which the file was created.  On some host platforms this datestamp may be read-only.</const>
      <const name="ACCESSED">The date on which the file was last accessed by a user or application.</const>
      <const name="ARCHIVED">The date on which the file was most recently archived.  Not supported by most filesystems.</const>
    </constants>

    <constants lookup="LDF" comment="Flags for LoadFile()">
      <const name="IGNORE_STATUS">The timestamp and size of the file will not be checked, which will result in the cached version of the file being returned regardless of any recent file changes.</const>
      <const name="CHECK_EXISTS">Limits the routine to checking the file cache for the existence of the file.  If found, the relevant cache entry is returned. The open count is not incremented by this action (it is therefore unnecessary to follow-up with a call to UnloadFile()).  If no up-to-date cache entry is available, ERR_Search is returned.</const>
    </constants>

    <constants lookup="FL" comment="File flags">
      <const name="LINK">Read-Only.  Indicates that the file is a symbolic link or shortcut to another file.</const>
      <const name="EXCLUDE_FOLDERS">Exclude folders when scanning this folder.</const>
      <const name="DEVICE">The file is a system device (must set if opening a device for read/write operations)</const>
      <const name="APPROXIMATE">Allows fuzzy matching of the file path when opening an existing file.  This means that the file extension will be ignored; for instance attempting to open a file of 'screenshot.png' when only a file name of 'screenshot.jpg' exists in the same folder, the 'screenshot.jpg' file will be opened instead.  If multiple files could potentially match to the file name, the file object will select the first match that is encountered.</const>
      <const name="EXCLUDE_FILES">Exclude files when scanning this folder.</const>
      <const name="RESET_DATE">For internal use only</const>
      <const name="STREAM">File data is streamed (e.g. PIPE, FIFO, socket) and may be accessed locally or via a network.</const>
      <const name="WRITE">Prepares a file for writing data, starting at byte position 0.  To start writing from the end of a file, use the Seek action after the file has been initialised.</const>
      <const name="DIRECTORY">The file object represents a folder.</const>
      <const name="NEW">Required when creating a new file.  If a file with the same name exists, its contents will be destroyed. If however the existing file is locked, the initalisation process will fail.</const>
      <const name="FILE">Explicitly declares the file object as an entity that stores content (as opposed to a device or folder for example).</const>
      <const name="READ">Required if the file needs to be opened for read access.</const>
      <const name="BUFFER">Activates a special mode in which the file data is stored in a memory buffer rather than a disk file.  Set the Size field to a value of at least 1 so that the initial buffer size is configured.  In this mode many of the available file operations are meaningless except for the Read, Write and Seek actions.</const>
      <const name="FOLDER">The file object represents a folder.</const>
      <const name="LOOP">In loop mode, the file object's position marker for read/write operations is allowed to extend past the actual file size.  Any read/write operation beyond the file size will loop back to the file at a corrected offset - for example, reading position 330 of a 100 byte file will start the operation from the 30th byte.  Loop mode does not affect any other area besides the read, write and seek operations.  The loop feature is typically used to create multimedia data streams with minimal effort.</const>
    </constants>

  </types>
  <structs>
    <struct name="rkBase64Decode" comment="Private structure for the StrBase64Decode() function." typeName="BASE64DECODE">
      <field name="Step" type="UBYTE">Internal</field>
      <field name="PlainChar" type="UBYTE">Internal</field>
      <field name="Initialised" type="UBYTE">Internal</field>
    </struct>

    <struct name="FileInfo" comment="Returned by GetFileInfo()">
      <field name="Size" type="LARGE">The size of the file's content.</field>
      <field name="TimeStamp" type="LARGE">64-bit time stamp - usable only for comparison (e.g. sorting).</field>
      <field name="Next" type="struct FileInfo *">Next structure in the list, or NULL.</field>
      <field name="Name" type="STRING">The name of the file.  This string remains valid until the next call to GetFileInfo().</field>
      <field name="Tags" type="struct KeyStore *">A store of special tag strings that are file-specific.</field>
      <field name="Flags" type="LONG" lookup="FL">Additional flags to describe the file.</field>
      <field name="Permissions" type="LONG" lookup="PERMIT">Standard permission flags.</field>
      <field name="UserID" type="LONG">User  ID (Unix systems only).</field>
      <field name="GroupID" type="LONG">Group ID (Unix systems only).</field>
      <field name="Created" type="struct DateTime">The date/time of the file's creation.</field>
      <field name="Modified" type="struct DateTime">The date/time of the last file modification.</field>
    </struct>

    <struct name="ChildEntry" comment="Structure for ListChildren() function">
      <field name="ObjectID" type="OBJECTID">Object ID</field>
      <field name="ClassID" type="CLASSID">The class ID of the referenced object.</field>
    </struct>

    <struct name="Field" comment="Used to describe the public fields of a class.">
      <field name="Arg" type="MAXINT">An option to complement the field type.  Can be a pointer or an integer value</field>
      <field name="GetValue" type="FUNCTION *" prototype="ERROR (*GetValue)(APTR, APTR)">A virtual function that will retrieve the value for this field.</field>
      <field name="SetValue" type="APTR">A virtual function that will set the value for this field.</field>
      <field name="WriteValue" type="FUNCTION *" prototype="ERROR (*WriteValue)(OBJECTPTR, struct Field *, LONG, const void *, LONG)">An internal function for writing to this field.</field>
      <field name="Name" type="CSTRING">The English name for the field, e.g. "Width"</field>
      <field name="FieldID" type="ULONG">Provides a fast way of finding fields, e.g. FID_WIDTH</field>
      <field name="Offset" type="UWORD">Field offset within the object</field>
      <field name="Index" type="UWORD">Field array index</field>
      <field name="Flags" type="LONG">Special flags that describe the field</field>
    </struct>

    <struct name="Function" comment="Function list array structure">
      <field name="Address" type="APTR">Pointer to the function entry point</field>
      <field name="Name" type="CSTRING">Name of the function</field>
      <field name="Args" type="const struct FunctionField *">A list of parameters accepted by the function</field>
    </struct>

    <struct name="MemoryLocks" comment="A supplement structure for ListTasks.">
      <field name="MemoryID" type="MEMORYID">Reference to a memory ID.</field>
      <field name="Locks" type="WORD">The total number of locks on the memory block.</field>
    </struct>

    <struct name="MemInfo" typeName="MEMINFO">
      <field name="Start" type="APTR">The starting address of the memory block (does not apply to public blocks).</field>
      <field name="ObjectID" type="OBJECTID">The object that owns the memory block.</field>
      <field name="Size" type="LONG">The size of the memory block.</field>
      <field name="AccessCount" type="WORD">Total number of active locks on this block.</field>
      <field name="Flags" type="WORD">The type of memory.</field>
      <field name="MemoryID" type="MEMORYID">The unique ID for this block.</field>
      <field name="LockID" type="OBJECTID">Reference to the task that currently has a lock on the block.</field>
      <field name="TaskID" type="OBJECTID">The Task that owns the memory block</field>
      <field name="Handle" type="LONG">Native system handle (e.g. the shmid in Linux)</field>
    </struct>

    <struct name="ListTasks" comment="Structure for ListTasks()">
      <field name="ProcessID" type="LONG">Core process ID</field>
      <field name="TaskID" type="OBJECTID">Task ID for this array entry</field>
      <field name="WaitingProcessID" type="LONG">If the task is waiting, this field reflects the other task's ID</field>
      <field name="WaitingMemoryID" type="MEMORYID">If the task is waiting, this field reflects the memory ID</field>
      <field name="WaitingTime" type="LONG">If the task is waiting, the time at which the sleep started (msec)</field>
      <field name="MessageID" type="MEMORYID">Message queue ID</field>
      <field name="OutputID" type="OBJECTID">The object that the task should output information to</field>
      <field name="Semaphore" type="HOSTHANDLE">Semaphore for IPC</field>
      <field name="InstanceID" type="LONG">Instance that the task belongs to</field>
      <field name="TotalMemoryLocks" type="LONG">Total number of held memory locks</field>
      <field name="ModalID" type="OBJECTID">Refers to any surface that currently holds a modal lock.</field>
      <field name="MemoryLocks" type="struct MemoryLocks *">An array of memory locks currently held by the process.</field>
    </struct>

    <struct name="DirInfo" comment="Used by OpenDir() only">
      <field name="Info" type="struct FileInfo *">Pointer to a FileInfo structure</field>
    </struct>

    <struct name="CompressedItem">
      <field name="OriginalSize" type="LARGE">Original size of the file</field>
      <field name="CompressedSize" type="LARGE">Compressed size of the file</field>
      <field name="Next" type="struct CompressedItem *">Used only if this is a linked-list.</field>
      <field name="Path" type="CSTRING">Path to the file (includes folder prefixes).  Archived folders will include the trailing slash.</field>
      <field name="Tags" type="struct KeyStore *">Any archive specific information is expressed here as key value pairs.</field>
      <field name="Permissions" type="LONG" lookup="PERMIT">Original permissions - see PERMIT flags.</field>
      <field name="UserID" type="LONG">Original user ID</field>
      <field name="GroupID" type="LONG">Original group ID</field>
      <field name="OthersID" type="LONG">Original others ID</field>
      <field name="Flags" type="LONG" lookup="FL">FL flags</field>
      <field name="Created" type="struct DateTime">Date and time of the file's creation.</field>
      <field name="Modified" type="struct DateTime">Date and time last modified.</field>
    </struct>

    <struct name="SystemState" comment="Returned by the GetSystemState() function.">
      <field name="ErrorMessages" type="CSTRING *">A sorted array of all error codes, translated into human readable strings.</field>
      <field name="ErrorHeaders" type="CSTRING *">A sorted array of all error header codes, translated into human readable strings.</field>
      <field name="RootPath" type="CSTRING">The current root path, which defaults to the location of the installation folder.</field>
      <field name="SystemPath" type="CSTRING">The current path of the 'system:' volume.</field>
      <field name="ModulePath" type="CSTRING">The current path to the system modules, normally 'system:modules/'</field>
      <field name="Platform" type="CSTRING">String-based field indicating the user's platform.  Currently returns 'Native', 'Windows', 'OSX' or 'Linux'.</field>
      <field name="ConsoleFD" type="HOSTHANDLE">Internal</field>
      <field name="CoreVersion" type="LONG">Reflects the Core version number.</field>
      <field name="CoreRevision" type="LONG">Reflects the Core revision number.</field>
      <field name="InstanceID" type="LONG">This is the ID of the instance that the calling process resides in.</field>
      <field name="TotalErrorMessages" type="LONG">The total number of error codes listed in the ErrorMessages array.</field>
      <field name="TotalErrorHeaders" type="LONG">The total number of error headers listed in the ErrorHeaders array.</field>
      <field name="Stage" type="LONG">The current operating stage.  -1 = Initialising, 0 indicates normal operating status; 1 means that the program is shutting down; 2 indicates a program restart; 3 is for mode switches.</field>
    </struct>

    <struct name="FileFeedback">
      <field name="Size" type="LARGE">Size of the file</field>
      <field name="Position" type="LARGE">Current seek position within the file if moving or copying</field>
      <field name="Path" type="STRING">Path to the file</field>
      <field name="Dest" type="STRING">Destination file/path if moving or copying</field>
      <field name="FeedbackID" type="LONG" lookup="FDB">Set to one of the FDB integers</field>
      <field name="Reserved" type="char" size="32">Reserved in case of future expansion</field>
    </struct>

    <struct name="FunctionField" comment="Used by ActionTable and Function structures to declare lists of parameters.">
      <field name="Name" type="CSTRING">Name of the field</field>
      <field name="Type" type="LONG">Type of the field</field>
    </struct>

    <struct name="KeyStore" comment="Key-pair storage created by VarNew()">
      <field name="Mutex" type="APTR">Internal mutex for managing thread-safety.</field>
      <field name="Data" type="struct KeyPair * *">Key-pairs are stored here.</field>
      <field name="TableSize" type="LONG">The size of the available storage area.</field>
      <field name="Total" type="LONG">Total number of currently stored key-pairs, including dead keys.</field>
      <field name="Flags" type="LONG" lookup="KSF">Optional flags used for VarNew()</field>
    </struct>

    <struct name="Message" comment="Messaging structures.  Note: This structure is utilised by NextMsg">
      <field name="Time" type="LARGE">A timestamp acquired from PreciseTime() when the message was first passed to SendMessage().</field>
      <field name="UniqueID" type="LONG">A unique identifier automatically created by SendMessage().</field>
      <field name="Type" type="LONG">A message type identifier as defined by the client.</field>
      <field name="Size" type="LONG">The size of the message data, in bytes.  If there is no data associated with the message, the Size will be set to zero.&lt;/&gt;</field>
    </struct>

    <struct name="RGB8" comment="8-bit RGB colour value." typeName="RGB8">
      <field name="Red" type="UBYTE">Red component value</field>
      <field name="Green" type="UBYTE">Green component value</field>
      <field name="Blue" type="UBYTE">Blue component value</field>
      <field name="Alpha" type="UBYTE">Alpha component value</field>
    </struct>

    <struct name="DateTime" comment="Generic structure for date-time management.">
      <field name="Year" type="LONG">Year</field>
      <field name="Month" type="LONG">Month 1 to 12</field>
      <field name="Day" type="LONG">Day 1 to 31</field>
      <field name="Hour" type="LONG">Hour 0 to 23</field>
      <field name="Minute" type="LONG">Minute 0 to 59</field>
      <field name="Second" type="LONG">Second 0 to 59</field>
      <field name="TimeZone" type="LONG">TimeZone -13 to +13</field>
    </struct>

    <struct name="FieldArray" comment="Used to construct class blueprints for the MetaClass.">
      <field name="Name" type="CSTRING">The name of the field, e.g. "Width"</field>
      <field name="Flags" type="LONG">Special flags that describe the field</field>
      <field name="Arg" type="MAXINT">Can be a pointer or an integer value</field>
      <field name="GetField" type="APTR">void GetField(*Object, APTR Result);</field>
      <field name="SetField" type="APTR">ERROR SetField(*Object, APTR Value);</field>
    </struct>

    <struct name="ActionTable" comment="Structure for ActionList">
      <field name="Hash" type="ULONG">Hash of the action name.</field>
      <field name="Size" type="LONG">Byte-size of the structure for this action.</field>
      <field name="Name" type="CSTRING">Name of the action.</field>
      <field name="Args" type="const struct FunctionField *">List of fields that are passed to this action.</field>
    </struct>

  </structs>
</book>
