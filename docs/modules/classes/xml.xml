<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="class.xsl"?>

<book>
  <info>
    <name>XML</name>
    <type>class</type>
    <module>XML</module>
    <comment>Provides XML data management services.</comment>
    <fileExtension>*.xml</fileExtension>
    <fileDescription>XML File</fileDescription>
    <version>1</version>
    <id>0b88bfd6</id>
    <idstring>ID_XML</idstring>
    <category>Data</category>
    <include>modules/xml.h</include>
    <copyright>Paul Manias Â© 2001-2017</copyright>
    <description>
<p>The XML class provides the necessary functionality to create and maintain XML data files.  It is capable of interpreting and validating XML files with or without correct structure and can perform various data manipulations while doing so. The XML class is also designed to minimise the amount of resources used in storing XML information and exhibits excellent performance in its processing.</p>
<p>Data can be loaded into an XML object either by specifying a file <field>Path</field> or by giving it an XML <field>Statement</field>.  If you have multiple XML statements to process, you can reset the Path or Statement fields after initialisation and the XML object will rebuild itself.  This saves you from having to allocate multiple XML objects for batch processing.</p>
<p>Once an XML object has interpreted a statement, you can read the information by scanning the array stored in the <field>Tags</field> field.  This array contains an XMLTag structure for each tag found in the original XML statement.  For more information on how to scan this information, refer to the <field>Tags</field> field.</p>
<p>Please note that all tag address pointers that are listed in the <field>Tags</field> field are volatile.  Any write operation to an XML object's tree structure will result in changes to the tag address list.</p></description>
    <source>
      <file>xml.c</file>
    </source>
  </info>

  <actions>
    <action>
      <name>Clear</name>
      <comment>Clears all of the data held in an XML object.</comment>
    </action>

    <action>
      <name>GetVar</name>
      <comment>Retrieves data from an xml object.</comment>
      <description>
<p>The XML class supports variable fields for the execution of XPath queries.  Documentation of the XPath standard is out of the scope for this document, however the following examples illustrate the majority of uses for this query language and a number of special instructions that we support:</p>
<types type="Path">
<type name="/menu/submenu">Return the content of the submenu tag whose parent is the first window.</type>
<type name="xpath:/menu[2]/window">Return the content of the submenu tag whose parent is the 3rd window.</type>
<type name="count:/menu">Return a count of all menu tags at the root level.</type>
<type name="xml:/menu/window/@title">Return the value of the title attribute from the window tag.</type>
<type name="content:/menu/window(@title='foo')">Return the content of the window tag which has title 'foo'.</type>
<type name="extract:/menu/window(@title='bar')">Extract all XML from the window tag which has title 'bar'.</type>
<type name="extract:/menu//window(=apple)">Extract all XML from the first window tag found anywhere inside &lt;menu&gt; that contains content 'apple'.</type>
<type name="exists:/menu/@title">Return '1' if a menu with a title attribute can be matched, otherwise '0'.</type>
<type name="contentexists:/menu">Return '1' if if the immediate child tags of the XPath contain text (white space is ignored).</type>
<type name="//window">Return content of the first window discovered at any branch of the XML tree (double-slash enables flat scanning of the XML tree).</type>
</types>
<p>The 'xpath', 'xml' and '/' prefixes are all identical in identifying the start of an xpath.  The 'content' prefix is used to specifically extract the content of the tag that matches the xpath.  Square brackets and round brackets may be used interchangeably for lookups and filtering clauses.</p>
<p>Direct tag lookups are also supported through variable fields (this is not normally possible using XPath).  You can retrieve an attribute or the content of any tag so long as you know its index number, using this field name format: <code>Tag(Name, Index, Attrib)</code>.</p>
<p>The Name indicates the name of the tag that you will be matching to.  If omitted, all tags are included in the lookup. The Index is used to match to the nth tag name that you are comparing against if a Name is specified, otherwise the Index is a direct lookup into the <field>Tags</field> array.  If an Attrib name is specified, then the value for that attribute will be returned.  If the Attrib name is omitted, the content of the matching tag will be returned.</p>
      </description>
    </action>

    <action>
      <name>Reset</name>
      <comment>Clears the information held in an XML object.</comment>
    </action>

    <action>
      <name>SaveToObject</name>
      <comment>Saves XML data to a storage object (e.g. file).</comment>
    </action>

    <action>
      <name>SetVar</name>
      <comment>Sets attributes and content in the XML tree using XPaths,</comment>
      <description>
<p>Use SetVar to add tag attributes and content using XPaths.  The XPath is specified in the Field parameter and the data is specified in the Value parameter.  Setting the Value to NULL will remove the attribute or existing content, while an empty string will keep an attribute but eliminate any associated data.</p>
<p>It is not possible to add new tags using this action - it is only possible to update existing tags.</p>
<p>Please note that making changes to the XML tree will render all previously obtained tag pointers and indexes invalid.</p>
      </description>
      <result>
        <error code="ReadOnly">Changes to the XML structure are not permitted.</error>
        <error code="Search">Failed to find the tag referenced by the XPath.</error>
        <error code="Okay">Operation successful.</error>
      </result>
    </action>

  </actions>

  <methods>
    <method>
      <name>Count</name>
      <comment>Count all tags that match a given XPath.</comment>
      <prototype>ERROR xmlCount(OBJECTPTR Object, CSTRING XPath, LONG * Result)</prototype>
      <input>
        <param type="CSTRING" name="XPath">The XPath on which to perform the count.</param>
        <param type="LONG *" name="Result">The total number of matching tags is returned here.</param>
      </input>
      <description>
<p>This method will count all tags that match a given XPath and return the value in the Result parameter.</p>
      </description>
      <result>
        <error code="NullArgs">Function call missing argument value(s)</error>
        <error code="Okay">Operation successful.</error>
      </result>
    </method>

    <method>
      <name>Filter</name>
      <comment>Filters the XML data down to a single tag and its children.</comment>
      <prototype>ERROR xmlFilter(OBJECTPTR Object, CSTRING XPath)</prototype>
      <input>
        <param type="CSTRING" name="XPath">Refers to a valid XPath string.</param>
      </input>
      <description>
<p>The Filter method is used to reduce the amount of data in an XML tree, filtering out all data exclusive to the targeted tag and its children.  This is useful for speeding up XPath queries where interest is limited to only one area of the XML tree, or for reducing the memory footprint of large trees.</p>
<p>It is not possible to retrieve data once it has been filtered out by this method.</p>
      </description>
      <result>
        <error code="NullArgs">Function call missing argument value(s)</error>
        <error code="Search">A matching tag could not be found.</error>
        <error code="Okay">Operation successful.</error>
      </result>
    </method>

    <method>
      <name>FindTag</name>
      <comment>Searches for a tag via XPath.</comment>
      <prototype>ERROR xmlFindTag(OBJECTPTR Object, CSTRING XPath, FUNCTION * Callback, LONG * Result)</prototype>
      <input>
        <param type="CSTRING" name="XPath">An XPath string.</param>
        <param type="FUNCTION *" name="Callback">Optional reference to a function that should be called for each matching tag.</param>
        <param type="LONG *" name="Result">The index of the first matching tag is returned in this parameter (not valid if a Callback is defined).</param>
      </input>
      <description>
<p>This method will return the first tag that matches the search string specified in XPath.  Optionally, if the XPath uses wild cards or would match multiple tags, a Callback function may be passed that will be called for each matching tag that  is discovered.  The synopsis for the callback function is <code>ERROR Function(*XML, struct XMLTag *Tag, STRING Attrib)</code>.</p>
<p>The callback routine can terminate the search early by returning ERR_Terminate.  All other error codes are ignored.</p>
<p>The <field>RootIndex</field> value has no effect on this method.  Use <method>FindTagFromIndex</method> to make restricted searches.</p>
      </description>
      <result>
        <error code="NullArgs">Function call missing argument value(s)</error>
        <error code="Search">A matching tag could not be found.</error>
        <error code="NoData">No data is available for use.</error>
        <error code="Okay">A matching tag was found.</error>
      </result>
    </method>

    <method>
      <name>FindTagFromIndex</name>
      <comment>Searches for a tag via XPath, starting from a specific tag index.</comment>
      <prototype>ERROR xmlFindTagFromIndex(OBJECTPTR Object, CSTRING XPath, LONG Start, FUNCTION * Callback, LONG * Result)</prototype>
      <input>
        <param type="CSTRING" name="XPath">An XPath string.</param>
        <param type="LONG" name="Start">The tag index to start searching from.</param>
        <param type="FUNCTION *" name="Callback">Optional reference to a function that should be called for each matching tag.</param>
        <param type="LONG *" name="Result">The index of the first matching tag is returned in this parameter (not valid if a Callback is defined).</param>
      </input>
      <description>
<p>This method will return the first tag that matches the search string specified in XPath.  The search begins at the tag indicated by the Start value.  This should be set to zero if searching from the top of the XML tree.</p>
<p>Optionally, if the XPath uses wild-cards or would match multiple tags, a Callback function may be passed that will be called for each matching tag that is discovered.  The synopsis for the callback function in C is <code>ERROR Function(*XML, struct XMLTag *Tag, STRING Attrib)</code>.</p>
<p>For Fluid: <code>function Callback(XML {ID}, TagIndex {Long}, Attrib {String})</code>.</p>
<p>The callback routine can terminate the search early by returning ERR_Terminate.  All other error codes are ignored.</p>
      </description>
      <result>
        <error code="OutOfRange">The Index is invalid.</error>
        <error code="Okay">Operation successful.</error>
      </result>
    </method>

    <method>
      <name>GetAttrib</name>
      <comment>Retrieves the value of an XML attribute.</comment>
      <prototype>ERROR xmlGetAttrib(OBJECTPTR Object, LONG Index, CSTRING Attrib, CSTRING * Value)</prototype>
      <input>
        <param type="LONG" name="Index">The index of the XML tag to search.</param>
        <param type="CSTRING" name="Attrib">The name of the attribute to search for (case insensitive).  If NULL or an empty string, the tag name is returned as the result.</param>
        <param type="CSTRING *" name="Value">The value of the attribute is returned here, or NULL if the named attribute does not exist.</param>
      </input>
      <description>
<p>The GetAttrib method scans a tag for a specific attribute and returns it. You need to provide the tag index and the name of the attribute that you are looking for.  If found, the attribute value is returned in the Value parameter.</p>
<p>A faster alternative for C/C++ users is to use the inline function XMLATTRIB(Tag,Attrib), which returns the attribute value or NULL if not found.</p>
      </description>
      <result>
        <error code="NotFound">The attribute name was not found.</error>
        <error code="Okay">The attribute was found.</error>
        <error code="Args">The required arguments were not specified.</error>
      </result>
    </method>

    <method>
      <name>GetContent</name>
      <comment>Extracts the content embedded inside an XML tag.</comment>
      <prototype>ERROR xmlGetContent(OBJECTPTR Object, LONG Index, STRING Buffer, LONG Length)</prototype>
      <input>
        <param type="LONG" name="Index">Index of a tag that contains content.</param>
        <param type="STRING" name="Buffer">Pointer to a buffer that will receive the string data.</param>
        <param type="LONG" name="Length">The length of the Buffer in bytes.</param>
      </input>
      <description>
<p>The GetContent method is used to extract the string content from an XML tag.  It will extract content that is immediately embedded within the XML tag and will not perform deep analysis of the tag structure (refer to <method>GetString</method> for deep extraction).  Consider the following structure:</p>
<pre>&lt;body&gt;
  Hello
  &lt;bold&gt;my&lt;/bold&gt;
  friend!
&lt;/body&gt;
</pre>
<p>This will produce the result "Hello friend!" and omit everything encapsulated within the bold tag.</p>
      </description>
      <result>
        <error code="BufferOverflow">The buffer was not large enough to hold the content (the resulting string will be valid but truncated).</error>
        <error code="Okay">The content string was successfully extracted.</error>
        <error code="Args">Invalid arguments passed to function.</error>
      </result>
    </method>

    <method>
      <name>GetString</name>
      <comment>Retrieves data from an XML object in standard XML string format.</comment>
      <prototype>ERROR xmlGetString(OBJECTPTR Object, LONG Index, LONG Flags, STRING * Result)</prototype>
      <input>
        <param type="LONG" name="Index">Index to a source tag for pulling data out of the XML object.</param>
        <param type="LONG" name="Flags" lookup="XMF">Special flags that affect the construction of the XML string.</param>
        <param type="STRING *" name="Result">The resulting string is returned in this parameter.</param>
      </input>
      <description>
<p>The GetString method builds XML strings from data that has been loaded into an XML object.  The string is created from the entire XML object or from a specific area of the XML tree by setting the Index parameter.</p>
<p>The XML string that is built by this method will be stored in the Result parameter.  The memory block must be freed once the content is no longer required.</p>
      </description>
      <result>
        <error code="AllocMemory">Failed to allocate an XML string for the result.</error>
        <error code="Okay">The XML string was retrieved.</error>
        <error code="NoData">No information has been loaded into the XML object.</error>
        <error code="Args">Invalid arguments passed to function.</error>
      </result>
    </method>

    <method>
      <name>GetTag</name>
      <comment>Returns a pointer to the XMLTag structure for a given tag index.</comment>
      <prototype>ERROR xmlGetTag(OBJECTPTR Object, LONG Index, struct XMLTag ** Result)</prototype>
      <input>
        <param type="LONG" name="Index">The index of the tag that is being retrieved.</param>
        <param type="struct XMLTag **" name="Result">The XMLTag is returned in this parameter.</param>
      </input>
      <description>
<p>This method will return the XMLTag structure for a given tag Index.  The Index is checked to ensure it is valid prior to retrieval, and an ERR_OutOfRange error will be returned if it is invalid.</p>
      </description>
      <result>
        <error code="NullArgs">Function call missing argument value(s)</error>
        <error code="OutOfRange">The Index parameter is invalid.</error>
        <error code="Okay">Operation successful.</error>
      </result>
    </method>

    <method>
      <name>InsertContent</name>
      <comment>Inserts XML content into the XML tree.</comment>
      <prototype>ERROR xmlInsertContent(OBJECTPTR Object, LONG Index, LONG Where, CSTRING Content, LONG * Result)</prototype>
      <input>
        <param type="LONG" name="Index">The index to which the statement should be inserted (zero is the beginning).  If the index exceeds the <field>TagCount</field>, the value will be automatically limited to the last tag index.</param>
        <param type="LONG" name="Where" lookup="XMI">Use XMI_PREV or XMI_NEXT to insert behind or ahead of the target tag.  Use XMI_CHILD for a child insert.</param>
        <param type="CSTRING" name="Content">The content to insert.</param>
        <param type="LONG *" name="Result">The index of the new tag is returned here.</param>
      </input>
      <description>
<p>The InsertContent method is used to insert content strings into any position within the XML tree.  A content string must be provided in the Content parameter and the target insertion point is specified in the Index parameter. An insertion point relative to the target index must be specified in the Where parameter.  The new tags can be inserted as a child of the target by using a Where value of XMI_CHILD.  To insert behind or after the target, use XMI_PREV or XMI_NEXT.</p>
<p>To modify existing content, the <method>SetAttrib</method> method should be used.</p>
      </description>
      <result>
        <error code="NullArgs">Function call missing argument value(s)</error>
        <error code="ReadOnly">A delete or write operation failed due to read-only status.</error>
        <error code="Okay">Operation successful.</error>
      </result>
    </method>

    <method>
      <name>InsertXML</name>
      <comment>Inserts an XML statement in the XML tree.</comment>
      <prototype>ERROR xmlInsertXML(OBJECTPTR Object, LONG Index, LONG Where, CSTRING XML, LONG * Result)</prototype>
      <input>
        <param type="LONG" name="Index">The index to which the statement should be inserted (zero is the beginning).</param>
        <param type="LONG" name="Where" lookup="XMI">Use XMI_PREV or XMI_NEXT to insert behind or ahead of the target tag.  Use XMI_CHILD or XMI_CHILD_END for a child insert.</param>
        <param type="CSTRING" name="XML">The statement to process.</param>
        <param type="LONG *" name="Result">The resulting tag index.</param>
      </input>
      <description>
<p>The InsertXML method is used to translate and insert a new set of XML tags into any position within the XML tree.  A standard XML statement must be provided in the XML parameter and the target insertion point is specified in the Index parameter.  An insertion point relative to the target index must be specified in the Insert parameter.  The new tags can be inserted as a child of the target by using a Insert value of XMI_CHILD.  Use XMI_CHILD_END to insert at the end of the child list.  To insert behind or after the target, use XMI_PREV or XMI_NEXT.</p>
<p>The <field>RootIndex</field> value has no effect on this method.</p>
      </description>
      <result>
        <error code="OutOfRange">A specified number is outside of the valid range.</error>
        <error code="Args">Invalid arguments passed to function.</error>
        <error code="NullArgs">Function call missing argument value(s)</error>
        <error code="ReadOnly">Changes to the XML data are not permitted.</error>
        <error code="Okay">The statement was added successfully.</error>
      </result>
    </method>

    <method>
      <name>InsertXPath</name>
      <comment>Inserts an XML statement in an XML tree.</comment>
      <prototype>ERROR xmlInsertXPath(OBJECTPTR Object, CSTRING XPath, LONG Where, CSTRING XML, LONG * Result)</prototype>
      <input>
        <param type="CSTRING" name="XPath">An XPath string that refers to the target insertion point.</param>
        <param type="LONG" name="Where" lookup="XMI">Use XMI_PREV or XMI_NEXT to insert behind or ahead of the target tag.  Use XMI_CHILD for a child insert.</param>
        <param type="CSTRING" name="XML">The statement to process.</param>
        <param type="LONG *" name="Result">The index of the new tag is returned here.</param>
      </input>
      <description>
<p>The InsertXPath method is used to translate and insert a new set of XML tags into any position within the XML tree.  A standard XML statement must be provided in the XML parameter and the target insertion point is referenced as a valid XPath location string.  An insertion point relative to the XPath target must be specified in the Insert parameter.  The new tags can be inserted as a child of the target by using an Insert value of XMI_CHILD or XMI_CHILD_END.  To insert behind or after the target, use XMI_PREV or XMI_NEXT.</p>
      </description>
      <result>
        <error code="NullArgs">Function call missing argument value(s)</error>
        <error code="Search">The XPath could not be resolved.</error>
        <error code="Okay">Operation successful.</error>
      </result>
    </method>

    <method>
      <name>MoveTags</name>
      <comment>Move an XML tag group to a new position in the XML tree.</comment>
      <prototype>ERROR xmlMoveTags(OBJECTPTR Object, LONG Index, LONG Total, LONG DestIndex, LONG Where)</prototype>
      <input>
        <param type="LONG" name="Index">Index of the source tag to be moved.</param>
        <param type="LONG" name="Total">The total number of sibling tags to be moved from the source index.  Minimum value of 1.</param>
        <param type="LONG" name="DestIndex">The destination tag index.  If the index exceeds the <field>TagCount</field>, the value will be automatically limited to the last tag index.</param>
        <param type="LONG" name="Where" lookup="XMI">Use XMI_PREV or XMI_NEXT to insert behind or ahead of the target tag.  Use XMI_CHILD for a child insert.</param>
      </input>
      <description>
<p>This method is used to move XML tags within the XML tree structure.  This routine is designed to support the movement of a single tag, or a group of tags from one index to another using one function call.  You are required to supply the index of the tag that will be moved, and the index of the target tag.  All child tags of the source will be included in the move.</p>
<p>An insertion point relative to the target index must be specified in the Where parameter.  The source tag can be inserted as a child of the destination by using a Where of XMI_CHILD.  To insert behind or after the target, use XMI_PREV or XMI_NEXT.</p>
      </description>
      <result>
        <error code="NullArgs">Function call missing argument value(s)</error>
        <error code="ReadOnly">A delete or write operation failed due to read-only status.</error>
        <error code="Okay">Tags were moved successfully.</error>
      </result>
    </method>

    <method>
      <name>RemoveTag</name>
      <comment>Removes tag(s) from the XML structure.</comment>
      <prototype>ERROR xmlRemoveTag(OBJECTPTR Object, LONG Index, LONG Total)</prototype>
      <input>
        <param type="LONG" name="Index">Reference to the tag that will be removed.</param>
        <param type="LONG" name="Total">The total number of sibling (neighbouring) tags that should also be deleted.  A value of one or less will remove only the indicated tag and its children.  The total may exceed the number of tags actually available, in which case all tags up to the end of the branch will be affected.</param>
      </input>
      <description>
<p>The RemoveTag method is used to remove one or more tags from an XML structure.  Child tags will automatically be discarded as a consequence of using this method, in order to maintain a valid XML structure.</p>
<p>This method is capable of deleting multiple tags if the Total parameter is set to a value greater than 1.  Each consecutive tag and its children following the targeted tag will be removed from the XML structure until the count is exhausted. This is useful for mass delete operations.</p>
<p>After using this method, you must assume that all tag addresses have been changed due to the rearrangement of the XML structure.  Thus if you have obtained pointers to various parts of the XML structure, they are invalid and must be recalculated.</p>
      </description>
      <result>
        <error code="NullArgs">Function call missing argument value(s)</error>
        <error code="ReadOnly">A delete or write operation failed due to read-only status.</error>
        <error code="OutOfRange">A specified number is outside of the valid range.</error>
        <error code="Okay">Operation successful.</error>
      </result>
    </method>

    <method>
      <name>RemoveXPath</name>
      <comment>Removes tag(s) from the XML structure, using an xpath lookup.</comment>
      <prototype>ERROR xmlRemoveXPath(OBJECTPTR Object, CSTRING XPath, LONG Total)</prototype>
      <input>
        <param type="CSTRING" name="XPath">An XML path string.</param>
        <param type="LONG" name="Total">The total number of matching tags that should be deleted.  A value of one or less will remove only the indicated tag and its children.  The total may exceed the number of tags actually available, in which case all matching tags up to the end of the tree will be affected.</param>
      </input>
      <description>
<p>The RemoveXPath method is used to remove one or more tags from an XML structure.  Child tags will automatically be discarded as a consequence of using this method, in order to maintain a valid XML structure.</p>
<p>Individual tag attributes can also be removed if an attribute is referenced at the end of the XPath.</p>
<p>The removal routine will be repeated so that each tag that matches the XPath will be deleted, or the Total is reached.</p>
<p>After using this method, you must assume that all tag addresses have been changed due to the rearrangement of the XML structure.  Thus if you have obtained pointers to various parts of the XML structure then you should proceed to consider them invalid and re-establish them.</p>
      </description>
      <result>
        <error code="NullArgs">Function call missing argument value(s)</error>
        <error code="ReadOnly">A delete or write operation failed due to read-only status.</error>
        <error code="Okay">Operation successful.</error>
      </result>
    </method>

    <method>
      <name>SetAttrib</name>
      <comment>Adds, updates and removes XML attributes.</comment>
      <prototype>ERROR xmlSetAttrib(OBJECTPTR Object, LONG Index, LONG Attrib, CSTRING Name, CSTRING Value)</prototype>
      <input>
        <param type="LONG" name="Index">Index to the XML tag that is to be updated.</param>
        <param type="LONG" name="Attrib" lookup="XMS">Either the index number of the attribute that is to be updated, or set to XMS_NEW, XMS_UPDATE or XMS_UPDATE_ONLY.</param>
        <param type="CSTRING" name="Name">String containing the new name for the attribute.  If NULL, the name will not be changed.  If Attrib is XMS_NEW, XMS_UPDATE or XMS_UPDATE_ONLY, the Name is used to find the attribute.</param>
        <param type="CSTRING" name="Value">String containing the new value for the attribute.  If NULL, the attribute is removed.</param>
      </input>
      <description>
<p>This method is used to update and add attributes to existing XML tags, as well as adding or modifying content.  You need to supply the address of a tag index and the index number of the attribute that you are going to update.</p>
<p>The data for the attribute is defined in the Name and Value parameters. You can set a Value of "" if no data is to be associated with the attribute.  Set the Value pointer to NULL to remove the attribute. If both Name and Value are NULL, an error will be returned.</p>
<p>Please note that the attribute at index 0 declares the name of the tag and should not normally be accompanied with a value declaration.  However, if the tag represents content within its parent, then the Name must be set to NULL and the Value string will determine the content.</p>
<p>NOTE: The address of the original tag will be invalidated as a result of calling this method.  Any tag pointers that have been stored by the client program will need to be refreshed from the XML tag list after calling this method, for example:</p>
<pre>LONG index = tag-&gt;Index; // Store the index of tag.
xmlSetAttrib(XML, tag-&gt;Index, XMS_NEW, "name", "value");
tag = XML-&gt;Tags[index]; // Refresh the pointer to tag.
</pre>
      </description>
      <result>
        <error code="AllocMemory">A call to AllocMemory() failed.</error>
        <error code="OutOfRange">The Index or Attrib value is out of range.</error>
        <error code="Args">Invalid arguments passed to function.</error>
        <error code="NullArgs">Function call missing argument value(s)</error>
        <error code="ReadOnly">The XML object is read-only.</error>
        <error code="Search">The attribute, identified by Name, could not be found.</error>
        <error code="Okay">Operation successful.</error>
      </result>
    </method>

    <method>
      <name>SetRoot</name>
      <comment>Defines a root-level tag for all XPath queries.</comment>
      <prototype>ERROR xmlSetRoot(OBJECTPTR Object, CSTRING XPath)</prototype>
      <input>
        <param type="CSTRING" name="XPath">The new root-level tag, expressed as an XPath string.  Set to NULL to reset the root index.</param>
      </input>
      <description>
<p>To optimise XPath processing in a particular area of the XML tree, a root tag can be defined that will limit all lookups to that tag and its children.  The root tag will remain in effect until either this method is called with a NULL XPath or the XML tree is modified.</p>
<p>The following example illustrates setting the root to the 84th action tag and then extracting the content from its name tag.</p>
<pre>xml.SetRoot("/action(84)")
name = xml.get("content:/action/name")
</pre>
<p>Changing the root index affects variable field queries only.  Siblings of the targeted root tag will still be accessible for lookup following a call to this method whilst prior and parent tags are not.</p>
<p>As an alternative, the root tag can be set by writing the <field>RootIndex</field> field with a valid tag index.</p>
      </description>
      <result>
        <error code="Okay">Operation successful.</error>
        <error code="OutOfRange">The Index parameter is invalid.</error>
        <error code="Search">Unable to find a tag matching the provided XPath.</error>
      </result>
    </method>

    <method>
      <name>Sort</name>
      <comment>Sorts XML tags to your specifications.</comment>
      <prototype>ERROR xmlSort(OBJECTPTR Object, CSTRING XPath, CSTRING Sort, LONG Flags)</prototype>
      <input>
        <param type="CSTRING" name="XPath">Sort everything under the specified tag, or NULL to sort the entire top level.</param>
        <param type="CSTRING" name="Sort">Pointer to a sorting instruction string.</param>
        <param type="LONG" name="Flags" lookup="XSF">Optional flags.</param>
      </input>
      <description>
<p>The Sort method is used to sort a block of XML tags to your specifications.  You are required to pass an XPath that refers to the tag containing each item that you want to sort.  To sort the root level, use an XPath of NULL.  A Sort parameter is required that will specify the sorting instructions.  The format for the Sort string is <code>Tag:Attrib,Tag:Attrib,...</code>.</p>
<p>The Tag indicates the tag name that should be identified for sorting each node (naming child tags is acceptable).  Set the Tag name to "Default" if sorting values should be retrieved from every tag at the requested XPath level.</p>
<p>The Attrib field defines what attribute contains the sort data in each XML tag.  To sort on content, do not define an Attrib value (use the format <code>Tag:,</code>).</p>
      </description>
      <result>
        <error code="AllocMemory">A call to AllocMemory() failed to create a new memory block.</error>
        <error code="NullArgs">Function call missing argument value(s)</error>
        <error code="NothingDone">The XML array was already sorted to your specifications.   Dependent on XSF_REPORT_SORTING.</error>
        <error code="ReadOnly">A delete or write operation failed due to read-only status.</error>
        <error code="Okay">The XML object was successfully sorted.</error>
      </result>
    </method>

  </methods>

  <fields>
    <field>
      <name>CurrentTag</name>
      <comment>Determines the index of the main tag to use when building XML strings.</comment>
      <access read="R" write="W">Read/Write</access>
      <type>INT</type>
      <description>
<p>When using any XML function that creates an XML string (e.g. SaveToObject), the XML object will include the entire XML tree by default.  If you would like to change this behaviour so that only a certain section of the tree is included in the build, set the CurrentTag to the index of the tag that you would like to start building from.  You can learn the index number of an XMLTag by reading its Index field.  An index of zero will cover the entire XML hierarchy.</p>
<p>The CurrentTag field currently affects the <action>SaveToObject</action> action and the <field>Statement</field> field.</p>
      </description>
    </field>

    <field>
      <name>Flags</name>
      <comment>Optional flags.</comment>
      <access read="R" write="W">Read/Write</access>
      <type lookup="XMF">INT</type>
      <description>
<types lookup="XMF"/>
      </description>
    </field>

    <field>
      <name>Modified</name>
      <comment>A timestamp of when the XML data was last modified.</comment>
      <access read="R">Read</access>
      <type>INT</type>
      <description>
<p>The Modified field provides an artificial timestamp value of when the XML data was last modified (e.g. by a tag insert or update).  This allows you to read the current Modified value and then later make a comparison to the current value to see if any changes have been made to the XML data.</p>
      </description>
    </field>

    <field>
      <name>Path</name>
      <comment>Set this field if the XML document originates from a file source.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>STRING</type>
      <description>
<p>XML documents can be loaded from the file system by specifying a file path in this field.  If set post-initialisation, all currently loaded data will be cleared and the file will be parsed automatically.</p>
<p>The XML class supports <function module="Core">LoadFile</function>, so an XML file can be pre-cached by the program if it is frequently used during a program's life cycle.</p>
      </description>
    </field>

    <field>
      <name>PrivateDataSize</name>
      <comment>Allocates a private data buffer for the owner's use against each XML tag.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>INT</type>
      <description>
<p>Buffer space can be allocated against each XML tag by defining a value in this field.  If set, each XMLTag structure referenced in the <field>Tags</field> field will be allocated extra bytes that will be referenced in the Private field.  The owner of the XML object is free to use this extra space as it wishes.</p>
      </description>
    </field>

    <field>
      <name>ReadOnly</name>
      <comment>Prevents modifications and enables caching for a loaded XML data source.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>INT</type>
      <description>
<p>This field can be set to TRUE prior to initialisation of an XML object that will use an existing data source.  It prevents modifications to the XML object.  If the data originates from a file path, the data may be cached to optimise parsing where the same data is used across multiple XML objects.</p>
      </description>
    </field>

    <field>
      <name>RootIndex</name>
      <comment>Defines the root tag for queries into the XML tree.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>INT</type>
      <description>
<p>XML tree queries are offset by the value of the RootIndex field.  By default the root index is set to zero so that all queries start from the top of the tree.  The index cannot exceed the value in the <field>TagCount</field> field.</p>
      </description>
    </field>

    <field>
      <name>Source</name>
      <comment>Set this field if the XML document is to be sourced from another object.</comment>
      <access read="R" write="I">Read/Init</access>
      <type>OBJECTPTR</type>
      <description>
<p>An XML document can be loaded from another object by referencing it here, on the condition that the object's class supports the Read action.</p>
<p>If set post-initialisation, all currently loaded data will be cleared and the source object will be parsed automatically.</p>
      </description>
    </field>

    <field>
      <name>Statement</name>
      <comment>XML data is processed through this field.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>STRING</type>
      <description>
<p>To parse a string through an XML object, set the Statement field with a pointer to the XML formatted data.  If this field is set after initialisation then the XML object will respond by clearing out any existing data and processing the new information that has been passed to it.</p>
<p>Be warned that setting this field with an invalid statement will result in an empty XML object.</p>
<p>If the Statement field is read, a string-based version of the XML object's data is returned.  By default all tags will be included in the statement unless a predefined starting position is set by the <field>CurrentTag</field> field.  The string result is an allocation that must be freed.</p>
      </description>
    </field>

    <field>
      <name>TagCount</name>
      <comment>Reflects the total number of tags in the XML Tags array.</comment>
      <access read="R">Read</access>
      <type>INT</type>
    </field>

    <field>
      <name>Tags</name>
      <comment>Points to an array of tags loaded into an XML object.</comment>
      <access read="G">Get</access>
      <type>struct XMLTag * *</type>
      <description>
<p>After initialising data to an XML object, you can read the processed information through the Tags field.  The Tags field is a null terminated array of all the XML tags that were retrieved from the original XML data. The XML tags are represented in an XMLTag structure.</p>
<p>Each XMLTag will also have at least one attribute set in the Attrib array (the first attribute reflects the tag name) and the exact number of attributes is indicated by the TotalAttrib field.</p>
<p>There are two methods available for reading the XML tags.  The first involves looping through the array, reading each XMLTag reference until a NULL entry is reached (this gives a 'flat' view of the data).  The second is to read the first tag in the array and use the Next, Prev and Child fields to recurse through the XML tags.  Tags that have a Name setting of NULL in the first attribute are to be treated as embedded content, the data of which is defined in the Value string.</p>
<p>The Tags field is still defined in the event that it is empty (the array will consist of a null terminated entry).</p>
      </description>
    </field>

  </fields>
  <types>
    <constants lookup="XSF" comment="Options for the Sort method.">
      <const name="REPORT_SORTING">If set, ERR_NothingDone will be returned in the event that a rearrangement of the list was not necessary.</const>
      <const name="DESC">Sort in descending order.</const>
      <const name="CHECK_SORT">Tells the algorithm to check for a 'sort' attribute in each analysed tag and if found, the algorithm will use that as the sort value instead of that indicated in the Attrib field.</const>
    </constants>

    <constants lookup="XMF" comment="Standard flags for the XML class.">
      <const name="LOWER_CASE">Convert all names and attributes into lower-case characters.</const>
      <const name="PARSE_HTML">Automatically parse HTML escape codes.</const>
      <const name="INCLUDE_COMMENTS">By default, comments are stripped from all XML input.  This flag ensures that they are retained.</const>
      <const name="NO_ESCAPE">Turns off escape code conversion.</const>
      <const name="STRIP_CDATA">Do not echo CDATA sections.  Note that this option is used as a parameter, not an object flag.</const>
      <const name="READABLE">Indent the output of XML tags to improve readability.</const>
      <const name="STRIP_CONTENT">Strip all content from incoming XML data.</const>
      <const name="INCLUDE_SIBLINGS">Include siblings when building an XML string (GetXMLString only)</const>
      <const name="STRIP_HEADERS">XML headers found in the source data will not be included in the parsed results.</const>
      <const name="DEBUG">Print extra log messages.</const>
      <const name="WELL_FORMED">By default, the XML class will accept badly structured XML data.  By setting this flag, all processed XML statements must be well formed (tags must balance) or a BadData error will be returned during processing.</const>
      <const name="UPPER_CASE">Convert all names and attributes into upper-case characters.</const>
      <const name="NEW">Creates an empty XML object on initialisation - if the Path field has been set, the source file will not be loaded.</const>
      <const name="LOCK_REMOVE">Prevents removal of tags from the XML tree.  This specifically affects the RemoveTag and RemoveXPath methods.</const>
      <const name="ALL_CONTENT">By default the XML parser will trim whitespace (such as return codes, spaces and tabs) found in the XML content between tags.  Setting this flag turns off this feature, allowing all whitespace to be included.</const>
      <const name="INDENT">Indent the output of XML tags to improve readability.</const>
      <const name="PARSE_ENTITY">Entity references in the DTD will be parsed automatically.</const>
    </constants>

    <constants lookup="XMI" comment="Tag insertion options.">
      <const name="PREV">Insert as the previous tag of the target.</const>
      <const name="CHILD">Insert as the first child of the target.</const>
      <const name="NEXT">Insert as the next tag of the target.</const>
      <const name="CHILD_END">Insert as the last child of the target.</const>
    </constants>

    <constants lookup="XMS" comment="For SetAttrib()">
      <const name="UPDATE_ONLY">SetAttrib will find the target attribute and update it.  It is not possible to rename the attribute when using this technique.  ERR_Search is returned if the attribute cannot be found.</const>
      <const name="NEW">Adds a new attribute.  Note that if the attribute already exists, this will result in at least two attributes of the same name in the tag.  Use XMS_DEFINE if this is undesirable.</const>
      <const name="UPDATE">As for XMS_UPDATE_ONLY, but if the attribute does not exist, it will be created.</const>
    </constants>

  </types>
  <structs>
    <struct name="XMLTag" typeName="XMLTAG">
      <field name="Index" type="LONG">Position within the XML array</field>
      <field name="ID" type="LONG">Unique ID assigned to the tag on creation</field>
      <field name="Child" type="struct XMLTag *">Reference to further child tags</field>
      <field name="Prev" type="struct XMLTag *">Reference to the previous tag at this level in the chain</field>
      <field name="Next" type="struct XMLTag *">Reference to the next tag at this level in the chain</field>
      <field name="Private" type="APTR">Developer's private memory reference</field>
      <field name="Attrib" type="struct XMLAttrib *">Attributes of the tag, starting with the name</field>
      <field name="TotalAttrib" type="WORD">Total number of listed attributes for this tag</field>
      <field name="Branch" type="UWORD">The branch level for this XML node</field>
      <field name="LineNo" type="LONG">Line number on which this tag was encountered</field>
    </struct>

    <struct name="XMLAttrib" typeName="XMLATT">
      <field name="Name" type="STRING">The name of the attribute.</field>
      <field name="Value" type="STRING">The value assigned to the attribute.</field>
    </struct>

  </structs>
</book>
