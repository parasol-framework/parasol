<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="class.xsl"?>

<book>
  <info>
    <name>Vector</name>
    <type>class</type>
    <module>Vector</module>
    <comment>This is a base class for supporting vector graphics objects and functionality.</comment>
    <version>1</version>
    <id>227baf98</id>
    <idstring>ID_VECTOR</idstring>
    <category>Graphics</category>
    <include>modules/vector.h</include>
    <copyright>Paul Manias Â© 2010-2017</copyright>
    <description>
<p>Vector is an abstract class that is used as a blueprint for other vector classes that provide specific functionality for a vector scene.  At this time the classes are <class name="VectorClip">VectorClip</class>, <class name="VectorEllipse">VectorEllipse</class>, <class name="VectorGroup">VectorGroup</class>, <class name="VectorPath">VectorPath</class>, <class name="VectorPolygon">VectorPolygon</class>, <class name="VectorRectangle">VectorRectangle</class>, <class name="VectorText">VectorText</class> and <class name="VectorViewport">VectorViewport</class>.</p>
<p>The majority of sub-classes support all of the functionality provided by Vector.  The general exception is that graphics functions will not be supported by non-graphical classes, for instance <class name="VectorGroup">VectorGroup</class> and <class name="VectorViewport">VectorViewport</class> do not produce a vector path and therefore cannot be rendered.</p></description>
    <source>
      <file path="vectors/">vector.cpp</file>
    </source>
  </info>

  <actions>
    <action>
      <name>Reset</name>
      <comment>Clears all transform settings from the vector.</comment>
    </action>

  </actions>

  <methods>
    <method>
      <name>ApplyMatrix</name>
      <comment>Applies a 3x2 transform matrix to the vector.</comment>
      <prototype>ERROR vecApplyMatrix(OBJECTPTR Object, DOUBLE A, DOUBLE B, DOUBLE C, DOUBLE D, DOUBLE E, DOUBLE F)</prototype>
      <input>
        <param type="DOUBLE" name="A">Matrix value at (0,0)</param>
        <param type="DOUBLE" name="B">Matrix value at (1,0)</param>
        <param type="DOUBLE" name="C">Matrix value at (2,0)</param>
        <param type="DOUBLE" name="D">Matrix value at (0,1)</param>
        <param type="DOUBLE" name="E">Matrix value at (1,1)</param>
        <param type="DOUBLE" name="F">Matrix value at (2,1)</param>
      </input>
      <description>
<p>This method will apply a 3x2 transformation matrix to the vector.  If the matrix is preceded with the application of other transforms, the outcome is that the matrix is multiplied with the combination of the former transforms.</p>
      </description>
      <result>
        <error code="NullArgs">Function call missing argument value(s)</error>
        <error code="AllocMemory">A call to AllocMemory() failed to create a new memory block.</error>
        <error code="Okay">Operation successful.</error>
      </result>
    </method>

    <method>
      <name>ClearTransforms</name>
      <comment>Clear all transform instructions currently associated with the vector.</comment>
      <prototype>ERROR vecClearTransforms(OBJECTPTR Object)</prototype>
      <description>
<p>This method will clear all transform instructions that have been applied to the vector.</p>
      </description>
      <result>
        <error code="Okay">Operation successful.</error>
      </result>
    </method>

    <method>
      <name>GetBoundary</name>
      <comment>Returns the graphical boundary of a vector.</comment>
      <prototype>ERROR vecGetBoundary(OBJECTPTR Object, LONG Flags, DOUBLE * X, DOUBLE * Y, DOUBLE * Width, DOUBLE * Height)</prototype>
      <input>
        <param type="LONG" name="Flags" lookup="VBF">Optional flags.</param>
        <param type="DOUBLE *" name="X">The left-most position of the boundary is returned here.</param>
        <param type="DOUBLE *" name="Y">The top-most position of the boundary is returned here.</param>
        <param type="DOUBLE *" name="Width">The width of the boundary is returned here.</param>
        <param type="DOUBLE *" name="Height">The height of the boundary is returned here.</param>
      </input>
      <description>
<p>This function will return the boundary of a vector's path in terms of its top-left position, width and height.  All transformations and position information that applies to the vector will be taken into account when computing the boundary.</p>
<p>If the VBF_INCLUSIVE flag is used, the result will include an analysis of all paths that belong to children of the target vector.</p>
<p>If the VBF_NO_TRANSFORM flag is used, the transformation step is not applied to the vector's path.</p>
      </description>
      <result>
        <error code="NullArgs">Function call missing argument value(s)</error>
        <error code="NoData">The vector does not have a computable path.</error>
        <error code="Okay">Operation successful.</error>
      </result>
    </method>

    <method>
      <name>GetTransform</name>
      <comment>Returns the values of applied transformation effects.</comment>
      <prototype>ERROR vecGetTransform(OBJECTPTR Object, LONG Type, struct VectorTransform ** Transform)</prototype>
      <input>
        <param type="LONG" name="Type">Type of transform to retrieve.  If set to zero, the first transformation is returned.</param>
        <param type="struct VectorTransform **" name="Transform">A matching VECTOR_TRANSFORM structure is returned in this parameter, if found.</param>
      </input>
      <description>
<p>This method returns a VECTOR_TRANSFORM structure for any given transform that has been applied to a vector.  It works for MATRIX, TRANSLATE, SCALE, ROTATE and SKEW transformations.  The structure of VECTOR_TRANSFORM is described in the <field>Transforms</field> field.</p>
<p>If the requested transform is not applied to the vector, the method will fail with an ERR_Search return code.</p>
      </description>
      <result>
        <error code="NullArgs">Function call missing argument value(s)</error>
        <error code="Search">The requested transform type is not applied.</error>
        <error code="NoData">No transformations are applied to the vector.</error>
        <error code="Okay">Operation successful.</error>
      </result>
    </method>

    <method>
      <name>PointInPath</name>
      <comment>Checks if point at (X,Y) is within a vector's path.</comment>
      <prototype>ERROR vecPointInPath(OBJECTPTR Object, DOUBLE X, DOUBLE Y)</prototype>
      <input>
        <param type="DOUBLE" name="X">The X coordinate of the point.</param>
        <param type="DOUBLE" name="Y">The Y coordinate of the point.</param>
      </input>
      <description>
<p>This method provides an accurate means of determining if a specific coordinate is inside the path of a vector.  It is important to note that in some cases this operation may be computationally expensive, as each pixel normally drawn in the path may need to be calculated until the (X,Y) point is hit.</p>
      </description>
      <result>
        <error code="NoSupport">The vector type does not support path generation.</error>
        <error code="NoData">The vector is unable to generate a path based on its current values.</error>
        <error code="False">The point is not in the path.</error>
        <error code="NullArgs">Function call missing argument value(s)</error>
        <error code="Okay">The point is in the path.</error>
      </result>
    </method>

    <method>
      <name>Push</name>
      <comment>Push a vector to a new position within its area of the vector stack.</comment>
      <prototype>ERROR vecPush(OBJECTPTR Object, LONG Position)</prototype>
      <input>
        <param type="LONG" name="Position">Specify a relative position index here (-ve to move backwards, +ve to move forwards)</param>
      </input>
      <description>
<p>This method moves the position of a vector within its branch of the vector stack.  Repositioning is relative to the current position of the vector.  Every unit specified in the Position parameter will move the vector by one index in the stack frame.  Negative values will move the vector backwards; positive values move it forward.</p>
<p>It is not possible for an vector to move outside of its branch, i.e. it cannot change its parent.  If the vector reaches the edge of its branch with excess units remaining, the method will return immediately with an ERR_Okay error code.</p>
      </description>
      <result>
        <error code="NullArgs">Function call missing argument value(s)</error>
        <error code="Okay">Operation successful.</error>
      </result>
    </method>

    <method>
      <name>Rotate</name>
      <comment>Applies a rotation transformation to the vector.</comment>
      <prototype>ERROR vecRotate(OBJECTPTR Object, DOUBLE Angle, DOUBLE CenterX, DOUBLE CenterY)</prototype>
      <input>
        <param type="DOUBLE" name="Angle">Angle of rotation</param>
        <param type="DOUBLE" name="CenterX">Center of rotation on the horizontal axis.</param>
        <param type="DOUBLE" name="CenterY">Center of rotation on the vertical axis.</param>
      </input>
      <description>
<p>This method will apply a rotation transformation to a vector.  The rotation will be computed on a run-time basis and does not affect the path stored with the vector.  Any children associated with the vector will also be affected by the transformation.</p>
<p>If a rotation already exists for the vector, it will be replaced with the new specifications.</p>
<p>The transformation can be removed at any time by calling the <method>ClearTransforms</method> method.</p>
      </description>
      <result>
        <error code="NullArgs">Function call missing argument value(s)</error>
        <error code="AllocMemory">A call to AllocMemory() failed to create a new memory block.</error>
        <error code="Okay">Operation successful.</error>
      </result>
    </method>

    <method>
      <name>Scale</name>
      <comment>Scale the size of the vector by (x,y)</comment>
      <prototype>ERROR vecScale(OBJECTPTR Object, DOUBLE X, DOUBLE Y)</prototype>
      <input>
        <param type="DOUBLE" name="X">The scale factor on the x-axis.</param>
        <param type="DOUBLE" name="Y">The scale factor on the y-axis.</param>
      </input>
      <description>
<p>This method will add a scale transformation to the vector's transform commands.  Values of less than 1.0 will shrink the path along the target axis, while values greater than 1.0 will enlarge it.</p>
<p>The scale factors are applied to every path point, and scaling is relative to position (0,0).  If the width and height of the vector shape needs to be transformed without affecting its top-left position, the client must translate the vector to (0,0) around its center point.  The vector should then be scaled and transformed back to its original top-left coordinate.</p>
<p>The scale transform can also be formed to flip the vector path if negative values are used.  For instance, a value of -1.0 on the x axis would result in a 1:1 flip across the horizontal.</p>
      </description>
      <result>
        <error code="NullArgs">Function call missing argument value(s)</error>
        <error code="AllocMemory">A call to AllocMemory() failed to create a new memory block.</error>
        <error code="Okay">Operation successful.</error>
      </result>
    </method>

    <method>
      <name>Skew</name>
      <comment>Skews the vector along the horizontal and/or vertical axis.</comment>
      <prototype>ERROR vecSkew(OBJECTPTR Object, DOUBLE X, DOUBLE Y)</prototype>
      <input>
        <param type="DOUBLE" name="X">The angle to skew along the horizontal.</param>
        <param type="DOUBLE" name="Y">The angle to skew along the vertical.</param>
      </input>
      <description>
<p>The Skew method applies a skew transformation to the horizontal and/or vertical axis of the vector and its children. Valid X and Y values are in the range of -90 &lt; Angle &lt; 90.</p>
      </description>
      <result>
        <error code="NullArgs">Function call missing argument value(s)</error>
        <error code="OutOfRange">At least one of the angles is out of the allowable range.</error>
        <error code="Okay">Operation successful.</error>
      </result>
    </method>

    <method>
      <name>TracePath</name>
      <comment>Returns the coordinates for a vector path, using callbacks.</comment>
      <prototype>ERROR vecTracePath(OBJECTPTR Object, FUNCTION * Callback)</prototype>
      <input>
        <param type="FUNCTION *" name="Callback">The function to call with each coordinate of the path.</param>
      </input>
      <description>
<p>Any vector that generates a path can be traced by calling this method.  Tracing allows the caller to follow the path for each pixel that would be drawn if the path were to be rendered with a stroke size of 1.  The prototype of the callback function is <code>ERROR Function(OBJECTPTR Vector, LONG Index, LONG Command, DOUBLE X, DOUBLE Y)</code>.</p>
<p>The Vector parameter refers to the vector targeted by the method.  The Index is an incrementing counter that reflects the currently plotted point.  The X and Y parameters reflect the coordinate of a point on the path.</p>
<p>If the Callback returns ERR_Terminate, then no further coordinates will be processed.</p>
      </description>
      <result>
        <error code="NullArgs">Function call missing argument value(s)</error>
        <error code="Okay">Operation successful.</error>
      </result>
    </method>

    <method>
      <name>Transform</name>
      <comment>Apply a transformation to a vector.</comment>
      <prototype>ERROR vecTransform(OBJECTPTR Object, CSTRING Transform)</prototype>
      <input>
        <param type="CSTRING" name="Transform">The transform to apply, expressed as a string instruction.</param>
      </input>
      <description>
<p>This method parses a sequence of transformation instructions and applies them to the vector.  The transformation will be computed on a run-time basis and does not affect the path stored with the vector.  Any children associated with the vector will be affected by the transformation.</p>
<p>The transform string must be written using SVG guidelines for the transform attribute, for example <code>skewX(20) rotate(45 50 50)</code> would be valid.</p>
<p>Any existing transformation instructions for the vector will be replaced by this operation.</p>
<p>The transformation can be removed at any time by calling the <method>ClearTransforms</method> method.</p>
      </description>
      <result>
        <error code="NullArgs">Function call missing argument value(s)</error>
        <error code="AllocMemory">A call to AllocMemory() failed to create a new memory block.</error>
        <error code="Okay">Operation successful.</error>
      </result>
    </method>

    <method>
      <name>Translate</name>
      <comment>Translates the vector by (X,Y).</comment>
      <prototype>ERROR vecTranslate(OBJECTPTR Object, DOUBLE X, DOUBLE Y)</prototype>
      <input>
        <param type="DOUBLE" name="X">Translation along the x-axis.</param>
        <param type="DOUBLE" name="Y">Translation along the y-axis.</param>
      </input>
      <description>
<p>This method will apply a translation along (X,Y) to the vector's transform command sequence.</p>
      </description>
      <result>
        <error code="NullArgs">Function call missing argument value(s)</error>
        <error code="AllocMemory">A call to AllocMemory() failed to create a new memory block.</error>
        <error code="Okay">Operation successful.</error>
      </result>
    </method>

  </methods>

  <fields>
    <field>
      <name>ActiveTransforms</name>
      <comment>Indicates the transforms that are currently applied to a vector.</comment>
      <access read="R">Read</access>
      <type>INT</type>
      <description>
<p>Each time that a transform is applied to a vector through methods such as <method>Scale</method> and <method>Translate</method>, a flag will be set in ActiveTransforms that indicates the type of transform that was applied.</p>
      </description>
    </field>

    <field>
      <name>Child</name>
      <comment>The first child vector, or NULL.</comment>
      <access read="R">Read</access>
      <type class="Vector">*Vector</type>
      <description>
<p>The Child value refers to the first vector that forms a branch under this object.  This field cannot be set directly as it is managed internally.  Instead, use object ownership when a vector needs to be associated with a new parent.</p>
      </description>
    </field>

    <field>
      <name>ClipRule</name>
      <comment>Determines the algorithm to use when clipping the shape.</comment>
      <access read="G" write="S">Get/Set</access>
      <type lookup="VFR">INT</type>
      <description>
<p>The ClipRule attribute only applies to vector shapes when they are contained within a <class name="VectorClip">VectorClip</class> object.  In terms of outcome, the ClipRule works similarly to <field>FillRule</field>.</p>
<types lookup="VFR"/>
      </description>
    </field>

    <field>
      <name>DashArray</name>
      <comment>Controls the pattern of dashes and gaps used to stroke paths.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>DOUBLE []</type>
      <description>
<p>The DashArray is a list of lengths that alternate between dashes and gaps.  If an odd number of values is provided, then the list of values is repeated to yield an even number of values.  Thus <code>5,3,2</code> is equivalent to <code>5,3,2,5,3,2</code>.</p>
      </description>
    </field>

    <field>
      <name>DashOffset</name>
      <comment>The distance into the dash pattern to start the dash.  Can be a negative number.</comment>
      <access read="R" write="W">Read/Write</access>
      <type>DOUBLE</type>
    </field>

    <field>
      <name>DashTotal</name>
      <comment>The total number of values in the <field>DashArray</field>.</comment>
      <access read="R">Read</access>
      <type>INT</type>
    </field>

    <field>
      <name>EnableBkgd</name>
      <comment>If true, allows filters to use BackgroundImage and BackgroundAlpha source types.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>INT</type>
      <description>
<p>The EnableBkgd option must be set to true if a section of the vector tree uses filters that have 'BackgroundImage' or 'BackgroundAlpha' as a source.  If it is not set, then filters using BackgroundImage and BackgroundAlpha references will not produce the expected behaviour.</p>
<p>The EnableBkgd option can be enabled on Vector sub-classes <class name="VectorGroup">VectorGroup</class>, <class name="VectorPattern">VectorPattern</class> and <class name="VectorViewport">VectorViewport</class>.  All other sub-classes will ignore the option if used.</p>
      </description>
    </field>

    <field>
      <name>Fill</name>
      <comment>Defines the fill painter using SVG's IRI format.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>STRING</type>
      <description>
<p>The painter used for filling a vector path can be defined through this field.  The string is parsed through the <function module="Vector">ReadPainter</function> function in the Vector module.  Please refer to it for further details on valid  formatting.</p>
      </description>
    </field>

    <field>
      <name>FillColour</name>
      <comment>Defines a solid colour for filling the vector path.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>ARRAY</type>
      <description>
<p>Set the FillColour field to define a solid colour for filling the vector path.  The colour is defined as an array of four 32-bit floating point values between 0 and 1.0.  The array elements consist of Red, Green, Blue and Alpha values in that order.</p>
<p>If the Alpha component is set to zero then the FillColour will be ignored by the renderer.</p>
      </description>
    </field>

    <field>
      <name>FillOpacity</name>
      <comment>The opacity to use when filling the vector.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>DOUBLE</type>
      <description>
<p>The FillOpacity value is used by the painting algorithm when it is rendering a filled vector.  It is multiplied with the <field>Opacity</field> to determine a final opacity value for the render.</p>
      </description>
    </field>

    <field>
      <name>FillRule</name>
      <comment>Determines the algorithm to use when filling the shape.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>INT</type>
      <description>
<p>The FillRule field indicates the algorithm which is to be used to determine what parts of the canvas are included when filling the shape. For a simple, non-intersecting path, it is intuitively clear what region lies "inside"; however, for a more complex path, such as a path that intersects itself or where one sub-path encloses another, the interpretation of "inside" is not so obvious.</p>
      </description>
    </field>

    <field>
      <name>Filter</name>
      <comment>Assign a post-effects filter to a vector.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>STRING</type>
      <description>
<p>This field assigns a graphics filter to the rendering pipeline of the vector.  The filter must initially be created using the <class name="VectorFilter">VectorFilter</class> class and added to a VectorScene using <class name="VectorScene" index="AddDef()">VectorScene:AddDef()</class>.  The filter can then be referenced by ID in the Filter field of any vector object.  Please refer to the <class name="VectorFilter">VectorFilter</class> class for further details on filter configuration.</p>
<p>The Filter value can be in the format <code>ID</code> or <code>url(<field>ID</field>)</code> according to client preference.</p>
      </description>
    </field>

    <field>
      <name>ID</name>
      <comment>String identifier for a vector.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>STRING</type>
      <description>
<p>The ID field is provided for the purpose of SVG support.  Where possible we would recommend that you use the existing object name and automatically assigned ID's for identifiers.</p>
      </description>
    </field>

    <field>
      <name>InnerJoin</name>
      <comment>Adjusts the handling of thickly stroked paths that cross back at the join.</comment>
      <access read="G" write="S">Get/Set</access>
      <type lookup="VIJ">INT</type>
      <description>
<p>The InnerJoin value is used to make very technical adjustments to the way that paths are stroked when they form corners.  Visually, the impact of this setting is only noticeable when a path forms an awkward corner that crosses over itself - usually due to the placement of bezier control points.</p>
<p>The available settings are MITER, ROUND, BEVEL, JAG and INHERIT.  The default of MITER is recommended as it is the fastest, but ROUND produces the best results in ensuring that the stroked path is filled correctly.  The best approach is to leave this field at the default setting and switch to ROUND if issues are noted near the corners of the path.</p>
<types lookup="VIJ"/>
      </description>
    </field>

    <field>
      <name>LineCap</name>
      <comment>The shape to be used at the start and end of a stroked path.</comment>
      <access read="G" write="S">Get/Set</access>
      <type lookup="VLC">INT</type>
      <description>
<p>LineCap is the equivalent of SVG's stroke-linecap attribute.  It defines the shape to be used at the start and end of a stroked path.</p>
<types lookup="VLC"/>
      </description>
    </field>

    <field>
      <name>LineJoin</name>
      <comment>The shape to be used at path corners that are stroked.</comment>
      <access read="G" write="S">Get/Set</access>
      <type lookup="VLJ">INT</type>
      <description>
<p>LineJoin is the equivalent of SVG's stroke-linejoin attribute.  It defines the shape to be used at path corners that are being stroked.</p>
<types lookup="VLJ"/>
      </description>
    </field>

    <field>
      <name>Mask</name>
      <comment>Reference a VectorClip object here to apply a clipping mask to the rendered vector.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>OBJECTPTR</type>
      <description>
<p>A mask can be applied to a vector by setting the Mask field with a reference to a <class name="VectorClip">VectorClip</class> object.  Please refer to the <class name="VectorClip">VectorClip</class> class for further information.</p>
      </description>
    </field>

    <field>
      <name>MiterLimit</name>
      <comment>Imposes a limit on the ratio of the miter length to the StrokeWidth.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>DOUBLE</type>
      <description>
<p>When two line segments meet at a sharp angle and miter joins have been specified in <field>LineJoin</field>, it is possible for the miter to extend far beyond the thickness of the line stroking the path. The MiterLimit imposes a limit on the ratio of the miter length to the <field>StrokeWidth</field>. When the limit is exceeded, the join is converted from a miter to a bevel.</p>
<p>The ratio of miter length (distance between the outer tip and the inner corner of the miter) to <field>StrokeWidth</field> is directly related to the angle (theta) between the segments in user space by the formula: <code>MiterLength / StrokeWidth = 1 / sin ( theta / 2 )</code>.</p>
<p>For example, a miter limit of 1.414 converts miters to bevels for theta less than 90 degrees, a limit of 4.0 converts them for theta less than approximately 29 degrees, and a limit of 10.0 converts them for theta less than approximately 11.5 degrees.</p>
      </description>
    </field>

    <field>
      <name>Morph</name>
      <comment>Enables morphing of the vector to a target path.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>OBJECTPTR</type>
      <description>
<p>If the Morph field is set to a Vector object that generates a path, the vector will be morphed to follow the target vector's path shape.  This works particularly well for text and shapes that follow a horizontal path that is much wider than it is tall.</p>
<p>Squat shapes will fare poorly if morphed, so experimentation may be necessary to understand how the morph feature is best utilised.</p>
      </description>
    </field>

    <field>
      <name>MorphFlags</name>
      <comment>Optional flags that affect morphing.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>INT</type>
    </field>

    <field>
      <name>Next</name>
      <comment>The next vector in the branch, or NULL.</comment>
      <access read="R" write="S">Read/Set</access>
      <type class="Vector">*Vector</type>
      <description>
<p>The Next value refers to the next vector in the branch.  If the value is NULL, the vector is positioned at the end of the branch.</p>
<p>The Next value can be set to another vector at any time, on the condition that both vectors share the same owner.  If this is not true, change the current owner before setting the Next field.  Changing the Next value will result in updates to the <field>Parent</field> and <field>Prev</field> fields.</p>
      </description>
    </field>

    <field>
      <name>NumericID</name>
      <comment>A unique identifier for the vector.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>INT</type>
      <description>
<p>This field assigns a numeric ID to a vector.  Alternatively it can also reflect a case-sensitive hash of the <field>ID</field> field if that has been defined previously.</p>
<p>If NumericID is set by the client, then any value in <field>ID</field> will be immediately cleared.</p>
      </description>
    </field>

    <field>
      <name>Opacity</name>
      <comment>Defines an overall opacity for the vector's graphics.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>DOUBLE</type>
      <description>
<p>The overall opacity of a vector can be defined here using a value between 0 and 1.0.  The value will be multiplied with other opacity settings as required during rendering.  For instance, when filling a vector the opacity will be calculated as <field>FillOpacity</field> * Opacity.</p>
      </description>
    </field>

    <field>
      <name>Parent</name>
      <comment>The parent of the vector, or NULL if this is the top-most vector.</comment>
      <access read="R">Read</access>
      <type>OBJECTPTR</type>
      <description>
<p>The Parent value will refer to the owner of the vector within its respective branch.  To check if the vector is at the top or bottom of its branch, please refer to the @Prev and @Next fields.</p>
      </description>
    </field>

    <field>
      <name>Prev</name>
      <comment>The previous vector in the branch, or NULL.</comment>
      <access read="R" write="S">Read/Set</access>
      <type class="Vector">*Vector</type>
      <description>
<p>The Prev value refers to the previous vector in the branch.  If the value is NULL, then the vector is positioned at the top of the branch.</p>
<p>The Prev value can be set to another vector at any time, on the condition that both vectors share the same owner.  If this is not true, change the current owner before setting the Prev field.  Changing the value will result in updates to the <field>Parent</field> and <field>Next</field> values.</p>
      </description>
    </field>

    <field>
      <name>Scene</name>
      <comment>Short-cut to the top-level <class name="VectorScene">VectorScene</class>.</comment>
      <access read="R">Read</access>
      <type class="VectorScene">*VectorScene</type>
      <description>
<p>All vectors are required to be grouped within the hierarchy of a <class name="VectorScene">VectorScene</class>.  This requirement is enforced on initialisation and a reference to the top-level <class name="VectorScene">VectorScene</class> is recorded in this field.</p>
      </description>
    </field>

    <field>
      <name>Sequence</name>
      <comment>Convert the vector's path to the equivalent SVG path string.</comment>
      <access read="G">Get</access>
      <type>STRING</type>
      <description>
<p>The Sequence is a string of points and instructions that define the path.  It is based on the SVG standard for the path element 'd' attribute, but also provides some additional features that are present in the vector engine.  Commands are case insensitive.</p>
<p>The following commands are supported:</p>
<pre>M: Move To
L: Line To
V: Vertical Line To
H: Horizontal Line To
Q: Quadratic Curve To
T: Quadratic Smooth Curve To
C: Curve To
S: Smooth Curve To
A: Arc
Z: Close Path
</pre>
<p>The use of lower case characters will indicate that the provided coordinates are relative (based on the coordinate of the previous command).</p>
      </description>
    </field>

    <field>
      <name>Stroke</name>
      <comment>Defines the stroke of a path using SVG's IRI format.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>STRING</type>
      <description>
<p>The stroker used for rendering a vector path can be defined through this field.  The string is parsed through the <function module="Vector">ReadPainter</function> function in the Vector module.  Please refer to it for further details on valid formatting.</p>
      </description>
    </field>

    <field>
      <name>StrokeColour</name>
      <comment>Defines the colour of the path stroke in RGB float format.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>ARRAY</type>
      <description>
<p>The colour that will be used in stroking a path is defined by the StrokeColour field.  The colour is composed of 4 floating point values comprising Red, Green, Blue and Alpha.  The intensity of each colour component is determined by a value range between 0 and 1.0.  If the Alpha value is zero, a coloured stroke will not be applied when drawing the vector.</p>
<p>This field is complemented by the <field>StrokeOpacity</field> and <field>Stroke</field> fields.</p>
      </description>
    </field>

    <field>
      <name>StrokeOpacity</name>
      <comment>Defines the opacity of the path stroke.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>DOUBLE</type>
      <description>
<p>The StrokeOpacity value expresses the opacity of a path stroke as a value between 0 and 1.0.  A value of zero would render the stroke invisible and the maximum value of one would render it opaque.</p>
<p>Please note that thinly stroked paths may not be able to appear as fully opaque in some cases due to anti-aliased rendering.</p>
      </description>
    </field>

    <field>
      <name>StrokeWidth</name>
      <comment>The width to use when stroking the path.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>DOUBLE</type>
      <description>
<p>The StrokeWidth defines the pixel width of a path when it is stroked.  If this field is set to zero, the path will not be stroked.</p>
<p>The StrokeWidth is affected by scaling factors imposed by transforms and viewports.</p>
      </description>
    </field>

    <field>
      <name>Transforms</name>
      <comment>A linked list of transforms that have been applied to the vector.</comment>
      <access read="R">Read</access>
      <type>struct VectorTransform *</type>
      <description>
<p>Any transforms that have been applied to the vector can be read from the Transforms field.  Each transform is represented by the VECTOR_TRANSFORM structure, and are linked in the order in which they are applied to the vector.</p>
<struct lookup="VectorTransform"/>
      </description>
    </field>

    <field>
      <name>Transition</name>
      <comment>Reference a VectorTransition object here to apply multiple transforms over the vector's path.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>OBJECTPTR</type>
      <description>
<p>A transition can be applied by setting this field with a reference to a <class name="VectorTransition">VectorTransition</class> object.  Please refer to the <class name="VectorTransition">VectorTransition</class> class for further information.</p>
<p>Not all vector types are well-suited or adapted to the use of transitions.  At the time of writing, only <class name="VectorText">VectorText</class> and <class name="VectorWave">VectorWave</class> are able to take full advantage of this feature.</p>
      </description>
    </field>

    <field>
      <name>Visibility</name>
      <comment>Controls the visibility of a vector and its children.</comment>
      <access read="R" write="W">Read/Write</access>
      <type lookup="VIS">INT</type>
      <description>
<types lookup="VIS"/>
      </description>
    </field>

  </fields>
  <types>
    <constants lookup="ARC" comment="Options for drawing arcs.">
      <const name="LARGE"/>
      <const name="SWEEP"/>
    </constants>

    <constants lookup="CS" comment="Colour space options.">
      <const name="SRGB">The default colour-space is sRGB, recommended for its speed.</const>
      <const name="LINEAR_RGB">Linear RGB is the default colour space for SVG and produces the best results.</const>
      <const name="INHERIT">Inherit the colour space option from the parent vector.</const>
    </constants>

    <constants lookup="VIJ" comment="Inner join options for angled lines.">
      <const name="BEVEL">Blunts the edge of the join.</const>
      <const name="MITER">Forms a sharp point at the join.  Typically not the best looking option.</const>
      <const name="JAG">A special non-SVG option.</const>
      <const name="ROUND">Rounds the edge of the join to produce the best looking results.</const>
      <const name="INHERIT">Inherit the parent's join value.</const>
    </constants>

    <constants lookup="VBF" comment="For vecGetBoundary()">
      <const name="INCLUSIVE">The result will be inclusive of all paths that belong to children of the queried vector.</const>
      <const name="NO_TRANSFORM">The transformation step will not be applied to the vector's path.</const>
    </constants>

    <constants lookup="VPF" comment="Optional flags for the VectorScene object.">
      <const name="RENDER_TIME">Compute the drawing frame-rate for the RenderTime field.</const>
      <const name="BITMAP_SIZED">Automatically adjust the PageWidth and PageHeight to match the target Bitmap width and height.</const>
      <const name="RESIZE">The vector will be stretched to fit the PageWidth and PageHeight values, if defined by the client.</const>
    </constants>

    <constants lookup="VSM">
      <const name="AUTO">The default option is chosen by the system.  This will typically be bilinear, but slow machines may switch to nearest neighbour and high speed machines could use more advanced methods.</const>
      <const name="NEIGHBOUR">Nearest neighbour is the fastest sampler at the cost of poor quality.</const>
      <const name="BILINEAR">Bilinear is a common algorithm that produces a reasonable quality image.</const>
      <const name="BICUBIC">Produces a similar result to bilinear with a marginally sharper after-effect.</const>
      <const name="SPLINE16">About 1/2 the speed of bilinear, this method produces a considerably better result.</const>
      <const name="KAISER"/>
      <const name="QUADRIC"/>
      <const name="GAUSSIAN"/>
      <const name="BESSEL"/>
      <const name="MITCHELL"/>
      <const name="SINC3">Five times slower than bilinear, the final result is of very good quality.</const>
      <const name="LANCZOS3">This well known algorithm may serve as a point of comparison for evaluating the results of other methods.  It shares characteristics with SINC and BLACKMAN.</const>
      <const name="BLACKMAN3">Five times slower than bilinear, the final result will lack sharpness when compared to SINC3.</const>
      <const name="SINC8">15 times slower than bilinear, the final result is of excellent quality but may be marginally over-sharpened.</const>
      <const name="LANCZOS8"/>
      <const name="BLACKMAN8">15 times slower than bilinear, the final result is of excellent quality and sharpness is well balanced.</const>
    </constants>

    <constants lookup="VGF" comment="Gradient flags">
      <const name="FIXED_FY">FY is fixed</const>
      <const name="RELATIVE_X2">X2 is relative</const>
      <const name="RELATIVE_X1">X1 is relative</const>
      <const name="FIXED_X1">X1 is fixed</const>
      <const name="FIXED_Y2">Y2 is fixed</const>
      <const name="RELATIVE_CX">CX is relative</const>
      <const name="FIXED_RADIUS">is fixed</const>
      <const name="RELATIVE_RADIUS">Radius is relative</const>
      <const name="RELATIVE_FX">FX is relative</const>
      <const name="FIXED_CX">CX is fixed</const>
      <const name="RELATIVE_Y2">Y2 is relative</const>
      <const name="RELATIVE_CY">CY is relative</const>
      <const name="FIXED_FX">FX is fixed</const>
      <const name="RELATIVE_FY">FY is relative</const>
      <const name="FIXED_Y1">Y1 is fixed</const>
      <const name="FIXED_CY">CY is fixed</const>
      <const name="RELATIVE_Y1">Y1 is relative</const>
      <const name="FIXED_X2">X2 is fixed</const>
    </constants>

    <constants lookup="VLC" comment="Line-cap options.">
      <const name="BUTT">The default.  The line is sharply squared off at its exact end point.</const>
      <const name="SQUARE">Similar to butt, the line is sharply squared off but will extend past the end point by 'StrokeWidth / 2'.</const>
      <const name="ROUND">The line cap is a half-circle and the line's end-point forms the center point.</const>
      <const name="INHERIT">The cap type is inherited from the parent (defaults to butt if unspecified).</const>
    </constants>

    <constants lookup="VUNIT">
      <const name="UNDEFINED"/>
      <const name="BOUNDING_BOX">Coordinates are relative to the object's bounding box.</const>
      <const name="USERSPACE">Coordinates are relative to the current viewport.</const>
    </constants>

    <constants lookup="VIS" comment="Options for the Vector class' Visibility field.">
      <const name="HIDDEN">Hide the vector and its children.</const>
      <const name="VISIBLE">The default.  Ensures that the vector is visible.</const>
      <const name="COLLAPSE">Hide the vector and its children.  Do not use - provided for SVG compatibility only.</const>
      <const name="INHERIT">Inherit the visibility state from the parent.</const>
    </constants>

    <constants lookup="VTF" comment="Types of vector transforms.">
      <const name="SKEW">Skew the vector by (X,Y)</const>
      <const name="TRANSLATE">Translate the vector by (X,Y)</const>
      <const name="MATRIX">Apply a 2x3 matrix transformation to the vector.</const>
      <const name="SCALE">Scale the vector by (X,Y)</const>
      <const name="ROTATE">Rotate the vector around (CX,CY) by Angle.</const>
    </constants>

    <constants lookup="VGT" comment="VectorGradient options.">
      <const name="LINEAR">A linear gradient is drawn from (X1,Y1) to (X2,Y2).</const>
      <const name="RADIAL">A radial gradient is drawn from CenterX,CenterY to Radius.  An optional focal point can be expressed with FX and FY.</const>
      <const name="CONIC">The conic gradient is a variant on the radial type, whereby the colour values are drawn as a line that revolves around the cone's center point.</const>
      <const name="DIAMOND">A diamond gradient is drawn as a square emanating from the center point.</const>
      <const name="CONTOUR">Contoured gradients follow the contours of the vector path in which they are rendered.</const>
    </constants>

    <constants lookup="VSPREAD" comment="Spread method options define the method to use for tiling filled graphics.">
      <const name="UNDEFINED">Either the default setting will be applied or the setting will be inherited from a parent object.</const>
      <const name="PAD">Scale the graphic to the object bounds.</const>
      <const name="REFLECT">Tile the graphic, reflecting the image alternately on the X and Y axis.</const>
      <const name="REPEAT">Tile the graphic repeatedly.</const>
      <const name="REFLECT_X">Tile the graphic, reflecting the image alternately on the X axis only.</const>
      <const name="REFLECT_Y">Tile the graphic, reflecting the image alternately on the Y axis only.</const>
      <const name="CLIP">Do not scale the graphic in any way and clip it if it extends past imposed boundaries.</const>
    </constants>

    <constants lookup="VFR" comment="Vector fill rules for the FillRule field in the Vector class.">
      <const name="NON_ZERO">This is the default.  This rule determines the 'insideness' of a point on the canvas by drawing a ray from that point to infinity in any direction and then examining the places where a segment of the shape crosses the ray. Starting with a count of zero, add one each time a path segment crosses the ray from left to right and subtract one each time a path segment crosses the ray from right to left. After counting the crossings, if the result is zero then the point is outside the path. Otherwise, it is inside.</const>
      <const name="EVEN_ODD">This rule determines the 'insideness' of a point on the canvas by drawing a ray from that point to infinity in any direction and counting the number of path segments from the given shape that the ray crosses. If this number is odd, the point is inside; if even, the point is outside.</const>
      <const name="INHERIT">The rule is inherited from the parent vector(s).</const>
    </constants>

    <constants lookup="VLJ" comment="Options for the look of line joins.">
      <const name="MITER">The default.  The join will form a pointed edge.</const>
      <const name="MITER_REVERT"/>
      <const name="ROUND">The join is rounded.</const>
      <const name="BEVEL">The join is blunted, eliminating overly sharp edges.</const>
      <const name="MITER_ROUND">Default to MITER, but switch to ROUND if the miter limit is exceeded.</const>
      <const name="INHERIT">Inherit the join option from the parent.</const>
    </constants>

  </types>
  <structs>
    <struct name="VectorTransform">
      <field name="Next" type="struct VectorTransform *">The next transform in the list.</field>
      <field name="Prev" type="struct VectorTransform *">The previous transform in the list.</field>
      <field name="X" type="DOUBLE">The X value, the meaning of which is defined by the Type</field>
      <field name="Y" type="DOUBLE">The Y value, the meaning of which is defined by the Type</field>
      <field name="Angle" type="DOUBLE">Requires VTF_ROTATE.  A rotation by Angle degrees about a given point.  If optional parameters X and Y are not specified, the rotate is about the origin of the current user coordinate system.</field>
      <field name="Matrix[6]" type="DOUBLE">Requires VTF_MATRIX.  A transformation expressed as a matrix of six values.</field>
      <field name="Type" type="WORD" lookup="VTF">The VTF indicates the type of transformation: rotate, skew etc</field>
    </struct>

    <struct name="PathCommand" comment="Base structure for path commands.">
      <field name="Type" type="UBYTE"></field>
      <field name="Curved" type="UBYTE"></field>
      <field name="LargeArc" type="UBYTE"></field>
      <field name="Sweep" type="UBYTE">Arc sweep</field>
      <field name="Pad" type="LONG"></field>
      <field name="X" type="DOUBLE"></field>
      <field name="Y" type="DOUBLE"></field>
      <field name="AbsX" type="DOUBLE"></field>
      <field name="AbsY" type="DOUBLE"></field>
      <field name="X2" type="DOUBLE">Doubles as RX/RY for arcs</field>
      <field name="Y2" type="DOUBLE"></field>
      <field name="X3" type="DOUBLE"></field>
      <field name="Y3" type="DOUBLE"></field>
      <field name="Angle" type="DOUBLE">Arc angle</field>
    </struct>

  </structs>
</book>
