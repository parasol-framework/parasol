<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="class.xsl"?>

<book>
  <info>
    <name>Script</name>
    <type>class</type>
    <module>Core</module>
    <comment>The Script class defines a common interface for script execution.</comment>
    <version>1</version>
    <id>1b600fba</id>
    <idstring>ID_SCRIPT</idstring>
    <category>Data</category>
    <include>modules/script.h</include>
    <copyright>Paul Manias 1996-2017</copyright>
    <description>
<p>The Script class defines a common interface for the purpose of executing scripts, such as Fluid.  The class does not include a default parser or execution process of any kind.</p>
<p>To execute a script, set the <field>Path</field> field and then <action>Activate</action> the Script object.  Global input parameters for the script can be defined via the <action>SetVar</action> action.</p>
<p>Activating a script can result in the generation of objects that outlive the script after it is destroyed.</p></description>
    <source>
      <file path="src/classes/">class_script.c</file>
    </source>
  </info>

  <actions>
    <action>
      <name>Activate</name>
      <comment>Executes the script.</comment>
    </action>

    <action>
      <name>GetVar</name>
      <comment>Script parameters can be retrieved through this action.</comment>
    </action>

    <action>
      <name>Reset</name>
      <comment>Resets an object to its original state.</comment>
    </action>

    <action>
      <name>SetVar</name>
      <comment>Script parameters can be set through this action.</comment>
    </action>

  </actions>

  <methods>
    <method>
      <name>Callback</name>
      <comment>An internal method for managing callbacks.</comment>
      <prototype>ERROR scCallback(OBJECTPTR Object, LARGE ProcedureID, const struct ScriptArg * Args, LONG TotalArgs)</prototype>
      <input>
        <param type="LARGE" name="ProcedureID">An identifier for the target procedure.</param>
        <param type="const struct ScriptArg *" name="Args">Optional CSV string containing arguments to pass to the procedure.</param>
        <param type="LONG" name="TotalArgs">The total number of arguments in the Args parameter.</param>
      </input>
      <description>
<p>Private</p>
      </description>
      <result>
        <error code="Args">Invalid arguments passed to function.</error>
        <error code="Okay">Operation successful.</error>
      </result>
    </method>

    <method>
      <name>DerefProcedure</name>
      <comment>Dereferences a function.</comment>
      <prototype>ERROR scDerefProcedure(OBJECTPTR Object, FUNCTION * Procedure)</prototype>
      <input>
        <param type="FUNCTION *" name="Procedure">The function to be dereferenced.</param>
      </input>
      <description>
<p>This method is applicable to scripting languages that manage function references as a keyed resource.  Fluid is one such language.</p>
<p>Any routine that accepts a script function as a parameter should call DerefProcedure at a later point in order to ensure that the function reference is released.  Not doing so may leave the reference in memory until the Script that owns the procedure is terminated.</p>
      </description>
      <result>
        <error code="NullArgs">Function call missing argument value(s)</error>
        <error code="Okay">Operation successful.</error>
      </result>
    </method>

    <method>
      <name>Exec</name>
      <comment>Executes a procedure in the script.</comment>
      <prototype>ERROR scExec(OBJECTPTR Object, CSTRING Procedure, const struct ScriptArg * Args, LONG TotalArgs)</prototype>
      <input>
        <param type="CSTRING" name="Procedure">The name of the procedure to execute, or NULL for the default entry point.</param>
        <param type="const struct ScriptArg *" name="Args">Optional CSV string containing arguments to pass to the procedure (applies to script-based Exec only).</param>
        <param type="LONG" name="TotalArgs">Total number of script arguments provided.</param>
      </input>
      <description>
<p>Use the Exec method to execute a named procedure in a script, optionally passing that procedure a series of arguments. This method has two different interfaces - one for scripting, which takes parameters as a CSV string, and another for C/C++, which takes parameters in a serialised array.</p>
<p>The behaviour of the execution process matches that of the <action>Activate</action> action and will return the same error codes in the event of failure.  If the procedure returns results, they will be available from the <field>Results</field> field after execution.</p>
<p>If parameters will be passed to the procedure in script (e.g. Fluid), they must be specified as a Comma Separated Value list in the Args string. Exec will interpret all the values as a string type.  Double or single quotes should be used to encapsulate string values (use two quotes in sequence as a means of an escape character).  Values should instead be set as named variables in the script object.</p>
<p>If parameters will be passed to the procedure in C/C++ or similar compiled language, they must be specified as an array of ScriptArg structures.  The following example illustrates such a list:</p>
<pre>
struct ScriptArg args[] = {
   { "Object",       FD_OBJECTID, { .Long = Self-&gt;Head.UniqueID } },
   { "Output",       FD_PTR,      { .Address = output } },
   { "OutputLength", FD_LONG,     { .Long = len } }
};
</pre>
<p>The ScriptArg structure follows this arrangement:</p>
<pre>
struct ScriptArg {
   STRING Name;
   LONG Type;
   union {
      APTR   Address;
      LONG   Long;
      LARGE  Large;
      DOUBLE Double;
   };
};
</pre>
<p>The Field Descriptor (FD) specified in the Type must be a match to whatever value is defined in the union.  For instance if the Long field is defined then an FD_LONG Type must be used.  Supplementary field definition information, e.g. FD_OBJECT, may be used to assist in clarifying the type of the value that is being passed.  Field Descriptors are documented in detail in the Class Development Guide.</p>
<p>The C/C++ interface for Exec also requires a hidden third argument that is not specified in this documentation.  The argument, TotalArgs, must reflect the total number of entries in the Args array.</p>
      </description>
      <result>
        <error code="NullArgs">Function call missing argument value(s)</error>
        <error code="Args">The TotalArgs value is invalid.</error>
        <error code="Okay">The procedure was executed.</error>
      </result>
    </method>

    <method>
      <name>GetProcedureID</name>
      <comment>Converts a procedure name to an ID.</comment>
      <prototype>ERROR scGetProcedureID(OBJECTPTR Object, CSTRING Procedure, LARGE * ProcedureID)</prototype>
      <input>
        <param type="CSTRING" name="Procedure">The name of the procedure.</param>
        <param type="LARGE *" name="ProcedureID">The computed ID will be returned in this parameter.</param>
      </input>
      <description>
<p>This method will convert a procedure name to a unique reference that will be recognised by the script as a direct reference to that procedure.  The ID can be used to create new FUNCTION definitions, for example:</p>
<pre>FUNCTION callback;
SET_FUNCTION_SCRIPT(callback, script, procedure_id);
</pre>
<p>Resolving a procedure will often result in the Script maintaining an ongoing reference for it.  To discard the reference, call <method>DerefProcedure</method> once access to the procedure is no longer required.  Alternatively, destroying the script will also dereference all procedures.</p>
      </description>
      <result>
        <error code="NullArgs">Function call missing argument value(s)</error>
        <error code="Okay">Operation successful.</error>
      </result>
    </method>

  </methods>

  <fields>
    <field>
      <name>CacheFile</name>
      <comment>Compilable script languages can be compiled to a cache file.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>STRING</type>
      <description>
<p>Scripts that support compilation of the source code can be compiled to a target file when the script is initialised. This file is then used as a cache, so that if the cache file exists on the next initialisation then the cache file is used instead of the original source code.</p>
<p>If the cache file exists, a determination on whether the source code has been edited is usually made by comparing date stamps on the original and cache files.</p>
      </description>
    </field>

    <field>
      <name>CurrentLine</name>
      <comment>Indicates the current line being executed when in debug mode.</comment>
      <access read="R">Read</access>
      <type>INT</type>
      <description>
<p>In debug mode, the CurrentLine will indicate the current line of execution (according to the original source code for the script).</p>
<p>It should be noted that not all script processors will support this feature, in which case the value for this field will be set to -1.</p>
      </description>
    </field>

    <field>
      <name>Error</name>
      <comment>If a script fails during execution, an error code may be readable here.</comment>
      <access read="R">Read</access>
      <type>ERROR</type>
    </field>

    <field>
      <name>ErrorString</name>
      <comment>A human readable error string may be declared here following a script execution failure.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>STRING</type>
    </field>

    <field>
      <name>Flags</name>
      <comment>Optional flags.</comment>
      <access read="R" write="I">Read/Init</access>
      <type lookup="SCF">INT</type>
      <description>
<types lookup="SCF"/>
      </description>
    </field>

    <field>
      <name>Language</name>
      <comment>Indicates the language (locale) that the source script is written in.</comment>
      <access read="G">Get</access>
      <type>STRING</type>
      <description>
<p>The Language value indicates the language in which the source script was written.  The default setting is ENG, the code for international English.</p>
      </description>
    </field>

    <field>
      <name>LineOffset</name>
      <comment>For debugging purposes, this value is added to any message referencing a line number.</comment>
      <access read="R" write="W">Read/Write</access>
      <type>INT</type>
      <description>
<p>The LineOffset is a value that is added to all line numbers that are referenced in script debugging output.  It is primarily intended for internal usage only.</p>
      </description>
    </field>

    <field>
      <name>Path</name>
      <comment>The location of the file that is to be processed as a script.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>STRING</type>
      <description>
<p>Script files can be loaded by a script object by setting the Path field to the path of the source file.  The source must be provided prior to the initialisation process or the script object will fail (as an alternative, the <field>Statement</field> field can also be set).</p>
<p>Special parameters can also be passed to the script when setting the location.  The name of an executable procedure may be passed by following the location with a semicolon, then the name of the procedure to execute.  Arguments can also be passed to the script by following this with a second semicolon, then a sequence of arguments, each separated with a comma.  The following string illustrates the format used:</p>
<pre>dir:location;procedure;arg1=val1,arg2,arg3=val2</pre>
<p>A target for the script may be specified by using the 'target' argument in the parameter list (value must refer to a valid existing object).</p>
      </description>
    </field>

    <field>
      <name>Procedure</name>
      <comment>Allows you to specify a procedure to be executed from within a script.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>STRING</type>
      <description>
<p>Sometimes scripts are split into several procedures or functions that can be executed independently from the 'main' area of the script.  If a script that you have loaded contains procedures, you can set the Procedure field to execute a specific routine whenever the script is activated with the Activate action.</p>
<p>If this field is not set, the first procedure in the script, or the 'main' procedure (as defined by the script type) is executed by default.</p>
<p>A special feature in DML allows the use of XPaths for running code at a specific point in the source.  Ensure that the xpath string starts with a forward slash and this special run-case will be enabled.  The target does not necessarily need to start with a 'dml' tag, although this is recommended.</p>
      </description>
    </field>

    <field>
      <name>Results</name>
      <comment>Stores multiple string results for languages that support this feature.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>STRING []</type>
      <description>
<p>If a scripting language supports the return of multiple results, this field may reflect those result values after the execution of any procedure.</p>
<p>For maximum compatibility in type conversion, the results are stored as an array of strings.</p>
      </description>
    </field>

    <field>
      <name>Statement</name>
      <comment>Scripts can be executed from any string passed into this field.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>STRING</type>
      <description>
<p>Scripts may be compiled into a script object by setting the Statement field with a complete script string.  This is often convenient for embedding a small script into another script file without having to make external file references. It is also commonly used for executing scripts that have been embedded into program binaries.</p>
      </description>
    </field>

    <field>
      <name>Target</name>
      <comment>Reference to the default container that new script objects will be initialised to.</comment>
      <access read="R" write="W">Read/Write</access>
      <type>OBJECTID</type>
      <description>
<p>This field can refer to the target object that new objects at the root of the script will be initialised to.  If this field is not set, the root-level objects in the script will be initialised to the script's owner.</p>
      </description>
    </field>

    <field>
      <name>TotalArgs</name>
      <comment>Reflects the total number of arguments used in a script object.</comment>
      <access read="G">Get</access>
      <type>INT</type>
      <description>
<p>The total number of arguments that have been set in a script object through the unlisted field mechanism are reflected in the value of this field.  If you have not set any arguments then the field value will be zero.</p>
      </description>
    </field>

    <field>
      <name>WorkingPath</name>
      <comment>Defines the script's working path (folder).</comment>
      <access read="G" write="S">Get/Set</access>
      <type>STRING</type>
      <description>
<p>The working path for a script is defined here.  By default this is defined as the location from which the script was loaded, without the file name.  If this cannot be determined then the working path for the parent task is used (this is usually set to the location of the parasol-gui program).</p>
<p>The working path is always fully qualified with a slash or colon at the end of the string.</p>
<p>You can manually change the working path by setting this field with a custom string.</p>
      </description>
    </field>

  </fields>
  <types>
    <constants lookup="FDB" comment="Feedback event indicators.">
      <const name="DECOMPRESS_FILE"/>
      <const name="COMPRESS_FILE"/>
      <const name="REMOVE_FILE"/>
      <const name="DECOMPRESS_OBJECT"/>
    </constants>

    <constants lookup="MOF" comment="Module flags">
      <const name="LINK_LIBRARY">Module refers to a symbolic link library (e.g. libz DLL or SO)</const>
      <const name="STATIC">This flag prevents the loaded module code from being unloaded when the module object is freed.  This may be needed in cases where a module is designed with the presumption that it will remain in memory after being loaded by the developer.</const>
    </constants>

    <constants lookup="CNF" comment="Flags for the Config class.">
      <const name="STRIP_QUOTES">Removes quotes from key values that are quote-encapsulated.</const>
      <const name="LOCK_RECORDS">Locks existing keys so that they can't be overwritten.  It will still be possible to add new keys to the config object.</const>
      <const name="NEW">On initialisation, do not load any data from the referenced configuration file.</const>
      <const name="FILE_EXISTS">Setting this flag will force the config class to fail if the source file defined in Path does not exist.</const>
      <const name="AUTO_SAVE">When the configuration object is freed, automatically save the configuration data back to the original file source.</const>
    </constants>

    <constants lookup="EVG" comment="Event categories.">
      <const name="FILESYSTEM">File system events.</const>
      <const name="NETWORK">Network events.</const>
      <const name="SYSTEM">System-wide events</const>
      <const name="GUI">Events generated by the Graphical User Interface.</const>
      <const name="DISPLAY">Video display events.</const>
      <const name="IO">Input/Output events.</const>
      <const name="HARDWARE">Hardware device events that are not covered by other types.</const>
      <const name="AUDIO">Audio system events.</const>
      <const name="USER">User activity events (such as user login).</const>
      <const name="POWER">Power Management - can also include app-specific events relating to resource management.</const>
      <const name="CLASS">Custom event dispatched from a class that doesn't fit within the rest of the event framework</const>
      <const name="APP">Custom event dispatched from an application</const>
      <const name="ANDROID">Android specific events that do not already fit existing categories.</const>
    </constants>

    <constants lookup="SCF" comment="Script flags">
      <const name="DEBUG">Enables execution debugging.  More information will be printed to the console in this mode.</const>
      <const name="EXIT_ON_ERROR">The script will automatically terminate its execution process if an error is detected.</const>
    </constants>

    <constants lookup="LTF" comment="Flags for ListTasks()">
      <const name="CURRENT_PROCESS"/>
    </constants>

    <constants lookup="SBF" comment="Flags for StrBuildArray()">
      <const name="NO_DUPLICATES">Sort the resulting list and remove duplicated strings.</const>
      <const name="SORT">Sort the resulting list.</const>
      <const name="CSV">The list is in CSV format and the Size and Total parameters should be ignored. Note that the source string will be modified in this mode.</const>
      <const name="DESC">Sort in descending order.</const>
      <const name="CASE">Use case-sensitivity when comparing strings in the list.</const>
    </constants>

    <constants lookup="STT" comment="Types for StrDatatype().">
      <const name="NUMBER">The string represents a whole number.</const>
      <const name="FLOAT">The string represents a floating point number.</const>
      <const name="HEX">The string represents a hexadecimal number.</const>
      <const name="STRING">The string represents plain-text.</const>
    </constants>

    <constants lookup="IDTYPE" comment="Types for AllocateID()">
      <const name="MESSAGE">Message ID's are allocated for the purpose of sending uniquely identifiable messages between tasks.</const>
      <const name="GLOBAL">Global ID's have no specific association with anything.</const>
      <const name="FUNCTION">Function ID's are used to track FUNCTION types and are assigned to the function ID field.</const>
    </constants>

    <constants lookup="THF" comment="Thread flags">
      <const name="AUTO_FREE">Automatically destroy the Thread object when the user routine has completed.</const>
      <const name="MSG_HANDLER">Allow the thread to handle messages that target objects that it has created.</const>
    </constants>

    <constants lookup="DEVICE">
      <const name="TEMPORARY">All storage is temporary</const>
      <const name="MEMORY">Device is RAM, ROM, WORM, NVRAM, flashdisk or other form of memory.  Does not guarantee a fast connection as it could be over a slow USB 1.1 connection for example</const>
      <const name="REMOVABLE">Device media is removable from the hardware</const>
      <const name="SCANNER">Device is a two dimensional scanner.</const>
      <const name="MODEM">Device is a modem.</const>
      <const name="WRITE">Device is writeable</const>
      <const name="PRINTER_3D">Device is a three dimensional printer.</const>
      <const name="READ">Device is readable</const>
      <const name="COMPACT_DISC">Compact disc style device</const>
      <const name="PRINTER">Device is a paper-based printer.</const>
      <const name="TAPE">Tape/Stream style device</const>
      <const name="SCANNER_3D">Device is a three dimensional scanner.</const>
      <const name="NETWORK">Device represents a network link</const>
      <const name="HARD_DISK">Hard disk style device</const>
      <const name="USB">Removable USB storage device.  May be further qualified by DEVICE_HARDDISK, DEVICE_FLOPPYDISK etc</const>
      <const name="REMOVEABLE">Device media is removable from the hardware</const>
      <const name="SOFTWARE">Device is virtual/software defined</const>
      <const name="FLOPPY_DISK">Floppy disk style device</const>
    </constants>

    <constants lookup="SEF" comment="Optional flags for StrEvaluate()">
      <const name="KEEP_ESCAPE">Escaped string symbols will not be altered if this flag is used.</const>
      <const name="NO_SCRIPT">Turns off the embedded script feature.  An error code is returned if an attempt to embed a script is made.</const>
      <const name="IGNORE_QUOTES">Areas marked with double-quotes will not be translated.  The quote characters will also not be removed.</const>
      <const name="STRICT">Enforces strict processing.  An error code will always be returned if at least one of the translation attempts failed.  Failed translations will be unprocessed (normally they are removed from the resulting string).</const>
    </constants>

    <constants lookup="MSF" comment="Message flags.">
      <const name="MESSAGE_ID">The Type parameter refers to a unique message ID rather than a message type for this call.</const>
      <const name="WAIT">Wait before inserting the message if the queue is at maximum capacity.</const>
      <const name="ADD">The default behaviour - this will add the message to the end of the queue.</const>
      <const name="NO_DUPLICATE">If the Type parameter matches a message already inside the queue, the new message will not be added and the function will immediately return with ERR_Okay.</const>
      <const name="UPDATE">If the Type parameter matches a message already inside the queue, the data for that message will be deleted, then the new message will be added to the end of the queue.</const>
    </constants>

    <constants lookup="STR">
      <const name="WILDCARD">Allow the use of wildcard characters '|', '?' and '*'.</const>
      <const name="MATCH_LEN">The strings must be of equal length to be matched.</const>
      <const name="MATCH_CASE">Perform a case-sensitive match.</const>
      <const name="CASE">Perform a case-sensitive match.</const>
    </constants>

    <constants lookup="NSF" comment="Flags for NotifySubscribers">
      <const name="LOCAL">Only send messages to objects that are owned by the current process.</const>
      <const name="DELAY">Place all notifications on the message queue.</const>
      <const name="FORCE_DELAY">Place all notifications on the message queue.</const>
      <const name="OTHER_TASKS">Only send messages to objects that are owned by other processes.</const>
      <const name="EXCLUSIVE">Instead of messaging each object, the function will attempt to gain exclusive access to each of the subscribed objects and send the notification directly.</const>
      <const name="LOCAL_TASK">Only send messages to objects that are owned by the current process.</const>
    </constants>

    <constants lookup="AC" comment="Action identifiers.">
      <const name="ActionNotify"/>
      <const name="Activate"/>
      <const name="AccessObject"/>
      <const name="Clear"/>
      <const name="FreeWarning"/>
      <const name="OwnerDestroyed"/>
      <const name="CopyData"/>
      <const name="DataFeed"/>
      <const name="Deactivate"/>
      <const name="Draw"/>
      <const name="Flush"/>
      <const name="Focus"/>
      <const name="Free"/>
      <const name="ReleaseObject"/>
      <const name="GetVar"/>
      <const name="DragDrop"/>
      <const name="Hide"/>
      <const name="Init"/>
      <const name="Lock"/>
      <const name="LostFocus"/>
      <const name="Move"/>
      <const name="MoveToBack"/>
      <const name="MoveToFront"/>
      <const name="NewChild"/>
      <const name="NewOwner"/>
      <const name="NewObject"/>
      <const name="Redo"/>
      <const name="Query"/>
      <const name="Read"/>
      <const name="Rename"/>
      <const name="Reset"/>
      <const name="Resize"/>
      <const name="SaveImage"/>
      <const name="SaveToObject"/>
      <const name="Scroll"/>
      <const name="Seek"/>
      <const name="SetVar"/>
      <const name="Show"/>
      <const name="Undo"/>
      <const name="Unlock"/>
      <const name="Next"/>
      <const name="Prev"/>
      <const name="Write"/>
      <const name="SetField"/>
      <const name="Clipboard"/>
      <const name="Refresh"/>
      <const name="Disable"/>
      <const name="Enable"/>
      <const name="Redimension"/>
      <const name="MoveToPoint"/>
      <const name="ScrollToPoint"/>
      <const name="Custom"/>
      <const name="Sort"/>
      <const name="SaveSettings"/>
      <const name="SelectArea"/>
      <const name="END"/>
    </constants>

    <constants lookup="KSF" comment="Flags for VarNew()">
      <const name="THREAD_SAFE">Enable thread safety for a small performance penalty.</const>
      <const name="UNTRACKED">Do not track the key-store to the object with the current context.</const>
      <const name="CASE">Enable case-sensitive keys.</const>
      <const name="AUTO_REMOVE">Automatically call FreeResource() on remaining key values when FreeResource() is called for the key-store.</const>
    </constants>

    <constants lookup="CLF" comment="Flags for the MetaClass.">
      <const name="XML_CONTENT">Script processing should treat any object content as XML.</const>
      <const name="SHARED_ONLY">Forces all objects of this class to be shared.</const>
      <const name="PUBLIC_OBJECTS">Forces all class objects to be allocated in public memory.</const>
      <const name="SHARED_OBJECTS">Forces all objects of this class to be shared.</const>
      <const name="PROMOTE_INTEGRAL">Promote class support for any integral object defined in the class definition structure.</const>
      <const name="NO_OWNERSHIP">Objects created will not be tracked to the creating process, nor any parent object (SetOwner() will not work either).</const>
      <const name="PRIVATE_ONLY">Do not allow public-memory instances of the class (private-shared objects will still be possible).</const>
    </constants>

    <constants lookup="RFD" comment="Flags for RegisterFD()">
      <const name="WRITE">Activate the callback if there is room to write to the FD's buffer.</const>
      <const name="REMOVE">Stop monitoring this file descriptor.</const>
      <const name="SOCKET">Identifies the file descriptor as a socket (Linux systems only).</const>
      <const name="READ">Activate the callback if there is data available to read.</const>
      <const name="EXCEPT">Activate the callback if error conditions are pending.</const>
      <const name="RECALL">Set if the subscriber needs to manually check for incoming/outgoing data.  This is supported as a one-off check, so the flag will be disabled automatically when the subscriber is called.</const>
    </constants>

    <constants lookup="RP" comment="Path types for SetResourcePath()">
      <const name="MODULE_PATH">An alternative path leading to the system modules (normally 'system:modules/').  Introduced for platforms such as Android, where modules are stored in asset folders.</const>
      <const name="SYSTEM_PATH">The path of the 'system:' volume, which otherwise defaults to '[root]:system/'.</const>
      <const name="ROOT_PATH">Overrides the root path, which defaults to the location at which Parasol is installed.</const>
    </constants>

    <constants lookup="RES">
      <const name="MESSAGE_QUEUE">Use this resource to retrieve the message queue ID of the current task.</const>
      <const name="GLOBAL_INSTANCE">If a global instance is active, this resource holds the instance ID.  Otherwise the value is 0.</const>
      <const name="PRIVILEGED_USER">If this value is set to 1, the process will operate in privileged mode (typically this enables full administrator rights).  This feature will only work for Unix processes that are granted admin rights when launched.  Setting the Value to 0 reverts to the user's permission settings.  SetResource() will return an error code indicating the level of success.</const>
      <const name="PRIVILEGED">This is set to TRUE if the process has elevated privileges (such as superuser or administrative rights).</const>
      <const name="RANDOM_SEED">Changes the PRNG seed value for RandomNumber().</const>
      <const name="PARENT_CONTEXT">Read-only pointer to the parent object of the current context.</const>
      <const name="LOG_LEVEL">The current level of log detail (larger numbers indicate more detail).</const>
      <const name="TOTAL_SHARED_MEMORY">The total amount of shared memory in use.</const>
      <const name="MAX_PROCESSES">The maximum number of processes that can be supported at any time.</const>
      <const name="LOG_DEPTH">The current depth of log messages.</const>
      <const name="JNI_ENV">Return the current JNI environment string.</const>
      <const name="THREAD_ID">Return the ID of the current thread.</const>
      <const name="CURRENT_MSG">Returns a Message structure if the program is currently processing a message - otherwise returns NULL.  This resource type is meaningful only during a ProcessMessages call.</const>
      <const name="OPEN_INFO">Pointer to the OpenInfo structure originally used to initialise the system.</const>
      <const name="EXCEPTION_HANDLER"/>
      <const name="PROCESS_STATE">Life-cycle stage of the running process</const>
      <const name="TOTAL_MEMORY">The total amount of installed memory.</const>
      <const name="TOTAL_SWAP">The total amount of available swap space.</const>
      <const name="CPU_SPEED">The average top-speed of all CPU cores in Mhz.</const>
      <const name="FREE_MEMORY">The total amount of free memory.</const>
      <const name="FREE_SWAP">The total amount of free swap memory.</const>
      <const name="KEY_STATE">Maintains the state of key qualifiers such as caps-lock and the shift keys.</const>
      <const name="CORE_IDL">Refers to the Core module's compressed IDL string.</const>
    </constants>

    <constants lookup="CF" comment="Compression stream formats">
      <const name="GZIP">The 'gzip' format</const>
      <const name="ZLIB">The 'zlib' format</const>
      <const name="DEFLATE">The 'deflate' format</const>
    </constants>

    <constants lookup="CMF" comment="Compression flags">
      <const name="READ_ONLY">Forces read-only access, which is strongly recommended if an existing archive is being opened with no modifications intended.  If this flag is not set, initialisation can fail if the user does not have write access to the source file.</const>
      <const name="NEW">Force the creation of a new file archive.  Any existing file data at the target location will be destroyed.</const>
      <const name="APPLY_SECURITY">When decompressing, apply individual file permissions if they are available in the compression file.</const>
      <const name="NO_LINKS">Treat symbolic links as normal files/folders.</const>
      <const name="CREATE_FILE">Create a new archive only if the source file does not already exist.</const>
      <const name="PASSWORD">A password has been set on the object.</const>
    </constants>

    <constants lookup="PERMIT" comment="Permission flags">
      <const name="USER_EXEC">Synonym for EXEC</const>
      <const name="GROUP_WRITE">Group members can write.</const>
      <const name="GROUP">Synonym for GROUP_READ | GROUP_WRITE | GROUP_EXEC | GROUP_DELETE</const>
      <const name="GROUP_DELETE">Group members can delete.</const>
      <const name="ALL_EXEC">Synonym for EVERYONE_EXEC</const>
      <const name="OTHERS_EXEC">Others can execute.</const>
      <const name="OTHERS">Synonym for OTHERS_READ | OTHERS_WRITE | OTHERS_EXEC | OTHERS_DELETE</const>
      <const name="ALL_WRITE">Synonym for EVERYONE_WRITE</const>
      <const name="OTHERS_READ">Others can read.</const>
      <const name="OTHERS_DELETE">Others can delete.</const>
      <const name="EVERYONE_EXEC">Synonym for EXEC | GROUP_EXEC | OTHERS_EXEC</const>
      <const name="GROUP_READ">Group members can read.</const>
      <const name="GROUP_EXEC">Group members can execute.</const>
      <const name="ARCHIVE">Marks the file for future backup.  The flag should be cleared after the backup has succeeded.</const>
      <const name="OTHERS_WRITE">Others can write.</const>
      <const name="WRITE">User/Owner can write.</const>
      <const name="USER">Synonym for READ | WRITE | EXEC | DELETE</const>
      <const name="READ">User/Owner has read access.  This will not allow compiled code to be executed.</const>
      <const name="OFFLINE">File content for this networked file has not been cached on the local PC.</const>
      <const name="INHERIT">Inherit permissions from parent folder and logical OR them with preset permission flags.</const>
      <const name="PASSWORD">File is password protected.</const>
      <const name="DELETE">Owner can delete.  If the file system does not support this, deletion is enabled via the WRITE flag.</const>
      <const name="ALL_READ">Synonym for EVERYONE_READ</const>
      <const name="EVERYONE_READ">Synonym for READ | GROUP_READ | OTHERS_READ</const>
      <const name="NETWORK">File is hosted on another machine.</const>
      <const name="EVERYONE_READWRITE">Synonym for EVERYONE_READ | EVERYONE_WRITE</const>
      <const name="EVERYONE_WRITE">Synonym for WRITE | GROUP_WRITE | OTHERS_WRITE</const>
      <const name="USER_WRITE">Synonym for WRITE</const>
      <const name="EVERYONE_DELETE">Synonym for DELETE | GROUP_DELETE | OTHERS_DELETE</const>
      <const name="EVERYONE_ACCESS">Synonym for EVERYONE_READ | EVERYONE_WRITE | EVERYONE_EXEC | EVERYONE_DELETE</const>
      <const name="GROUPID">Allows executables to run with a set group id.</const>
      <const name="HIDDEN">Recommends that the file is hidden from view by default.</const>
      <const name="EXEC">User/Owner can execute.</const>
      <const name="ALL_DELETE">Synonym for EVERYONE_DELETE</const>
      <const name="USERID">Allows executables to run with a set user id.</const>
      <const name="USER_READ">Synonym for READ</const>
    </constants>

    <constants lookup="NF" comment="Flags that can be passed to NewObject().  If a flag needs to be stored with the object, it must be specified in the lower word.">
      <const name="PRIVATE"/>
      <const name="NAME">Use the Name parameter to name the created object.  This flag is not required if using NF_UNIQUE.</const>
      <const name="INTEGRAL">Integral objects can only be allocated by classes that need to adopt the functionality of said object.  Integral objects do not appear in the object tree, effectively making them hidden from view.</const>
      <const name="UNTRACKED">An object created with this flag will not be tracked back to the object that created it.  If combined with the NF_PUBLIC flag, the object can also remain in memory when the object's related task is terminated.</const>
      <const name="NO_TRACK">An object created with this flag will not be tracked back to the object that created it.  If combined with the NF_PUBLIC flag, the object can also remain in memory when the object's related task is terminated.</const>
      <const name="TIMER_SUB">Indicates that the object is subscribed to a timer Zinterval.</const>
      <const name="PUBLIC">Allocates a public object using shareable resources, allowing it to be accessed directly by any process.  Access is granted via exclusive access locks  - refer to the AccessObject() and ReleaseObject() functions.</const>
      <const name="RECLASSED">The object switched from the base-class to a sub-class during initialisation.</const>
      <const name="INITIALISED">Read-only indicator if the object has been initialised.</const>
      <const name="UNIQUE">Use to allocate an object that has a guaranteed unique name.  This will prevent code from shadowing any object that exists with the same name, which can be imperative when creating public objects.  If it is discovered that an identically named object exists, NewObject() will return ERR_ObjectExists.  This flag works in conjunction with the Name argument.</const>
      <const name="UNLOCK_FREE">Read-only indicator for when the object is marked for deletion.</const>
      <const name="MESSAGE">Action has been called against the object through the message system (managed by ProcessMessages()).</const>
      <const name="FOREIGN_OWNER">Read-only indicator for when an object's parent is in a foreign process.</const>
      <const name="FREE">Read-only indicator for when the object is being freed.</const>
    </constants>

    <constants lookup="CCF" comment="Class categories">
      <const name="IO">IO classes manage hardware and software based input and output.</const>
      <const name="SYSTEM">System classes are designed to provide low-level services related to system management.</const>
      <const name="MISC">Miscellaneous classes do not fit into any of the other available categories.</const>
      <const name="NETWORK">Network classes interface with network drivers to simplify network communications for the developer.</const>
      <const name="AUDIO">Audio classes interface with audio hardware and drivers for audio playback and recording purposes.</const>
      <const name="EFFECT">Effect classes draw graphics and/or play audio for non-productive demonstration purposes.</const>
      <const name="DRAWABLE">Drawable classes provide graphical areas that are designed to be drawn to.</const>
      <const name="MULTIMEDIA"/>
      <const name="DATA">Data classes parse, query and manipulate data.</const>
      <const name="TOOL">Tool classes are focussed on providing interactive services to the user.</const>
      <const name="FILESYSTEM">FileSystem classes are based on file management and interaction with file based data.</const>
      <const name="COMMAND">Command classes perform specific procedures, like copying or moving a file, managing volumes or executing a program.</const>
      <const name="GUI">GUI classes are used in the development of graphical user interfaces.</const>
      <const name="GRAPHICS">Graphics classes provide graphical manipulation and drawing services to developers.</const>
    </constants>

    <constants lookup="IDF" comment="IdentifyFile() values">
      <const name="SECTION">Return the name of the Config section that supports the file association, rather than an executable command.</const>
      <const name="IGNORE_HOST">Ignore the host platform's file assocations.</const>
      <const name="HOST">Query the host platform's file associations only.</const>
    </constants>

    <constants lookup="MEM" comment="Memory types used by AllocMemory().  The lower 16 bits are stored with allocated blocks, the upper 16 bits are function-relative only.">
      <const name="NO_BLOCK">If this flag is set against a public memory block then the access blocking mechanism will be permanently turned off for all accesses to that particular memory block.  This means that multiple tasks can have full read/write access to the memory block at once regardless of the flags passed to AccessMemory().</const>
      <const name="FIXED">This flag can be applied to public memory blocks that need to be mapped to a fixed address that is common to all tasks.  For instance, if the system locks the memory block to address 0x56084000 for your task, then all other tasks that map the memory block will also see it at that address.  This flag is typically used for supporting absolute code execution.</const>
      <const name="READ_WRITE">Synonym for READ | WRITE</const>
      <const name="WRITE">The memory is explicitly marked as writeable.</const>
      <const name="NO_BLOCKING">If this flag is set against a public memory block then the access blocking mechanism will be permanently turned off for all accesses to that particular memory block.  This means that multiple tasks can have full read/write access to the memory block at once regardless of the flags passed to AccessMemory().</const>
      <const name="CALLER">This flag is usable only in routines that are supporting a class method.  It forces the memory allocation to be tracked to the object that made the method call.  This is particularly important in methods that return memory blocks that do not form a part of the object itself.</const>
      <const name="UNTRACKED">Allocating an untracked memory block will prevent the memory block from being tracked back to the object holding the current context.</const>
      <const name="MANAGED">Enables custom resource management for the memory block.  The start of the block will need to be reserved with a pointer to a ResourceManager structure, which is included as part of the block's declared Size.  The Free() callback will be called when the block is removed.</const>
      <const name="NO_LOCK">For AllocMemory() only, indicates that the (private) memory block should not be locked on return.</const>
      <const name="TASK">Track the memory block to the current process, as opposed to the current object.</const>
      <const name="SHARED">Public memory can be allocated by specifying this flag.  Public memory blocks are accessible by all tasks, but access can only be gained by knowing the unique memory ID and utilising the AccessMemory() function.</const>
      <const name="RESERVED">This special flag is used to allocate shared memory blocks that require reserved ID numbers.  When using the MEM_RESERVED flag, you are required to set the longword pointed to by the ID argument to the ID that you wish to reserve.  If that memory ID is already taken, the AllocMemory() call will fail.</const>
      <const name="DATA">The default type, MEM_DATA, is used to indicate a standard memory allocation from system RAM.</const>
      <const name="PUBLIC">Public memory can be allocated by specifying this flag.  Public memory blocks are accessible by all tasks, but access can only be gained by knowing the unique memory ID and utilising the AccessMemory() function.</const>
      <const name="AUDIO">Identifies the memory space as being reserved by an audio device such as a sound card.</const>
      <const name="NO_POOL">Gives a hint to the allocator to allocate the block outside of the memory pool.</const>
      <const name="READ">The memory is explicitly marked as readable.</const>
      <const name="NO_CLEAR">Do not clear the memory on allocation (saves time).</const>
      <const name="CODE">Indicates that the memory will contain executable program code.</const>
      <const name="HIDDEN">Hidden blocks are not recorded and are excluded from resource tracking.</const>
      <const name="TMP_LOCK">Enables temporary locking restrictions.  Prevents processes from sleeping while holding a lock on the memory block.</const>
      <const name="STRING">Identifies the memory content as a null terminated string. Useful for debugging and run-time type identification in scripts.</const>
      <const name="TEXTURE">The memory space is reserved by a video driver for hosting texture graphics.</const>
      <const name="VIDEO">The memory space is reserved by a video device such as a graphics card for display purposes, e.g. framebuffer.</const>
    </constants>

    <constants lookup="ALF">
      <const name="SHARED">The lock will be shared between foreign processes.</const>
      <const name="RECURSIVE">Set if support for recursive locking within the same thread is required.</const>
    </constants>

    <constants lookup="RSF" comment="Flags for ResolvePath()">
      <const name="PATH">Use the PATH environment variable to resolve the file name in the Path parameter.</const>
      <const name="NO_FILE_CHECK">Do not test for the existence of the targeted file or folder during the resolution process.</const>
      <const name="APPROXIMATE">Ignores file extensions for the purpose of file name matching.</const>
      <const name="CHECK_VIRTUAL">If the volume referenced by Path is traced to another volume that is reserved by a virtual file system driver, ERR_VirtualVolume is returned. The volume is still resolved as far as possible and the resulting path will be returned by this function.</const>
      <const name="CASE_SENSITIVE">For use on host systems that use case-insensitive file systems such as Windows; this option checks that the discovered file is a case-sensitive match to the Path.</const>
      <const name="NO_DEEP_SCAN">Do not perform more than one iteration when resolving the source file path.</const>
    </constants>

    <constants lookup="RDF" comment="Flags for the OpenDir() function.">
      <const name="LINK">Feedback only - file/folder is actually a link to another location.</const>
      <const name="ARCHIVE">Feedback only - archive bit is set.</const>
      <const name="QUALIFIED">Return fully qualified folder names (i.e. trailing slash or colon for each name).</const>
      <const name="QUALIFY">Return fully qualified folder names (i.e. trailing slash or colon for each name).</const>
      <const name="VIRTUAL">Path is to a virtual device.</const>
      <const name="READ_ALL">Synonym for SIZE | DATE | PERMISSIONS | FILES | FOLDERS</const>
      <const name="READ_ONLY">Read-only (not permissions related and might indicate read-only media).</const>
      <const name="SIZE">Retrieve the byte size of each file.</const>
      <const name="PERMISSIONS">Get permission/security information.</const>
      <const name="FILES">Read all files in the folder.</const>
      <const name="STREAM">Path is connected via a stream, e.g. network connection.</const>
      <const name="DATE">Retrieve the date stamp of each file.</const>
      <const name="FOLDER">Read all folders/volumes in the folder.</const>
      <const name="VOLUME">Feedback only - indicates a volume.</const>
      <const name="HIDDEN">Feedback only - file/folder is hidden.</const>
      <const name="FILE">Read all files in the folder.</const>
      <const name="TAGS">Receive additional information for each file, such as comments, author and copyright.  The results are stored in the Tags field of each file.</const>
      <const name="TIME">Retrieve the date stamp of each file.</const>
      <const name="FOLDERS">Read all folders/volumes in the folder.</const>
    </constants>

    <constants lookup="MFF" comment="Flags for the File Watch() method.">
      <const name="MOVED">Existing file moved or renamed.</const>
      <const name="UNMOUNT">Host filesystem was unmounted.</const>
      <const name="ATTRIB">File permissions or datestamp changed.</const>
      <const name="DEEP">Receive notifications from sub-folders (Windows only).</const>
      <const name="CLOSED">An opened file has been closed.</const>
      <const name="FILE">File identifier; if passed to Watch() then indicates a preference for file events only.</const>
      <const name="FOLDER">Folder identifier; if passed to Watch() then indicates a preference for folder events only.</const>
      <const name="WRITE">File modified via write or truncation.</const>
      <const name="SELF">Event applies to the monitored folder and not a contained item</const>
      <const name="OPENED">Existing file was opened.</const>
      <const name="RENAME">Existing file moved or renamed.</const>
      <const name="READ">File was accessed (read).</const>
      <const name="CREATE">New file/link created or renamed in folder.</const>
      <const name="DELETE">Existing file deleted</const>
      <const name="MODIFY">File modified via write or truncation.</const>
    </constants>

    <constants lookup="LOC" comment="AnalysePath() values">
      <const name="DIRECTORY">The path refers to a folder.</const>
      <const name="VOLUME">The path refers to a volume name.</const>
      <const name="FILE">The path refers to a file.</const>
    </constants>

    <constants lookup="ACF" comment="AssociateCmd() values">
      <const name="ALL_USERS">Apply the command link to all users for that file type.  This will cause an error if sufficient privileges are not available to the logged-in user.</const>
    </constants>

    <constants lookup="TSF" comment="Task flags">
      <const name="PIPE">Enable the output pipe to the launched process so that it can read data.</const>
      <const name="SHELL">Enables shell mode.  On Unix systems, this means that a shell (usually BASH) will be used to launch the process.</const>
      <const name="DEBUG">Additional debug messages will be printed during normal usage of the task class when this flag is set.</const>
      <const name="WAIT">This flag will cause the parent process to halt when the task is activated.  Control is returned to the parent process once the child process terminates.</const>
      <const name="QUIET">Setting this flag will divert all process output to /dev/null or the nearest equivalent for non-Unix systems.</const>
      <const name="RESET_PATH">If set, the executed process will start in its own folder rather than the folder of the parent process.</const>
      <const name="FOREIGN">Set this flag when using the task object to execute a foreign process - that is an executable that does not use the Parasol API.</const>
      <const name="ATTACHED">Forces new task to be attached to the parent (child will close when parent closes).</const>
      <const name="DETACHED">Forces new task to be detached from the parent.</const>
      <const name="PRIVILEGED">During a normal execution process, any privileges of the parent process will be dropped so that the child process runs unprivileged.  This behaviour can be reversed if he PRIVILEGED flag is set, in which case the child process has the same privileges as the parent.</const>
    </constants>

    <constants lookup="FDT" comment="Flags for the SetDate() file method.">
      <const name="MODIFIED">The date on which the file was last modified.</const>
      <const name="CREATED">The date on which the file was created.  On some host platforms this datestamp may be read-only.</const>
      <const name="ACCESSED">The date on which the file was last accessed by a user or application.</const>
      <const name="ARCHIVED">The date on which the file was most recently archived.  Not supported by most filesystems.</const>
    </constants>

    <constants lookup="LDF" comment="Flags for LoadFile()">
      <const name="IGNORE_STATUS">The timestamp and size of the file will not be checked, which will result in the cached version of the file being returned regardless of any recent file changes.</const>
      <const name="CHECK_EXISTS">Limits the routine to checking the file cache for the existence of the file.  If found, the relevant cache entry is returned. The open count is not incremented by this action (it is therefore unnecessary to follow-up with a call to UnloadFile()).  If no up-to-date cache entry is available, ERR_Search is returned.</const>
    </constants>

    <constants lookup="FL" comment="File flags">
      <const name="LINK">Read-Only.  Indicates that the file is a symbolic link or shortcut to another file.</const>
      <const name="EXCLUDE_FOLDERS">Exclude folders when scanning this folder.</const>
      <const name="DEVICE">The file is a system device (must set if opening a device for read/write operations)</const>
      <const name="APPROXIMATE">Allows fuzzy matching of the file path when opening an existing file.  This means that the file extension will be ignored; for instance attempting to open a file of 'screenshot.png' when only a file name of 'screenshot.jpg' exists in the same folder, the 'screenshot.jpg' file will be opened instead.  If multiple files could potentially match to the file name, the file object will select the first match that is encountered.</const>
      <const name="EXCLUDE_FILES">Exclude files when scanning this folder.</const>
      <const name="RESET_DATE">For internal use only</const>
      <const name="STREAM">File data is streamed (e.g. PIPE, FIFO, socket) and may be accessed locally or via a network.</const>
      <const name="WRITE">Prepares a file for writing data, starting at byte position 0.  To start writing from the end of a file, use the Seek action after the file has been initialised.</const>
      <const name="DIRECTORY">The file object represents a folder.</const>
      <const name="NEW">Required when creating a new file.  If a file with the same name exists, its contents will be destroyed. If however the existing file is locked, the initalisation process will fail.</const>
      <const name="FILE">Explicitly declares the file object as an entity that stores content (as opposed to a device or folder for example).</const>
      <const name="READ">Required if the file needs to be opened for read access.</const>
      <const name="BUFFER">Activates a special mode in which the file data is stored in a memory buffer rather than a disk file.  Set the Size field to a value of at least 1 so that the initial buffer size is configured.  In this mode many of the available file operations are meaningless except for the Read, Write and Seek actions.</const>
      <const name="FOLDER">The file object represents a folder.</const>
      <const name="LOOP">In loop mode, the file object's position marker for read/write operations is allowed to extend past the actual file size.  Any read/write operation beyond the file size will loop back to the file at a corrected offset - for example, reading position 330 of a 100 byte file will start the operation from the 30th byte.  Loop mode does not affect any other area besides the read, write and seek operations.  The loop feature is typically used to create multimedia data streams with minimal effort.</const>
    </constants>

  </types>
  <structs>
    <struct name="MethodArray">
      <field name="MethodID" type="LONG"></field>
      <field name="Routine" type="APTR">ERROR (*Routine)(OBJECTPTR, APTR);</field>
      <field name="Name" type="CSTRING"></field>
      <field name="Args" type="const struct FunctionField *"></field>
      <field name="Size" type="LONG"></field>
    </struct>

    <struct name="rkBase64Decode" comment="Private structure for the StrBase64Decode() function." typeName="BASE64DECODE">
      <field name="Step" type="UBYTE"></field>
      <field name="PlainChar" type="UBYTE"></field>
      <field name="Initialised" type="UBYTE"></field>
    </struct>

    <struct name="FileInfo" comment="Returned by GetFileInfo()">
      <field name="Size" type="LARGE">The size of the file's content.</field>
      <field name="TimeStamp" type="LARGE">64-bit time stamp - usable only for comparison (e.g. sorting).</field>
      <field name="Next" type="struct FileInfo *">Next structure in the list, or NULL.</field>
      <field name="Name" type="STRING">The name of the file.  This string remains valid until the next call to GetFileInfo().</field>
      <field name="Tags" type="struct KeyStore *">A store of special tag strings that are file-specific.</field>
      <field name="Flags" type="LONG" lookup="FL">Additional flags to describe the file.</field>
      <field name="Permissions" type="LONG" lookup="PERMIT">Standard permission flags.</field>
      <field name="UserID" type="LONG">User  ID (Unix systems only).</field>
      <field name="GroupID" type="LONG">Group ID (Unix systems only).</field>
      <field name="Created" type="struct DateTime">The date/time of the file's creation.</field>
      <field name="Modified" type="struct DateTime">The date/time of the last file modification.</field>
    </struct>

    <struct name="ChildEntry" comment="Structure for ListChildren() function">
      <field name="ObjectID" type="OBJECTID">Object ID</field>
      <field name="ClassID" type="CLASSID">The class ID of the referenced object.</field>
    </struct>

    <struct name="Field" comment="Used to describe the public fields of a class.">
      <field name="Arg" type="MAXINT">An option to complement the field type.  Can be a pointer or an integer value</field>
      <field name="GetValue" type="FUNCTION *" prototype="ERROR (*GetValue)(APTR, APTR)">A virtual function that will retrieve the value for this field.</field>
      <field name="SetValue" type="APTR">A virtual function that will set the value for this field.</field>
      <field name="WriteValue" type="FUNCTION *" prototype="ERROR (*WriteValue)(OBJECTPTR, struct Field *, LONG, const void *, LONG)">An internal function for writing to this field.</field>
      <field name="Name" type="CSTRING">The English name for the field, e.g. "Width"</field>
      <field name="FieldID" type="ULONG">Provides a fast way of finding fields, e.g. FID_WIDTH</field>
      <field name="Offset" type="UWORD">Field offset within the object</field>
      <field name="Index" type="UWORD">Field array index</field>
      <field name="Flags" type="LONG">Special flags that describe the field</field>
    </struct>

    <struct name="Function" comment="Function list array structure">
      <field name="Address" type="APTR"></field>
      <field name="Name" type="CSTRING"></field>
      <field name="Args" type="const struct FunctionField *"></field>
    </struct>

    <struct name="MemoryLocks" comment="A supplement structure for ListTasks.">
      <field name="MemoryID" type="MEMORYID">Reference to a memory ID.</field>
      <field name="Locks" type="WORD">The total number of locks on the memory block.</field>
    </struct>

    <struct name="MemInfo" typeName="MEMINFO">
      <field name="Start" type="APTR">The starting address of the memory block (does not apply to public blocks).</field>
      <field name="ObjectID" type="OBJECTID">The object that owns the memory block.</field>
      <field name="Size" type="LONG">The size of the memory block.</field>
      <field name="AccessCount" type="WORD">Total number of active locks on this block.</field>
      <field name="Flags" type="WORD">The type of memory.</field>
      <field name="MemoryID" type="MEMORYID">The unique ID for this block.</field>
      <field name="LockID" type="OBJECTID">Reference to the task that currently has a lock on the block.</field>
      <field name="TaskID" type="OBJECTID">The Task that owns the memory block</field>
      <field name="Handle" type="LONG">Native system handle (e.g. the shmid in Linux)</field>
    </struct>

    <struct name="ListTasks" comment="Structure for ListTasks()">
      <field name="ProcessID" type="LONG">Core process ID</field>
      <field name="TaskID" type="OBJECTID">Task ID for this array entry</field>
      <field name="WaitingProcessID" type="LONG">If the task is waiting, this field reflects the other task's ID</field>
      <field name="WaitingMemoryID" type="MEMORYID">If the task is waiting, this field reflects the memory ID</field>
      <field name="WaitingTime" type="LONG">If the task is waiting, the time at which the sleep started (msec)</field>
      <field name="MessageID" type="MEMORYID">Message queue ID</field>
      <field name="OutputID" type="OBJECTID">The object that the task should output information to</field>
      <field name="Semaphore" type="HOSTHANDLE"></field>
      <field name="InstanceID" type="LONG">Instance that the task belongs to</field>
      <field name="TotalMemoryLocks" type="LONG"></field>
      <field name="ModalID" type="OBJECTID"></field>
      <field name="MemoryLocks" type="struct MemoryLocks *"></field>
    </struct>

    <struct name="DirInfo" comment="Used by OpenDir() only">
      <field name="Info" type="struct FileInfo *">Pointer to a FileInfo structure</field>
    </struct>

    <struct name="CompressedItem">
      <field name="OriginalSize" type="LARGE">Original size of the file</field>
      <field name="CompressedSize" type="LARGE">Compressed size of the file</field>
      <field name="Next" type="struct CompressedItem *">Used only if this is a linked-list.</field>
      <field name="Path" type="CSTRING">Path to the file (includes folder prefixes).  Archived folders will include the trailing slash.</field>
      <field name="Tags" type="struct KeyStore *">Any archive specific information is expressed here as key value pairs.</field>
      <field name="Permissions" type="LONG" lookup="PERMIT">Original permissions - see PERMIT flags.</field>
      <field name="UserID" type="LONG">Original user ID</field>
      <field name="GroupID" type="LONG">Original group ID</field>
      <field name="OthersID" type="LONG">Original others ID</field>
      <field name="Flags" type="LONG" lookup="FL">FL flags</field>
      <field name="Created" type="struct DateTime">Date and time of the file's creation.</field>
      <field name="Modified" type="struct DateTime">Date and time last modified.</field>
    </struct>

    <struct name="SystemState" comment="Returned by the GetSystemState() function.">
      <field name="ErrorMessages" type="CSTRING *">A sorted array of all error codes, translated into human readable strings.</field>
      <field name="ErrorHeaders" type="CSTRING *">A sorted array of all error header codes, translated into human readable strings.</field>
      <field name="RootPath" type="CSTRING">The current root path, which defaults to the location of the installation folder.</field>
      <field name="SystemPath" type="CSTRING">The current path of the 'system:' volume.</field>
      <field name="ModulePath" type="CSTRING">The current path to the system modules, normally 'system:modules/'</field>
      <field name="Platform" type="CSTRING">String-based field indicating the user's platform.  Currently returns 'Native', 'Windows', 'OSX' or 'Linux'.</field>
      <field name="ConsoleFD" type="HOSTHANDLE">Internal</field>
      <field name="CoreVersion" type="LONG">Reflects the Core version number.</field>
      <field name="CoreRevision" type="LONG">Reflects the Core revision number.</field>
      <field name="InstanceID" type="LONG">This is the ID of the instance that the calling process resides in.</field>
      <field name="TotalErrorMessages" type="LONG">The total number of error codes listed in the ErrorMessages array.</field>
      <field name="TotalErrorHeaders" type="LONG">The total number of error headers listed in the ErrorHeaders array.</field>
      <field name="Stage" type="LONG">The current operating stage.  -1 = Initialising, 0 indicates normal operating status; 1 means that the program is shutting down; 2 indicates a program restart; 3 is for mode switches.</field>
    </struct>

    <struct name="FileFeedback">
      <field name="Size" type="LARGE">Size of the file</field>
      <field name="Position" type="LARGE">Current seek position within the file if moving or copying</field>
      <field name="Path" type="STRING"></field>
      <field name="Dest" type="STRING">Destination file/path if moving or copying</field>
      <field name="FeedbackID" type="LONG" lookup="FDB">Set to one of the FDB integers</field>
      <field name="Reserved" type="char" size="32">Reserved in case of future expansion</field>
    </struct>

    <struct name="FunctionField" comment="Used by ActionTable and Function structures to declare lists of parameters.">
      <field name="Name" type="CSTRING">Name of the field</field>
      <field name="Type" type="LONG">Type of the field</field>
    </struct>

    <struct name="KeyStore" comment="Key-pair storage created by VarNew()">
      <field name="Mutex" type="APTR">Internal mutex for managing thread-safety.</field>
      <field name="Data" type="struct KeyPair * *">Key-pairs are stored here.</field>
      <field name="TableSize" type="LONG">The size of the available storage area.</field>
      <field name="Total" type="LONG">Total number of currently stored key-pairs, including dead keys.</field>
      <field name="Flags" type="LONG" lookup="KSF">Optional flags used for VarNew()</field>
    </struct>

    <struct name="Message" comment="Messaging structures.  Note: This structure is utilised by NextMsg">
      <field name="Time" type="LARGE">A timestamp acquired from PreciseTime() when the message was first passed to SendMessage().</field>
      <field name="UniqueID" type="LONG">A unique identifier automatically created by SendMessage().</field>
      <field name="Type" type="LONG">A message type identifier as defined by the client.</field>
      <field name="Size" type="LONG">The size of the message data, in bytes.  If there is no data associated with the message, the Size will be set to zero.&lt;/&gt;</field>
    </struct>

    <struct name="RGB8" comment="8-bit RGB colour value." typeName="RGB8">
      <field name="Red" type="UBYTE">Red component value</field>
      <field name="Green" type="UBYTE">Green component value</field>
      <field name="Blue" type="UBYTE">Blue component value</field>
      <field name="Alpha" type="UBYTE">Alpha component value</field>
    </struct>

    <struct name="DateTime" comment="Generic structure for date-time management.">
      <field name="Year" type="LONG">Year</field>
      <field name="Month" type="LONG">Month 1 to 12</field>
      <field name="Day" type="LONG">Day 1 to 31</field>
      <field name="Hour" type="LONG">Hour 0 to 23</field>
      <field name="Minute" type="LONG">Minute 0 to 59</field>
      <field name="Second" type="LONG">Second 0 to 59</field>
      <field name="TimeZone" type="LONG">TimeZone -13 to +13</field>
    </struct>

    <struct name="FieldArray" comment="Used to construct class blueprints for the MetaClass.">
      <field name="Name" type="CSTRING">The name of the field, e.g. "Width"</field>
      <field name="Flags" type="LONG">Special flags that describe the field</field>
      <field name="Arg" type="MAXINT">Can be a pointer or an integer value</field>
      <field name="GetField" type="APTR">void GetField(*Object, APTR Result);</field>
      <field name="SetField" type="APTR">ERROR SetField(*Object, APTR Value);</field>
    </struct>

    <struct name="ActionTable" comment="Structure for ActionList">
      <field name="Hash" type="ULONG">Hash of the action name.</field>
      <field name="Name" type="CSTRING">Name of the action.</field>
      <field name="Args" type="const struct FunctionField *">List of fields that are passed to this action.</field>
      <field name="Size" type="LONG">Byte-size of the structure for this action.</field>
    </struct>

  </structs>
</book>
