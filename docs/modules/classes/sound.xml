<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="class.xsl"?>

<book>
  <info>
    <name>Sound</name>
    <type>class</type>
    <module>Audio</module>
    <comment>Plays and records sound samples in a variety of different data formats.</comment>
    <fileExtension>*.wav|*.wave|*.snd</fileExtension>
    <fileDescription>Sound Sample</fileDescription>
    <version>1</version>
    <id>105ee06e</id>
    <idstring>ID_SOUND</idstring>
    <category>Audio</category>
    <include>modules/sound.h</include>
    <copyright>Paul Manias Â© 2002-2022</copyright>
    <description>
<p>The Sound class provides a simple interface for any program to load and play audio sample files. By default all loading and saving of sound data is in WAVE format.  Other audio formats can be supported through Sound class extensions, if available.</p>
<p>Smart, transparent streaming is enabled by default.  If an attempt is made to play an audio file that is considerably large (relative to system resources), it will be streamed from the source location.  You can alter or force streaming behaviour through the <field>Stream</field> field.</p>
<p>The following example illustrates playback of a sound sample one octave higher than its normal frequency.  The subscription to the Deactivate action will result in the program closing once the sample has finished playback.</p>
<pre>local snd = obj.new('sound', { path='audio:samples/doorbell.wav', note='C6' })

snd.subscribe("deactivate", function(SoundID)
   mSys.SendMessage(0, MSGID_QUIT)
end)

snd.acActivate()
</pre></description>
    <source>
      <file>class_sound.cpp</file>
    </source>
  </info>

  <actions>
    <action>
      <name>Activate</name>
      <comment>Plays the audio sample.</comment>
    </action>

    <action>
      <name>Deactivate</name>
      <comment>Stops the audio sample and resets the playback position.</comment>
    </action>

    <action>
      <name>Disable</name>
      <comment>Disable playback of an active audio sample.</comment>
    </action>

    <action>
      <name>Enable</name>
      <comment>Continues playing a sound if it has been disabled.</comment>
    </action>

    <action>
      <name>GetVar</name>
      <comment>Retrieve custom tag values.</comment>
      <description>
<p>The following custom tag values are formally recognised and may be defined automatically when loading sample files:</p>
<types type="Tag">
<type name="Author">The name of the person or organisation that created the sound sample.</type>
<type name="Copyright">Copyright details of an audio sample.</type>
<type name="Description">Long description for an audio sample.</type>
<type name="Disclaimer">The disclaimer associated with an audio sample.</type>
<type name="Software">The name of the application that was used to record the audio sample.</type>
<type name="Title">The title of the audio sample.</type>
</types>
      </description>
    </action>

    <action>
      <name>Reset</name>
      <comment>Stops audio playback, resets configuration details and restores the playback position to the start of the sample.</comment>
    </action>

    <action>
      <name>SaveToObject</name>
      <comment>Saves audio sample data to an object.</comment>
    </action>

    <action>
      <name>Seek</name>
      <comment>Moves sample playback to a new position.</comment>
    </action>

    <action>
      <name>SetVar</name>
      <comment>Define custom tags that will be saved with the sample data.</comment>
    </action>

  </actions>

  <fields>
    <field>
      <name>Active</name>
      <comment>Returns TRUE if the sound sample is being played back.</comment>
      <access read="G">Get</access>
      <type>INT</type>
    </field>

    <field>
      <name>Audio</name>
      <comment>Refers to the audio object/device to use for playback.</comment>
      <access read="R" write="I">Read/Init</access>
      <type>OBJECTID</type>
      <description>
<p>Set this field if a specific <class name="Audio">Audio</class> object should be targeted when playing the sound sample.</p>
      </description>
    </field>

    <field>
      <name>BitsPerSample</name>
      <comment>Indicates the sample rate of the audio sample, typically 8 or 16 bit.</comment>
      <access read="R" write="W">Read/Write</access>
      <type>INT</type>
    </field>

    <field>
      <name>BufferLength</name>
      <comment>Defines the size of the buffer to use when streaming is enabled.</comment>
      <access read="R" write="I">Read/Init</access>
      <type>INT</type>
      <description>
<p>This field fine-tunes the size of the buffer that is used when streaming.  When manually choosing a buffer size, it is usually best to keep the size between 64 and 128k.  Some systems may ignore the BufferLength field if the audio driver is incompatible with manually defined buffer lengths.</p>
      </description>
    </field>

    <field>
      <name>BytesPerSecond</name>
      <comment>The flow of bytes-per-second when the sample is played at normal frequency.</comment>
      <access read="R" write="W">Read/Write</access>
      <type>INT</type>
      <description>
<p>This field is set on initialisation.  It indicates the total number of bytes per second that will be played if the sample is played back at its normal frequency.</p>
      </description>
    </field>

    <field>
      <name>ChannelIndex</name>
      <comment>Refers to the channel that the sound is playing through.</comment>
      <access read="R">Read</access>
      <type>INT</type>
      <description>
<p>This field reflects the audio channel index that the sound is currently playing through, or has most recently played through.</p>
      </description>
    </field>

    <field>
      <name>Compression</name>
      <comment>Determines the amount of compression used when saving an audio sample.</comment>
      <access read="R" write="W">Read/Write</access>
      <type>INT</type>
      <description>
<p>Setting the Compression field will determine how much compression is applied when saving an audio sample.  The range of compression is 0 to 100%, with 100% being the strongest level available while 0% is uncompressed and loss-less.  This field is ignored if the file format does not support compression.</p>
      </description>
    </field>

    <field>
      <name>Flags</name>
      <comment>Optional initialisation flags.</comment>
      <access read="R" write="S">Read/Set</access>
      <type lookup="SDF">INT</type>
      <description>
<types lookup="SDF"/>
      </description>
    </field>

    <field>
      <name>Frequency</name>
      <comment>The frequency of a sampled sound is specified here.</comment>
      <access read="R" write="I">Read/Init</access>
      <type>INT</type>
      <description>
<p>This field specifies the frequency of the sampled sound data.  If the frequency cannot be determined from the source, this value will be zero.</p>
<p>Note that if the playback frequency needs to be altered, set the <field>Playback</field> field.</p>
      </description>
    </field>

    <field>
      <name>Header</name>
      <comment>Contains the first 128 bytes of data in a sample's file header.</comment>
      <access read="G">Get</access>
      <type>APTR []</type>
      <description>
<p>The Header field is a pointer to a 128 byte buffer that contains the first 128 bytes of information read from an audio file on initialisation.  This special field is considered to be helpful only to developers writing add-on components for the sound class.</p>
<p>The buffer that is referred to by the Header field is not populated until the Init action is called on the sound object.</p>
      </description>
    </field>

    <field>
      <name>Length</name>
      <comment>Indicates the total byte-length of sample data.</comment>
      <access read="R" write="W">Read/Write</access>
      <type>INT</type>
      <description>
<p>This field specifies the length of the sample data in bytes.  To get the length of the sample in seconds, divide this value by the <field>BytesPerSecond</field> field.</p>
      </description>
    </field>

    <field>
      <name>LoopEnd</name>
      <comment>The byte position at which sample looping will end.</comment>
      <access read="R" write="W">Read/Write</access>
      <type>INT</type>
      <description>
<p>When using looped samples (via the <code>SDF_LOOP</code> flag), set the LoopEnd field if the sample should end at a position that is earlier than the sample's actual length.  The LoopEnd value is specified in bytes and must be less or equal to the length of the sample and greater than the <field>LoopStart</field> value.</p>
      </description>
    </field>

    <field>
      <name>LoopStart</name>
      <comment>The byte position at which sample looping begins.</comment>
      <access read="R" write="W">Read/Write</access>
      <type>INT</type>
      <description>
<p>When using looped samples (via the <code>SDF_LOOP</code> flag), set the LoopStart field if the sample should begin at a position other than zero.  The LoopStart value is specified in bytes and must be less than the length of the sample and the <field>LoopEnd</field> value.</p>
<p>Note that the LoopStart variable does not affect the position at which playback occurs for the first time - it only affects the restart position when the end of the sample is reached.</p>
      </description>
    </field>

    <field>
      <name>Note</name>
      <comment>The musical note to use when playing a sound sample.</comment>
      <access read="G" write="S">Get/Set</access>
      <type lookup="NOTE">STRING</type>
      <description>
<p>Set the Note field to alter the playback frequency of a sound sample.  By setting this field as opposed to the <field>Playback</field> frequency, you can be assured that the sample is played as a correctly scaled note.</p>
<p>The Note field can be set using either string or integer based format.  If you are using the integer format, the number that you choose reflects on the position on a musical keyboard.  A value of zero refers to the middle C key.  Each octave is measured in sets of 12 notes, so a value of 24 would indicate a C note at 3 times normal playback.  To play at lower values, simply choose a negative integer to slow down sample playback.</p>
<p>Setting the Note field with the string format is useful if human readability is valuable.  The correct format is <code>KEY OCTAVE SHARP</code>.  Here are some examples: <code>C5, D7#, G2, E3S</code>.</p>
<p>The middle C key for this format is <code>C5</code>.  The maximum octave that you can achieve for the string format is 9 and the lowest is 0.  Use either the <code>S</code> character or the <code>#</code> character for referral to a sharp note.</p>
<types lookup="NOTE"/>
      </description>
    </field>

    <field>
      <name>Octave</name>
      <comment>The octave to use for sample playback.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>INT</type>
      <description>
<p>The Octave field determines the octave to use when playing back a sound sample.  The default setting is zero, which represents the octave at which the sound was sampled.  Setting a negative octave will lower the playback rate, while positive values raise the playback rate.  The minimum octave setting is -5 and the highest setting is +5.</p>
<p>The octave can also be adjusted by setting the <field>Note</field> field.  Setting the Octave field directly is useful if you need to quickly double or halve the playback rate.</p>
      </description>
    </field>

    <field>
      <name>Pan</name>
      <comment>Determines the horizontal position of a sound when played through stereo speakers.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>DOUBLE</type>
      <description>
<p>The Pan field adjusts the "horizontal position" of a sample that is being played through stereo speakers. The default value for this field is zero, which plays the sound through both speakers at an equal level.  The minimum value is -1.0 to force play through the left speaker and the maximum value is 1.0 for the right speaker.</p>
      </description>
    </field>

    <field>
      <name>Path</name>
      <comment>Location of the audio sample data.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>STRING</type>
      <description>
<p>This field must refer to a file that contains the audio data that will be loaded.  If creating a new sample with the <code>SDF_NEW</code> flag, it is not necessary to define a file source.</p>
      </description>
    </field>

    <field>
      <name>Playback</name>
      <comment>The playback frequency of the sound sample can be defined here.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>INT</type>
      <description>
<p>Set this field to define the exact frequency of a sample's playback.  The playback frequency can be modified at any time, including during audio playback if real-time adjustments to a sample's audio output rate is desired.</p>
      </description>
    </field>

    <field>
      <name>Position</name>
      <comment>The current playback position.</comment>
      <access read="G" write="S">Get/Set</access>
      <type>INT</type>
      <description>
<p>The current playback position of the audio sample is indicated by this field.  Writing to the field will alter the playback position, either when the sample is next played, or immediately if it is currently playing.</p>
      </description>
    </field>

    <field>
      <name>Priority</name>
      <comment>The priority of a sound in relation to other sound samples being played.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>INT</type>
      <description>
<p>The playback priority of the sample is defined here. This helps to determine if the sample should be played when all available mixing channels are busy. Naturally, higher priorities are played over samples with low priorities.</p>
<p>The minimum priority value allowed is -100, the maximum is 100.</p>
      </description>
    </field>

    <field>
      <name>Stream</name>
      <comment>Defines the preferred streaming method for the sample.</comment>
      <access read="R" write="W">Read/Write</access>
      <type lookup="STREAM">STREAM</type>
      <description>
<types lookup="STREAM"/>
      </description>
    </field>

    <field>
      <name>StreamFile</name>
      <comment>Refers to a File object that is being streamed for playback.</comment>
      <access read="R" write="I">Read/Init</access>
      <type>OBJECTID</type>
      <description>
<p>This field is maintained internally and is defined post-initialisation.  It refers to a <class name="File">File</class> object that is being streamed.</p>
      </description>
    </field>

    <field>
      <name>Volume</name>
      <comment>The volume to use when playing the sound sample.</comment>
      <access read="R" write="S">Read/Set</access>
      <type>DOUBLE</type>
      <description>
<p>The field specifies the volume of a sound in the range 0 - 1.0 (low to high).  Setting this field during sample playback will dynamically alter the volume.</p>
      </description>
    </field>

  </fields>
  <types>
    <constants lookup="NOTE" comment="Definitions for the Note field.  An 'S' indicates a sharp note.">
      <const name="A"/>
      <const name="AS"/>
      <const name="B"/>
      <const name="C"/>
      <const name="CS"/>
      <const name="D"/>
      <const name="DS"/>
      <const name="E"/>
      <const name="F"/>
      <const name="FS"/>
      <const name="G"/>
      <const name="GS"/>
      <const name="OCTAVE"/>
    </constants>

    <constants lookup="SDF" comment="Sound flags">
      <const name="LOOP">Enables sample looping. The LoopStart and LoopEnd fields determine where the looping area lies within the sample data.</const>
      <const name="NEW">Create the sample from scratch (e.g. for audio recording purposes).</const>
      <const name="QUERY">Query the meta data of the sample source; do not load sample data.</const>
      <const name="RESTRICT_PLAY">Restricts playback so that the sound can never play on more than one channel at any given time.</const>
      <const name="STEREO">Indicates that the sound has multiple audio channels.</const>
      <const name="STREAM">Read-Only. Indicates that streaming is enabled.</const>
    </constants>

    <constants lookup="STREAM" comment="Streaming options">
      <const name="ALWAYS">Stream if the sample length exceeds 64k.</const>
      <const name="NEVER">No streaming - load all data into memory.</const>
      <const name="SMART">Smart streaming is the default.  If the sample appears to be relatively small with respect to available system RAM, it will be loaded into memory.  Otherwise it will be streamed.</const>
    </constants>

  </types>
  <structs>
  </structs>
</book>
