<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="module.xsl"?>

<book>
  <info>
    <name>Audio</name>
    <type>module</type>
    <version>1</version>
    <copyright>Paul Manias Â© 2002-2022</copyright>
    <classes>
      <class>Audio</class>
      <class>Sound</class>
    </classes>
  </info>

  <function>
    <name>MixContinue</name>
    <comment>Continue playing a stopped channel.</comment>
    <prototype>ERROR sndMixContinue(objAudio * Audio, LONG Handle)</prototype>
    <input>
      <param type="objAudio *" name="Audio">The target Audio object.</param>
      <param type="LONG" name="Handle">The target channel.</param>
    </input>
    <description>
<p>This function will continue playback on a channel that has previously been stopped.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>MixEndSequence</name>
    <comment>Ends the buffering of mix commands.</comment>
    <prototype>ERROR sndMixEndSequence(objAudio * Audio, LONG Handle)</prototype>
    <input>
      <param type="objAudio *" name="Audio">The target Audio object.</param>
      <param type="LONG" name="Handle">The target channel.</param>
    </input>
    <description>
<p>Use this function to end a buffered command sequence that was started by <function module="Audio">MixStartSequence</function>.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>MixFadeIn</name>
    <comment>Fade in a channel from zero volume.</comment>
    <prototype>ERROR sndMixFadeIn(objAudio * Audio, LONG Handle)</prototype>
    <input>
      <param type="objAudio *" name="Audio">The target Audio object.</param>
      <param type="LONG" name="Handle">The target channel.</param>
    </input>
    <description>
<p>This function will fade in a mixer channel that has previously been faded out with MixFadeOut.  It is a requirement that <code>VOL_RAMPING</code> or <code>OVER_SAMPLING</code> flags have been set in the target Audio object.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>MixFadeOut</name>
    <comment>Fade a channel to zero volume.</comment>
    <prototype>ERROR sndMixFadeOut(objAudio * Audio, LONG Handle)</prototype>
    <input>
      <param type="objAudio *" name="Audio">The target Audio object.</param>
      <param type="LONG" name="Handle">The target channel.</param>
    </input>
    <description>
<p>This function will fade out a mixer channel if in oversampling mode and the channel has data being played.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>MixFrequency</name>
    <comment>Sets a channel's playback rate.</comment>
    <prototype>ERROR sndMixFrequency(objAudio * Audio, LONG Handle, LONG Frequency)</prototype>
    <input>
      <param type="objAudio *" name="Audio">The target Audio object.</param>
      <param type="LONG" name="Handle">The target channel.</param>
      <param type="LONG" name="Frequency">The desired frequency.</param>
    </input>
    <description>
<p>Use this function to set the playback rate of a mixer channel.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>MixMute</name>
    <comment>Mutes the audio of a channel.</comment>
    <prototype>ERROR sndMixMute(objAudio * Audio, LONG Handle, LONG Mute)</prototype>
    <input>
      <param type="objAudio *" name="Audio">The target Audio object.</param>
      <param type="LONG" name="Handle">The target channel.</param>
      <param type="LONG" name="Mute">Set to any value to mute the channel.  A value of 0 will undo the mute setting.</param>
    </input>
    <description>
<p>Use this function to mute the audio of a mixer channel.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>MixPan</name>
    <comment>Sets a channel's panning value.</comment>
    <prototype>ERROR sndMixPan(objAudio * Audio, LONG Handle, DOUBLE Pan)</prototype>
    <input>
      <param type="objAudio *" name="Audio">The target Audio object.</param>
      <param type="LONG" name="Handle">The target channel.</param>
      <param type="DOUBLE" name="Pan">The desired pan value between -1.0 and 1.0.</param>
    </input>
    <description>
<p>Use this function to set a mixer channel's panning value.  Accepted values are between -1.0 (left) and 1.0 (right).</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>MixPlay</name>
    <comment>Commences channel playback at a set frequency..</comment>
    <prototype>ERROR sndMixPlay(objAudio * Audio, LONG Handle, LONG Frequency)</prototype>
    <input>
      <param type="objAudio *" name="Audio">The target Audio object.</param>
      <param type="LONG" name="Handle">The target channel.</param>
      <param type="LONG" name="Frequency">The new playing position, measured in bytes.</param>
    </input>
    <description>
<p>This function will start playback of the sound sample associated with the target mixer channel.  If the channel is already in playback mode, it will be stopped to facilitate the new playback request.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>MixPosition</name>
    <comment>Sets a channel's playing position relative to the current sample.</comment>
    <prototype>ERROR sndMixPosition(objAudio * Audio, LONG Handle, LONG Position)</prototype>
    <input>
      <param type="objAudio *" name="Audio">The target Audio object.</param>
      <param type="LONG" name="Handle">The target channel.</param>
      <param type="LONG" name="Position">The new playing position, measured in bytes.</param>
    </input>
    <description>
<p>This function will change the playing position of a mixer channel for the current sound sample.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="OutOfRange">A specified number is outside of the valid range.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>MixRate</name>
    <comment>Sets a new update rate for a channel.</comment>
    <prototype>ERROR sndMixRate(objAudio * Audio, LONG Handle, LONG Rate)</prototype>
    <input>
      <param type="objAudio *" name="Audio">The target Audio object.</param>
      <param type="LONG" name="Handle">The target channel.</param>
      <param type="LONG" name="Rate">The new update rate in milliseconds.</param>
    </input>
    <description>
<p>This function will set a new update rate for all channels, measured in milliseconds.  The default update rate is 125, which is equivalent to 5000Hz.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>MixSample</name>
    <comment>Associate a sound sample with a mixer channel.</comment>
    <prototype>ERROR sndMixSample(objAudio * Audio, LONG Handle, LONG Sample)</prototype>
    <input>
      <param type="objAudio *" name="Audio">The target Audio object.</param>
      <param type="LONG" name="Handle">The target channel.</param>
      <param type="LONG" name="Sample">A sample handle allocated from <class name="Audio" index="AddSample()">Audio:AddSample()</class> or <class name="Audio" index="AddStream()">Audio:AddStream()</class>.</param>
    </input>
    <description>
<p>This function will associate a sound sample with a mixer channel.  Configuration should then follow (e.g. volume and pan values).</p>
<p>The referenced Sample must have been added to the audio server via the <class name="Audio" index="AddSample()">Audio:AddSample()</class> or <class name="Audio" index="AddStream()">Audio:AddStream()</class> methods.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>MixStartSequence</name>
    <comment>Initiates buffering of mix commands.</comment>
    <prototype>ERROR sndMixStartSequence(objAudio * Audio, LONG Handle)</prototype>
    <input>
      <param type="objAudio *" name="Audio">The target Audio object.</param>
      <param type="LONG" name="Handle">The target channel.</param>
    </input>
    <description>
<p>Use this function to initiate the buffering of mix commands, up until a call to <function module="Audio">MixEndSequence</function> is made.  The buffering of mix commands makes it possible to create batches of commands that are executed at timed intervals as determined by <function module="Audio">MixRate</function>.</p>
<p>This feature can be used to implement complex sound mixes and digital music players.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>MixStop</name>
    <comment>Stops all playback on a channel.</comment>
    <prototype>ERROR sndMixStop(objAudio * Audio, LONG Handle)</prototype>
    <input>
      <param type="objAudio *" name="Audio">The target Audio object.</param>
      <param type="LONG" name="Handle">The target channel.</param>
    </input>
    <description>
<p>This function will stop a channel that is currently playing.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>MixStopLoop</name>
    <comment>Cancels any playback loop configured for a channel.</comment>
    <prototype>ERROR sndMixStopLoop(objAudio * Audio, LONG Handle)</prototype>
    <input>
      <param type="objAudio *" name="Audio">The target Audio object.</param>
      <param type="LONG" name="Handle">The target channel.</param>
    </input>
    <description>
<p>This function will cancel any loop that is associated with a mixer channel in playback mode.  This does not affect the loop configuration if playback is restarted for the active sample.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>MixVolume</name>
    <comment>Changes the volume of a channel.</comment>
    <prototype>ERROR sndMixVolume(objAudio * Audio, LONG Handle, DOUBLE Volume)</prototype>
    <input>
      <param type="objAudio *" name="Audio">The target Audio object.</param>
      <param type="LONG" name="Handle">The target channel.</param>
      <param type="DOUBLE" name="Volume">The new volume for the channel.</param>
    </input>
    <description>
<p>This function will change the volume of a mixer channel.  Valid values are between 0 and 1.0.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
      <error code="NullArgs">Function call missing argument value(s)</error>
    </result>
  </function>

  <function>
    <name>SetChannels</name>
    <comment>Defines the maximum number of channels available for sound mixing.</comment>
    <prototype>LONG sndSetChannels(LONG Total)</prototype>
    <input>
      <param type="LONG" name="Total">The total number of sound channels required by the client.</param>
    </input>
    <description>
<p>The maximum number of sound channels used for software-based sound mixing can be altered by calling this function. The recommended number of channels is 8, which would indicate that a maximum of 8 sound samples could be played simultaneously at any given time.</p>
    </description>
    <result type="LONG">The previous setting for the maximum number of sound channels is returned.</result>
  </function>

  <function>
    <name>StartDrivers</name>
    <comment>Starts the audio drivers (platform dependent).</comment>
    <prototype>ERROR sndStartDrivers()</prototype>
    <description>
<p>This function will start the audio drivers if they have not already been loaded and initialised.  This feature is platform specific and is typically used on boot-up only.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
    </result>
  </function>

  <function>
    <name>WaitDrivers</name>
    <comment>Wait for audio drivers to become initialised on boot-up.</comment>
    <prototype>ERROR sndWaitDrivers(LONG TimeOut)</prototype>
    <input>
      <param type="LONG" name="TimeOut">The desired timeout value indicated in 1/1000ths of a second.</param>
    </input>
    <description>
<p>This is an internal function used by the audio server to wait for audio drivers to start.  It does not return until the drivers have been initialised or the indicated TimeOut has expired.</p>
    </description>
    <result type="ERROR">
      <error code="Okay">Operation successful.</error>
    </result>
  </function>

  <types>
    <constants lookup="ADF" comment="Optional flags for the Audio object.">
      <const name="AUTO_SAVE">Save configuration information on exit.</const>
      <const name="FILTER_HIGH">Enable a high level of output filtering to minimise distortion.</const>
      <const name="FILTER_LOW">Enable a low level of output filtering to minimise distortion.</const>
      <const name="OVER_SAMPLING">Enables oversampling for higher quality audio at the cost of slower mixing.</const>
      <const name="STEREO">Enable stereo output (set by default if the platform supports stereo).  If not set, output is in mono.</const>
      <const name="SYSTEM_WIDE">Mixer changes should be applied system-wide.</const>
      <const name="VOL_RAMPING">Enable volume ramping for softer playback when a sample is played multiple times (enabled by default).</const>
    </constants>

    <constants lookup="CHF" comment="Optional flags for the AudioChannel structure.">
      <const name="BACKWARD">Play channel backwards.</const>
      <const name="CHANGED">Sample change</const>
      <const name="MUTE">Channel is muted.</const>
      <const name="VOL_RAMP">Volume ramping is enabled.</const>
    </constants>

    <constants lookup="CHS" comment="Channel status types for the AudioChannel structure.">
      <const name="FADE_OUT">Playback is fading out.</const>
      <const name="FINISHED">Playing has ended (not force stopped).</const>
      <const name="PLAYING">Sample playing and not released.</const>
      <const name="RELEASED">Sample playing and note has been released.</const>
      <const name="STOPPED">Playing is stopped.</const>
    </constants>

    <constants lookup="LOOP" comment="Loop modes for the AudioLoop structure.">
      <const name="AMIGA">Single loop: Amiga style.</const>
      <const name="AMIGA_NONE">Amiga loop: Do nothing.</const>
      <const name="DOUBLE">Double loop: When the note is released, playing shifts to the second loop.</const>
      <const name="SINGLE">Single loop: Releasing will end the note.</const>
      <const name="SINGLE_RELEASE">Single loop: Sample data after the loop will be played when the note is released.</const>
    </constants>

    <constants lookup="LTYPE" comment="Loop types for the AudioLoop structure.">
      <const name="BIDIRECTIONAL">The sample will play in reverse whenever it hits the end marker, then forwards when it hits the start marker.</const>
      <const name="UNIDIRECTIONAL">The sample playback position returns to the byte position specified in the Loop1Start field.</const>
    </constants>

    <constants lookup="NOTE" comment="Definitions for the Note field.  An 'S' indicates a sharp note.">
      <const name="A"/>
      <const name="AS"/>
      <const name="B"/>
      <const name="C"/>
      <const name="CS"/>
      <const name="D"/>
      <const name="DS"/>
      <const name="E"/>
      <const name="F"/>
      <const name="FS"/>
      <const name="G"/>
      <const name="GS"/>
      <const name="OCTAVE"/>
    </constants>

    <constants lookup="SDF" comment="Sound flags">
      <const name="LOOP">Enables sample looping. The LoopStart and LoopEnd fields determine where the looping area lies within the sample data.</const>
      <const name="NEW">Create the sample from scratch (e.g. for audio recording purposes).</const>
      <const name="QUERY">Query the meta data of the sample source; do not load sample data.</const>
      <const name="RESTRICT_PLAY">Restricts playback so that the sound can never play on more than one channel at any given time.</const>
      <const name="STEREO">Indicates that the sound has multiple audio channels.</const>
      <const name="STREAM">Read-Only. Indicates that streaming is enabled.</const>
    </constants>

    <constants lookup="SFM" comment="These audio bit formats are supported by AddSample and AddStream.">
      <const name="BIG_ENDIAN">Combine this flag with any audio format to declare it as big endian.</const>
      <const name="S16_BIT_MONO">16-bit mono signed sample.</const>
      <const name="S16_BIT_STEREO">16-bit stereo signed sample.</const>
      <const name="U8_BIT_MONO">8-bit mono unsigned sample.</const>
      <const name="U8_BIT_STEREO">8-bit stereo unsigned sample.</const>
    </constants>

    <constants lookup="STREAM" comment="Streaming options">
      <const name="ALWAYS">Stream if the sample length exceeds 64k.</const>
      <const name="NEVER">No streaming - load all data into memory.</const>
      <const name="SMART">Smart streaming is the default.  If the sample appears to be relatively small with respect to available system RAM, it will be loaded into memory.  Otherwise it will be streamed.</const>
    </constants>

    <constants lookup="SVF" comment="Flags for the SetVolume() method.">
      <const name="CAPTURE">Set input, not output.</const>
      <const name="MUTE">Mute the audio for this channel.</const>
      <const name="SYNC">Synchronise volume settings between channels.</const>
      <const name="UNMUTE">Unmute the audio for this channel.</const>
      <const name="UNSYNC">Allow un-synchronised volume settings.</const>
    </constants>

    <constants lookup="VCF" comment="Volume control flags">
      <const name="CAPTURE">The mixer supports audio input.</const>
      <const name="JOINED">The mixer channels are joined (e.g. left and right speakers cannot be adjusted separately).</const>
      <const name="MONO">The mixer is restricted to mono input/output.</const>
      <const name="MUTE">The mixer is muted.</const>
      <const name="PLAYBACK">The mixer supports audio output.</const>
      <const name="SYNC">The mixer is synchronised.</const>
    </constants>

  </types>
  <structs>
    <struct name="AudioLoop" comment="Loop settings for the AddSample() method.">
      <field name="LoopMode" type="LOOP" lookup="LOOP">Loop mode (single, double)</field>
      <field name="Loop1Type" type="LTYPE" lookup="LTYPE">First loop type (unidirectional, bidirectional)</field>
      <field name="Loop2Type" type="LTYPE" lookup="LTYPE">Second loop type (unidirectional, bidirectional)</field>
      <field name="Loop1Start" type="LONG">Start of the first loop</field>
      <field name="Loop1End" type="LONG">End of the first loop</field>
      <field name="Loop2Start" type="LONG">Start of the second loop</field>
      <field name="Loop2End" type="LONG">End of the second loop</field>
    </struct>

  </structs>
</book>
