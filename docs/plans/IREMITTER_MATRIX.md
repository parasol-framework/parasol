# IrEmitter Coverage Matrix

This matrix captures the Step 1 audit from docs/plans/IREMITTER.md: every legacy parser helper that still emits bytecode directly is mapped to the AST node kinds defined in `ast_nodes.h`, together with the bytecode helpers it triggers and the IrEmitter's current handling.  The table doubles as a to-do list—the "IrEmitter status" column records whether the new emitter already supports the construct or still falls back to `unsupported_*` so we can drive parity work item by item.

## Expression coverage

| Ast node kind | Legacy helper(s) | Key bytecode helpers / semantics | IrEmitter status |
| --- | --- | --- | --- |
| LiteralExpr | `expr_simple` recognises nil/boolean/number/string tokens and builds `ExpDesc` literals via `expr_init`; `expr_kvalue` turns literal expdescs into TValue constants for table templates.【F:src/fluid/luajit-2.1/src/parser/parse_expr.cpp†L600-L637】【F:src/fluid/luajit-2.1/src/parser/parse_expr.cpp†L137-L149】 | Only constant folding (`expr_init`, `expr_kvalue`); no bytecode emitted. | ✅ `emit_literal_expr` handles all literal kinds, mirroring the legacy ExpDesc creation.【F:src/fluid/luajit-2.1/src/parser/ir_emitter.cpp†L293-L341】 |
| IdentifierExpr | `expr_primary_with_context` dispatches identifiers to `LexState::var_lookup`, which searches locals/upvalues/globals via `var_lookup_`.【F:src/fluid/luajit-2.1/src/parser/parse_expr.cpp†L502-L564】【F:src/fluid/luajit-2.1/src/parser/parse_scope.cpp†L78-L140】 | `expr_init` populates `ExpKind::Local/Upval/Global`; may set `fscope_uvmark` to flag upvalue captures.【F:src/fluid/luajit-2.1/src/parser/parse_scope.cpp†L118-L139】 | ✅ `emit_identifier_expr` resolves locals, upvalues and globals via `resolve_local` and the `NameRef` metadata.【F:src/fluid/luajit-2.1/src/parser/ir_emitter.cpp†L343-L370】 |
| VarArgExpr | `expr_simple` handles the `...` token, emits `BC_VARG`, reserves a register, and tags the expdesc as `ExpKind::Call`.【F:src/fluid/luajit-2.1/src/parser/parse_expr.cpp†L611-L619】 | `bcemit_ABC(fs, BC_VARG, base, 2, numparams)` forwards all vararg results; `expr_set_flag(HasRhsReg)` preserves the source register.【F:src/fluid/luajit-2.1/src/parser/parse_expr.cpp†L611-L618】 | ✅ `emit_vararg_expr` reproduces the same pattern (register reserve + `BC_VARG`).【F:src/fluid/luajit-2.1/src/parser/ir_emitter.cpp†L373-L382】 |
| UnaryExpr | `expr_unop` parses prefix operators, calls `expr_simple` recursively, and emits `BC_UNM/BC_NOT/BC_LEN` or invokes `bcemit_unary_bit_call`.【F:src/fluid/luajit-2.1/src/parser/parse_expr.cpp†L880-L911】 | `bcemit_unop` for arithmetic/logical negation and length; `bcemit_unary_bit_call` for `~`. | ✅ `emit_unary_expr` mirrors the same opcode selection and helper usage.【F:src/fluid/luajit-2.1/src/parser/ir_emitter.cpp†L384-L409】 |
| BinaryExpr | `expr_binop` drives precedence, emits conditional chains for ternary/`??` mixes, calls `bcemit_binop_left`/`bcemit_binop`, and relies on `expr_shift_chain` for bitwise sequences.【F:src/fluid/luajit-2.1/src/parser/parse_expr.cpp†L917-L1028】 | `bcemit_binop_left`, `bcemit_binop`, jump patching for ternary/if-empty; `expr_collapse_freereg` normalises registers.【F:src/fluid/luajit-2.1/src/parser/parse_expr.cpp†L940-L1007】【F:src/fluid/luajit-2.1/src/parser/parse_expr.cpp†L1030-L1040】 | ⚠️ Partial – `emit_binary_expr` handles mapped operators but immediately rejects Fluid-specific ones (ternary/if-empty) because `map_binary_operator` lacks mappings, causing `unsupported_expr`.【F:src/fluid/luajit-2.1/src/parser/ir_emitter.cpp†L411-L430】 |
| UpdateExpr | Postfix/prefix `++/--` flow through `LexState::inc_dec_op`, which emits arithmetic bytecode and stores back to locals or indexed slots while tracking `ExprFlag::PostfixIncStmt`.【F:src/fluid/luajit-2.1/src/parser/parse_expr.cpp†L642-L683】 | `bcemit_arith`, `bcemit_store`, register guards for indexed writes.【F:src/fluid/luajit-2.1/src/parser/parse_expr.cpp†L656-L680】 | ❌ Not implemented—`AstNodeKind::UpdateExpr` never appears in `emit_expression`'s switch, so such nodes fall into `unsupported_expr`.【F:src/fluid/luajit-2.1/src/parser/ir_emitter.cpp†L293-L315】 |
| TernaryExpr | The `? :>` operator is encoded inside `expr_binop`, which emits `BC_ISEQP`/`BC_ISEQN`/`BC_ISEQS` branches, tracks depth, and patches jump lists for true/false arms.【F:src/fluid/luajit-2.1/src/parser/parse_expr.cpp†L940-L1007】 | Uses `bcemit_INS` with compare opcodes plus `JumpListView` patching to multiplex registers.【F:src/fluid/luajit-2.1/src/parser/parse_expr.cpp†L954-L1007】 | ❌ Not implemented—`AstNodeKind::TernaryExpr` does not have an emitter and defaults to `unsupported_expr`.【F:src/fluid/luajit-2.1/src/parser/ir_emitter.cpp†L293-L315】 |
| PresenceExpr | The postfix `??`/presence operator is parsed both via `should_emit_presence` and explicit `TokenKind::Presence` handling in `expr_primary_with_context`, which calls `bcemit_presence_check`.【F:src/fluid/luajit-2.1/src/parser/parse_expr.cpp†L125-L132】【F:src/fluid/luajit-2.1/src/parser/parse_expr.cpp†L545-L552】 | `bcemit_presence_check` rewrites the expdesc in place after the helper runs.【F:src/fluid/luajit-2.1/src/parser/parse_expr.cpp†L545-L552】 | ✅ `emit_presence_expr` executes the same helper after recursively emitting the child expression.【F:src/fluid/luajit-2.1/src/parser/ir_emitter.cpp†L433-L446】 |
| CallExpr | `expr_primary` suffix loop and `parse_args` drive function calls, covering `f()`, `f{}` and string args, vararg forwarding, and method dispatch (`bcemit_method`).【F:src/fluid/luajit-2.1/src/parser/parse_expr.cpp†L502-L557】【F:src/fluid/luajit-2.1/src/parser/parse_expr.cpp†L446-L503】 | `bcemit_method`, `expr_tonextreg`, `BC_CALL` vs `BC_CALLM`, `setbc_b` patches for varargs.【F:src/fluid/luajit-2.1/src/parser/parse_expr.cpp†L446-L503】 | ✅ `emit_call_expr` supports direct/method targets, argument lists, and BC_CALL/BC_CALLM selection, but lacks colon-call sugar beyond string receiver inference (needs future work for optional targets).【F:src/fluid/luajit-2.1/src/parser/ir_emitter.cpp†L485-L520】 |
| MemberExpr | `expr_field` turns dot/colon access into indexed expressions by interning string keys and calling `expr_index`.【F:src/fluid/luajit-2.1/src/parser/parse_expr.cpp†L64-L72】 | `expr_toanyreg` loads the table; `expr_index` encodes string constants into `u.s.aux`.【F:src/fluid/luajit-2.1/src/parser/parse_expr.cpp†L28-L59】 | ✅ `emit_member_expr` reproduces this flow (string key + `expr_index`).【F:src/fluid/luajit-2.1/src/parser/ir_emitter.cpp†L448-L462】 |
| IndexExpr | `expr_bracket` parses `t[expr]`, drains the key, then `expr_index` encodes register/constant indices before further suffix processing.【F:src/fluid/luajit-2.1/src/parser/parse_expr.cpp†L77-L86】【F:src/fluid/luajit-2.1/src/parser/parse_expr.cpp†L28-L59】 | `expr_toanyreg` on the table, `expr_toval` on the key, `expr_index` rewrites the expdesc to `ExpKind::Indexed`. | ✅ `emit_index_expr` mirrors the same `expr_toanyreg` + `expr_index` flow after emitting child expressions.【F:src/fluid/luajit-2.1/src/parser/ir_emitter.cpp†L464-L483】 |
| TableExpr | `expr_table` emits `BC_TNEW/TSET*` opcodes, folds constant keys into template tables, handles array/hash growth, and rewrites to `BC_TSETM` when the last entry is a call.【F:src/fluid/luajit-2.1/src/parser/parse_expr.cpp†L154-L279】 | Heavy use of `bcemit_AD`, `RegisterGuard`, `expr_kvalue`, `lj_tab_*` helpers, `BC_TSETM`, and `JumpListView` patches for multi-result writes.【F:src/fluid/luajit-2.1/src/parser/parse_expr.cpp†L154-L279】 | ❌ Not supported—`AstNodeKind::TableExpr` is absent from `emit_expression`'s switch, so constructors always error out. | 
| FunctionExpr | `expr_simple` detects the `function` keyword and calls `parse_body` to build nested prototypes (`BC_FUNCF` placeholder, child `FuncState`, `BC_FNEW` in parent).【F:src/fluid/luajit-2.1/src/parser/parse_expr.cpp†L621-L628】【F:src/fluid/luajit-2.1/src/parser/parse_expr.cpp†L315-L366】 | `bcemit_AD(BC_FUNCF)` placeholder in child, `bcemit_AD(BC_FNEW, const_gc(proto))` in parent, `fscope` nesting for parameters/upvalues.【F:src/fluid/luajit-2.1/src/parser/parse_expr.cpp†L315-L366】 | ❌ Not yet emitted—`AstNodeKind::FunctionExpr` falls through to `unsupported_expr`.【F:src/fluid/luajit-2.1/src/parser/ir_emitter.cpp†L293-L315】 |
| Block/ExpressionStmt nodes (expression wrappers) | Expression statements are parsed via `parse_call_assign` when the lhs is a call; AST builder wraps them as `ExpressionStmt`.【F:src/fluid/luajit-2.1/src/parser/parse_stmt.cpp†L347-L375】 | `setbc_b(...,1)` drops results for call statements, or expression value is stored/assigned. | ✅ `emit_expression_stmt` evaluates and frees the value (no bytecode).【F:src/fluid/luajit-2.1/src/parser/ir_emitter.cpp†L154-L167】 |

## Statement coverage

| Ast node kind | Legacy helper(s) | Key bytecode helpers / semantics | IrEmitter status |
| --- | --- | --- | --- |
| BlockStmt | `parse_block` opens a new `FuncScope`, parses nested statements, and relies on `parse_chunk` to free registers between statements.【F:src/fluid/luajit-2.1/src/parser/parse_stmt.cpp†L656-L663】【F:src/fluid/luajit-2.1/src/parser/parse_stmt.cpp†L1000-L1009】 | `ScopeGuard` pushes scope flags; `fs->freereg` reset at end of each statement. | ✅ `emit_block` mirrors the scope guard + local binding lifetime.【F:src/fluid/luajit-2.1/src/parser/ir_emitter.cpp†L103-L119】 |
| AssignmentStmt | `parse_assignment`, `assign_adjust`, `assign_hazard`, `assign_compound`, and `assign_if_empty` cover plain, compound, and `??` writes, calling helpers such as `bcemit_store`, `bcemit_binop`, and register guards.【F:src/fluid/luajit-2.1/src/parser/parse_stmt.cpp†L12-L151】【F:src/fluid/luajit-2.1/src/parser/parse_stmt.cpp†L157-L326】 | `bcemit_store`, `bcemit_binop_left`, `bcemit_nil`, hazard renames, `JumpListView` for `??`. | ⚠️ Minimal – `emit_assignment_stmt` only handles single plain identifiers and bails on everything else, so the emitter still reports unsupported for complex LHS/compound ops.【F:src/fluid/luajit-2.1/src/parser/ir_emitter.cpp†L232-L277】 |
| LocalDeclStmt | `parse_local` reserves variable slots, optionally emits initializer expressions, and uses `assign_adjust` to fill missing RHS terms.【F:src/fluid/luajit-2.1/src/parser/parse_stmt.cpp†L380-L438】 | `var_new`, `var_add`, `expr_list`, `assign_adjust`. | ⚠️ Limited – `emit_local_decl_stmt` allocates locals but only supports trivial value lists and does not yet handle local functions or destructuring defaults.【F:src/fluid/luajit-2.1/src/parser/ir_emitter.cpp†L201-L231】 |
| LocalFunctionStmt | Special-case branch inside `parse_local` that stores a nested function into the new slot and marks it initialised.【F:src/fluid/luajit-2.1/src/parser/parse_stmt.cpp†L385-L408】 | `parse_body`, `expr_toreg`, `var_get(...).startpc`. | ❌ Not emitted—IrEmitter lacks a dedicated path for local function declarations (AST nodes still routed through unsupported assignment). |
| FunctionStmt | `parse_func` resolves the dotted name, emits `BC_FNEW`, and stores the prototype (optionally with colon sugar).【F:src/fluid/luajit-2.1/src/parser/parse_stmt.cpp†L527-L545】 | `var_lookup`, `expr_field`, `bcemit_store`, line fixup on the store instruction.【F:src/fluid/luajit-2.1/src/parser/parse_stmt.cpp†L527-L545】 | ❌ Not supported—`emit_statement` does not include `FunctionStmt`, so top-level `function` definitions always raise `unsupported_stmt`.【F:src/fluid/luajit-2.1/src/parser/ir_emitter.cpp†L123-L150】 |
| IfStmt | `parse_if` reuses `parse_then`, emits jump lists for each branch, and patches them at `end`.【F:src/fluid/luajit-2.1/src/parser/parse_stmt.cpp†L912-L934】 | `expr_cond`, `bcemit_jmp`, `JumpListView::patch_to_here`. | ❌ Not emitted—control-flow statements fall into `unsupported_stmt`.【F:src/fluid/luajit-2.1/src/parser/ir_emitter.cpp†L123-L151】 |
| WhileStmt | `parse_while` evaluates the condition via `expr_cond`, emits `BC_LOOP` and backwards jumps, and invokes `fscope_loop_continue`.【F:src/fluid/luajit-2.1/src/parser/parse_stmt.cpp†L667-L692】 | `bcemit_AD(BC_LOOP)`, `bcemit_jmp`, `JumpListView`, `fscope_loop_continue`. | ❌ Unsupported in the emitter. |
| RepeatStmt | Builds nested scopes for `repeat ... until`, emits `BC_LOOP`, condition jumps, and handles upvalue-closing via `parse_break`.【F:src/fluid/luajit-2.1/src/parser/parse_stmt.cpp†L697-L727】 | `bcemit_AD(BC_LOOP)`, `expr_cond`, `JumpListView`, optional `BC_UCLO` path. | ❌ Unsupported. |
| NumericForStmt | `parse_for_num` allocates hidden loop variables, emits `BC_FORI/BC_FORL`, and patches loop heads/tails.【F:src/fluid/luajit-2.1/src/parser/parse_stmt.cpp†L732-L779】 | `bcemit_AJ(BC_FORI/BC_FORL)`, `var_new_fixed`, `fscope_loop_continue`. | ❌ Unsupported. |
| GenericForStmt | `parse_for_iter` handles iterator tuples, predicts `next`, emits `BC_ITERC/BC_ITERL` (or `ISNEXT`), and reserves registers for hidden/visible vars.【F:src/fluid/luajit-2.1/src/parser/parse_stmt.cpp†L819-L874】 | `bcreg_bump`, `predict_next`, `bcemit_ABC(BC_ITERC/ITERN)`, `JumpListView`. | ❌ Unsupported. |
| ForStmt | `parse_for` dispatches to numeric vs iterator helpers after consuming the control variable and wraps the loop in a `FuncScopeFlag::Loop`.【F:src/fluid/luajit-2.1/src/parser/parse_stmt.cpp†L879-L892】 | Combines the helper flows above. | ❌ Unsupported. |
| BreakStmt | `parse_break` resolves the surrounding loop scope, emits `bcemit_jmp`, and records the pending jump via `gola_new`.【F:src/fluid/luajit-2.1/src/parser/parse_stmt.cpp†L636-L649】 | `execute_defers`, `gola_new(JUMP_BREAK, VarInfoFlag::Jump, bcemit_jmp(fs))`. | ❌ Unsupported. |
| ContinueStmt | Same as break but with `JUMP_CONTINUE`, so deferred frames and pending gotos are managed correctly.【F:src/fluid/luajit-2.1/src/parser/parse_stmt.cpp†L617-L631】 | `gola_new(JUMP_CONTINUE, VarInfoFlag::Jump, bcemit_jmp(fs))`. | ❌ Unsupported. |
| ReturnStmt | `parse_return` handles bare returns, tail calls, vararg propagation, snapshots registers, executes deferred scopes, and emits `BC_UCLO` when children exist.【F:src/fluid/luajit-2.1/src/parser/parse_stmt.cpp†L567-L612】 | `expr_list`, `BC_RET0/RET1/RET/RETM`, `snapshot_return_regs`, `execute_defers`, `bcemit_AJ(BC_UCLO)`. | ✅ `emit_return_stmt` mirrors these cases (RET0/RET1/RETM) and patches `BC_VARG` calls for tail returns.【F:src/fluid/luajit-2.1/src/parser/ir_emitter.cpp†L169-L221】 |
| DoStmt | The `TokenKind::Do` branch in `parse_stmt` enters a block scope and requires `end` matching.【F:src/fluid/luajit-2.1/src/parser/parse_stmt.cpp†L955-L959】 | Reuses `parse_block`, `lex_match(TK_end)`. | ✅ `emit_statement` special-cases `DoStmt` by recursing into `emit_block`.【F:src/fluid/luajit-2.1/src/parser/ir_emitter.cpp†L123-L147】 |
| DeferStmt | `parse_defer` emits an inline closure (`parse_body_defer`), optional arguments, tags locals as `VarInfoFlag::Defer/DeferArg`, and lets runtime execute them when scopes exit.【F:src/fluid/luajit-2.1/src/parser/parse_stmt.cpp†L475-L522】 | `var_new`, `var_add`, `expr_tonextreg`, `execute_defers` (called when blocks close). | ❌ Unsupported—the AST node maps to `AstNodeKind::DeferStmt`, but IrEmitter has no handler yet. |
| ExpressionStmt | Default clause in `parse_stmt` executes `parse_call_assign`; call statements zero return counts while other expressions fall into assignment lowering.【F:src/fluid/luajit-2.1/src/parser/parse_stmt.cpp†L347-L375】 | `setbc_b(bcptr(call), 1)` for statements; assignment path uses helpers above. | ✅ Covered via `emit_expression_stmt` (though only simple expressions currently supported).【F:src/fluid/luajit-2.1/src/parser/ir_emitter.cpp†L123-L167】 |
| ReturnStmt / chunk terminators | `parse_stmt` marks `return` as the last statement in a chunk and frees registers between statements.【F:src/fluid/luajit-2.1/src/parser/parse_stmt.cpp†L939-L963】【F:src/fluid/luajit-2.1/src/parser/parse_stmt.cpp†L1000-L1009】 | `fs->freereg = fs->nactvar` after each statement to keep stack balanced. | ✅ Managed by `emit_block`'s local binding scope reset and expression cleanup. |
| GotoStmt / LabelStmt | The legacy codebase keeps the goto/label infrastructure alive via `gola_new`, `gola_patch`, `gola_close`, `gola_resolve`, and `gola_fixup`, but the current token set no longer exposes `goto ::label::` syntax—only `break`/`continue` feed the machinery today.【F:src/fluid/luajit-2.1/src/parser/parse_scope.cpp†L155-L268】 | `gola_*` manipulates pending jumps, rewrites `BC_JMP` to `BC_UCLO`, and propagates loop flags. | ❌ No AST nodes are emitted yet (and IrEmitter lacks handlers), so reintroducing `goto`/labels would require both AST support and statement emitters. |
| Defer / scope unwinding | `execute_defers` (invoked from `break`, `continue`, `return`, etc.) closes registered closures before leaving scopes.【F:src/fluid/luajit-2.1/src/parser/parse_stmt.cpp†L617-L649】【F:src/fluid/luajit-2.1/src/parser/parse_stmt.cpp†L567-L612】 | `execute_defers(fs, nactvar)` ensures pending handlers run. | ❌ IrEmitter has no equivalent, so defer scopes from AST nodes cannot execute yet. |

## Unsupported-node telemetry

To validate this matrix against real Fluid code while the AST pipeline is opt-in, `IrEmitter::unsupported_stmt`/`unsupported_expr` now increment shared counters and emit throttled `pf::Log` warnings identifying the node kind and source span each time a fallback occurs.  This instrumentation will stay in place until the coverage table reads "✅" across the board.
