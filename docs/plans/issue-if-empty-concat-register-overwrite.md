# Issue: If-Empty Operator Corrupts Call Base During Concatenation

## Status
RESOLVED - Runtime register preservation in place

## Problem Description
Running the Fluid label suite shows `fluid_if_empty::testConcatMsg` raising `attempt to call local 'Number' (a number value)` and aborting the test. The same run also reports downstream failures in the safe navigation and ternary suites. 【e1b2d3†L1-L88】【e1b2d3†L92-L127】

## Evidence Collected
* Adding a temporary `DebugLog('disasm')` inside `testConcatMsg()` captures the generated bytecode for `fakeFunction(Number ? 2)` and the subsequent `msg` calls. The disassembly shows that register `R2` first receives the callee (`MOV A=R2 D=R0`) and is then overwritten by the result of the `if-empty` expression (`MOV A=R2 D=R1`) immediately before the `CALL A=R2` instruction. When the VM executes the call, the base register now holds the numeric `1`, reproducing the runtime error. 【3a0deb†L43-L94】
* Review of the LuaJIT emitter confirms that the runtime branch of `bcemit_binop_left()` for `OPR_IF_EMPTY` stashes the left-hand value in place and records `fs->freereg` as the register reserved for the RHS. Later, `bcemit_binop()` moves the RHS result back into the original `reg` and collapses `freereg`. When the expression appears as a function argument, the call setup already moved the callee into that same `reg`, so the `BC_MOV` emitted here clobbers the function reference. 【F:src/fluid/luajit-2.1/src/parser/lj_parse_operators.c†L123-L189】【F:src/fluid/luajit-2.1/src/parser/lj_parse_operators.c†L408-L519】

## Impact Assessment
* `fluid_if_empty::testConcatMsg` crashes because the optional operator overwrites the call base when used inside `fakeFunction(Number ? 2)` and the two `msg(...)` calls, causing the VM to try to invoke the literal `1` as a function. 【3a0deb†L43-L94】
* `fluid_safe_nav::testChainingWithIfEmpty` and `fluid_ternary::testConcat` also fail in the same run. Both tests mix the `?` operator with concatenation or chained calls, so they are likely tripping the same register clobbering path. 【e1b2d3†L88-L127】

## Next Steps / Recommendations
1. ✅ `OPR_IF_EMPTY` now preserves the call base by copying the truthy value into the reserved RHS register and evaluating the falsey branch into the same destination, preventing clobbering.
2. ✅ Added a regression assertion in `testConcatMsg()` to confirm that `fakeFunction` receives the truthy argument when `if-empty` is used inside a call.
3. ☐ Follow-up: re-run the safe navigation and ternary suites to confirm they no longer trip the same register handling path.
