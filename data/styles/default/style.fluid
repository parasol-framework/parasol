-- Class oriented UI style settings, managed by drwApplyStyleGraphics() and drwApplyStyleValues() in the Surface module.

   require 'gui'

   if (mVec == nil) then mVec = mod.load('vector') end
   if (mFont == nil) then mFont = mod.load('font') end

   glSelf = obj.find('self')
   glCounter = 1
   glThemeColour = { first={ r=250,g=249,b=248 }, last={ r=210,g=211,b=212 } }

-- The applyStyle() function is used to set style defaults against an object.

function applyStyle(Class, Object)
   if (Class) then
      Class = Class:lower()
      if (glStyles[Class]) and (glStyles[Class].defaultValues) then
         glStyles[Class].defaultValues(Object)
         return
      else
         msg('No style information for ' .. Class)
      end
   else
      msg('No class name specified to applyStyle().')
   end
   glSelf.error = ERR_NoSupport
end

function applyDecoration(Class, Object, Surface, StyleType)
   if (Class) then
      Class = Class:lower()
      if (glStyles[Class]) then
         if nz(StyleType) then
            if (glStyles[Class][StyleType]) then
               glStyles[Class][StyleType](Object, Surface)
               return
            else
               msg('No style type ' .. nz(StyleType,'NIL'))
            end
         elseif (glStyles[Class].decoration) then
            glStyles[Class].decoration(Object, Surface)
            return
         else
            msg('No decoration routine for ' .. Class)
         end
      else
         msg('No style information for ' .. Class)
      end
   else
      msg('No class name specified to applyDecoration().')
   end
   glSelf.error = ERR_NoSupport
end

-- Apply a fill to a vector and all its children

local function applyFill(Vector, Fill)
   while (Vector != nil) do
      if (Vector.fill != 'none') then
         Vector.fill = Fill
      end
      if (Vector.stroke != nil) then Vector.stroke = Fill end
      local child = Vector.child
      if (child != nil) then applyFill(child, Fill) end
      Vector = Vector.next
   end
end

local function defineGradient(Scene, Name, First, Last, X1, Y1, X2, Y2, Units)
   local stops = { }
   local first = struct.new('GradientStop')
   first.offset    = 0
   first.rgb.red   = First.r / 255
   first.rgb.green = First.g / 255
   first.rgb.blue  = First.b / 255
   first.rgb.alpha = nz(First.a,255) / 255
   table.insert(stops, first)

   local last = struct.new('GradientStop')
   last.offset    = 1.0
   last.rgb.red   = Last.r / 255
   last.rgb.green = Last.g / 255
   last.rgb.blue  = Last.b / 255
   last.rgb.alpha = nz(Last.a,255) / 255
   table.insert(stops, last)

   if (Scene) then
      local gradient = Scene.new('VectorGradient', {
         name=nz(Name, 'styleGradient'), type='linear', stops=stops, x1=X1, y1=Y1, x2=X2, y2=Y2, units=nz(Units,'boundingbox')
      })
      Scene.mtAddDef(Name, gradient)
      return gradient
   else
      return obj.new('VectorGradient', {
         name=nz(Name, 'styleGradient'), type='linear', stops=stops, x1=X1, y1=Y1, x2=X2, y2=Y2, units=nz(Units,'boundingbox')
      })
   end
end

local function scaleGradient(svgGroup, svgGradient)
   local viewport = svgGroup.child
   if (viewport != nil) then
      local child = viewport.child
      while (child != nil) do
         if (child.class.id == ID_VECTORVIEWPORT) then
            viewport = child
            break
         end
         child = child.child
      end

      if (viewport.viewHeight < viewport.viewWidth) then
         svgGradient.y1 = viewport.viewY - ((viewport.viewWidth - viewport.viewHeight) * 0.5)
         svgGradient.y2 = svgGradient.y1 + viewport.viewWidth
      else
         svgGradient.y1 = viewport.viewY
         svgGradient.y2 = viewport.viewY + viewport.viewHeight
      end
   end
end

-- Create an icon with a scaled gradient background for theming.  Requires a parent Viewport for placement.

local function createIcon(IconName, Viewport, ViewportSettings)
   local icon = { gradientName='icon' .. glCounter }
   glCounter = glCounter + 1
   icon.viewport = Viewport.new('VectorViewport', ViewportSettings)
   icon.gradient = defineGradient(Viewport.scene, icon.gradientName, glThemeColour.first, glThemeColour.last, 0, 0, 0, 1)
   obj.new('svg', { target=icon.viewport, path='icons:' .. IconName .. '.svg' })
   applyFill(icon.viewport, 'url(#' .. icon.gradientName .. ')')
   scaleGradient(icon.viewport, icon.gradient) -- Scale the gradient to the loaded icon
   return icon
end

glStyles = {
   menu = {
      defaultValues = function(Menu)
         Menu.fontHighlight = '0,0,0'
         Menu.highlight     = '220,220,235'
         Menu.fontColour    = '0,0,0'
         Menu.flags         = '!showimages|showkeys'
         Menu.vSpacing      = 5
         Menu.highlightLM   = 1
         Menu.highlightRM   = 1
         Menu.font.face     = 'Open Sans'
         Menu.font.point    = 10
         --Menu.fadeDelay = ?
         --Menu.mouseOverDelay = ?
      end,
      decoration = function(Menu, Surface)
         Surface.mtAddCallback(function(Surface, Bitmap)
            local err, border = Bitmap.mtGetColour(100, 100, 100, 255)
            local err, colour = Bitmap.mtGetColour(240, 240, 240, 255)
            Bitmap.mtDrawRectangle(0, 0, Surface.width, Surface.height, border, 0)
            Bitmap.mtDrawRectangle(1, 1, Surface.width-2, Surface.height-2, colour, BAF_FILL)
         end)
      end,
      brk = function(MenuItem, Surface)
         Surface.mtAddCallback(function(Surface, Bitmap)
            local err, colour = Bitmap.mtGetColour(160, 160, 160, 255)
            Bitmap.mtDrawRectangle(32, MenuItem.y+2, Surface.width-64, 1, colour, BAF_BLEND)
         end)
      end
   },
   menudropdown = {
      defaultValues = function(Menu)
         Menu.fontHighlight = '#000000'
         Menu.highlight     = '220,220,235'
         Menu.fontColour    = '#000000'
         Menu.highlightLM   = 1
         Menu.highlightRM   = 1
      end,
      decoration = function(Menu, Surface)
         Surface.new('box', { border='120,120,120', colour='255,255,255' })
      end,
      brk = function(MenuItem, Surface)
         Surface.new('box', { x=6, xOffset=6, y=MenuItem.y+2, height=1, colour='#b0b0b0' })
      end
   },
   menupopup = {
      defaultValues = function(Menu)
         Menu.fontHighlight = '255,255,255'
         Menu.fontColour    = '255,255,255'
         Menu.highlight     = '#a080c0'
         Menu.vSpacing      = 5
         Menu.flags         = '!showimages'
         Menu.font.face     = 'Open Sans'
         Menu.font.point    = 10
         Menu.leftMargin    = 4
         Menu.topMargin     = 4
         Menu.bottomMargin  = 8
         Menu.rightMargin   = 8
         Menu.highlightLM   = 2
         Menu.highlightRM   = 6
         Menu.iconFilter    = 'pearl'
      end,
      decoration = function(Menu, Surface)
         Surface.precopy      = true
         Surface.rightMargin  = 4
         Surface.bottomMargin = 4

         Surface.new('box', { boxes='(4,!0,!0,4) (!0,4,4,!4)', colour='0,0,0,85', colour1='0,0,0,85' })
         Surface.new('gradient', { x=0, y=0, xOffset=4, yOffset=4, firstColour='76,62,128', lastColour='126,123,187', direction='horizontal' })
         local stripes = Surface.new('stripes', { direction='vertical', y=1, x=1, xOffset=5, yOffset=5 })
         stripes.acDataFeed(0, DATA_XML, [[<line colour="0,0,0,0"/><line colour="0,0,0,30"/>]])
         Surface.new('box', { raised=true, boxes='(0,0,!4,!4)', highlight='166,163,207,85', shadow='0,0,0,85' })
      end,
      brk = function(MenuItem, Surface)
         Surface.new('box', { x=32, xOffset=36, y=MenuItem.y+2, height=1, colour='#a0a0a0' })
      end
   },
   menucontext = {
      defaultValues = function(Menu)
         Menu.fontHighlight = '0,0,0'
         Menu.highlight     = '220,220,235'
         Menu.fontColour    = '0,0,0'
         Menu.face          = 'Open Sans:10'
         Menu.flags         = '!showimages|showkeys|popup'
         Menu.vSpacing      = 7
         Menu.highlightLM   = 1
         Menu.highlightRM   = 1
      end,
      decoration = function(Menu, Surface)
         Surface.new('box', { border='100,100,100', colour='240,240,240' })
      end,
      brk = function(MenuItem, Surface)
         Surface.new('box', { x=32, xOffset=32, y=MenuItem.y+2, height=1, colour='#a0a0a0' })
      end
   },
   button = {
      defaultValues = function(Button)

      end,
      decoration = function(Button, Viewport)
         local state = Viewport.state()
         state.clickX = 0
         state.clickY = 0
         local dimensions = Viewport.dimensions

         if bit.band(dimensions, DMF_HEIGHT) == 0 then
            if (bit.band(dimensions, DMF_Y) == 0) or
               (bit.band(dimensions, DMF_Y_OFFSET) == 0) then
               Viewport.height = 30
            end
         end

         if bit.band(dimensions, DMF_WIDTH) == 0 then
            if (bit.band(dimensions, DMF_X) == 0) or
               (bit.band(dimensions, DMF_X_OFFSET) == 0) then
               Viewport.width = 1
               calc_width = true
            end
         end

         Viewport.acInit()

         local height = Viewport.height

         local ICON_SIZE = height * 0.56
         local X_GAP     = height * 0.25
         local COL_BKGD  = 'rgb(0,0,0,80)'
         local COL_EDGE  = 'rgb(255,255,255,60)'
         local STROKE_WIDTH = 2

         state.bkgd = Viewport.new('VectorRectangle', {
            fill        = COL_BKGD,
            stroke      = COL_EDGE,
            strokeWidth = STROKE_WIDTH,
            x           = STROKE_WIDTH * 0.5,
            y           = STROKE_WIDTH * 0.5,
            roundX      = STROKE_WIDTH * 2,
            roundY      = STROKE_WIDTH * 2,
            width       = Viewport.width - STROKE_WIDTH,
            height      = height - STROKE_WIDTH
         })

         state.focus = Viewport.new('VectorRectangle', {
            stroke      = 'rgb(0,0,0,60)',
            strokeWidth = STROKE_WIDTH * 0.5,
            x           = STROKE_WIDTH * 0.5,
            y           = STROKE_WIDTH * 0.5,
            roundX      = STROKE_WIDTH * 2,
            roundY      = STROKE_WIDTH * 2,
            dashArray   = '2 2',
            width       = Viewport.width - STROKE_WIDTH,
            height      = height - STROKE_WIDTH,
            visibility  = VIS_HIDDEN
         })

         state.label = Viewport.new('VectorText', {
            x        = X_GAP,
            face     = gui.fonts.button.face,
            fontSize = Viewport.height * 0.66 * (3/4),
            fill     = 'rgb(' .. gui.colours.boxedText .. ')',
            string   = Button.string
         })

         state.label.y = (Viewport.height * 0.5) + (state.label.font.height * 0.5)

         if (Button.icon) then
            catch(function()
               state.icon = createIcon(Button.icon, Viewport, {
                  x = X_GAP,
                  y = (Viewport.height - ICON_SIZE) * 0.5,
                  width  = ICON_SIZE,
                  height = ICON_SIZE
               })

               state.label.x = X_GAP + ICON_SIZE + X_GAP
            end)
         end

         if calc_width then
            local w = (X_GAP * 2) + mFont.StringWidth(state.label.font, Button.string, -1)
            if state.icon then w = w + ICON_SIZE + X_GAP end
            Viewport.width = w
         end

         Viewport.subscribe('disable', function(Viewport, Args, State)
            State.bkgd.fill = COL_BKGD
            State.label.opacity = 0.25
            Viewport.acDraw()
         end, state)

         Viewport.subscribe('enable', function(Viewport, Args, State)
            State.bkgd.fill = COL_BKGD
            State.label.opacity = 1.0
            Viewport.acDraw()
         end, state)

         Viewport.subscribe('focus', function(Viewport, Args, Button)
            local state = Viewport.state()

            if bit.band(Button.flags, BTF_DISABLED) == 0 then
               state.focus.visibility = VIS_VISIBLE
            else
               state.focus.visibility = VIS_HIDDEN
            end

            Viewport.acDraw()
         end, Button)

         Viewport.subscribe('lostfocus', function(Viewport, Args, State)
            State.focus.visibility = VIS_HIDDEN
            Viewport.acDraw()
         end, state)

         local function resizeTriggered(Button)
            local viewport = Button.viewport
            local state = viewport.state()

            state.bkgd.x = STROKE_WIDTH * 0.5
            state.bkgd.y = STROKE_WIDTH * 0.5
            state.bkgd.width  = viewport.width - STROKE_WIDTH
            state.bkgd.height = viewport.height - STROKE_WIDTH

            state.focus.x = STROKE_WIDTH * 0.5
            state.focus.y = STROKE_WIDTH * 0.5
            state.focus.width  = viewport.width - STROKE_WIDTH
            state.focus.height = viewport.height - STROKE_WIDTH
         end

         Button.styleTrigger = function(Button, StyleChange)
            local state = Button.viewport.state()

            if StyleChange == STYLE_CONTENT then
               state.label.string = Button.string
               state.label.y = (Button.viewport.height * 0.5) + (state.label.font.height * 0.5)
            elseif StyleChange == STYLE_RESIZE then
               resizeTriggered(Button)
            end
         end

         Viewport.mtSubscribeKeyboard(function(Viewport, Qualifiers, Value, Unicode)
            if bit.band(Qualifiers, KQ_PRESSED) == 0 then return end

            if (Value == K_ENTER) or (Value == K_NP_ENTER) or (Value == K_SPACE) then
               Button.acActivate()
            end
         end)

         Viewport.mtSubscribeInput(bit.bor(JTYPE_FEEDBACK, JTYPE_BUTTON, JTYPE_REPEATED),
            function(Viewport, Msg)
               local state = Viewport.state()
               repeat
                  if Msg.type == JET_ENTERED_SURFACE then
                     Button.hoverState = BHS_INSIDE

                     if bit.band(Button.flags, BTF_DISABLED) == 0 then
                        state.bkgd.fill = 'rgb(255,255,255,40)'
                        Viewport.acDraw()
                     end
                  elseif Msg.type == JET_LEFT_SURFACE then
                     Button.hoverState = BHS_OUTSIDE
                     if bit.band(Button.flags, BTF_DISABLED) == 0 then
                        state.bkgd.fill = COL_BKGD
                        Viewport.acDraw()
                     end
                  elseif Msg.type == JET_LMB then
                     if Msg.value > 0 then
                        if bit.band(Button.flags, BTF_DISABLED) == 0 then
                           if bit.band(Msg.flags, JTYPE_REPEATED) != 0 then
                              if bit.band(Button.flags, BTF_PULSE) != 0 then
                                 Button.acActivate()
                              end
                           else
                              Button.clicked = true
                              state.clickX  = Msg.x
                              state.clickY  = Msg.y
                              Viewport.acDraw()
                           end
                        end
                     elseif Button.clicked then
                        Button.clicked = false
                        local clickX = Msg.x - state.clickX
                        local clickY = Msg.y - state.clickY
                        if (clickX < 0) then clickX = -clickX end
                        if (clickY < 0) then clickY = -clickY end

                        Viewport.acDraw()

                        if ((clickX < 4) and (clickY < 4)) or bit.band(Button.flags, BTF_PULSE) != 0 then
                           Button.acActivate()
                        end
                     end
                  end
                  Msg = Msg.next
               until Msg == nil
            end)

         resizeTriggered(Button)
      end
   },
   checkbox = {
      defaultValues = function(Check)

      end,
      decoration = function(Check, Viewport)
         local COL_BKGD = 'rgb(0,0,0,64)'
         local COL_STROKE_NO_FOCUS = 'rgb(255,255,255,60)'
         local COL_STROKE_HAS_FOCUS = 'rgb(255,255,255,90)'
         local GAP = 5
         local STROKE_WIDTH = 2

         local state = Viewport.state()
         state.entered = false

         if bit.band(Viewport.dimensions, DMF_HEIGHT) == 0 then
            if (bit.band(Viewport.dimensions, DMF_Y) == 0) or
               (bit.band(Viewport.dimensions, DMF_Y_OFFSET) == 0) then
               Viewport.height = 18
            end
         end

         local lBoxSize = Viewport.height

         state.bkgd = Viewport.new('VectorRectangle', {
            fill        = COL_BKGD,
            stroke      = COL_STROKE_NO_FOCUS,
            strokeWidth = STROKE_WIDTH,
            x           = STROKE_WIDTH * 0.5,
            y           = STROKE_WIDTH * 0.5,
            roundX      = STROKE_WIDTH * 2,
            roundY      = STROKE_WIDTH * 2,
            width       = lBoxSize - STROKE_WIDTH,
            height      = lBoxSize - STROKE_WIDTH
         })

         state.focus = Viewport.new('VectorRectangle', {
            stroke      = 'rgb(0,0,0,60)',
            strokeWidth = STROKE_WIDTH,
            x           = STROKE_WIDTH * 0.5,
            y           = STROKE_WIDTH * 0.5,
            roundX      = STROKE_WIDTH * 2,
            roundY      = STROKE_WIDTH * 2,
            width       = lBoxSize - STROKE_WIDTH,
            height      = lBoxSize - STROKE_WIDTH,
            dashArray   = '2 2',
            visibility  = VIS_HIDDEN
         })

         if nz(Check.label) then
            state.label = Viewport.new('VectorText', {
               x      = lBoxSize + GAP,
               face   = gui.fonts.widget.face,
               fill   = 'rgb(0,0,0,255)',
               string = Check.label
            })

            state.label.y = (Viewport.height * 0.5) + (state.label.font.height * 0.5)

            if (Check.labelWidth < 1) then
               Check.labelWidth = mFont.StringWidth(state.label.font, Check.label, -1) + 8
            end
         end

         if bit.band(Viewport.dimensions, DMF_WIDTH) == 0 then
            if (bit.band(Viewport.dimensions, DMF_X) == 0) or
               (bit.band(Viewport.dimensions, DMF_X_OFFSET) == 0) then
               Viewport.width = Check.labelWidth + lBoxSize + GAP
            end
         end

         catch(function()
            local size = Viewport.height * 0.7
            state.icon = createIcon('items/checkmark', Viewport, {
               x = (Viewport.height - size) * 0.5,
               y = (Viewport.height - size) * 0.5,
               width  = size,
               height = size
            })

            if Check.status == 0 then
               state.icon.viewport.opacity = 0.25
            else
               state.icon.viewport.opacity = 1.0
            end
         end)

         local function resizeTriggered(Check)
            local state = Viewport.state()

         end

         if bit.band(Check.align, ALIGN_RIGHT) != 0 then

         end

         Viewport.subscribe('disable', function(Viewport, Args, State)
            State.label.opacity = 0.25
         end, state)

         Viewport.subscribe('enable', function(Viewport, Args, State)
            State.label.opacity = 1.0
         end, state)

         Viewport.subscribe('focus', function(Viewport, Args, Check)
            local state = Viewport.state()
            if bit.band(Check.flags, CBF_DISABLED) == 0 then
               state.focus.visibility = VIS_VISIBLE
            else
               state.focus.visibility = VIS_HIDDEN
            end
            Viewport.acDraw()
         end, Check)

         Viewport.subscribe('lostfocus', function(Viewport, Args, Check)
            local state = Viewport.state()
            state.bkgd.stroke = COL_STROKE_NO_FOCUS
            state.focus.visibility = VIS_HIDDEN
            Viewport.acDraw()
         end, Check)

         Check.styleTrigger = function(Check, StyleChange)
            local state = Viewport.state()
            if StyleChange == STYLE_CONTENT then
               if state.icon then
                  if Check.status == 0 then
                     state.icon.viewport.opacity = 0.25
                  else
                     state.icon.viewport.opacity = 1.0
                  end
               end

               state.label.string = Check.label
               state.label.y = (Viewport.height * 0.5) + (state.label.font.height * 0.5)

               Viewport.acDraw()
            elseif StyleChange == STYLE_RESIZE then
               resizeTriggered(Check)
            end
         end

         Viewport.mtSubscribeKeyboard(function(Viewport, Qualifiers, Value, Unicode)
            if bit.band(Qualifiers, KQ_PRESSED) == 0 then return end

            if (Value == K_ENTER) or (Value == K_NP_ENTER) or (Value == K_SPACE) then
               Check.acActivate()
            end
         end)

         Viewport.mtSubscribeInput(bit.bor(JTYPE_FEEDBACK, JTYPE_BUTTON),
            function(Viewport, Msg)
               local state = Viewport.state()
               repeat
                  if (Msg.type == JET_ENTERED_SURFACE) then
                     state.entered = true

                     if not (bit.band(Check.flags, CBF_DISABLED) == CBF_DISABLED) then
                        state.bkgd.stroke = COL_HIGHLIGHT
                        state.bkgd.fill = COL_BKGD
                     else
                        state.bkgd.fill = COL_BKGD
                     end

                     if bit.band(Check.flags, CBF_DISABLED) == 0 then
                        Viewport.acDraw()
                     end
                  elseif (Msg.type == JET_LEFT_SURFACE) then
                     state.entered = false
                     state.bkgd.fill = COL_BKGD

                     if bit.band(Check.flags, CBF_DISABLED) == 0 then
                        Viewport.acDraw()
                     end
                  elseif (Msg.type == JET_LMB) and (Msg.value > 0) then
                     if bit.band(Check.flags, CBF_DISABLED) == 0 then
                        if Check.status == 0 then
                           Check.status = 1
                        else
                           Check.status = 0
                        end
                     end
                  end
                  Msg = Msg.next
               until Msg == nil
            end)

         resizeTriggered(Check)
      end
   },
   combobox = {
      defaultValues = function(Combo)

      end,
      decoration = function(Combo, Viewport)
         local COL_BKGD = 'rgb(0,0,0,64)'
         local COL_HIGHLIGHT = 'rgb(255,255,255,255)'
         local COL_STROKE_NO_FOCUS = 'rgb(255,255,255,60)'
         local COL_STROKE_HAS_FOCUS = 'rgb(255,255,255,130)'
         local GAP = 5
         local BORDER = 1
         local MIN_MENU_WIDTH = 120
         local MAX_MENU_WIDTH = 300
         local STROKE_WIDTH = 2
         local STROKE_HALF_WIDTH = STROKE_WIDTH * 0.5

         local state = Viewport.state()
         state.entered = false

         -- A fixed height based on the widget font must be applied

         Viewport.height = gui.getFontHeight(gui.fonts.widget) * 1.3

         local iconSize = Viewport.height * 0.6

         local textInput = Combo.textInput

         if nz(Combo.label) then
            state.label = Viewport.new('VectorText', {
               x      = 0,
               face   = gui.fonts.label.face,
               fill   = 'rgb(' .. gui.fonts.label.colour .. ')',
               string = Combo.label
            })

            if Combo.labelWidth < 1 then
               Combo.labelWidth = mFont.StringWidth(state.label.font, Combo.label, -1) + GAP
            end

            state.boxX = Combo.labelWidth + STROKE_HALF_WIDTH
         end

         state.bkgd = Viewport.new('VectorRectangle', {
            fill   = COL_BKGD,
            stroke = COL_STROKE_NO_FOCUS,
            strokeWidth = STROKE_WIDTH,
            x      = Combo.labelWidth,
            roundX = STROKE_WIDTH * 2,
            roundY = STROKE_WIDTH * 2
         })

         -- Initialise the text area that the user will be able to interact with.

         if bit.band(Combo.flags, CMF_EDIT) != 0 then
            textInput.flags = TXF_EDIT
         end

         if bit.band(Combo.flags, CMF_NO_TRANSLATION) == 0 then
            local str = textInput.string
            local translate = mSys.strTranslateText(str)
            if (translate != str) then
               textInput = translate
            end
         end

         local menu = Combo.menu
         menu.relative = Viewport
         menu.x        = Combo.labelWidth
         menu.vSpacing = 4
         menu.face     = textInput.face
         menu.point    = textInput.point
         local flags   = MNF_IGNORE_FOCUS
         if bit.band(Combo.flags, CMF_NO_TRANSLATION) != 0 then flags = bit.bor(flags, MNF_NO_TRANSLATION) end
         if bit.band(Combo.flags, CMF_SHOW_ICONS) != 0 then flags = bit.bor(flags, MNF_SHOW_IMAGES) end
         menu.flags = flags
         menu.lineLimit = 8

         -- Compute the width of the combobox relative to the width of the drop-down menu.

         if bit.band(Viewport.dimensions, DMF_WIDTH) == 0 then
            if bit.band(Viewport.dimensions, DMF_X) == 0 or bit.band(Viewport.dimensions, DMF_X_OFFSET) == 0 then
               local menuWidth = menu.width
               if (menuWidth > MAX_MENU_WIDTH) then menuWidth = MAX_MENU_WIDTH end
               if (Combo.labelWidth + menuWidth > MIN_MENU_WIDTH) then
                  Viewport.width = Combo.labelWidth + menuWidth + iconSize
               else
                  Viewport.width = Combo.labelWidth + MIN_MENU_WIDTH + iconSize
               end
            end
         end

         local function resizeTriggered(Combo)
            local state = Combo.viewport.state()
            local viewport = Combo.viewport

            if state.label then
               state.label.y = (viewport.height * 0.5) + (state.label.font.height * 0.5)
            end

            state.bkgd.x = Combo.labelWidth + (STROKE_WIDTH * 0.5)
            state.bkgd.y = STROKE_WIDTH * 0.5
            state.bkgd.width  = viewport.width - Combo.labelWidth - STROKE_WIDTH
            state.bkgd.height = viewport.height - STROKE_WIDTH

            local gap = (viewport.height - iconSize) * 0.5
            local x = viewport.width - iconSize - gap
            state.icon.viewport.x = x
            state.textMask.width = x - state.textMask.x - (STROKE_WIDTH * 2)

            Combo.menu.y = viewport.height - 1
            Combo.menu.width = viewport.width - Combo.labelWidth
         end

         Combo.styleTrigger = function(Combo, StyleChange)
            if StyleChange == STYLE_CONTENT then
               local state = Combo.viewport.state()
               if state.label then state.label.string = Combo.label end
            elseif StyleChange == STYLE_RESIZE then -- Needed in case the label changes
               resizeTriggered(Combo)
            end
         end

         state.textClip = Viewport.new('VectorClip', { })
         state.textMask = state.textClip.new('VectorRectangle', {
            x = Combo.labelWidth + (STROKE_WIDTH * 2),
            y = 0,
            width = '100%',
            height = '100%'
         })

         textInput.face = gui.fonts.widget.face
         textInput.fill = 'rgb(' .. gui.fonts.widget.colour .. ')'
         textInput.x    = Combo.labelWidth + (STROKE_WIDTH * 2)
         textInput.y    = (Viewport.height * 0.5) + (state.label.font.height * 0.5)
         textInput.mask = state.textClip

         if textInput.acInit() != ERR_Okay then return ERR_Init end
         if menu.acInit() != ERR_Okay then return ERR_Init end

         -- Place an icon for invoking the drop-down menu

         catch(function()
            local gap = (Viewport.height - iconSize) * 0.5
            local x = Viewport.width - iconSize - gap
            state.icon = createIcon('arrows/down', Viewport, {
               x = x, y = gap, width = iconSize, height = iconSize
            })
            state.textMask.width = x - state.textMask.x - (STROKE_WIDTH * 2)
         end,
         function()
           state.textMask.width = Viewport.width - state.textMask.x - (STROKE_WIDTH * 2)
         end)

         Viewport.subscribe('disable', function(Viewport, Args, Combo)
            local state = Combo.viewport.state()
            state.bkgd.fill = COL_BKGD
            if state.label then state.label.opacity = 0.25 end
            Viewport.acDraw()
         end, Combo)

         Viewport.subscribe('enable', function(Viewport, Args, Combo)
            local state = Combo.viewport.state()
            state.bkgd.fill = COL_BKGD
            if state.label then state.label.opacity = 1.0 end
            Viewport.acDraw()
         end, Combo)

         Viewport.subscribe('focus', function(Viewport, Args, Combo)
            local state = Viewport.state()
            if bit.band(Viewport.flags, VF_DISABLED) == 0 then
               state.bkgd.stroke = COL_STROKE_HAS_FOCUS
            else
               state.bkgd.stroke = COL_STROKE_NO_FOCUS
            end
            Viewport.acDraw()
         end, Combo)

         Viewport.subscribe('lostfocus', function(Viewport, Args, Combo)
            local state = Combo.viewport.state()
            state.bkgd.stroke = COL_STROKE_NO_FOCUS
            Combo.menu.acHide()
            Viewport.acDraw()
         end, Combo)

         Viewport.subscribe('redimension', function(Viewport, Args, Combo)
            resizeTriggered(Combo)
         end, Combo)

         Combo.menu.subscribe('activate', function(Menu, Args, Combo)
            local item = Combo.menu.selection
            if item then
               if item.text != textInput.string then
                  Combo.string = item.text
                  Combo.acActivate()
               end
            else
               error('No item selected.')
            end
         end, Combo)

         Viewport.mtSubscribeInput(JTYPE_BUTTON,
            function(Viewport, Msg)
               local state = Viewport.state()
               repeat
                  if Msg.type == JET_ENTERED_SURFACE then
                     state.entered = true
                     if bit.band(Viewport.flags, VF_DISABLED) == 0 then
                        state.bkgd.stroke = COL_HIGHLIGHT
                        state.bkgd.fill   = COL_BKGD
                     else
                        state.bkgd.fill = COL_BKGD
                     end
                     Viewport.acDraw()
                  elseif Msg.type == JET_LEFT_SURFACE then
                     state.entered = false
                     state.bkgd.fill = COL_BKGD
                     Viewport.acDraw()
                  elseif (Msg.type == JET_LMB) and (Msg.value > 0) then
                     if bit.band(Viewport.flags, VF_DISABLED) == 0 and (Msg.x > Combo.labelWidth) then
                        if (Msg.x > Viewport.width - Viewport.height) then
                           -- The button on the combobox has been pressed, so switch the menu visibility.
                           -- About 300ms must pass before a switch can occur.
                           Combo.menu.mtSwitch(200)
                        elseif (Msg.x >= Combo.labelWidth) then
                           if bit.band(textInput.flags, TXF_EDIT) == 0 then
                              Combo.menu.mtSwitch(5)
                           end
                        end
                     end
                  end
                  Msg = Msg.next
               until Msg == nil
            end)

         resizeTriggered(Combo)
      end
   },
   input = {
      defaultValues = function(Input)
         Input.textInput.fill      = 'rgb(' .. gui.colours.widgetText .. ')'
         Input.textInput.lineLimit = 1
         Input.textInput.face      = gui.fonts.widget.face
      end,
      decoration = function(Input, Viewport)
         local COL_BKGD = 'rgb(0,0,0,64)'
         local COL_STROKE_NO_FOCUS = 'rgb(255,255,255,60)'
         local COL_STROKE_HAS_FOCUS = 'rgb(255,255,255,90)'
         local GAP = 5
         local BORDER = 1
         local MARGIN = 2
         local STROKE_WIDTH = 2
         local STROKE_HALF_WIDTH = STROKE_WIDTH * 0.5

         local state = Viewport.state()
         state.entered = false
         state.computeFixedWidth = true

         -- A fixed height based on the widget font must be applied

         Viewport.height = gui.getFontHeight(gui.fonts.widget) * 1.3

         state.boxX = STROKE_WIDTH * 0.5

         if nz(Input.label) then
            state.label = Viewport.new('VectorText', {
               x      = 0,
               face   = gui.fonts.label.face,
               fill   = 'rgb(' .. gui.fonts.label.colour .. ')',
               string = Input.label
            })

            if Input.labelWidth < 1 then
               Input.labelWidth = mFont.StringWidth(state.label.font, Input.label, -1) + GAP
            end

            state.label.y = (Viewport.height * 0.5) + (state.label.font.height * 0.5)
            state.boxX = Input.labelWidth + STROKE_HALF_WIDTH
         end

         if nz(Input.postLabel) then
            state.postlabel = Viewport.new('VectorText', {
               face   = gui.fonts.widget.face,
               fill   = 'rgb(' .. gui.fonts.label.colour .. ')',
               string = Input.postLabel
            })
         end

         state.bkgd = Viewport.new('VectorRectangle', {
            fill   = COL_BKGD,
            stroke = COL_STROKE_NO_FOCUS,
            strokeWidth = STROKE_WIDTH,
            roundX = STROKE_WIDTH * 2,
            roundY = STROKE_WIDTH * 2
         })

         if bit.band(Viewport.dimensions, bit.bor(DMF_FIXED_WIDTH, DMF_RELATIVE_WIDTH)) != 0 then
            state.computeFixedWidth = false
         elseif bit.band(Viewport.dimensions, bit.bor(DMF_FIXED_X_OFFSET, DMF_RELATIVE_X_OFFSET)) != 0 and
                bit.band(Viewport.dimensions, bit.bor(DMF_FIXED_X, DMF_RELATIVE_X)) != 0 then
            state.computeFixedWidth = false
         end

         local function resizeTriggered(Input)
            local state = Viewport.state()
            local viewport = Input.viewport

            local boxWidth = Input.inputWidth -- The client can fix the width of the input area

            if nz(Input.postLabel) then
               state.postlabel.y = (viewport.height * 0.5) + (state.postlabel.font.height * 0.5)
               state.postlabel_width = mFont.StringWidth(state.postlabel.font, Input.postLabel, -1) + GAP
            else
               state.postlabel_width = 0
            end

            state.boxX = Input.labelWidth + STROKE_HALF_WIDTH

            if state.computeFixedWidth then -- Client did not specify a width for the viewport
               if boxWidth < 1 then
                  boxWidth = mFont.StringWidth(Input.textInput.font, Input.string, -1) + (MARGIN + BORDER) * 2
                  if (boxWidth < 90) then boxWidth = 90 end
               end

               viewport.width = Input.labelWidth + boxWidth + GAP + state.postlabel_width
               state.computeFixedWidth = false
            elseif (boxWidth < 1) then -- Input area automatically expands to match the viewport
               boxWidth = viewport.width - state.boxX
               if state.postlabel_width > 0 then
                  boxWidth = boxWidth - state.postlabel_width - GAP
               end
               if (boxWidth < 3) then boxWidth = 3 end
               boxWidth = boxWidth - STROKE_WIDTH
            elseif (state.boxX + boxWidth - STROKE_WIDTH > viewport.width) then -- Restrict width to available space
               boxWidth = viewport.width - state.boxX - STROKE_WIDTH
            end

            state.bkgd.x      = state.boxX
            state.bkgd.y      = STROKE_HALF_WIDTH
            state.bkgd.width  = boxWidth
            state.bkgd.height = viewport.height - STROKE_WIDTH

            if state.postlabel then
               state.postlabel.x = state.boxX + boxWidth + GAP
            end

            state.textMask.x = state.boxX + STROKE_WIDTH
            state.textMask.y = STROKE_WIDTH
            state.textMask.width  = boxWidth - (STROKE_WIDTH * 2)
            state.textMask.height = viewport.height - (STROKE_WIDTH * 2)
         end

         Input.styleTrigger = function(Input, StyleChange)
            if StyleChange == STYLE_CONTENT then
               local state = Input.viewport.state()
               if state.label then state.label.string = Input.label end

               if state.postlabel then
                  state.postlabel.string = Input.postLabel
                  state.postlabel.x = Input.labelWidth + Input.inputWidth
               end
            elseif StyleChange == STYLE_RESIZE then -- Needed in case the label changes
               resizeTriggered(Input)
            end
         end

         -- Remove rounding if edges are flush

         if not state.label and (Viewport.x == 0) and (Viewport.xOffset == 0) then
            state.bkgd.roundX = 0
            state.bkgd.roundY = 0
         end

         -- Initialise the text area that the user will be able to interact with.

         local textInput = Input.textInput
         local flags = bit.bor(textInput.flags, VTXF_EDITABLE)
         if bit.band(Input.flags, INF_ENTER_TAB) != 0 then flags = bit.bor(flags, VTXF_ENTER_TAB) end
         if bit.band(Input.flags, INF_SECRET) != 0 then flags = bit.bor(flags, VTXF_SECRET) end

         state.textClip = Viewport.new('VectorClip', { })
         state.textMask = state.textClip.new('VectorRectangle', { x=0, y=0, width='100%', height='100%' })
         textInput.mask = state.textClip
         textInput.face  = gui.fonts.widget.face
         textInput.fill  = 'rgb(' .. gui.fonts.widget.colour .. ')'
         textInput.x     = Input.labelWidth + (STROKE_WIDTH * 2)
         textInput.textFlags = flags
         if textInput.acInit() != ERR_Okay then return ERR_Init end
         textInput.y = (Viewport.height * 0.5) + (textInput.font.height * 0.5)

         if bit.band(Input.flags, INF_SELECT_TEXT) != 0 then textInput.mtSelectArea(0, 0, 20000, 20000) end
         if bit.band(Input.flags, INF_DISABLED) != 0 then Input.acDisable() end

         Viewport.subscribe('disable', function(Viewport, Args, State)
            State.bkgd.fill = COL_BKGD
            if State.label then State.label.opacity = 0.25 end
            if State.postlabel then State.postlabel.opacity = 1.0 end
         end, state)

         Viewport.subscribe('enable', function(Viewport, Args, State)
            State.bkgd.fill = COL_BKGD
            if State.label then State.label.opacity = 1.0 end
            if State.postlabel then State.postlabel.opacity = 1.0 end
         end, state)

         Viewport.subscribe('focus', function(Viewport, Args, State)
            if bit.band(Viewport.flags, VF_DISABLED) == 0 then
               State.bkgd.stroke = COL_STROKE_HAS_FOCUS
            else
               State.bkgd.stroke = COL_STROKE_NO_FOCUS
            end
         end, state)

         Viewport.subscribe('lostfocus', function(Viewport, Args, Input)
            local state = Viewport.state()
            state.bkgd.stroke = COL_STROKE_NO_FOCUS
            local mask = Input.inputMask
            if mask then
               local userInput = Input.string
               if string.len(userInput) > 0 then
                  if not string.find(userInput, mask) then
                     Input.string = ''
                  end
               end
            end
         end, Input)

         Viewport.subscribe('redimension', function(Viewport, Args, Input)
            resizeTriggered(Input)
         end, Input)

         Viewport.mtSubscribeKeyboard(function(Viewport, Qualifiers, Value, Unicode)
            if bit.band(Qualifiers, KQ_PRESSED) == 0 then return end

            if (Value == K_ENTER) or (Value == K_TAB) or (Value == K_NP_ENTER) then
               Input.acActivate()
            end
         end)

         Viewport.mtSubscribeInput(JTYPE_FEEDBACK,
            function(Viewport, Msg)
               local state = Viewport.state()
               repeat
                  if Msg.type == JET_ENTERED_SURFACE then
                     state.entered = true
                     if bit.band(Viewport.flags, VF_DISABLED) == 0 then
                        Viewport.acDraw()
                     end
                  elseif Msg.type == JET_LEFT_SURFACE then
                     state.entered = false
                     if bit.band(Viewport.flags, VF_DISABLED) == 0 then
                        Viewport.acDraw()
                     end
                  end
                  Msg = Msg.next
               until Msg == nil
            end)

         resizeTriggered(Input)
      end
   },
   menubar = {
      defaultValues = function(Bar)
         Bar.height     = 23
         Bar.font.point = 10
         Bar.font.face  = 'Open Sans'
      end,
      decoration = function(Bar, Surface)
         Surface.mtAddCallback(function(Surface, Bitmap)
            Bitmap.mtDrawRectangle(0, Surface.height-1, Surface.width, 1, gui.bitmapColour(Bitmap, 'highlight'), bit.bor(BAF_FILL, BAF_BLEND))
            Bitmap.mtDrawRectangle(0, Surface.height-2, Surface.width, 1, gui.bitmapColour(Bitmap, 'shadow'), bit.bor(BAF_FILL, BAF_BLEND))
         end)
      end
   },
   scrollbar = {
      defaultValues = function(Scrollbar)
      end,
      decoration = function(Scrollbar, Viewport)
      end
   },
   view = {
      defaultValues = function(View)
         View.face         = 'open sans:10:light'
         View.groupFace    = 'open sans:12:bold'
         View.vSpacing     = 4
         View.colTitleFont = '255,255,255,255'
         View.gfxFlags     = '!outlinetitle|branches|drawtable'
         View.colHairline  = '255,255,255,0'
         View.colHighlight = '0,0,0,0'
         View.colSelectHairline = '255,255,255,0'
         View.colSelect         = '0,0,60,140'
         View.colSelectFont     = '255,255,255'
         View.colItem           = '#000000'
         View.colBkgdHighlight  = '0,0,0,10'
         View.colBackground     = '255,255,255'
         View.colBorder         = '160,160,160'
         View.buttonHighlight   = '#f0f0f0'
         View.buttonShadow      = '#d0d0d0'
         View.buttonBackground  = '#f0f0f0'
         View.buttonThickness   = 0
      end,
      groupheader = function(View, Surface)
         Surface.new('gradient', { firstColour='170,170,170', lastColour='140,140,140', direction='vertical', y=0, yoffset=0 })
         local stripes = Surface.new('stripes', { direction='vertical' })
         stripes.acDataFeed(0, DATA_XML, [[<line colour="0,0,0,20"/><line colour="0,0,0,0"/>]])
         Surface.new('box', { x=0, y=0, width=26, yoffset=0, colour='0,0,0,40' })
         Surface.new('box', { height=1, colour='255,255,255,64' })
         Surface.new('box', { height=1, yoffset=0, colour='0,0,0,30' })
      end,
      groupselect = function(View, Surface)
         Surface.new('gradient', { lastColour='200,200,200', firstColour='140,140,140', direction='vertical', y=0, yOffset=0 })
         local stripes = Surface.new('stripes', { direction='vertical' })
         stripes.acDataFeed(0, DATA_XML, [[<line colour="0,0,0,20"/><line colour="0,0,0,0"/>]])
         Surface.new('box', { x=0, y=0, width=26, yoffset=0, colour='0,0,0,40' })
         Surface.new('box', { height=1, colour='255,255,255,64' })
         Surface.new('box', { height=1, yoffset=0, colour='0,0,0,30' })
      end
   },
   fileview = {
      defaultValues = function(View)
         View.face         = 'Open Sans:10'
         View.groupFace    = 'Open Sans:10:bold'
         View.colTitleFont = '255,255,255,255'
         View.gfxFlags     = 'branches|hairlines'
         View.colHairline  = '0,0,0,80'
         View.colHighlight = '0,0,0,0'
         View.colSelectHairline = '255,255,255,0'
         View.colSelect         = '0,0,0,140'
         View.colSelectFont     = '255,255,255'
         View.colItem           = '#000000'
         View.colBkgdHighlight  = '0,0,0,10'
         View.colBackground     = '255,255,255'
         View.colBorder         = '0,0,0,0'
         View.colButtonFont     = '255,255,255'
         View.buttonhighlight   = '255,255,255,80'
         View.buttonshadow      = '0,0,0,0'
         View.buttonbackground  = '#55555F'
         View.buttonthickness   = 0
      end
   },
   window = {
      defaultValues = function(Window)
         local parent = Window.parent
         if parent then
            Window.x = parent.leftMargin + 10
            Window.y = parent.topMargin + 10
         end
         Window.moveToBack   = 0
         Window.resizeBorder = 6
         Window.leftLimit    = 0
         Window.topLimit     = 0
         Window.rightLimit   = 0
         Window.bottomLimit  = 0
         Window.clientTop    = 29
         Window.clientLeft   = 5
         Window.clientRight  = 5
         Window.clientBottom = 5
         Window.leftMargin   = 5
         Window.topMargin    = 5
         Window.bottomMargin = 5
         Window.rightMargin  = 5
         Window.resize       = 'all'
         Window.minimiseCallback = function(Window)
            Window.surface.acHide()
            local desktop = obj.find('desktop')
            if (desktop) then desktop.acFocus() end
         end
      end,
      decoration = function(Window, Surface)
         Surface.mtAddCallback(function(Surface, Bitmap)
            local greyA, greyB, greyC
            local err, black = Bitmap.mtGetColour(0, 0, 0, 0, 255)
            if bit.band(Surface.flags, RNF_HAS_FOCUS) == 0 then
               err, greyA = Bitmap.mtGetColour(140, 140, 140, 255)
               err, greyB = Bitmap.mtGetColour(160, 160, 160, 255)
               err, greyC = Bitmap.mtGetColour(200, 200, 200, 255)
            else
               err, greyA = Bitmap.mtGetColour(120, 120, 190, 255)
               err, greyB = Bitmap.mtGetColour(140, 140, 210, 255)
               err, greyC = Bitmap.mtGetColour(180, 180, 250, 255)
            end

            -- Window Frame
            Bitmap.mtDrawRectangle(0, 0, Surface.width, Surface.height, black, 0)
            Bitmap.mtDrawRectangle(1, 1, Surface.width-2, Surface.height-2, greyA, 0)
            Bitmap.mtDrawRectangle(2, 2, Surface.width-4, Surface.height-4, greyB, 0)
            Bitmap.mtDrawRectangle(3, 3, Surface.width-6, Surface.height-6, greyC, 0)
            Bitmap.mtDrawRectangle(4, 4, Surface.width-8, Surface.height-8, greyB, 0)
            Bitmap.mtDrawRectangle(5, 5, Surface.width-10, Surface.height-10, gui.bitmapColour(Bitmap, 'window'), BAF_FILL)
            -- Titlebar edge
            Bitmap.mtDrawRectangle(4, 26, Surface.width-8, 1, greyB, BAF_FILL)
            Bitmap.mtDrawRectangle(4, 27, Surface.width-8, 1, greyC, BAF_FILL)
            Bitmap.mtDrawRectangle(4, 28, Surface.width-8, 1, greyB, BAF_FILL)

            if nz(Window.insideBorder) then
               local err, border = Bitmap.mtGetColour(180, 180, 200, 255)
               Bitmap.mtDrawRectangle(Surface.leftMargin-1, Surface.topMargin-1, Surface.width - Surface.rightMargin + 1,
                  Surface.height - Surface.bottomMargin + 1, border, BAF_BLEND)
            end
         end)
      end,
      menubar = function(Window, Surface)
         local menubar
         if (Surface.parent != nil) then -- Window is in the native desktop
            menubar = Surface.new('menubar', { x=5, y=Window.clientTop, xOffset=5, target=Surface.parent, path=Window.menu })
         else -- Window is in a hosted environment (e.g. X11, Windows)
            menubar = Surface.new('menubar', { x=0, y=0, xOffset=0, path=Window.menu })
         end
         Surface.topMargin = menubar.bottom + 4
         Window.menubar = menubar
      end,
      titlebar = function(Window, Surface)
         local bar = Surface.new('surface', { drag=Surface, height=21, x=5, y=5, xOffset=5, flags='!StickToFront' })

         local lGradientA = defineGradient(nil, nil, {r=76,g=62,b=128,a=255}, {r=126,g=123,b=187,a=255}, 0, 0, '100%', 0)
         local lGradientB = defineGradient(nil, nil, {r=76,g=76,b=76,a=255}, {r=150,g=150,b=150,a=255}, 0, 0, '100%', 0)

         bar.mtAddCallback(function(Surface, Bitmap)
            local err, path = mVec.generateRectangle(0, 0, Surface.width, Surface.height)
            if (err == ERR_Okay) then
               if (bit.band(Surface.flags, RNF_HAS_FOCUS) != RNF_HAS_FOCUS) then
                  mVec.drawPath(Bitmap, path, 0, nil, lGradientA)
               else
                  mVec.drawPath(Bitmap, path, 0, nil, lGradientB)
               end
               mVec.freePath(path)
            end
            for y=1,Surface.height,2 do
               local err, colShade = Bitmap.mtGetColour(0, 0, 0, 40)
               Bitmap.mtDrawRectangle(0, y, Surface.width, 1, colShade, bit.bor(BAF_FILL, BAF_BLEND))
            end
         end)

         Window.titleObject = bar.new('text', {
            face=gui.fonts.titlebar.face, colour=gui.fonts.titlebar.colour, outline='40,40,40',
            string=Window.title, x=26, xOffset=60, y=1
         })

         -- Application icon to the left of the titlebar

         bar.new('image', { x=5, align='vertical', path=Window.icon .. '(16)', iconFilter='pearl' })

         local tlX, tlY
         input.subscribe(JTYPE_BUTTON, bar, 0, function(Handler, Msg)
            if (Msg.type != JET_BUTTON_1) then return end
            if (Msg.x >= 5) and (Msg.x < 22) then
               if (Msg.value > 0) then -- Button down
                  tlX = Msg.absX
                  tlY = Msg.absY
               else -- Released
                  if (bit.band(Msg.flags, JTYPE_DBL_CLICK) != 0) then
                     if (math.abs(Msg.absX - tlX) <= 2) and (math.abs(Msg.absY - tlY) <= 2) then
                        Window.mtClose()
                     end
                  end
               end
            end
         end)

         -- Clicking anywhere on the titlebar will move the window to the front.

         input.subscribe(JTYPE_BUTTON, bar, 0, function(Handler, Msg)
            if (Msg.type == JET_BUTTON_1) and (Msg.value > 0) then
               Surface.acMoveToFront()
            end
         end)

         -- Double clicking on the titlebar will maximise it.

         local xoffset = 3
         if nz(Window.maximise) then
            input.subscribe(JTYPE_BUTTON, bar, 0, function(Handler, Msg)
               if (Msg.type == JET_BUTTON_1) and (bit.band(Msg.flags, JTYPE_DBL_CLICK) != 0) and (Msg.value == 0) then
                  if (Msg.x >= 24) and (Msg.y >= 0) and (Msg.x < bar.width - 60) and (Msg.y < bar.height) then
                     Window.mtMaximise(1)
                  end
               end
            end)
         end

         -- Close Gadget

         if nz(Window.close) then
            catch(function()
               local rgnClose = bar.new('surface', { xoffset=xoffset, y=2, width=17, height=17, region=true })
               rgnClose.acShow()
               input.subscribe(JTYPE_BUTTON, rgnClose, 0, function(Handler, Msg)
                  Window.mtClose()
               end)
               rgnClose.new('image', { path='icons:items/checkmark_cross(16)', iconFilter='pearl', align='center' })
               xoffset = xoffset + 22
            end)
         end

         -- Maximise Gadget

         catch(function()
            local max = bar.new('surface', { width=17, height=17, y=2, xoffset=xoffset, region=true })
            max.acShow()
            input.subscribe(JTYPE_BUTTON, max, 0, function(Handler, Msg)
               Window.mtMaximise()
            end)
            if nz(Window.maximise) then
               max.new('image', { path='icons:items/window_maximise(16)', iconFilter='pearl', align='center' })
            else
               max.new('image', { path='icons:items/window_maximise(16)', iconFilter='pearl', align='center', opacity='33%' })
            end
            xoffset = xoffset + 22
         end)

         -- Minimise Gadget

         catch(function()
            local min = bar.new('surface', { width=17, height=17, y=2, xoffset=xoffset, region=true })
            min.acShow()
            input.subscribe(JTYPE_BUTTON, min, 0, function(Handler, Msg)
               Window.mtMinimise()
            end)
            if nz(Window.minimise) then
               min.new('image', { path='icons:items/window_minimise(16)', iconFilter='pearl', align='center' })
            else
               min.new('image', { path='icons:items/window_minimise(16)', iconFilter='pearl', align='center', opacity='33%' })
            end
            xoffset = xoffset + 22
         end)

         -- Move-To-Back Gadget

         if nz(Window.moveToBack) then
            catch(function()
               local mtb = bar.new('surface', { width=17, height=17, y=2, xoffset=xoffset, region=true })
               mtb.acShow()
               input.subscribe(JTYPE_BUTTON, mtb, 0, function(Handler, Msg)
                  Surface.acMoveToBack()
               end)
               mtb.new('image', { path='icons:layers/bringforward(16)', align='center' })
               xoffset = xoffset + 22
            end)
         end

         bar.acShow()
      end
   }
} -- glStyles
