-- Graphical User Interface functions

   if (mSys == nil) then mSys = mod.load('core') end

if (gui == nil) then
   gui = {
      dpi = 160,
      fonts = { },
      colours = { },
      interface = { },
      rgb = { }
   }

   do
      local mSurface = mod.load('surface') // Temporarily load to ensure glStyle is available.
      local xml = obj.find('glStyle')

      if (xml != nil) then
         xml.mtFindTag('/fonts/font',
            function(XML, TagIndex, Attrib)
               local font = { }
               local err, name = xml.mtGetAttrib(TagIndex, 'name')
               if nz(name) then
                  err, font.face = xml.mtGetAttrib(TagIndex, 'face')
                  if nz(font.face) then
                     err, font.size = xml.mtGetAttrib(TagIndex, 'size')
                     err, font.colour = xml.mtGetAttrib(TagIndex, 'colour')
                     err, font.highlight = xml.mtGetAttrib(TagIndex, 'highlight')
                     gui.fonts[name] = font
                  end
               end
            end)

         local err, index = xml.mtFindTag('/colours')
         if (err == ERR_Okay) then
            err, gui.colours['shadow']        = xml.mtGetAttrib(index, 'shadow')
            err, gui.colours['highlight']     = xml.mtGetAttrib(index, 'highlight')
            err, gui.colours['colour']        = xml.mtGetAttrib(index, 'colour')
            err, gui.colours['widget']        = xml.mtGetAttrib(index, 'widget')
            err, gui.colours['button']        = xml.mtGetAttrib(index, 'button')
            err, gui.colours['buttonClick']   = xml.mtGetAttrib(index, 'buttonClick')
            err, gui.colours['menubar']       = xml.mtGetAttrib(index, 'menubar')
            err, gui.colours['menu']          = xml.mtGetAttrib(index, 'menu')
            err, gui.colours['border']        = xml.mtGetAttrib(index, 'border')
            err, gui.colours['menuBorder']    = xml.mtGetAttrib(index, 'menuBorder')
            err, gui.colours['desktop']       = xml.mtGetAttrib(index, 'desktop')
            err, gui.colours['recess']        = xml.mtGetAttrib(index, 'recess')
            err, gui.colours['white']         = xml.mtGetAttrib(index, 'white')
            err, gui.colours['red']           = xml.mtGetAttrib(index, 'red')
            err, gui.colours['green']         = xml.mtGetAttrib(index, 'green')
            err, gui.colours['blue']          = xml.mtGetAttrib(index, 'blue')
            err, gui.colours['background']    = xml.mtGetAttrib(index, 'background')
            err, gui.colours['textHighlight'] = xml.mtGetAttrib(index, 'textHighlight')
            err, gui.colours['window']        = xml.mtGetAttrib(index, 'window')
         else
            error('No colours tag in style values.')
         end

         local err, index = xml.mtFindTag('/interface')
         if (err == ERR_Okay) then
            err, gui.interface['inputBorder']    = xml.mtGetAttrib(index, 'inputBorder')
            err, gui.interface['outputBorder']   = xml.mtGetAttrib(index, 'outputBorder')
            err, gui.interface['widgetMargin']   = xml.mtGetAttrib(index, 'widgetMargin')
            err, gui.interface['widgetGap']      = xml.mtGetAttrib(index, 'widgetGap')
            err, gui.interface['textBorder']     = xml.mtGetAttrib(index, 'textBorder')
            err, gui.interface['fontSize']       = xml.mtGetAttrib(index, 'fontSize')
            err, gui.interface['sliderSize']     = xml.mtGetAttrib(index, 'sliderSize')
            err, gui.interface['scrollSize']     = xml.mtGetAttrib(index, 'scrollSize')
            err, gui.interface['scrollOpacity']  = xml.mtGetAttrib(index, 'scrollOpacity')
            err, gui.interface['iconRatio']      = xml.mtGetAttrib(index, 'iconRatio')
            err, gui.interface['iconTheme']      = xml.mtGetAttrib(index, 'iconTheme')
            err, gui.interface['iconSize']       = xml.mtGetAttrib(index, 'iconSize')
         else
            error('No interface tag in style values.')
         end

         xml = nil
      else
         error('Failed to retrieve style information.')
      end

      mSurface = nil
   end
end

------------------------------------------------------------------------------

gui.bitmapColour = function(Bitmap, ColourName)
   if (gui.rgb[ColourName] == nil) then
      local str = gui.colours[ColourName]
      if (str == nil) then
         error('Unrecognised colour "' .. nz(ColourName,'NIL') .. '"')
      end
      gui.rgb[ColourName] = gui.strToRGB(str)
   end

   local rgb = gui.rgb[ColourName]
   local err, col = Bitmap.mtGetColour(rgb.r, rgb.g, rgb.b, rgb.a)
   return col
end

------------------------------------------------------------------------------
-- Create a border inside a surface, suitable for a basic rectangular widget.  Options include:
--
--   fill:  Fill the box with the default solid colour or pattern.
--   style: Set to 'input', 'output' or 'text'.
--   updateMargins: Update the surface margins to accomodate the border thickness.

gui.insideBorder = function(Surface, Options)
   local thickness = 0
   if (Options.style == 'input') then thickness = gui.pixel(gui.interface.inputBorder) end
   if (Options.style == 'output') then thickness = gui.pixel(gui.interface.outputBorder) end
   if (Options.style == 'text') then thickness = gui.pixel(gui.interface.inputBorder) end

   if (thickness > 0) then
      if (Options.updateMargins) then
         box.leftMargin   = thickness
         box.rightMargin  = thickness
         box.topMargin    = thickness
         box.bottomMargin = thickness
      end
   end

   Surface.mtAddCallback(function(Surface, Bitmap)
      for i=0,thickness-1 do
         Bitmap.mtDrawRectangle(i, i, Surface.width-(i*2), Surface.height-(i*2), gui.bitmapColour(Bitmap, 'border'), 0)
      end

      if Options.fill then
         Bitmap.mtDrawRectangle(thickness, thickness, Surface.width-(thickness*2), Surface.height-(thickness*2),
            gui.bitmapColour(Bitmap, 'background'), BAF_FILL)
      end
   end)
end

------------------------------------------------------------------------------
-- Read a style value and return it in pixel units.

gui.pixel = function(val)
   if (val != nil) then
      local num, alpha = val:match('^(%d+)(%a-)$')
      num = tonumber(num)
      if (num == nil) then error('Invalid graphics unit \'' .. val .. '\'') end
      if (alpha != nil) then
         if (alpha == 'px') then
            return num
         elseif (alpha == 'in') then
            return gui.dpi * num
         elseif (alpha == 'mm') then // 25.4 units per inch
            return gui.dpi * (num / 25.4)
         elseif (alpha == 'pt') then // 72 units per inch
            return gui.dpi * (num / 72)
         elseif (alpha == 'dp') then // 160dpi relative value
            return num * (gui.dpi * 0.00625)
         end
      end
      return num
   else
      return 0
   end
end

------------------------------------------------------------------------------
-- Convert an RGB string to an RGB table.

gui.strToRGB = function(Value)
   if (string.byte(Value) == 35) then
      local colour = mSys.StrToHex(Value)
      if (Value:len() == 7) then
         return {
            r = bit.band(bit.rshift(colour, 16), 0xff),
            g = bit.band(bit.rshift(colour, 8), 0xff),
            b = bit.band(colour, 0xff),
            a = 255
         }
      elseif (Value:len() == 9) then
         return {
            r = bit.band(bit.rshift(colour, 24), 0xff),
            g = bit.band(bit.rshift(colour, 16), 0xff),
            b = bit.band(bit.rshift(colour, 8), 0xff),
            a = bit.band(colour, 0xff)
         }
      else
         return { r=0, g=0, b=0, a=255 }
      end
   else
      local colours = { }
      for str in string.gmatch(Value, '([^,]+)') do
         table.insert(colours, tonumber(str))
      end
      local r = nz(colours[1], 0)
      local g = nz(colours[2], 0)
      local b = nz(colours[3], 0)
      local a = nz(colours[4], 255)
      if (r > 255) then r = 255 end
      if (g > 255) then g = 255 end
      if (b > 255) then b = 255 end
      if (a > 255) then a = 255 end
      if (r < 0) then r = 0 end
      if (g < 0) then g = 0 end
      if (b < 0) then b = 0 end
      if (a < 0) then a = 0 end
      return { r=r, g=g, b=b, a=a }
   end
end
