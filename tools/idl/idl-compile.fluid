-- Read Parasol FDL files and save interface information in our standard IDL string format.  IDL strings describe
-- the structures, flags and constants used by modules in a universal format that is easy parse.  The headers can be
-- dynamically consumed by any language for the purpose of achieving full integration with the Parasol runtime
-- environment, which is written in C.
--
-- Usage: parasol sdk:scripts/idl-fluid.fluid src=source.fdl
-- Example: parasol sdk:scripts/idl-fluid.fluid src=sdk:core/modules/core/core.fdl

   require 'common'

   global glSelf = obj.find('self')
   global glPath = glSelf.workingPath
   global glOutput = { }
   global glHeader = { }
   
   global glProgram    = 'idl-compile'
   global glSource     = arg('src')
   global glOutputPath = arg('output')
   global glFeedback   = arg('feedback')
   global glFormat     = arg('format')
   global glAppend     = arg('append')
   
   global glOrderedStructures = { }
   global glStructures = { }
   global glConstants = { }

-- Dummy functions for loaded FDL files to prevent errors.

global function c_include(...) end
global function cpp_include(...) end
global function class(Name, Options, Def, Private) end
global function functionNames(Prefix, ...) end
global function methods(ClassName, Prefix, Methods) end
global function c_insert(Raw) end
global function privateNames(List) end

   require './include/utils'

----------------------------------------------------------------------------------------------------------------------
-- FDL function
-- Restricts the output of anything declared within the referenced function.

global function restrict(Function)
   local status = glRestrict
   global glRestrict = 'ALL'
   Function()
   glRestrict = status
end

----------------------------------------------------------------------------------------------------------------------

global function module(Options, Function)
   global glModuleName = Options['name']
   Function()
end

----------------------------------------------------------------------------------------------------------------------

global function header(Options, Function)
   global glHeaderPath = Options['path']
   Function()
end

----------------------------------------------------------------------------------------------------------------------

global function flags(Prefix, Options, ...)
   Options = checkOptions(Options)

   if Options.restrict?? or glRestrict then return end -- Restricted definitions are never exported
   if Options.module?? and (Options.module:lower() != glModuleName:lower()) then return end
   verbose('Processing flags ' .. Prefix)

   list = { }
   f = 0
   for _, flag_def in ipairs({...}) do
      if type(flag_def) is 'string' then
         local key, comment = flag_def:match('^(.+):%s+(.+)$')
         if not key then key = flag_def end

         for _, v in ipairs(key:split('|')) do
            list[v] = 1 << f
         end
      elseif type(flag_def) is 'table' then
         for flag, ref in pairs(flag_def) do
            local key, comment
            if type(ref) != 'number' then
               key, comment = ref:match('^(.+):%s+(.+)$')
               if key then
                  if key:find('^0x%d+$') or key:find('^[+-]?%d+$') then
                     key = tonumber(key)
                  end
               end
            end

            if not key then key = ref end

            if type(key) is 'number' then
               list[flag] = key
            else
               local f = 0
               for _, v in ipairs(key:split('|')) do
                  if list[v] then
                     f = f | list[v]
                  else
                     print("Failed to lookup reference '" .. v .. "'")
                  end
               end
               list[flag] = f
            end
         end
      else
         error("Invalid flag type for '" .. Prefix .. "', expected string, got '" .. type(flag_def) .. "'")
      end
      f++
   end

   glConstants[Prefix] = list
end

----------------------------------------------------------------------------------------------------------------------

global function enum(Prefix, Options, ...)
   Options = checkOptions(Options)

   if Options.restrict?? or glRestrict then return end -- Restricted definitions are never exported
   if Options.module?? and (Options.module:lower() != glModuleName:lower()) then return end
   verbose('Processing enum ' .. Prefix)

   list = { }
   inc = Options.start ?? 0
   for k, enum_def in ipairs({...}) do
      if type(enum_def) is 'string' then
         val = enum_def:match('^(.-):%s+.+$')  -- Scrap any comment for this value
         val ?= enum_def

         for _, name in ipairs(val:split('|')) do
            list[name] = inc
         end
      elseif type(enum_def) is 'table' then -- The client provided a table of fixed values
         for name, client_val in pairs(enum_def) do
            list[name] = client_val
         end
      else
         error("Invalid enum type for '" .. Prefix .. "', expected string, got '" .. type(enum_def) .. "'")
      end
      inc++
   end

   glConstants[Prefix] = list
end

----------------------------------------------------------------------------------------------------------------------

global function const(Prefix, Options, ...)
   Options = checkOptions(Options)

   if Options.restrict?? or glRestrict then return end -- Restricted definitions are never exported
   if Options.module?? and (Options.module:lower() != glModuleName:lower()) then return end
   verbose('Processing constants ' .. Prefix)

   list = { }
   for k, const_def in ipairs({...}) do
      if type(const_def) is 'table' then
         for k, v in pairs(const_def) do
            local val, comment
            if type(v) is 'string' then
               val, comment = v:match('^(.-):%s+(.+)$')
            end
            if not val then val = v end

            if string.find(val, '^0x%d+$') or string.find(val, '^[+-]?%d+$') then
               val = tonumber(val)
            end

            list[k] = val
         end
      else
         error("Invalid const type for '" .. Prefix .. "', expected string, got '" .. type(const_def) .. "'")
      end
   end
   glConstants[Prefix] = list
end

----------------------------------------------------------------------------------------------------------------------

global function hash(Prefix, Format, ...)
   for k, hash_def in ipairs({...}) do
      hash_name = hash_def:gsub('[^%w]', '_')
      hash_id = string.format('%08x', hash_name:hash()):sub(-8)
      output('#define ' .. Prefix .. '_' .. hash_name .. ' ' .. string.format(Format, hash_id))
   end
   output()
end

----------------------------------------------------------------------------------------------------------------------

global function platform(Platform, Function)
   if (Platform:lower() is 'windows') then
      Function()
   elseif (Platform:lower() is 'linux') then
      Function()
   elseif (Platform:lower() is 'x11') then
      Function()
   else
      error("Unrecognised platform '" .. Platform .. "'")
   end
end

----------------------------------------------------------------------------------------------------------------------

global function str_to_bytes(String)
   local list
   String = String:gsub("\\n", string.char(10))
   for i = 0, #String - 1 do
      if list then
         list ..= string.format(',%d', String:byte(i))
      else
         list = string.format('%d', String:byte(i))
      end
   end
   return list
end

----------------------------------------------------------------------------------------------------------------------

global glTypes = {
   hhandle = 'l',
   mem     = 'l',
   int     = 'l',
   uint    = 'ul',
   ptr     = 'p',
   cptr    = 'p',
   oid     = 'l',
   short   = 'w',
   ushort  = 'uw',
   uchar   = 'uc',
   char    = 'c',
   error   = 'l',
   large   = 'x',
   cid     = 'ul',
   obj     = 'o',
   str     = 's',
   cstr    = 's',
   func    = 'r',
   float   = 'f',
   double  = 'd',
   maxint  = 'm',
   eid     = 'l',
   fid     = 'x',
   struct  = 'e',
   resource = 'e'
}

global function cType(Field, Origin)
   assert(Field.type, "Field definition incorrect, missing 'type' value for '" .. (Origin ?? 'NIL') .. "'")

   do
      cpp_type = Field.type:match("^cpp%((.+)%)$")
      if cpp_type then
         Field.cpp  = true
         Field.type = cpp_type
         cType(Field, Origin)
         Field.type = 'z' .. Field.type
         return Field
      end
   end

   do
      local const, struct = Field.type:match('^(c-)struct%((.+)%)$')
      if struct then
         ptr_struct = struct:match('%*(.+)')
         if ptr_struct then struct = ptr_struct end

         Field.struct = struct
         Field.type = ptr_struct ? 'p' :> 'e'
         Field.name ..= ':' .. struct

         return Field
      end
   end

   do
      object = Field.type:match('^obj%((.+)%)$')
      if object then
         ptr_struct = object:match('%*(.+)')
         Field.type = ptr_struct ? 'p' :> 'o'
         return Field
      end
   end

   do
      local bit = Field.type:match('^bit%((.+)%)$')
      if bit then
         Field.type = cType({ type=bit, name='Bit' }, Origin).type
         Field.name = 'Bit'
         return Field
      end
   end

   do -- Char flags / Strong typing
      if Field.type:match('^char%((%a+)%)') then
         Field.type = 'c'
         return Field
      end
   end

   do -- Short flags / Strong typing
      if Field.type:match('^short%((%a+)%)') then
         Field.type = 'w'
         return Field
      end
   end

   do -- Integer flags / Strong typing
      if Field.type:match('^int%((%a+)%)') then
         Field.type = 'l'
         return Field
      end
   end

   do -- Large flags / Strong typing
      if Field.type:match('^large%((%a+)%)') then
         Field.type = 'x'
         return Field
      end
   end

   do -- Char arrays
      local unsigned, count = Field.type:match('^(u-)char%((.+)%)$')
      if count then
         Field.type = 'c'
         if unsigned?? then Field.type = 'uc' end
         Field.name ..= '[' .. count .. ']'
         return Field
      end
   end

   do -- Integer arrays
      local unsigned, count = Field.type:match('^(u-)int%((%d+)%)')
      if count then
         if unsigned?? then
            Field.type = 'ul'
         else
            Field.type = 'l'
         end
         Field.name ..= '[' .. count .. ']'
         return Field
      end
   end

   do -- Double arrays
      count = Field.type:match('^double%((.+)%)')
      if count then
         Field.type = 'd'
         Field.name ..= '[' .. count .. ']'
         return Field
      end
   end

   do -- Float arrays
      count = Field.type:match('^float%((.+)%)')
      if count then
         Field.type = 'f'
         Field.name ..= '[' .. count .. ']'
         return Field
      end
   end

   do
      local const, ptr_type = Field.type:match('^(c-)ptr%((.+)%)')
      if ptr_type then
         Field.type = 'p'
         return Field
      end
   end

   do
      array_type, array_size = Field.type:match('^array%((.+),(%d+)%)$')
      if array_type then
         Field.type = array_type
         Field = cType(Field, Origin)
         Field.name ..= '[' .. array_size .. ']'
         return Field
      end
   end

   do
      array_type = Field.type:match('^array%((.+)%)$')
      if array_type then
         Field.type = array_type
         Field = cType(Field, Origin)
         Field.name ..= '[]'
         return Field
      end
   end

   do
      if Field.type:match('^fptr%((.+)%)$') then
         Field.type = 'p'
         return Field
      end
   end

   assert(glTypes[Field.type], 'No handling for field type "' .. Field.type .. '" from ' .. Origin)

   Field.type = glTypes[Field.type] ?? Field.type
   return Field
end

----------------------------------------------------------------------------------------------------------------------
-- Returns { type, name, comment }

global function extractFields(Def, Origin)
   fields = { }
   for line, content in ipairs(Def:split('\n')) do
      -- Extract comment, if specified
      comment = content:match('^.+#%s-(.+)$')
      if comment?? then
         content = content:match('^(.+)#%s-.+$')
      else
         -- Support for alternative comment format where the colon is used.
         comment = content:match('^.+:%s-(.+)$')
         if comment?? then
            content = content:match('^(.+):%s-.+$')
         end
      end

      local type, name = content:match('^%s*(.+)%s+([^%s]+)%s-$')
      if type then
         local field = cType({ type=type:trim(), name=name:trim() }, Origin)
         table.insert(fields, field)
      elseif not content:trim()?? then
         -- Ignore empty line
      else
         error("Unable to process line '" .. tostring(content) .. "' for '" .. tostring(Origin) .. "'")
      end
   end

   return fields
end

----------------------------------------------------------------------------------------------------------------------

global function struct(Name, Options, Def, Append)
   Options = checkOptions(Options)
   if Options.restrict?? or glRestrict then return end -- Restricted structures are never exported
   if Options.module?? and (Options.module:lower() != glModuleName:lower()) then return end
   verbose('Processing structure ' .. Name)
   local struct = {
      name    = Name,
      version = Options.version,
      type    = Options.type,
      fields  = extractFields(Def, Name)
   }
   struct.sequence = sequenceStruct(struct.fields)
   glStructures[Name] = struct
   table.insert(glOrderedStructures, struct)
end

----------------------------------------------------------------------------------------------------------------------
-- Convert a struct definition into a string-based field sequence.

global function sequenceStruct(fields)
   seq = ''
   for _, f in ipairs(fields) do
      if seq?? then seq ..= ',' end
      if f.sequence then
         seq ..= 'e' .. f.name:cap() .. ':' .. f.type
      else
         seq ..= f.type .. f.name:cap()
      end
   end
   return seq
end

----------------------------------------------------------------------------------------------------------------------

global function saveOutput()
   outPath = glOutputPath

   if not outPath then
      if glModuleName?? then
         outPath = 'sdk:data/config/defs/' .. glModuleName:lower() .. '.def'
      else
         error('No output path specified in command-line.')
      end
   end

   print('Saving compressed IDL output to "' .. outPath .. '"')

   err, file = catch(function()
      if glAppend then
         file = obj.new('file', { flags='WRITE', path=outPath } )
         file.acSeek(0, SEEK_END)
         return file
      else
         return obj.new('file', { flags='WRITE|NEW', path=outPath } )
      end
   end)

   if err then
      print('Failed to write output to ' .. outPath)
      return
   end

   EOL = '\n'
   if glFormat is 'c' then EOL = '\\n' end

   -- Build structures string

   s = ''
   for _, struct in pairs(glOrderedStructures) do
      if struct.fields then
         s ..= 's.' .. struct.name .. ':' .. struct.sequence .. EOL
      end
   end

   -- Build constants strings

   sortedConstants = { }
   for prefix, tab in pairs(glConstants) do
      sortedkv = { }
      for k, v in pairs(tab) do
         table.insert(sortedkv, { name = k, value = v })
      end
      table.sort(sortedkv, function(a,b) return a.name < b.name end)
      table.insert(sortedConstants, { prefix=prefix, table=sortedkv })
   end
   table.sort(sortedConstants, function(a,b) return a.prefix < b.prefix end)

   c = ''
   for _, group in ipairs(sortedConstants) do
      c ..= 'c.' .. group.prefix .. ':'
      e = ''
      for _, const in ipairs(group.table) do
         if e?? then e ..= ',' end
         if type(const.value) is 'string' then
            val = const.value:match('^(.-):%s+.+$') -- Scrap any defined comment for this value.
            val ?= const.value
            e ..= const.name .. '="' .. const.value .. '"'
         else
            hexval = string.format('%x', const.value)
            if hexval:len() is 16 then hexval = hexval:sub(-8) end
            e ..= const.name .. '=0x' .. hexval
         end
      end
      c ..= e .. EOL
   end

   if glFormat is 'c' then
      if s:len() + c:len() >= 16 * 1024 then -- MSVC doesn't like defined strings > 16Kb, so we need this alternative
         file.acWrite('char glIDL[] = { ')
         file.acWrite(str_to_bytes((s ?? '') .. (c ?? '')))
         file.acWrite(',0 };\n')
      else
         file.acWrite('#undef MOD_IDL\n#define MOD_IDL "')
         if s?? then file.acWrite(s) end
         if c?? then file.acWrite(c) end
         file.acWrite('"\n')
      end
   else
      if s?? then file.acWrite(s) end
      if c?? then file.acWrite(c) end
   end
end

----------------------------------------------------------------------------------------------------------------------

   if not glSource then
      print('This command is used to compile IDL definition files.  Provide a reference to a')
      print('source file, or directory of source files in the SRC argument.  The resulting data will be')
      print('printed to the output object that was used in executing the command.')
      return
   end

   resolveSDKPath(arg('sdk'))

   local err, type = mSys.AnalysePath(glSource)
   assert(type is LOC_FILE, 'The specified source "' .. glSource .. '" is invalid.')

   loadFile(glSource)
   saveOutput()
