-- This program produces C++ headers, auto-generated values and documentation from Parasol FDL files.
--
-- Usage: parasol sdk:tools/idl/idl-c.fluid src=source.fdl
-- Example: parasol sdk:tools/idl/idl-c.fluid src=sdk:core/modules/core/core.fdl

   include 'core'
   include 'xml'

   require 'common'

   iStruct = struct -- Save the struct interface because struct() is going to overwrite it.

   glSelf = obj.find('self')
   glPath = glSelf.workingPath
   glIDLTimestamp = 20241015

----------------------------------------------------------------------------------------------------------------------

glActionStubs = {
   -- Hidden actions
   Free          = "",
   FreeWarning   = "",
   NewChild      = "",
   NewObject     = "",
   NewOwner      = "",
   NewPlacement  = "",

   -- Actions without parameters
   Activate     = "   inline ERR activate() noexcept { return Action(AC::Activate, this, NULL); }",
   Clear        = "   inline ERR clear() noexcept { return Action(AC::Clear, this, NULL); }",
   Deactivate   = "   inline ERR deactivate() noexcept { return Action(AC::Deactivate, this, NULL); }",
   Disable      = "   inline ERR disable() noexcept { return Action(AC::Disable, this, NULL); }",
   Enable       = "   inline ERR enable() noexcept { return Action(AC::Enable, this, NULL); }",
   Flush        = "   inline ERR flush() noexcept { return Action(AC::Flush, this, NULL); }",
   Focus        = "   inline ERR focus() noexcept { return Action(AC::Focus, this, NULL); }",
   Hide         = "   inline ERR hide() noexcept { return Action(AC::Hide, this, NULL); }",
   Init         = "   inline ERR init() noexcept { return InitObject(this); }",
   Lock         = "   inline ERR lock() noexcept { return Action(AC::Lock, this, NULL); }",
   LostFocus    = "   inline ERR lostFocus() noexcept { return Action(AC::LostFocus, this, NULL); }",
   MoveToBack   = "   inline ERR moveToBack() noexcept { return Action(AC::MoveToBack, this, NULL); }",
   MoveToFront  = "   inline ERR moveToFront() noexcept { return Action(AC::MoveToFront, this, NULL); }",
   Next         = "   inline ERR next() noexcept { return Action(AC::Next, this, NULL); }",
   Prev         = "   inline ERR prev() noexcept { return Action(AC::Prev, this, NULL); }",
   Query        = "   inline ERR query() noexcept { return Action(AC::Query, this, NULL); }",
   Refresh      = "   inline ERR refresh() noexcept { return Action(AC::Refresh, this, NULL); }",
   Reset        = "   inline ERR reset() noexcept { return Action(AC::Reset, this, NULL); }",
   SaveSettings = "   inline ERR saveSettings() noexcept { return Action(AC::SaveSettings, this, NULL); }",
   Show         = "   inline ERR show() noexcept { return Action(AC::Show, this, NULL); }",
   Unlock       = "   inline ERR unlock() noexcept { return Action(AC::Unlock, this, NULL); }",

   CopyData = [[
   inline ERR copyData(OBJECTPTR Dest) noexcept {
      struct acCopyData args = { .Dest = Dest };
      return Action(AC::CopyData, this, &args);
   }]],
   DragDrop = [[
   inline ERR dragDrop(OBJECTPTR Source, LONG Item, CSTRING Datatype) noexcept {
      struct acDragDrop args = { .Source = Source, .Item = Item, .Datatype = Datatype };
      return Action(AC::DragDrop, this, &args);
   }]],
   Clipboard = [[
   inline ERR clipboard(CLIPMODE Mode) noexcept {
      struct acClipboard args = { Mode };
      return Action(AC::Clipboard, this, &args);
   }]],
   Draw = [[
   inline ERR draw() noexcept { return Action(AC::Draw, this, NULL); }
   inline ERR drawArea(LONG X, LONG Y, LONG Width, LONG Height) noexcept {
      struct acDraw args = { X, Y, Width, Height };
      return Action(AC::Draw, this, &args);
   }]],
   DataFeed = [[
   inline ERR dataFeed(OBJECTPTR Object, DATA Datatype, const void *Buffer, LONG Size) noexcept {
      struct acDataFeed args = { Object, Datatype, Buffer, Size };
      return Action(AC::DataFeed, this, &args);
   }]],
   Move = [[
   inline ERR move(DOUBLE X, DOUBLE Y, DOUBLE Z) noexcept {
      struct acMove args = { X, Y, Z };
      return Action(AC::Move, this, &args);
   }]],
   Read = [[
   template <class T, class U> ERR read(APTR Buffer, T Size, U *Result) noexcept {
      static_assert(std::is_integral<U>::value, "Result value must be an integer type");
      static_assert(std::is_integral<T>::value, "Size value must be an integer type");
      const LONG bytes = (Size > 0x7fffffff) ? 0x7fffffff : Size;
      struct acRead read = { (BYTE *)Buffer, bytes };
      if (auto error = Action(AC::Read, this, &read); error IS ERR::Okay) {
         *Result = static_cast<U>(read.Result);
         return ERR::Okay;
      }
      else { *Result = 0; return error; }
   }
   template <class T> ERR read(APTR Buffer, T Size) noexcept {
      static_assert(std::is_integral<T>::value, "Size value must be an integer type");
      const LONG bytes = (Size > 0x7fffffff) ? 0x7fffffff : Size;
      struct acRead read = { (BYTE *)Buffer, bytes };
      return Action(AC::Read, this, &read);
   }]],
   Redo = [[
   inline ERR redo(LONG Steps) noexcept {
      struct acRedo args = { Steps };
      return Action(AC::Redo, this, &args);
   }]],
   Redimension = [[
   inline ERR redimension(DOUBLE X, DOUBLE Y, DOUBLE Z, DOUBLE Width, DOUBLE Height, DOUBLE Depth) noexcept {
      struct acRedimension args = { X, Y, Z, Width, Height, Depth };
      return Action(AC::Redimension, this, &args);
   }
   inline ERR redimension(DOUBLE X, DOUBLE Y, DOUBLE Width, DOUBLE Height) noexcept {
      struct acRedimension args = { X, Y, 0, Width, Height, 0 };
      return Action(AC::Redimension, this, &args);
   }]],
   Rename = [[
   inline ERR rename(CSTRING Name) noexcept {
      struct acRename args = { Name };
      return Action(AC::Rename, this, &args);
   }]],
   Resize = [[
   inline ERR resize(DOUBLE Width, DOUBLE Height, DOUBLE Depth = 0) noexcept {
      struct acResize args = { Width, Height, Depth };
      return Action(AC::Resize, this, &args);
   }]],
   Undo = [[
   inline ERR undo(LONG Steps) noexcept {
      struct acUndo args = { Steps };
      return Action(AC::Undo, this, &args);
   }]],
   GetKey = [[
   inline ERR getKey(CSTRING Key, STRING Value, LONG Size) noexcept {
      struct acGetKey args = { Key, Value, Size };
      auto error = Action(AC::GetKey, this, &args);
      if ((error != ERR::Okay) and (Value)) Value[0] = 0;
      return error;
   }]],
   MoveToPoint = [[
   inline ERR moveToPoint(DOUBLE X, DOUBLE Y, DOUBLE Z, MTF Flags) noexcept {
      struct acMoveToPoint moveto = { X, Y, Z, Flags };
      return Action(AC::MoveToPoint, this, &moveto);
   }]],
   SaveImage = [[
   inline ERR saveImage(OBJECTPTR Dest, CLASSID ClassID = CLASSID::NIL) noexcept {
      struct acSaveImage args = { Dest, { ClassID } };
      return Action(AC::SaveImage, this, &args);
   }]],
   SaveToObject = [[
   inline ERR saveToObject(OBJECTPTR Dest, CLASSID ClassID = CLASSID::NIL) noexcept {
      struct acSaveToObject args = { Dest, { ClassID } };
      return Action(AC::SaveToObject, this, &args);
   }]],
   Seek = [[
   inline ERR seek(DOUBLE Offset, SEEK Position = SEEK::CURRENT) noexcept {
      struct acSeek args = { Offset, Position };
      return Action(AC::Seek, this, &args);
   }
   inline ERR seekStart(DOUBLE Offset) noexcept { return seek(Offset, SEEK::START); }
   inline ERR seekEnd(DOUBLE Offset) noexcept { return seek(Offset, SEEK::END); }
   inline ERR seekCurrent(DOUBLE Offset) noexcept { return seek(Offset, SEEK::CURRENT); }
   ]],
   SetKeys = [[
   inline ERR setKeys(CSTRING tags, ...) noexcept {
      struct acSetKey args;
      va_list list;
      va_start(list, tags);
      while ((args.Field = va_arg(list, STRING)) != TAGEND) {
         args.Value = va_arg(list, STRING);
         if (Action(AC::SetKey, this, &args) != ERR::Okay) {
            va_end(list);
            return ERR::Failed;
         }
      }
      va_end(list);
      return ERR::Okay;
   }]],
   Write = [[
   inline ERR write(CPTR Buffer, LONG Size, LONG *Result = NULL) noexcept {
      struct acWrite write = { (BYTE *)Buffer, Size };
      if (auto error = Action(AC::Write, this, &write); error IS ERR::Okay) {
         if (Result) *Result = write.Result;
         return ERR::Okay;
      }
      else {
         if (Result) *Result = 0;
         return error;
      }
   }
   inline ERR write(std::string Buffer, LONG *Result = NULL) noexcept {
      struct acWrite write = { (BYTE *)Buffer.c_str(), LONG(Buffer.size()) };
      if (auto error = Action(AC::Write, this, &write); error IS ERR::Okay) {
         if (Result) *Result = write.Result;
         return ERR::Okay;
      }
      else {
         if (Result) *Result = 0;
         return error;
      }
   }
   inline LONG writeResult(CPTR Buffer, LONG Size) noexcept {
      struct acWrite write = { (BYTE *)Buffer, Size };
      if (Action(AC::Write, this, &write) IS ERR::Okay) return write.Result;
      else return 0;
   }]],
   SelectArea = [[
   inline ERR acSelectArea(DOUBLE X, DOUBLE Y, DOUBLE Width, DOUBLE Height) noexcept {
      struct acSelectArea area = { X, Y, Width, Height };
      return Action(AC::SelectArea, this, &area);
   }]],
   SetKey = [[
   inline ERR acSetKey(CSTRING FieldName, CSTRING Value) noexcept {
      struct acSetKey args = { FieldName, Value };
      return Action(AC::SetKey, this, &args);
   }]],
}

----------------------------------------------------------------------------------------------------------------------

glHeader = { }
glOutput = { }
glConstants = { }
glConstantOptions = { }
glActiveRefs = { } -- For cType()

function output(String)
   if nz(String) then
      if (String:sub(-1) == '\n') then
         table.insert(glOutput, String)
      else
         table.insert(glOutput, String:rtrim())
      end
   else
      table.insert(glOutput,'')
   end
end

function priority(Input)
   if (type(Input) == 'function') then
      local saveOutput = glOutput
      glOutput = { }
      Input()
      for k,v in ipairs(glOutput) do
         table.insert(glHeader, v)
      end
      glOutput = saveOutput
   elseif (type(Input) == 'string') and nz(Input) then
      table.insert(glHeader, Input:rtrim())
   else
      table.insert(glHeader,'')
   end
end

----------------------------------------------------------------------------------------------------------------------

function checkOptions(Options)
   if (type(Options) != 'table') then
      if (type(Options) != 'nil') then
         error('Invalid option type "' .. type(Options) .. '", expected table.')
      else
         return { }
      end
   end
   return Options
end

----------------------------------------------------------------------------------------------------------------------
-- FDL function

function c_include(...)
   for k,v in ipairs({...}) do
      if (v:find('^<(.+)>$') != nil) then
         priority('#include ' .. v)
      else
         priority('#include "' .. v .. '"')
      end
   end
   priority()
end

----------------------------------------------------------------------------------------------------------------------
-- FDL function

function cpp_include(...)
   priority('#ifdef __cplusplus')
   for k,v in ipairs({...}) do
      if (v:find('^<(.+)>$') != nil) then
         local inc = v:match('^<parasol/(.+)>$')

         if (inc != nil) then inc = inc:gsub('[/%.]', '_') end

         if (inc != nil) then
            priority('#ifndef ' .. inc:upper())
            priority('#include ' .. v)
            priority('#endif')
            priority()
         else
            priority('#include ' .. v)
         end
      else
         priority('#include "' .. v .. '"')
      end
   end
   priority('#endif')
   priority()
end

----------------------------------------------------------------------------------------------------------------------
-- FDL function
-- Restricts the output of anything declared within the Function.

function restrict(Function)
   local status = glRestrict
   glRestrict = 'ALL'
   Function()
   glRestrict = status
end

----------------------------------------------------------------------------------------------------------------------
-- FDL function

function module(Options, Function)
   if (nz(Options['timestamp'],0) > glIDLTimestamp) then
      -- Do nothing if the timestamp is > than the timestamp on this idl-c release
      glAbort = 'Timestamp on IDL file (' .. Options['timestamp'] .. ') exceeds IDL-C timestamp of ' .. glIDLTimestamp
      return
   end

   glModule = Options

   if nz(glModule.name) then
      priority('#pragma once')
      priority()
   else
      error('No "name" field specified in module() call.')
   end

   priority('// Name:      ' .. glModule.name:lower() .. '.h')

   if nz(Options['copyright']) then
      priority('// Copyright: ' .. Options['copyright'])
   end
   priority('// Generator: idl-c')
   priority()

   priority('#include <parasol/main.h>')
   priority()

   if nz(glModule.version) then
      priority('#define MODVERSION_' .. glModule.name:upper() .. ' (' .. glModule.version .. ')')
      priority()
   end

   Function()
end

----------------------------------------------------------------------------------------------------------------------
-- FDL function

function header(Options, Function)
   glHeaderPath = Options['path']
   if nz(glHeaderPath) then
      priority('#pragma once')
      priority()
      priority('// Name:      ' .. glHeaderPath:lower() .. '.h')
   else
      local s = ''
      for i=1,10 do
         s = s .. string.char(math.random(65, 90))
      end

      priority('#pragma once')
      priority()
   end

   if nz(Options['copyright']) then
      priority('// Copyright: ' .. Options['copyright'])
   end
   priority('// Generator: idl-c')
   priority()

   Function()
end

----------------------------------------------------------------------------------------------------------------------
-- FDL function
--
--  flags('KQ', { comment='Special qualifier flags' },
--    'L_SHIFT: Left Shift is held',
--    'R_SHIFT: Right Shift is held',
--    { SHIFT = 'L_SHIFT|R_SHIFT' }
--  )

function flags(Prefix, Options, ...)
   if (glFeedback == 'verbose') then print('Processing ' .. nz(Prefix,'NIL') .. ' flags.') end
   if (glCustomTypes[Prefix]) then print('WARN: A "' .. Prefix .. '" constant already exists.') end

   Options = checkOptions(Options)

   local out = { }
   local sortedFlags = { }
   if (nz(Options.comment)) then
      table.insert(out, '// ' .. Options.comment)
      table.insert(out, '')
   end

   local function outputFlagDef(Options, Prefix, flag_name, val)
      if (not Options.weak) then
         if (Options.bits == 16) then
            table.insert(sortedFlags, { value = val, define = string.format('   %s = 0x%.4x,', flag_name, val) } )
         else
            local hash_id = string.format('%08x', val):sub(-8)
            table.insert(sortedFlags, { value = val, define = string.format('   %s = 0x%s,', flag_name, hash_id) } )
         end
      elseif (Options.bits == 16) then
         table.insert(sortedFlags, { value = val, define = string.format('#define %s_%s 0x%.4x', Prefix, flag_name, val) })
      else
         -- Note: This unusual formatting solution helps to resolve output problems on 64-bit Linux
         local hash_id = string.format('%08x', val):sub(-8)
         table.insert(sortedFlags, { value = val, define = string.format('#define %s_%s 0x%s', Prefix, flag_name, hash_id) } )
      end
   end

   if (not Options.weak) then
      local type_size = 'ULONG'
      if (Options.bits == 64) then
         type_size = 'LARGE'
      elseif (Options.bits == 16) then
         type_size = 'UWORD'
      elseif (Options.bits == 8) then
         type_size = 'UBYTE'
      end
      table.insert(out, string.format('enum class %s : ' .. type_size .. ' {', Prefix))
      table.insert(out, '   NIL = 0,')
   end

   local lookup = { }
   local flags = {...}
   local f = 0
   for a=1,#flags do
      local flag_name
      if (type(flags[a]) == 'string') then
         local key, comment = flags[a]:match('^(.-):%s+(.+)$')
         if (key == nil) then key = flags[a] end

         for _, flag_name in ipairs(key:split('|')) do
            local val = bit.lshift(1, f)
            outputFlagDef(Options, Prefix, flag_name, val)
            lookup[flag_name] = { name=flag_name, value=val, comment=comment }
         end
      elseif (type(flags[a]) == 'table') then
         for flag_name, ref in pairs(flags[a]) do
            local val = 0

            local key, comment
            if (type(ref) != 'number') then
               key, comment = ref:match('^(.-):%s+(.+)$')
               if (key != nil) then
                  if (key:find('^0x%d+$')) or (key:find('^[+-]?%d+$')) then
                     key = tonumber(key)
                  end
               end
            end

            if (key == nil) then key = ref end

            if (type(key) == 'number') then
               val = key
            else -- Process named reference(s) to other flags
               local v
               for _, v in ipairs(key:split('|')) do
                  if (lookup[v] != nil) then
                     val = bit.bor(val, lookup[v].value)
                  else
                     error("Failed to lookup flag reference '" .. v .. "' for " .. Prefix .. "_" .. flag_name)
                  end
               end
               if (comment == nil) then comment = 'Synonym for `' .. key:gsub('|',' | ') .. '`' end
            end
            outputFlagDef(Options, Prefix, flag_name, val)
            lookup[flag_name] = { name=flag_name, value=val, comment=comment }
         end
      else
         error("Invalid flag type for '" .. Prefix .. "', expected string, got '" .. type(flags[a]) .. "'")
      end

      f = f + 1
   end

   table.sort(sortedFlags, function(a,b) return a.value < b.value end)
   for _, flag in ipairs(sortedFlags) do
      table.insert(out, flag.define)
   end

   if (not Options.weak) then
      table.insert(out, '};')
      table.insert(out, '')
      table.insert(out, 'DEFINE_ENUM_FLAG_OPERATORS(' .. Prefix .. ')')
   end

   table.insert(out, '')

   if nz(Options.module) and (Options.module:lower() != glModule.name:lower()) then
     -- Do nothing, module restriction imposed.
   elseif (glRestrict == nil) then
      for k,v in pairs(out) do table.insert(glConstants, v) end
   end

   glCustomTypes[Prefix] = {
      prefix=Prefix, grouping='flags', list=lookup, comment=Options.comment,
      restrict=glRestrict
   }

   if (not Options.weak) then -- Promote strong-typing to other C++ definitions
      glCustomTypes[Prefix].type = 'int'
   end
end

----------------------------------------------------------------------------------------------------------------------
-- FDL function

function privateNames(List)
   for k,v in pairs(List) do
      glPrivateNames[v] = true
   end
end

----------------------------------------------------------------------------------------------------------------------
-- FDL function

function hash(Prefix, Format, ...)
   for _, v in ipairs({...}) do
      local hash_name = v:gsub('[^%w]', '_')
      -- Note: This unusual formatting solution helps to resolve output problems on 64-bit Linux
      local hash_id = string.format('%08x', v:hash()):sub(-8)
      output('#define ' .. Prefix .. '_' .. hash_name .. ' ' .. string.format(Format, hash_id))
   end
   output()
end

function typedHash(Prefix, Type, ...)
   Type = cType({ type=Type }, Prefix)
   output('enum class ' .. Prefix .. ' : ' .. Type.type .. ' {')
   output('   NIL = 0,')
   for _, v in ipairs({...}) do
      local hash_name = v:gsub('[^%w]', '_')
      -- Note: This unusual formatting solution helps to resolve output problems on 64-bit Linux
      local hash_id = string.format('%08x', v:hash()):sub(-8)
      output('   ' .. hash_name .. ' = ' .. string.format("0x%sUL", hash_id) .. ',')
   end
   output('};')
   output()
end

----------------------------------------------------------------------------------------------------------------------
-- FDL function

function const(Prefix, Options, ...)
   if (glFeedback == 'verbose') then print('Processing ' .. nz(Prefix,'NIL') .. ' constants.') end
   if (glCustomTypes[Prefix]) then print('WARN: A "' .. Prefix .. '" constant already exists.') end

   Options = checkOptions(Options)

   local out = { }
   if (nz(Options.comment)) then
      table.insert(out, '// ' .. Options.comment)
      table.insert(out, '')
   end

   if (Options.type) then -- Strong typing enabled, convert via cType()
      Options.type = cType({ type=Options.type }, Prefix)
      table.insert(out, string.format('enum class %s : ' .. Options.type.type .. ' {', Prefix))
      table.insert(out, '   NIL = 0,')
   end

   local list = { }
   for k,va in ipairs({...}) do
      if (type(va) == 'string') then
         local key, comment = va:match('^(.-):%s+(.+)$')
         if (key == nil) then key = va end
         for _, v in ipairs(key:split('|')) do
            table.insert(out, '#define ' .. Prefix .. '_' .. v)
         end
      elseif (type(va) == 'table') then
         local sorted = { }
         for name, value in pairs(va) do
            table.insert(sorted, { name = name, value = value })
         end
         table.sort(sorted, function(a,b)
            if (a.value == b.value) then
               return a.name < b.name
            elseif type(a.value) == 'number' and type(b.value) == 'number' then
               return a.value < b.value
            else
               return tostring(a.value) < tostring(b.value)
            end
         end)

         for _, v in ipairs(sorted) do
            local val, comment
            if (type(v.value) == 'string') then
               val, comment = v.value:match('^(.-):%s+(.+)$')
            end
            if (val == nil) then val = v.value end

            if (Options.type) then
               table.insert(out, '   ' .. v.name .. ' = ' .. val .. ',')
            else
               table.insert(out, '#define ' .. Prefix .. '_' .. v.name .. ' ' .. val)
            end

            table.insert(list, { name=v.name, value=val, comment=comment })
         end
      else
         error('Invalid const type for "' .. Prefix .. '", expected string, got "' .. type(va) .. '"')
      end
   end

   if (Options.type) then
      table.insert(out, '};')
   end

   table.insert(out, '')

   if nz(Options.module) and (Options.module:lower() != glModule.name:lower()) then
     -- Do nothing, module restriction imposed.
   elseif (glRestrict == nil) then //.
      for k,v in pairs(out) do table.insert(glConstants, v) end
   end

   glCustomTypes[Prefix] = {
      prefix=Prefix, grouping='constants', list=list, comment=Options.comment,
      restrict=nz(glRestrict, Options.restrict),
      type=Options.type -- Promotes strong-typing to other C++ definitions
   }
end

----------------------------------------------------------------------------------------------------------------------
-- FDL function

function enum(Prefix, Options, ...)
   if (glFeedback == 'verbose') then print('Processing ' .. nz(Prefix,'NIL') .. ' enum.') end
   if (glCustomTypes[Prefix]) then print('WARN: A "' .. Prefix .. '" constant already exists.') end

   Options = checkOptions(Options)

   local out = { }
   if (nz(Options.comment)) then
      table.insert(out, '// ' .. Options.comment)
      table.insert(out, '')
   end

   if (Options.type) then -- Strong typing enabled, convert via cType()
      Options.type = cType({ type=Options.type }, Prefix)
      table.insert(out, string.format('enum class %s : ' .. Options.type.type .. ' {', Prefix))
      table.insert(out, '   NIL = 0,')
   end

   local list = { }
   local inc = nz(Options.start, 0)
   for k,va in ipairs({...}) do
      if (type(va) == 'string') then
         local key, comment = va:match('^(.-):%s+(.+)$')
         if (key == nil) then key = va end
         local synonym = false
         for _, name in ipairs(key:split('|')) do
            if (Options.type) then
               table.insert(out, '   ' .. name .. ' = ' .. inc .. ',')
            elseif (Options.bits == 64) then
               table.insert(out, '#define ' .. Prefix .. '_' .. name .. ' ' .. inc .. 'LL')
            else
               table.insert(out, '#define ' .. Prefix .. '_' .. name .. ' ' .. inc)
            end

            table.insert(list, { name=name, value=inc, comment=comment, synonym=synonym })
            synonym = true
         end

         inc = inc + 1
      elseif (type(va) == 'table') then -- The client provided a table of fixed values
         for name, client_val in pairs(va) do
            if (type(client_val) != 'number') then
               error('Client-provided enum values must be numeric')
            end

            if (Options.type) then
               table.insert(out, '   ' .. name .. ' = ' .. client_val .. ',')
            elseif (Options.bits == 64) then
               table.insert(out, '#define ' .. Prefix .. '_' .. name .. ' ' .. client_val .. 'LL')
            else
               table.insert(out, '#define ' .. Prefix .. '_' .. name .. ' ' .. client_val)
            end

            table.insert(list, { name=name, value=client_val })
         end
      else
         error('Invalid enum type for "' .. Prefix .. '", expected string, got "' .. type(va) .. '"')
      end
   end

   if (Options.type) then
      table.insert(out, '};')
   end

   table.insert(out, '')

   if nz(Options.module) and (Options.module:lower() != glModule.name:lower()) then
     -- Do nothing, module restriction imposed.
   elseif (glRestrict == nil) then
      for k,v in pairs(out) do table.insert(glConstants, v) end
   end

   glCustomTypes[Prefix] = {
      prefix=Prefix, grouping='constants', list=list, comment=Options.comment,
      restrict=nz(glRestrict, Options.restrict),
      bits=Options.bits,
      type=Options.type -- Promotes strong-typing to other C++ definitions
   }
end

----------------------------------------------------------------------------------------------------------------------
-- FDL function

function platform(Platform, Function)
   local saveHeader = glHeader
   local saveOutput = glOutput
   glHeader = { }
   glOutput = { }

   local define
   if (Platform:lower() == 'windows') then
      define = '_WIN32'
      Function()
   elseif (Platform:lower() == 'linux') then
      define = '__linux__'
      Function()
   elseif (Platform:lower() == 'x11') then
      define = '__xwindows__'
      Function()
   --elseif (Platform:lower() == 'osx') then
   --   define = '__xwindows__'
   --   Function()
   else
      error('Unrecognised platform "' .. Platform .. '"')
   end

   local platformHeader = glHeader
   local platformOutput = glOutput
   glHeader = saveHeader
   glOutput = saveOutput

   if #platformHeader > 0 then
      priority('#ifdef ' .. define)
      priority()
      for k,v in ipairs(platformHeader) do
         priority(v)
      end
      priority('#endif')
      priority()
   end

   if #platformOutput > 0 then
      output('#ifdef ' .. define)
      output()
      for k,v in ipairs(platformOutput) do
         output(v)
      end
      output('#endif')
      output()
   end
end

----------------------------------------------------------------------------------------------------------------------
-- FDL function

function struct(Name, Options, Def, Append)
   if (glFeedback == 'verbose') then print('Processing struct ' .. nz(Name,'NIL')) end

   local prevStruct = glCurrentStructure
   glCurrentStructure = Name

   catch(function()
      Options = checkOptions(Options)

      local out = { }
      local full_name = Name
      if (Options.version != nil) then
         table.insert(out, '#define VER_' .. Name:upper() .. ' ' .. Options.version)
         table.insert(out, '')
         full_name = Name .. 'V' .. Options.version
      end

      if Options.type == nil then
         table.insert(out, 'struct ' .. full_name ..  ' {')
      else
         table.insert(out, 'typedef struct ' .. full_name ..  ' {')
      end

      local fields = extractFields(Def, full_name)

      local type_len = 0
      local name_len = 0
      local type_max = 0
      for i, f in ipairs(fields) do
         local field_name = cName(f, true)
         if (field_name:len() > name_len) then name_len = field_name:len() end

         if (f.type:len() > type_len) then
            if (f.type:len() < 10) then
               type_len = f.type:len()
            end
         end

         if (f.type:len() + field_name:len() > type_max) then
            type_max = f.type:len() + 2 + field_name:len()
         end
      end

      local max_len = 3 + type_max + 1 + 2

      for i, f in ipairs(fields) do
         local field_name = cName(f, true)
         local left
         if nz(field_name) then -- field_name can be nil if the field describes a function pointer
            left = string.format('   %-' .. type_len .. 's %s;', nz(f.extType, f.type), field_name)
         else
            left = string.format('   %-' .. type_len .. 's;', nz(f.extType, f.type))
         end

         if nz(f.comment) then
            local clean_comment = f.comment:gsub('[`!@#]', '')
            table.insert(out, string.format('%-' .. max_len .. 's // %s', left, clean_comment))
         else
            print('WARN: ' .. full_name .. '.' .. f.name .. ' requires a comment.')
            table.insert(out, left)
         end
      end

      if (Append != nil) then
         table.insert(out, Append:rtrim())
      end

      if Options.type == nil then
         table.insert(out, '};')
         table.insert(out, '')
      else
         Options.type = Options.type:upper()
         table.insert(out, '} ' .. Options.type .. ';')
         table.insert(out, '')
      end

      if nz(Options.module) and (Options.module:lower() != glModule.name:lower()) then
        -- Do nothing, module restriction imposed.
      elseif (glRestrict == nil) then
         for k,v in pairs(out) do table.insert(glOutput, v) end
      end

      glStructures[Name] = {
         version = Options.version, type = Options.type, comment = Options.comment, fields = fields,
         restrict = nz(glRestrict, Options.restrict), name = Name
      }
   end,
   function(Exception)
      glCurrentStructure = prevStruct
      error(Exception.message)
   end)

   glCurrentStructure = prevStruct
end

----------------------------------------------------------------------------------------------------------------------
-- Create a C/C++ field name from the definitions in a Field object.

function cName(Field, CStruct)
   if (Field.isFunctionPtr) then return '' end // Functions have their name embedded in the type.

   local name = Field.name
   if (CStruct) then
      if (Field.type == 'OBJECTID') or (Field.type == 'MEMORYID') then
         if (name:sub(-2) != 'ID') then
            name = name .. 'ID'
         end
      end
   end

   if (Field.arraySize != nil) and (Field.arraySize > 0) then
      name = name .. '[' .. Field.arraySize .. ']'
   end

   if (Field.bits != nil) then
      name = name .. ':1'
   end

   return name
end

----------------------------------------------------------------------------------------------------------------------
-- FDL Function
-- Refer to outputClassHeader() for output of the class structure.

function class(Name, Options, Spec, Private, Custom)
   if (glFeedback == 'verbose') then print('Processing class ' .. nz(Name,'NIL')) end

   Options = checkOptions(Options)

   output('// ' .. Name .. ' class definition')
   output()
   output('#define VER_' .. Name:upper() .. ' (' .. string.format('%f', nz(Options.version,1.0)) .. ')')
   output()

   local class = registerClass(Name)
   class.name = Name -- The name defined by class() has priority over any name defined by method()
   class.src = Options.src
   if Options.base then
      class.base = "obj" .. Options.base
   end
   class.references = { }

   glActiveRefs = class.references

   if (type(class.src) == 'string') then class.src = { class.src } end -- Convert string to an array of strings

   if (mSys.GetResource(RES_STATIC_BUILD) == 0) then
      -- Attempt to load the class into memory.  This introduces a circular reference when the module is not yet
      -- compiled, so the meta information may only be used for phase 2 output (i.e. documentation).

      if (mSys.AnalysePath('~modules:' .. glModule.name) == ERR_Okay) then
         class.meta = mSys.FindClass(Name:hash(), 0)
      else
         if (glFeedback == 'verbose') then
            print('Module ' .. glModule.name .. ' not compiled, class documentation will not be produced.')
         end
      end
   else
      class.meta = mSys.FindClass(Name:hash(), 0)
   end

   -- Process methods and fields defined in the source code (if available)

   local cdef = processClassFields(class, Spec)

   if nz(Options.references) then
      for _, v in pairs(Options.references) do
         if nz(glCustomTypes[v]) then
            cdef = cdef .. outputLookup(class.name .. v, glCustomTypes[v].list)
            glCustomTypes[v].restrict = nil
         elseif nz(glStructures[v]) then
            class.references['STRUCT:' .. v] = true
            -- A manual reference to a structure will forcibly turn off any restriction
            glStructures[v].restrict = nil
         else
            print('Reference to lookup ' .. v .. ' not found.')
         end
      end
   end

   class.actions = { }
   if (class.src != nil) then
      -- Process -METHOD- and -FIELD- definitions

      local path
      for _, path in pairs(class.src) do
         if (glFeedback == 'verbose') then
            print()
            print('Class file: ' .. glFDLFolder .. path)
         end

         local content = file.readAll(glFDLFolder .. path)
         content = content:gsub('\r\n', '\n')

         -- Look for C/C++ action declarations, in the format: ERR CLASS_Action(...).  This will create a series
         -- of dummy action entries that can be overwritten with -ACTION- sections.

         local patterns = {
            'ERR%s-' .. Name:upper() .. '_(%a-)%(obj.-%)',
            'ERR%s-' .. Name:upper() .. '_(%a-)%(ext.-%)'
         }
         for _, pattern in pairs(patterns) do
            for actionName in string.gmatch(content, pattern) do
               if (glActions[actionName] != nil) then
                  if (glFeedback == 'verbose') then print('Discovered action ' .. actionName) end
                  class.actions[actionName] = { name=actionName }
               else
                  if (glFeedback == 'verbose') then print('Ignoring declaration of ' .. actionName) end
               end
            end
         end

         -- Extract possible content from within comments so that we don't get interference from the code while parsing.

         local extracted_content = nz(string.match(content, '^/%*+(.-)%*+/'),'') -- The first line might start with a comment.
         for extract in string.gmatch(content, '[^/]/%*+(.-)%*+/') do
            extracted_content = extracted_content .. '\n' .. extract
         end

         -- Parse each line individually

         local currentEntry = nil
         local processing = nil
         for line in string.gmatch(extracted_content, '(.-\n)') do
            if nz(line) then
               line = nz(line:match('^(.*%S)'),'')
               if (line == '-CLASS-') or (line == '-METHOD-') or (line == '-ACTION-') or (line == '-FIELD-') then
                  if (currentEntry != nil) then processClassEntry(class, processing, currentEntry) end
                  currentEntry = ''
                  processing = line
               elseif (line == '-END-') then
                  if (currentEntry != nil) then processClassEntry(class, processing, currentEntry) end
                  currentEntry = nil
                  processing = nil
               elseif (line == '-INTERNAL-') then
                  currentEntry = nil
                  processing = nil
               elseif (currentEntry != nil) then
                  currentEntry = currentEntry .. line .. '\n'
               end
            elseif (currentEntry != nil) then
               currentEntry = currentEntry .. '\n'
            end
         end

         if (currentEntry != nil) then processClassEntry(class, processing, currentEntry) end
      end
   end

   -- Export method definitions for a class

   if (class.methods != nil) then
      local pfx  = class.methodPrefix
      local lpfx = pfx:lower()

      if (glFeedback == 'verbose') then
         print('Generating ' .. #class.methods .. ' methods.')
      end

      for k, method in ipairs(class.methods) do
         if nz(method.input) then
            local t = { }
            local i = 1
            for str in string.gmatch(method.input, '([^;]+)') do
               t[i] = str:trim()
               i = i + 1
            end

            method.params = { }
            for _, v in ipairs(t) do
               local param = { }
               param.type, param.name = v:match('^(.+)%s([^%s]+)$')
               cType(param, 'Method ' .. method.name)
               table.insert(method.params, param)
            end
         end

         -- Generate a modified C method name for the function declaration if the method shares a name with an existing
         -- action.  E.g. 'XML_Sort' will become 'XML_SortXML'

         method.funcName = method.name
         if (glActions[method.funcName] != nil) then
            method.funcName = method.funcName .. Name
         end

         local function pName(Param)
            local name = Param.name
            if (Param.type == 'OBJECTID') or (Param.type == 'MEMORYID') then
               if (name:sub(-2) != 'ID') then
                  name = name .. 'ID'
               end
            end
            return name
         end

         local struct_params = '' -- struct parameter types & names
         local values = '' -- Parameter values
         local results = false
         local params = ''
         for _, param in ipairs(method.params) do
            struct_params = struct_params .. param.basicType .. ' ' .. pName(param) .. '; '

            if nz(params) then params = params .. ', ' end

            if (param.type == 'FUNCTION *') then
               params = params .. 'FUNCTION ' .. pName(param)
               if nz(values) then values = values .. ', ' end
               values = values .. '&' .. pName(param)
            else
               params = params .. param.type .. ' ' .. pName(param)
               if nz(values) then values = values .. ', ' end

               if (param.resultValue) then
                  values  = values .. '(' .. param.basicType .. ')0'
                  results = true
               else
                  values = values .. pName(param)
               end
            end
         end

         local action_support = 'static const AC id = AC(-' .. method.id .. '); ERR call(OBJECTPTR Object) { return Action(id, Object, this); }'
         if (method.params != nil) and (#method.params > 0) then
            class.methods[k].struct = 'struct ' .. method.name .. ' { ' .. struct_params .. action_support .. ' };'
         else
            class.methods[k].struct = 'struct ' .. method.name .. ' { ' .. action_support .. ' };'
         end

         local name = method.name:decap()
         if name == 'delete' then name = 'del' end -- C++ keyword check

         local inline = '   inline ERR ' .. name .. '(' .. params .. ') noexcept {\n'
         local args = 'NULL'

         if (method.params != nil) and (#method.params > 0) then
            inline = inline .. '      struct ' .. lpfx .. '::' .. method.name .. ' args = { ' .. values .. ' };\n'
            args = '&args'
         end

         if (results) then
            inline = inline .. '      ERR error = Action(AC(-' .. method.id .. '), this, ' .. args .. ');\n'
            for _, p in pairs(method.params) do
               if (p.resultValue) then
                  inline = inline .. '      if (' .. p.name .. ') *' .. p.name .. ' = args.' .. p.name .. ';\n'
               end
            end
            inline = inline .. '      return(error);\n'
         else
            inline = inline .. '      return(Action(AC(-' .. method.id .. '), this, ' .. args .. '));\n'
         end

         inline = inline .. '   }'
         class.methods[k].nestedInline = inline
      end

      output('// ' .. Name:cap() .. ' methods')
      output()

      if nz(lpfx) then
         output('namespace ' .. lpfx .. ' {')
      end

      for _, method in ipairs(class.methods) do
         if nz(method.struct) then
            output(method.struct)
         end
      end
      output()

      if nz(lpfx) then
         output('} // namespace')
      end

      output()
   end

   class.sortedActions = { }
   for _, a in pairs(class.actions) do
      table.insert(class.sortedActions, a)
   end

   if nz(class.sortedActions) then
      table.sort(class.sortedActions, function(a,b) return a.name < b.name end)
   end

   outputClassHeader(class, Private, Custom)

   -- Output internal C definitions for class methods & actions, if an output file has been specified.

   if nz(Options.output) then
      local mdef = ''
      if (class.methods != nil) then
         for k, m in ipairs(class.methods) do
            if nz(m.params) then
               mdef = mdef .. 'FDEF ma' .. m.name .. '[] = { ' .. buildInputParameters(m.params) .. ' };\n'
            end
         end
         mdef = mdef .. '\n'

         mdef = mdef .. 'static const struct MethodEntry cl' .. Name .. 'Methods[] = {\n'
         for k, m in ipairs(class.methods) do
            local structSize
            if not nz(m.params) then
               mdef = mdef .. '   { AC(-' .. m.id .. '), (APTR)' .. Name:upper() .. '_' .. m.funcName .. ', "' .. m.name .. '", 0, 0 },\n'
            else
               structSize = 'sizeof(struct ' .. class.methodPrefix:lower() .. '::' .. m.name .. ')'
               mdef = mdef .. '   { AC(-' .. m.id .. '), (APTR)' .. Name:upper() .. '_' .. m.funcName .. ', "' .. m.name .. '", ma' .. m.name .. ', ' .. structSize .. ' },\n'
            end
         end
         mdef = mdef .. '   { AC::NIL, 0, 0, 0, 0 }\n};\n\n'
      end

      if nz(class.sortedActions) then
         mdef = mdef .. "static const struct ActionArray cl" .. Name .. "Actions[] = {\n"
         for _, action in ipairs(class.sortedActions) do
            mdef = mdef .. "   { AC::" .. action.name .. ", " .. Name:upper() .. "_" .. action.name .. " },\n"
         end
         mdef = mdef .. "   { AC::NIL, NULL }\n};\n\n"
      end

      local file = obj.new("file", { flags="WRITE|NEW", location=glFDLFolder .. Options.output } )
      file.acWrite("// Auto-generated by idl-c.fluid\n\n")
      if nz(cdef) then file.acWrite(cdef) end
      if nz(mdef) then file.acWrite(mdef) end
   end
end

----------------------------------------------------------------------------------------------------------------------

function processClassEntry(Class, Type, Extract)
   if (Type == '-CLASS-') then
      processClassHeader(Class, Extract)
   elseif (Type == '-METHOD-') then
      processMethod(Class, Extract)
   elseif (Type == '-ACTION-') then
      processAction(Class, Extract)
   elseif (Type == '-FIELD-') then
      processField(Class, Extract)
   end
end

function processClassHeader(Class, Extract)
   Extract = '-CLASS-\n' .. Extract:trim() .. '\n-END-\n'
   local name
   name, Class.comment = Extract:match('\n(%w+):%s+(.-)\n')
   Class.status = Extract:match('\n[Ss]tatus:%s+(.-)\n')

   if (name:lower() != Class.name:lower()) then
      error("The name specified in the -CLASS- header '" .. name .. "' does not match the name specified in the class() call '" .. Class.name .. "'")
   end

   Class.description = Extract:match("\n\n(.-)\n%-[A-Z]+%-\n")
end

function processAction(class, extract)
   extract = '-ACTION-\n' .. extract:trim() .. '\n-END-\n'

   local name    = extract:match('\n[Nn]ame:%s+(.-)\n')
   local comment = extract:match('\n[Cc]omment:%s+(.-)\n')
   if (name == nil) then
      name, comment = extract:match('\n(%w+):%s+(.-)\n')
   end

   local action = class.actions[name]
   if (action == nil) then action = { } end
   action.name = name
   action.comment = comment
   action.description = extract:match('\n\n(.-)\n%-[A-Z]+%-\n')

   local errors = extract:match('\n%-ERRORS%-\n(.-)%-END%-')
   if nz(errors) then
      action.results = { }

      for line in string.gmatch(errors, '(.-)\n') do
         if not nz(line) then break end -- A double line-break forces a premature end to error processing.

         local ecode, comment = line:match('(%a-):%s+(.+)')
         if (ecode != nil) then
            table.insert(action.results, { code = _G['ERR_' .. ecode], codeName = ecode, msg = comment })
         else
            ecode = line:match('(%a+):?')
            if nz(ecode) then
               table.insert(action.results, { code = _G['ERR_' .. ecode], codeName = ecode, msg = mSys.GetErrorMsg(_G['ERR_' .. ecode]) })
            end
        end
      end

      table.sort(action.results, function(a,b) return a.code < b.code end)
   end
end

----------------------------------------------------------------------------------------------------------------------

function processField(class, extract)
   extract = '-FIELD-\n' .. extract:trim() .. '\n-END-\n'
   local lookup  = extract:match('\n[Ll]ookup:%s+(.-)\n')
   local status  = extract:match('\n[Ss]tatus:%s+(.-)\n')
   local name, comment = extract:match('\n(%w+):%s+(.-)\n')

   local description = extract:match('\n\n(.-)\n%-[A-Z]+%-\n')

   if not name then
      print('Name not defined for -FIELD- definition.')
      return
   end

   local f = findClassField(class, name)
   if (f != nil) then
      if nz(comment) then f.comment = comment end
      if nz(lookup) then
         if (glCustomTypes[lookup]) then
            f.lookup = lookup
            class.references['TYPE:' .. lookup] = 1
         else
            print('Requested lookup "' .. lookup .. '" is not known.')
         end
      end
      if string.match(nz(status,''), '^[Pp]rivate') or string.match(nz(comment,''), '^[Pp]rivate') then
         f.private = true
         f.access = 'Private'
      end
      f.description = description
   elseif (class.meta != nil) then
      print("Field '" .. class.name .. "." .. nz(name,'NIL') .. "' is not defined in the FDL or compiled class spec.")
   end
end

----------------------------------------------------------------------------------------------------------------------

function processMethod(class, extract)
   extract = '-METHOD-\n' .. extract:trim() .. '\n-END-\n'

   local name    = extract:match('\n[Nn]ame:%s+(.-)\n')
   local comment = extract:match('\n[Cc]omment:%s+(.-)\n')
   if (name == nil) then
      name, comment = extract:match('\n(%w+):%s+(.-)\n')
   end

   local status      = extract:match('\n[Ss]tatus:%s+(.-)\n')
   local description = extract:match('\n\n(.-)\n%-[A-Z]+%-\n')

   if (name:find('%(%)') != nil) then
      name = name:match('(%a+)()')
   end

   if not nz(name) then error('Failed to extract a name tag from -METHOD- definition.') end
   if not nz(comment) then error("Failed to extract a comment tag from -METHOD- definition of '" .. name .. "'")  end
   if not nz(description) then error("Failed to extract a description from -METHOD- definition of '" .. name .. "'") end

   if (glFeedback == 'verbose') then print('Processing method ' .. name) end

   local method -- Retrieve the definition for this method
   if (class.methods != nil) then
      method = class.lookupMethods[name]
      if (method == nil) then error("Method '" .. name .. "' is not registered in the FDL.") end
   else
      error("Methods need to be pre-defined for class '" .. nz(class.name,"NIL") .. "'")
   end

   method.params = { }
   method.description = description
   method.comment = comment
   method.status = status

   local input = extract:match('\n%-INPUT%-\n(.-)\n\n%-[A-Z]+%-\n')

   local errors = extract:match('\n%-ERRORS%-\n(.-)%-END%-')
   if nz(errors) then
      method.results = { }

      for line in string.gmatch(errors, '(.-)\n') do
         if not nz(line) then break end -- A double line-break forces a premature end to error processing.

         local ecode, comment = line:match('(%a-):%s+(.+)')
         if (ecode != nil) then
            table.insert(method.results, { code = _G['ERR_' .. ecode], codeName = ecode, msg = comment })
         else
            ecode = line:match('(%a+):?')
            if nz(ecode) then
               table.insert(method.results, { code = _G['ERR_' .. ecode], codeName = ecode, msg = mSys.GetErrorMsg(_G['ERR_' .. ecode]) })
            end
         end
      end

      table.sort(method.results, function(a,b) return nz(a.code,-1) < nz(b.code,-1) end)
   end

   if nz(input) then
      for line, content in ipairs(input:split('\n')) do
         local param = { }
         param.comment = content:match('^.+:%s-(.+)$')
         if nz(param.comment) then content = content:match('^(.+):%s-.+$') end
         param.type, param.name = content:match('^%s*(.+)%s+([^%s]+)%s-$')
         if (param.type != nil) then
            param.type = param.type:trim()
            param.name = param.name:trim()
            param.comment = param.comment:trim()
            cType(param, name)
            table.insert(method.params, param)
         elseif nz(content:trim()) then
            error("Unable to process line '" .. nz(content,"NULL") .. "' for method '" .. name .. "'")
         end
      end
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Scan class.fields for a specific field name.

function findClassField(class, fieldName)
   if (class.fields != nil) then
      for _, f in ipairs(class.fields) do
         if (f.name == fieldName) then
            return f
         end
      end
   end
end

----------------------------------------------------------------------------------------------------------------------

function outputLookup(Name, List)
    local sorted = { }
    for _, v in pairs(List) do
        table.insert(sorted, v)
    end

    table.sort(sorted, function(a,b)
        if (a.value == b.value) then
            return a.name < b.name
        else
            return a.value < b.value
        end
    end)

    local list = ''
    for _, v in ipairs(sorted) do
        if (v.name:upper() != 'PRIVATE') and (v.name:upper() != 'END') then
            -- Note: This unusual formatting solution helps to resolve output problems on 64-bit Linux
            local hash_id = '0x' .. string.format('%08x', v.value):sub(-8)
            if hash_id:match('^0x[8f][%dabcdef]+') != nil then hash_id = '(LONG)' .. hash_id end
            list = list .. string.format("   { \"%s\", %s },\n", shortName(v.name), hash_id)
        end
    end

    return 'static const struct FieldDef cl' .. Name .. '[] = {\n' .. list .. '   { NULL, 0 }\n};\n\n'
end

----------------------------------------------------------------------------------------------------------------------
-- Process the formal field definitions in a class spec.

function processClassFields(class, ClientSpec)
   local cdef = ''

   -- Process fields defined in the FDL

   class.fields = extractFields(ClientSpec, class.name)

   -- Add compiled fields into the field definitions.  NB: Technically this relies on a circular reference, so such
   -- information can only be taken advantage of for phase 2 processing (class documentation).

   if (class.meta != nil) then
      local newFields = {}

      -- NB: Some classes don't output any fields (which is permissable)

      local metaFields = class.meta.subFields
      if (not metaFields) and (class.meta.classID == class.meta.baseClassID) then
         metaFields = class.meta.fields
      end

      for k, f in ipairs(nz(metaFields, { })) do
         local def = getMetaFieldDefinition(f)
         if (def != nil) and (def.synonym != true) then
            local f = findClassField(class, def.name)
            if (f != nil) then
               f.write  = def.write
               f.read   = def.read
               f.flags  = def.flags
               f.access = nz(def.access, def.access)
               f.private = nz(f.private, def.private)
               if (f.type == nil) then f.type = nz(def.type,'NIL') end
            else
               def.virtual = true
               def.fullType = glTypes.void -- Dummy
               table.insert(newFields, def)
            end
         end
      end

      for _, f in ipairs(newFields) do
         table.insert(class.fields, f)
      end
   end

   class.lookupFields = { }
   if (class.fields != nil) then
      for _, f in ipairs(class.fields) do
         class.lookupFields[f.name] = f
      end
   end

   -- NB: FieldArray is not output because as yet fields (including virtual fields) cannot be accurately
   -- described without the developer writing a custom field configuration in C.

   local fdef = 'static const struct FieldArray cl' .. class.name .. 'Fields[] = {\n'
   class.longestType = 0
   local name_len = 0
   class.longestFieldType = 0  -- Holds the longest field + type string
   for _, f in ipairs(class.fields) do
      if not f.virtual then
         local field_name = cName(f)

         if (field_name:len() > name_len) then name_len = field_name:len() end

         if (f.type:len() > class.longestType) then
            if (f.type:len() < 10) then
               class.longestType = f.type:len()
            end
         end

         if (f.type:len() + field_name:len() > class.longestFieldType) then
            class.longestFieldType = f.type:len() + 2 + field_name:len()
         end

         if (f.ref != nil) then
            cdef = cdef .. outputLookup(class.name .. f.name, f.ref.list)
         end

         if not nz(f.fullType) then error('The fullType is not defined for field ' .. nz(f.name,'NIL')) end

         fdef = fdef .. "   { \"" .. f.name .. "\", " .. f.fullType.fd .. ", 0, NULL, NULL },\n"
      end
   end
   fdef = fdef .. '};\n\n'

   return cdef
end

----------------------------------------------------------------------------------------------------------------------
-- Output the CPP compatible class definition

function outputClassHeader(class, Private, Custom)
   local physicalFields = false
   for _, f in ipairs(class.fields) do
      if not f.virtual then physicalFields = true end
   end

   priority('class obj' .. class.name .. ';') -- Forward declaration
   output('class obj' .. class.name ..  ' : public ' .. nz(class.base, 'Object') .. ' {')
   output('   public:')
   output('   static constexpr CLASSID CLASS_ID = CLASSID::' .. class.name:upper() .. ';')
   output("   static constexpr CSTRING CLASS_NAME = \"" .. class.name .. "\";")
   output('')
   output('   using create = pf::Create<obj' .. class.name .. '>;')

   if physicalFields then
      output('')

      local max_len = 3 + class.longestFieldType + 1 + 2

      for _, f in ipairs(class.fields) do
         if not f.virtual then
            local left
            local field_name = cName(f, true)
            if nz(field_name) then
               left = string.format('   %-' .. class.longestType .. 's %s;', f.type, field_name)
            else
               left = string.format('   %-' .. class.longestType .. 's;', f.type)
            end

            if nz(f.comment) then
               local clean_comment = f.comment:gsub('[`!@#]', '')
               output(string.format('%-' .. max_len .. 's // %s', left, clean_comment))
            else
               output(left)
            end
         end
      end

      if (Private != nil) then
         output()
         output('#ifdef PRV_' .. class.name:upper())
         output(Private)
         output('#endif')
      end

      if (Custom != nil) then
         output('   public:')
         output(Custom)
      end
   end

   -- Insert registered actions

   if nz(class.sortedActions) then
      output('')
      output('   // Action stubs\n')
      for _, action in ipairs(class.sortedActions) do
         if glActionStubs[action.name] then
            if (glActionStubs[action.name]:len() != 0) then
               local stub = glActionStubs[action.name]
               stub = string.match(stub,'^()\n*$') and '' or string.match(stub,'^\n*(.*%S)')
               output(stub)
            end
         else
            output('   // ' .. action.name .. '\n')
         end
      end

      if not class.actions['Init'] then
         output(glActionStubs['Init'])
      end
   end

   -- Insert registered methods

   if nz(class.methods) then
      for _, m in ipairs(class.methods) do
         if m.nestedInline then output(m.nestedInline) end
      end
   end

   -- Insert customised set-field functions.  These are intended to be as fast as possible, so
   -- features such as error logging and parameter checking are not included.

   output('')
   output('   // Customised field setting\n')
   local indent = '      '

   for _, f in ipairs(class.fields) do
      local field_name = cName(f, true)
      if nz(field_name) and (f.write != nil) then
         local fid_name = field_name
         local id = fid_name:sub(-3)
         if id:find('^%lID$') then
            fid_name = fid_name:sub(1, -3)
         end

         local field_type = f.type

         if field_type:find('^STRUCT *') then -- Unnamed structs must be converted to PTR
            field_type = 'APTR'
         end

         if not field_type:find('^const ') then
            if (bit.band(f.flags, FD_STRING) != 0) and (bit.band(f.flags, FD_ARRAY) == 0) then
               if field_type:find('^STRING') or field_type:find('^CSTRING') then
                  field_type = 'T &&'
               else
                  field_type = 'const ' .. field_type
               end
            elseif bit.band(f.flags, bit.bor(FD_POINTER, FD_OBJECT)) != 0 then
               -- Applying const to pointers can cause type conversion issues.
            else
               field_type = 'const ' .. field_type
            end
         end

         if (f.write == 'Set') or nz(f.setField) or f.virtual then
            if f.struct then
               if field_type:sub(-1) != '*' then
                  field_type = field_type .. ' *'
               end
            end

            if (field_type:sub(-2) == '[]') then
               field_type = field_type:sub(1,-3) .. '*'
               output(string.format('   inline ERR set%s(%s Value, LONG Elements) noexcept {', fid_name, field_type))
            elseif (bit.band(f.flags, FD_ARRAY) != 0) then
               if bit.band(f.flags, FD_CPP) != 0 then
                  output(string.format('   inline ERR set%s(%s *Value) noexcept {', fid_name, field_type))
               else
                  output(string.format('   inline ERR set%s(%s Value, LONG Elements) noexcept {', fid_name, field_type))
               end
            elseif (field_type == 'T &&') then
               output(string.format('   template <class T> inline ERR set%s(%s Value) noexcept {', fid_name, field_type))
            else
               output(string.format('   inline ERR set%s(%s Value) noexcept {', fid_name, field_type))
            end

            if (f.write == 'Init') then
               output(indent .. 'if (this->initialised()) return ERR::NoFieldAccess;')
            end

            local err, fl, target = class.meta.mtFindField(f.name:hash())

            if (err != ERR_Okay) then
               print('Failed to field ' .. f.name .. ' in class ' .. class.name)
            end

            if (err == ERR_Okay) and (target.id == class.meta.id) then
               output(indent .. 'auto target = this;')
               output(indent .. string.format('auto field = &this->Class->Dictionary[%d];', fl.index))
            else
               output(indent .. 'OBJECTPTR target;')
               output(indent .. string.format('auto field = FindField(this, FID_%s, &target);', fid_name))
            end

            if bit.band(f.flags, FD_UNIT) != 0 then
               if bit.band(f.flags, bit.bor(FD_LONG,FD_LARGE,FD_DOUBLE,FD_FLOAT)) != 0 then
                  output(indent .. 'Unit var(Value);')
                  output(indent .. 'return field->WriteValue(target, field, FD_UNIT, &var, 1);')
               else
                  -- Pass through as pointer; requires further analysis to determine viability
                  output(indent .. 'return field->WriteValue(target, field, FD_POINTER, Value, 1);')
               end
            elseif bit.band(f.flags, FD_ARRAY) != 0 then
               if bit.band(f.flags, FD_CPP) != 0 then
                  local flags = string.format('%08x', f.flags):sub(-8)
                  output(indent .. 'return field->WriteValue(target, field, 0x' .. flags .. ', Value, LONG(Value->size()));')
               else
                  local flags = string.format('%08x', f.flags):sub(-8)
                  output(indent .. 'return field->WriteValue(target, field, 0x' .. flags .. ', Value, Elements);')
               end
            elseif bit.band(f.flags, FD_FUNCTION) != 0 then
               output(indent .. 'return field->WriteValue(target, field, FD_FUNCTION, &Value, 1);')
            elseif bit.band(f.flags, bit.bor(FD_STRING)) != 0 then
               local flags = string.format('%08x', f.flags):sub(-8)
               output(indent .. 'return field->WriteValue(target, field, 0x' .. flags .. ', to_cstring(Value), 1);')
            elseif bit.band(f.flags, bit.bor(FD_POINTER)) != 0 then
               local flags = string.format('%08x', f.flags):sub(-8)
               output(indent .. 'return field->WriteValue(target, field, 0x' .. flags .. ', Value, 1);')
            elseif bit.band(f.flags, bit.bor(FD_DOUBLE,FD_FLOAT)) != 0 then
               output(indent .. 'return field->WriteValue(target, field, FD_DOUBLE, &Value, 1);')
            elseif bit.band(f.flags, FD_LARGE) != 0 then
               output(indent .. 'return field->WriteValue(target, field, FD_LARGE, &Value, 1);')
            else
               output(indent .. 'return field->WriteValue(target, field, FD_LONG, &Value, 1);')
            end
         else
            if (field_type == 'T &&') then
               output(string.format('   template <class T> inline ERR set%s(%s Value) noexcept {', fid_name, field_type))
            else
               output(string.format('   inline ERR set%s(%s Value) noexcept {', fid_name, field_type))
            end
            if (f.write == 'Init') then
               output(indent .. 'if (this->initialised()) return ERR::NoFieldAccess;')
            end
            output(indent .. string.format('this->%s = Value;', field_name))
            output(indent .. 'return ERR::Okay;')
         end

         output('   }\n')
      end
   end
   output('};')
   output()
end

----------------------------------------------------------------------------------------------------------------------
-- Useful for ensuring strict XML compliance, like
--
-- From: <something>content</>
-- To:   <something>content</something>

function cleanXMLString(str, caller)
   if nz(str) then
      if (str:find('[<>]')) then
         str = '<ROOT>' .. str .. '</ROOT>'

         if cleanXMLString_xml == nil then
            cleanXMLString_xml, err = obj.new('xml', { statement=str, flags=XMF_INCLUDE_WHITESPACE })
         end

         if (cleanXMLString_xml != nil) then
            cleanXMLString_xml.statement = str
            local err, clean_str = cleanXMLString_xml.mtSerialise(0, XMF_INCLUDE_SIBLINGS)
            if (clean_str) then str = clean_str:match('<ROOT>(.-)</ROOT>'):trim() end
         else
            error('Failed to parse XML for ' .. nz(caller, 'undefined') .. '.')
         end
      end
   else
      str = ''
   end
   return str
end

----------------------------------------------------------------------------------------------------------------------
-- Extract information from a compiled class' field definition.

function getMetaFieldDefinition(Field)
   local fl = {
      name  = Field.name,
      type  = getFieldType(Field.flags, Field.name, Field.arg),
      flags = Field.flags
   }

   if (bit.band(Field.flags, FD_SYNONYM) != 0) then
      fl.synonym = true
   end

   if nz(Field.getField) then
      fl.read = 'Get'
      fl.get = Field.getField
   elseif bit.band(Field.flags, FD_READ) != 0 then
      fl.read = 'Read'
   end

   if nz(Field.setField) then
      fl.write = 'Set'
      fl.set = Field.setField
   elseif bit.band(Field.flags, FD_WRITE) != 0 then
      fl.write = 'Write'
   elseif bit.band(Field.flags, FD_INIT) != 0 then
      fl.write = 'Init'
   end

   if (nz(fl.read) and nz(fl.write)) then
      fl.access = fl.read .. '/' .. fl.write
   elseif nz(fl.read) then
      fl.access = fl.read
   elseif nz(fl.write) then
      fl.access = fl.write
   else
      fl.access = 'Private'
   end

   if (bit.band(Field.flags, FD_SYSTEM) != 0) then
      fl.access = 'Private'
      fl.private = true
   end

   return fl
end

----------------------------------------------------------------------------------------------------------------------
-- FDL Function
-- This is a shortened version of functions(), where only the names of the functions need to be specified as a list.
-- Further elaboration on the functions is normally done by embedding -FUNCTION- sections in the module code.

function functionNames(Prefix, ...)
   glFunctionPrefix = nz(Prefix,'')
   for _, fname in ipairs({...}) do
      if (fname:find('[^%w]')) then
         error('Invalid function name "' .. fname .. '"')
      end

      local func = {
         name  = fname,
         def   = '   void (*_' .. fname .. ')(void);',
         macro = function() -- Default macro, to be overridden by documented function
            return 'template <typename... Args> inline ERR ' .. glFunctionPrefix:lower() .. fname ..
               '(Args... pArgs) noexcept { return ' .. glModule.name .. 'Base->_' .. fname .. '(pArgs...); }'
         end,
         staticMacro = function()
            return 'template <typename... Args> ERR ' .. glFunctionPrefix:lower() .. fname .. '(Args... pArgs);'
         end
      }

      table.insert(glFunctions, func)
      glFunctionLookup[fname] = func
   end

   output('__FUNCTION_TABLE__')
end

----------------------------------------------------------------------------------------------------------------------
-- FDL Function
-- Register methods for a class.  This must be declared prior to the corresponding class() function call.

function methods(ClassName, Prefix, Methods)
   if (glFeedback == 'verbose') then print('Processing methods for class ' .. nz(ClassName,'NIL')) end

   local class = registerClass(ClassName)
   class.methodPrefix = Prefix
   class.methods = Methods

   -- Generate a lookup table by method name
   class.lookupMethods = { }
   for _, m in ipairs(class.methods) do
      class.lookupMethods[m.name] = m
   end
end

----------------------------------------------------------------------------------------------------------------------
-- FDL Function

function c_insert(Raw)
   output(Raw)
end

----------------------------------------------------------------------------------------------------------------------

   loadFile(glPath .. 'idl-types.fluid')

----------------------------------------------------------------------------------------------------------------------
-- Returns fields as a list returned by cType, featuring { type, name, comment }

function extractFields(Def, Origin)
   local fields = { }

   if not Def then return fields end

   for line, content in ipairs(Def:split("\n")) do
      -- Extract comment, if specified
      local comment = content:match("^.+#%s-(.+)$")
      if nz(comment) then
         content = content:match("^(.+)#%s-.+$")
      else
         -- Support for alternative comment format where the colon is used.
         comment = content:match("^.+:%s-(.+)$")
         if nz(comment) then
            content = content:match("^(.+):%s-.+$")
         end
      end

      local type, name = content:match("^%s*(.+)%s+([^%s]+)%s-$")
      if (type != nil) then
         local field = cType({ type=type:trim(), name=name:trim(), comment=string.trim(comment) }, Origin)
         table.insert(fields, field)
      elseif not nz(content:trim()) then
         -- Ignore empty line
      else
         error("Unable to process line '" .. nz(content,"NULL") .. "' for '" .. nz(Origin,'NIL') .. "'")
      end
   end

   return fields
end

----------------------------------------------------------------------------------------------------------------------
-- Convert a string such as 'SHOW_IMAGES' to 'ShowImages'

function shortName(Name)
   local result = ""
   for _, n in ipairs(Name:split("_")) do
      if (n=="XY") or (n=="SSL") or (n=="HTML") or (n=="CDATA") or (n=="2D") or (n =="3D") or (n=="DGA") or
         (n=="DPMS") or (n=="GTF") or (n=="SRGB") or (n=="RGB") or (n=="HSV") or (n=="CX") or (n=="CY") or
         (n=="FX") or (n=="FY") then
         result = result .. n
      else
         local cap, word = n:match("^(.)(.+)$")
         if (cap == nil) or (word == nil) then
            result = result .. n:upper()
         else
            result = result .. cap:upper() .. word:lower()
         end
      end
   end
   return result
end

----------------------------------------------------------------------------------------------------------------------

function registerClass(Name)
   if not nz(Name) then error('No Name provided to registerClass()') end
   if (glClasses == nil) then glClasses = { } end
   if (glClasses[Name:lower()] == nil) then
      glClasses[Name:lower()] = { name=Name:cap() }
   end
   return glClasses[Name:lower()]
end

----------------------------------------------------------------------------------------------------------------------

function processFDLFile(Source)
   local err, full_path = mSys.ResolvePath(Source)

   glFDLFolder = file.splitPath(full_path)

   if (err == ERR_Okay) then
      if (glFeedback == "verbose") then print("Process FDL file " .. full_path) end
      loadFile(full_path)
      return ERR_Okay
   else
      error("The specified source '" .. Source .. "' could not be located.")
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Load and process an FDL file source, then process raw source files containing -FUNCTION- definitions.

function processSourceFiles()
   if (glFeedback == 'verbose') then print('Processing source files...') end

   local srcFiles = { }

   for i=1,nz(arg('files:size'), 0) do
      table.insert(srcFiles, arg('files(' .. (i-1) .. ')'))
   end

   if (#srcFiles < 1) then
      if (glFeedback == 'verbose') then print('No source files were detected.') end
      return
   end

   local path
   for _, path in pairs(srcFiles) do
      -- Process --IDL_BEGIN/END-- sections, which allow the developer to embed FDL functions in the source code.

      local idlExtract, extract
      local content = file.readAll(path)
      content = '\n' .. content:gsub('\r\n', '\n')
      for extract in string.gmatch(content, '%-%-IDL_BEGIN%-%-(.-)%-%-IDL_END%-%-') do
         idlExtract = nz(idlExtract,'') .. extract
      end

      if (idlExtract != nil) then
         exec(idlExtract)
      end

      // Process -FUNCTION- definitions

      if (glFeedback == 'verbose') then
         print()
         print('File: ' .. path)
      end

      // Extract possible content from within comments so that we don't get interference from the code while parsing.

      local extracted_content = ''
      for extract in string.gmatch(content, '[^/]/%*+(.-)%*+/') do
         extracted_content = extracted_content .. '\n' .. extract
      end
      content = extracted_content

      // Parse each line individually

      local currentExtract = nil
      local processing = nil
      for line in string.gmatch(content, '(.-\n)') do
         if nz(line) then
            line = nz(line:match('^(.*%S)'),'')
            if (line == '-CATEGORY-') or (line == '-FUNCTION-') then
               if (processing == '-CATEGORY-') then processCategory(currentExtract) end
               if (processing == '-FUNCTION-') then processFunction(currentExtract) end
               currentExtract = ''
               processing = line
            elseif (line == '-END-') or (line == '-INTERNAL-') then
               if (processing == '-CATEGORY-') then processCategory(currentExtract) end
               if (processing == '-FUNCTION-') then processFunction(currentExtract) end
               currentExtract = nil
               processing = nil
            elseif (processing != nil) then
               currentExtract = currentExtract .. line .. '\n'
            end
         elseif (processing != nil) then
            currentExtract = currentExtract .. '\n'
         end
      end

      if (processing == '-CATEGORY-') then processCategory(currentExtract) end
      if (processing == '-FUNCTION-') then processFunction(currentExtract) end
   end
end

----------------------------------------------------------------------------------------------------------------------

function processCategory(extract)
   extract = '-CATEGORY-\n' .. extract:trim() .. '\n-END-\n'
   glCategory = extract:match('\n[Nn]ame:%s+(.-)\n')
   glCategories[glCategory] = { name=glCategory }
end

----------------------------------------------------------------------------------------------------------------------
-- Used by processSourceFiles() to process -FUNCTION- descriptions in self-documenting source code.

function processFunction(extract)
   if not nz(extract) then return end

   extract = '-FUNCTION-\n' .. extract:trim() .. '\n-END-\n'

   local name, comment = extract:match('\n(%w+):%s+(.-)\n')
   local status      = extract:match('\n[Ss]tatus:%s+(.-)\n')
   local category    = extract:match('\n[Cc]ategory:%s+(.-)\n')
   local ext_proto   = extract:match('\n[Ee]xtPrototype:%s+(.-)\n')
   local attrib      = extract:match('\n[Aa]ttribute:%s+(.-)\n') -- This value is appended to the jump table name
   local description = extract:match('\n\n(.-)\n%-[A-Z]+%-\n')

   if (name:find('%(%)') != nil) then
      name = name:match('(%a+)()')
   end

   if not nz(name) then
      error('Failed to extract a name tag from -FUNCTION- definition.')
   end

   if not nz(comment) then
      error("Failed to extract a comment tag from -FUNCTION- definition of '" .. name .. "'")
   end

   if not nz(description) then
      error("Failed to extract a description from -FUNCTION- definition of '" .. name .. "'")
   end

   if (glFeedback == "verbose") then
      print("Processing function " .. name .. "()")
   end

   local def = {
      input     = extract:match("\n%-INPUT%-\n(.-)\n%-[A-Z]+%-\n"),
      ext_proto = ext_proto,
      attrib    = attrib
   }

   local errors = extract:match("\n%-ERRORS%-\n(.-)%-END%-")
   if nz(errors) then
      def.result = cType({ type="error", values={ }, isFunction=true }, "Function " .. name)

      for line in string.gmatch(errors, "(.-)\n") do
         if not nz(line) then break end // A double line-break forces a premature end to error processing.

         local ecode, comment = line:match("(%a-):%s+(.+)")
         if nz(ecode) and nz(comment) then
            local codeValue = _G['ERR_' .. ecode]
            if not codeValue then
               print('Error code "' .. ecode .. '" referenced in function ' .. name .. '() is invalid.')
            else
               table.insert(def.result.values, { code = codeValue, codeName = ecode, msg = comment })
            end
         else
            ecode = line:match("(%a+):?")
            if nz(ecode) then
               codeValue = _G['ERR_' .. ecode]
               if not codeValue then
                  print('Error code "' .. ecode .. '" referenced in function ' .. name .. '() is invalid.')
               else
                  table.insert(def.result.values, { code = codeValue, codeName = ecode, msg = mSys.GetErrorMsg(codeValue) })
               end
            end
         end
      end

      table.sort(def.result.values, function(a,b) return a.code < b.code end)
   else
      local result = extract:match("\n%-RESULT%-\n(.-)\n%-END%-")
      if nz(result) then
         local ext_type, comment = result:match("(.-):%s-(.+)$")
         if (ext_type == nil) then error("Incorrectly defined result section in function '" .. name .. "'") end
         def.result = cType({ type=ext_type, comment=comment:trim(), isFunction=true, isResponse=true }, "Function " .. name)
      end
   end

   idlFunction(name, nz(category, glCategory), comment, status, description, def)
end

----------------------------------------------------------------------------------------------------------------------
-- Function definitions can be embedded into source code with the idlFunction() routine.

function idlFunction(Name, Category, Comment, Status, Description, Def)
   // Find the registered function definition that must have been pre-declared in the FDL.

   local func
   for k, f in ipairs(glFunctions) do
      if (f.name == Name) then
         func = f
         break
      end
   end

   if (func == nil) then
      local list = ''
      for k, f in ipairs(glFunctions) do
         list = list .. f.name .. '\n'
      end
      error("Function '" .. Name .. "' is not declared in the FDL.  Known functions are:\n" .. list)
   end

   if (Status) then func.status = Status:lower() end
   func.comment     = Comment
   func.description = Description
   func.category    = Category

   if (Def == nil) then Def = { } end

   if nz(Def.result) then
      func.result = Def.result
   elseif nz(Def.errors) then
      func.result = cType({ type="error", values=Def.errors, isFunction=true }, "Function " .. Name)
   end

   local outValues  = ""
   local argSeq     = ""
   local jumpArgs
   local proto      = ""
   local doc_proto  = ""
   local variadic   = false
   local last_param = nil

   if nz(Def.input) then
      func.input = { }
      for line, content in ipairs(Def.input:split("\n")) do
         local comment = content:match("^.-:%s-(.+)$")
         if nz(comment) then content = content:match("^(.-):%s-.+$") end
         local type, name = content:match("^%s*(.+)%s+([^%s]+)%s-$")
         if (type != nil) then
            local param = cType({
               type=type:trim(), name=name:trim(), comment=comment:trim(), isFunction=true
            }, "Function " .. Name)
            table.insert(func.input, param)

            if nz(argSeq) then
               argSeq = argSeq .. ", "
               proto = proto .. ", "
               doc_proto = doc_proto .. ", "
               outValues = outValues .. ","
            end

            if (param.type == '...') then
               jumpArgs = argSeq .. "..."
               argSeq = argSeq .. "Args... Tags"
            else
               if param.type:find('*$') then
                  argSeq = argSeq .. param.type .. cName(param)
               else
                  argSeq = argSeq .. param.type .. " " .. cName(param)
               end
            end

            if (param.type == "...") then
               proto = proto .. "..."
               doc_proto = doc_proto .. "..."
               if not nz(outValues) then
                  // This special case is required when '...' is the first parameter.
                  if (param.fullType.fd == "FD_VARTAGS") then
                     proto = "LARGE," .. proto
                  else
                     proto = "LONG," .. proto
                  end
               end
               outValues = outValues .. "Tags..."
               variadic = true
            else
               proto = proto .. nz(param.extType, param.type) .. " " .. cName(param)
               doc_proto = doc_proto .. param.type .. " " .. cName(param)
               outValues = outValues .. param.name
            end

            last_param = param
         elseif nz(content:trim()) then
            error("Unable to process line '" .. nz(content,"NULL") .. "' for function '" .. Name .. "'")
         end
      end
   end

   local response = func.result
   if (func.result == nil) then
      response = { type="void" }
   end

   if Def.ext_proto then
      jumpArgs = Def.ext_proto
      argSeq   = Def.ext_proto
      if (string.sub(argSeq, -3) == '...') then
         argSeq = string.sub(argSeq, 1, -4) .. "Args... Tags"
      end
   elseif not jumpArgs then
      jumpArgs = argSeq
   end

   -- The func.def is used for building the jump table
   func.def = "   " .. nz(response.type,"NIL")
   if Def.attrib then func.def = func.def .. " " .. Def.attrib end
   func.def = func.def  .. " (*_" .. func.name .. ")(" .. nz(jumpArgs,"void") .. ");"

   func.c_proto = proto
   func.doc_proto = doc_proto
   func.c_response = response.type

   if (variadic) then
      func.macro = function()
         return "template<class... Args> " .. nz(response.type,"NIL") .. " " .. func.name ..
            "(" .. nz(argSeq,"void") .. ")" ..
            " { return " .. glModule.name .. "Base->_" .. func.name .. "(" .. nz(outValues,"") .. "); }"
      end

      func.staticMacro = function()
         if nz(glFunctionPrefix) then
            return 'extern ' .. nz(response.type,'NIL') .. ' ' .. func.name .. '(' .. nz(jumpArgs,'void') .. ');'
         else
            return 'extern "C" ' .. nz(response.type,'NIL') .. ' ' .. func.name .. '(' .. nz(jumpArgs,'void') .. ');'
         end
      end
   else
      func.macro = function()
         return 'inline ' .. nz(response.type,'NIL') .. ' ' .. func.name .. '(' .. nz(argSeq,'void') .. ')' ..
            ' { return ' .. glModule.name .. 'Base->_' .. func.name .. '(' .. nz(outValues,'') .. '); }'
      end

      func.staticMacro = function()
         if nz(glFunctionPrefix) then
            return 'extern ' .. nz(response.type,'NIL') .. ' ' .. func.name .. '(' .. nz(jumpArgs,'void') .. ');'
         else
            return 'extern "C" ' .. nz(response.type,'NIL') .. ' ' .. func.name .. '(' .. nz(jumpArgs,'void') .. ');'
         end
      end
   end
end

----------------------------------------------------------------------------------------------------------------------

function saveOutput()
   if (#glOutput < 1) and (#glConstants < 1) then
      print("No output was generated for the destination file.")
      return
   end

   local tempPath = "temp:" .. nz(glModule.name,"idl-c"):lower() .. ".h"
   local outPath = glOutputPath
   if (outPath == nil) then
      if nz(glModule.name) then
         outPath = "sdk:include/parasol/modules/" .. glModule.name:lower() .. ".h"
      else
         error("No output path specified in command-line.")
      end
   end

   if (glFeedback == "verbose") then print("Saving C header to \"" .. outPath .. "\"") end

   do
      local file = obj.new("file", { flags="WRITE|NEW", location=tempPath } )

      priority() -- Blank line at the end

      local blank = 0
      for a=1, #glHeader do
         local str = glHeader[a] .. "\n"
         if (str == "\n") then
            blank = blank + 1
         else
            blank = 0
         end

         if (blank < 2) then file.acWrite(str, str:len()) end
      end

      for a=1, #glConstants do
         local str = glConstants[a] .. "\n"
         if (str == "\n") then
            blank = blank + 1
         else
            blank = 0
         end

         if (blank < 2) then file.acWrite(str, str:len()) end
      end

      for a=1, #glOutput do
         if (glOutput[a] == "__FUNCTION_TABLE__") then
            local out = ''
            out = out .. "#ifdef PARASOL_STATIC\n"
            out = out .. "#define JUMPTABLE_" .. glModule.name:upper() .. " static struct " .. glModule.name .. "Base *" .. glModule.name .. "Base;\n"
            out = out .. "#else\n"
            out = out .. "#define JUMPTABLE_" .. glModule.name:upper() .. " struct " .. glModule.name .. "Base *" .. glModule.name .. "Base;\n"
            out = out .. "#endif\n\n"

            out = out .. "struct " .. glModule.name .. "Base {\n"
            out = out .. "#ifndef PARASOL_STATIC\n"
            for k, func in ipairs(glFunctions) do
               if nz(func.def) then
                  out = out .. func.def .. "\n"
               end
            end
            out = out .. "#endif // PARASOL_STATIC\n"
            out = out .. "};\n\n"
            out = out .. "#ifndef PRV_" .. glModule.name:upper() .. "_MODULE\n"

            out = out .. "#ifndef PARASOL_STATIC\n"
            out = out .. "extern struct " .. glModule.name .. "Base *" .. glModule.name .. "Base;\n"
            if nz(glFunctionPrefix) then
               out = out .. "namespace " .. glFunctionPrefix:lower() .. " {\n"
            end
            for k, func in ipairs(glFunctions) do
               if nz(func.macro) then
                  out = out .. func.macro() .. "\n"
               end
            end
            if nz(glFunctionPrefix) then
               out = out .. "} // namespace\n"
            end
            out = out .. "#else\n"
            if nz(glFunctionPrefix) then
               out = out .. "namespace " .. glFunctionPrefix:lower() .. " {\n"
            end
            for k, func in ipairs(glFunctions) do
               if nz(func.staticMacro) and (func.status != 'private') then
                  out = out .. func.staticMacro() .. "\n"
               end
            end
            if nz(glFunctionPrefix) then
               out = out .. "} // namespace\n"
            end
            out = out .. "#endif // PARASOL_STATIC\n"
            out = out .. "#endif\n\n"
            file.acWrite(out, out:len())
         else
            local str = glOutput[a] .. "\n"
            if (str == "\n") then
               blank = blank + 1
            else
               blank = 0
            end

            if (blank < 2) then file.acWrite(str, str:len()) end
         end
      end
   end

   collectgarbage()

   mSys.MoveFile(tempPath, outPath)
end

----------------------------------------------------------------------------------------------------------------------
-- Generate private C function prototypes for the module.

function buildPrototypes()
   if (glClasses != nil) then
      for className, cl in pairs(glClasses) do
         if nz(cl.methods) then
            for _, method in ipairs(cl.methods) do
               local proto = "OBJECTPTR Object"
               if nz(method.params) then
                  for _, param in ipairs(method.params) do
                     proto = proto .. ", " .. nz(param.extType, param.type) .. " " .. param.name
                  end
               end
               method.prototype = "ERR " .. cl.methodPrefix:lower() .. '::' .. method.name .. "(" .. proto .. ")"
            end
         end
      end
   end

   if nz(glFunctions) then
      local proto = ''
      local prefix = ''
      if nz(glFunctionPrefix) then
         proto = 'namespace ' .. glFunctionPrefix .. ' {\n'
         prefix = glFunctionPrefix .. '::'
      end

      for k, func in ipairs(glFunctions) do
         local response
         if (func.result != nil) and (func.result.type != nil) then
            response = func.result.fullType.c_type
         else
            response = "void"
         end

         func.prototype = nz(func.c_response,"void") .. " " .. func.name .. "(" .. nz(func.c_proto,"") .. ")"
         func.docPrototype = nz(func.c_response,"void") .. " " .. prefix .. func.name .. "(" .. nz(func.doc_proto,"") .. ")"

         if nz(glFunctionPrefix) then
            proto = proto .. 'extern ' .. func.prototype .. ";\n"
         else
            proto = proto .. 'extern "C" ' .. func.prototype .. ";\n"
         end
      end

      if nz(glFunctionPrefix) then
         proto = proto .. '\n} // namespace\n'
      end

      return proto
   else
      return ""
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Generate private C definitions that describe the public functions of a module.

function buildDefs()
   if not nz(glFunctions) then return "" end

   local prefix = ''
   if nz(glFunctionPrefix) then prefix = glFunctionPrefix .. '::' end

   local flist = "\nconst struct Function glFunctions[] = {\n"
   for _, func in ipairs(glFunctions) do
      flist = flist .. "   { (APTR)" .. prefix .. func.name .. ", \"" .. func.name .. "\", args" .. func.name .. " },\n"
   end
   flist = flist .. "   { NULL, NULL, NULL }\n"
   flist = flist .. "};\n\n"

   table.sort(glFunctions, function(a,b) return a.name < b.name end)

   local plist = ""
   for _, func in ipairs(glFunctions) do
      plist = plist .."FDEF args" .. func.name .. "[] = {"

      // Process the result type first

      if (func.result != nil) and (func.result.type != nil) then
         local type = func.result.fullType

         if (type != nil) then
            local fd = type.fd
            local result_name = "Result"
            if (fd == "FD_LONG|FD_ERROR") then
               result_name = "Error"
            elseif (fd == "FD_OBJECTPTR") then
               result_name = "Object"
            elseif func.result.struct != nil then
               result_name = func.result.struct
            end
            if (func.result.allocated) then fd = fd .. "|FD_ALLOC" end
            plist = plist .. " { \"" .. result_name .. "\", " .. fd .. " }, "
         else
            plist = plist .. " { \"" .. func.result.type .. "\", FD_VOID }, "
         end
      else
         plist = plist .. " { \"Void\", FD_VOID }, "
      end

      plist = plist .. buildInputParameters(func.input) .. " };\n"
   end

   return "#ifndef FDEF\n#define FDEF static const struct FunctionField\n#endif\n\n" .. plist .. flist
end

----------------------------------------------------------------------------------------------------------------------
-- Build C parameter definitions for a function or method

function buildInputParameters(List)
   local plist = ""
   if (List != nil) then
      for _, param in ipairs(List) do
         local fd = param.fullType.fd
         if (param.allocated) then fd = fd .. "|FD_ALLOC" end
         if (param.resultValue) then fd = fd .. "|FD_RESULT" end
         if (param.struct != nil) then
            plist = plist .. "{ \"" .. param.struct .. ":" .. param.name .. "\", " .. fd .. " }, "
         else
            plist = plist .. "{ \"" .. param.name .. "\", " .. fd .. " }, "
         end
      end
   end
   return plist .. "{ 0, 0 }"
end

----------------------------------------------------------------------------------------------------------------------
-- Build a list of all available action names and their parameters.

function loadActions()
   if (glFeedback == "verbose") then print("Loading core actions...") end
   glActions = { }
   for id, actions in ipairs(mSys.ActionList()) do
      if nz(actions) and nz(actions.name) then
         glActions[actions.name] = { name=actions.name, input=actions.args, hash=actions.hash, id=id-1 }
      end
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Resolve the location of the Parasol SDK and create an 'sdk:' volume.

function resolveSDKPath(Path)
   local sdk_path
   local err = ERR_Failed
   local search_list = { }
   if not Path then
      local search_path = 'CMakeLists.txt'
      local limit = 5
      while (err != ERR_Okay) and (limit > 0) do
         table.insert(search_list, search_path)
         err, sdk_path = mSys.ResolvePath(search_path)
         search_path = '../' .. search_path
         limit = limit - 1
      end
   else
      table.insert(search_list, Path .. '/CMakeLists.txt')
      err, sdk_path = mSys.ResolvePath(Path .. '/CMakeLists.txt')
   end

   if (err == ERR_Okay) then
      sdk_path = sdk_path:match("(.+)CMakeLists%.txt")
   else
      local msg = ''
      for _, path in ipairs(search_list) do
         msg = msg .. path .. '\n'
      end
      print('Unable to find CMakeLists.txt after searching the following paths:\n' .. msg)
      error('A path to the Parasol SDK could not be determined.')
   end

   mSys.SetVolume('sdk', sdk_path)
end

----------------------------------------------------------------------------------------------------------------------

   glProgram     = 'idl-c' // FDL's can read this
   glSource      = arg('src')
   glOutputPath  = arg('output')
   glFeedback    = arg('feedback')
   glOutputDefs  = arg('output-defs')
   glOutputProto = arg('output-proto')
   glPrototypes  = arg('prototypes')

   if (glSource == nil) then
      print("This command is used to compile self-documenting source files.  Provide a reference to a")
      print("source '.fdl' file in the src parameter.  The resulting data will be saved to the file")
      print("referenced in the output parameter.")
      print("")
      print("  src          Source FDL file.")
      print("  output       Target file for generated C++ headers.")
      print("  feedback     Set to 'verbose' to print debug messages.")
      print("  output-defs  Target file for generated C++ value definitions.")
      print("  output-proto Target file for generated C++ function prototypes.")
      print("  prototypes   Set to 'static' to output static prototype functions.")
      return
   end

   mSys = mod.load('core')

   glFunctions      = { }
   glFunctionLookup = { }
   glMethods        = { }
   glFields         = { }
   glPaths          = { }
   glCustomTypes    = { }
   glStructures     = { }
   glDocuments      = { }
   glModule         = { }
   glTotalWarnings  = 0
   glCategory       = nil
   glCategories     = { }
   glPrivateNames   = { }

   resolveSDKPath(arg('sdk'))

   loadActions()

   loadFile(glPath .. 'idl-doc.fluid')

   if (processFDLFile(glSource) == ERR_Okay) then
      if glAbort then
         print('FDL processing cancelled, reason: ' .. glAbort)
         return
      end

      processSourceFiles()
      saveOutput()

      local protoDef = buildPrototypes()

      if nz(glOutputDefs) then
         catch(function()
            local file = obj.new('file', { flags='WRITE|NEW', location=glOutputDefs } )
            file.acWrite('// Auto-generated by idl-c.fluid\n\n')
            if (glOutputProto == glOutputDefs) and nz(protoDef) then
               glOutputProto = nil
               file.acWrite(protoDef)
            end
            local defs = buildDefs()
            if nz(defs) then file.acWrite(defs) end
         end,
         function(Exception)
            error('Failed to open or write file "' .. glOutputDefs .. '" ' .. Exception.message)
         end)
      end

      if nz(glOutputProto) then
         catch(function()
            local file = obj.new('file', { flags='WRITE|NEW', location=glOutputProto } )
            file.acWrite('// Auto-generated by idl-c.fluid\n\n')
            if nz(protoDef) then file.acWrite(protoDef) end
         end,
         function(Exception)
            error('Failed to open or write file "' .. glOutputProto .. '" ' .. Exception.message)
         end)
      end

      saveDocuments()
   end
