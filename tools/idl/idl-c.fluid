-- This program produces C++ headers, auto-generated values and documentation from Parasol FDL files.
--
-- Usage: parasol sdk:tools/idl/idl-c.fluid src=source.fdl
-- Example: parasol sdk:tools/idl/idl-c.fluid src=sdk:core/modules/core/core.fdl

   include 'core'
   include 'xml'

   require 'common'

   iStruct = struct -- Save the struct interface because struct() is going to overwrite it.

   glSelf = obj.find('self')
   glPath = glSelf.workingPath
   glIDLTimestamp = 20241015

----------------------------------------------------------------------------------------------------------------------

glActionStubs = {
   -- Hidden actions
   Free          = "",
   FreeWarning   = "",
   NewChild      = "",
   NewObject     = "",
   NewOwner      = "",
   NewPlacement  = "",

   -- Actions without parameters
   Activate     = "   inline ERR activate() noexcept { return Action(AC::Activate, this, nullptr); }",
   Clear        = "   inline ERR clear() noexcept { return Action(AC::Clear, this, nullptr); }",
   Deactivate   = "   inline ERR deactivate() noexcept { return Action(AC::Deactivate, this, nullptr); }",
   Disable      = "   inline ERR disable() noexcept { return Action(AC::Disable, this, nullptr); }",
   Enable       = "   inline ERR enable() noexcept { return Action(AC::Enable, this, nullptr); }",
   Flush        = "   inline ERR flush() noexcept { return Action(AC::Flush, this, nullptr); }",
   Focus        = "   inline ERR focus() noexcept { return Action(AC::Focus, this, nullptr); }",
   Hide         = "   inline ERR hide() noexcept { return Action(AC::Hide, this, nullptr); }",
   Init         = "   inline ERR init() noexcept { return InitObject(this); }",
   Lock         = "   inline ERR lock() noexcept { return Action(AC::Lock, this, nullptr); }",
   LostFocus    = "   inline ERR lostFocus() noexcept { return Action(AC::LostFocus, this, nullptr); }",
   MoveToBack   = "   inline ERR moveToBack() noexcept { return Action(AC::MoveToBack, this, nullptr); }",
   MoveToFront  = "   inline ERR moveToFront() noexcept { return Action(AC::MoveToFront, this, nullptr); }",
   Next         = "   inline ERR next() noexcept { return Action(AC::Next, this, nullptr); }",
   Prev         = "   inline ERR prev() noexcept { return Action(AC::Prev, this, nullptr); }",
   Query        = "   inline ERR query() noexcept { return Action(AC::Query, this, nullptr); }",
   Refresh      = "   inline ERR refresh() noexcept { return Action(AC::Refresh, this, nullptr); }",
   Reset        = "   inline ERR reset() noexcept { return Action(AC::Reset, this, nullptr); }",
   SaveSettings = "   inline ERR saveSettings() noexcept { return Action(AC::SaveSettings, this, nullptr); }",
   Show         = "   inline ERR show() noexcept { return Action(AC::Show, this, nullptr); }",
   Unlock       = "   inline ERR unlock() noexcept { return Action(AC::Unlock, this, nullptr); }",

   CopyData = [[
   inline ERR copyData(OBJECTPTR Dest) noexcept {
      struct acCopyData args = { .Dest = Dest };
      return Action(AC::CopyData, this, &args);
   }]],
   DragDrop = [[
   inline ERR dragDrop(OBJECTPTR Source, int Item, CSTRING Datatype) noexcept {
      struct acDragDrop args = { .Source = Source, .Item = Item, .Datatype = Datatype };
      return Action(AC::DragDrop, this, &args);
   }]],
   Clipboard = [[
   inline ERR clipboard(CLIPMODE Mode) noexcept {
      struct acClipboard args = { Mode };
      return Action(AC::Clipboard, this, &args);
   }]],
   Draw = [[
   inline ERR draw() noexcept { return Action(AC::Draw, this, nullptr); }
   inline ERR drawArea(int X, int Y, int Width, int Height) noexcept {
      struct acDraw args = { X, Y, Width, Height };
      return Action(AC::Draw, this, &args);
   }]],
   DataFeed = [[
   inline ERR dataFeed(OBJECTPTR Object, DATA Datatype, const void *Buffer, int Size) noexcept {
      struct acDataFeed args = { Object, Datatype, Buffer, Size };
      return Action(AC::DataFeed, this, &args);
   }]],
   Move = [[
   inline ERR move(double X, double Y, double Z) noexcept {
      struct acMove args = { X, Y, Z };
      return Action(AC::Move, this, &args);
   }]],
   Read = [[
   template <class T, class U> ERR read(APTR Buffer, T Size, U *Result) noexcept {
      static_assert(std::is_integral<U>::value, "Result value must be an integer type");
      static_assert(std::is_integral<T>::value, "Size value must be an integer type");
      const int bytes = (Size > 0x7fffffff) ? 0x7fffffff : Size;
      struct acRead read = { (int8_t *)Buffer, bytes };
      if (auto error = Action(AC::Read, this, &read); error IS ERR::Okay) {
         *Result = static_cast<U>(read.Result);
         return ERR::Okay;
      }
      else { *Result = 0; return error; }
   }
   template <class T> ERR read(APTR Buffer, T Size) noexcept {
      static_assert(std::is_integral<T>::value, "Size value must be an integer type");
      const int bytes = (Size > 0x7fffffff) ? 0x7fffffff : Size;
      struct acRead read = { (int8_t *)Buffer, bytes };
      return Action(AC::Read, this, &read);
   }]],
   Redo = [[
   inline ERR redo(int Steps) noexcept {
      struct acRedo args = { Steps };
      return Action(AC::Redo, this, &args);
   }]],
   Redimension = [[
   inline ERR redimension(double X, double Y, double Z, double Width, double Height, double Depth) noexcept {
      struct acRedimension args = { X, Y, Z, Width, Height, Depth };
      return Action(AC::Redimension, this, &args);
   }
   inline ERR redimension(double X, double Y, double Width, double Height) noexcept {
      struct acRedimension args = { X, Y, 0, Width, Height, 0 };
      return Action(AC::Redimension, this, &args);
   }]],
   Rename = [[
   inline ERR rename(CSTRING Name) noexcept {
      struct acRename args = { Name };
      return Action(AC::Rename, this, &args);
   }]],
   Resize = [[
   inline ERR resize(double Width, double Height, double Depth = 0) noexcept {
      struct acResize args = { Width, Height, Depth };
      return Action(AC::Resize, this, &args);
   }]],
   Undo = [[
   inline ERR undo(int Steps) noexcept {
      struct acUndo args = { Steps };
      return Action(AC::Undo, this, &args);
   }]],
   GetKey = [[
   inline ERR getKey(CSTRING Key, STRING Value, int Size) noexcept {
      struct acGetKey args = { Key, Value, Size };
      auto error = Action(AC::GetKey, this, &args);
      if ((error != ERR::Okay) and (Value)) Value[0] = 0;
      return error;
   }]],
   MoveToPoint = [[
   inline ERR moveToPoint(double X, double Y, double Z, MTF Flags) noexcept {
      struct acMoveToPoint moveto = { X, Y, Z, Flags };
      return Action(AC::MoveToPoint, this, &moveto);
   }]],
   SaveImage = [[
   inline ERR saveImage(OBJECTPTR Dest, CLASSID ClassID = CLASSID::NIL) noexcept {
      struct acSaveImage args = { Dest, { ClassID } };
      return Action(AC::SaveImage, this, &args);
   }]],
   SaveToObject = [[
   inline ERR saveToObject(OBJECTPTR Dest, CLASSID ClassID = CLASSID::NIL) noexcept {
      struct acSaveToObject args = { Dest, { ClassID } };
      return Action(AC::SaveToObject, this, &args);
   }]],
   Seek = [[
   inline ERR seek(double Offset, SEEK Position = SEEK::CURRENT) noexcept {
      struct acSeek args = { Offset, Position };
      return Action(AC::Seek, this, &args);
   }
   inline ERR seekStart(double Offset) noexcept { return seek(Offset, SEEK::START); }
   inline ERR seekEnd(double Offset) noexcept { return seek(Offset, SEEK::END); }
   inline ERR seekCurrent(double Offset) noexcept { return seek(Offset, SEEK::CURRENT); }
   ]],
   SetKeys = [[
   inline ERR setKeys(CSTRING tags, ...) noexcept {
      struct acSetKey args;
      va_list list;
      va_start(list, tags);
      while ((args.Field = va_arg(list, STRING)) != TAGEND) {
         args.Value = va_arg(list, STRING);
         if (Action(AC::SetKey, this, &args) != ERR::Okay) {
            va_end(list);
            return ERR::Failed;
         }
      }
      va_end(list);
      return ERR::Okay;
   }]],
   Write = [[
   inline ERR write(CPTR Buffer, int Size, int *Result = nullptr) noexcept {
      struct acWrite write = { (int8_t *)Buffer, Size };
      if (auto error = Action(AC::Write, this, &write); error IS ERR::Okay) {
         if (Result) *Result = write.Result;
         return ERR::Okay;
      }
      else {
         if (Result) *Result = 0;
         return error;
      }
   }
   inline ERR write(std::string Buffer, int *Result = nullptr) noexcept {
      struct acWrite write = { (int8_t *)Buffer.c_str(), int(Buffer.size()) };
      if (auto error = Action(AC::Write, this, &write); error IS ERR::Okay) {
         if (Result) *Result = write.Result;
         return ERR::Okay;
      }
      else {
         if (Result) *Result = 0;
         return error;
      }
   }
   inline int writeResult(CPTR Buffer, int Size) noexcept {
      struct acWrite write = { (int8_t *)Buffer, Size };
      if (Action(AC::Write, this, &write) IS ERR::Okay) return write.Result;
      else return 0;
   }]],
   SelectArea = [[
   inline ERR acSelectArea(double X, double Y, double Width, double Height) noexcept {
      struct acSelectArea area = { X, Y, Width, Height };
      return Action(AC::SelectArea, this, &area);
   }]],
   SetKey = [[
   inline ERR acSetKey(CSTRING FieldName, CSTRING Value) noexcept {
      struct acSetKey args = { FieldName, Value };
      return Action(AC::SetKey, this, &args);
   }]],
}

----------------------------------------------------------------------------------------------------------------------

glHeader = { }
glOutput = { }
glConstants = { }
glConstantOptions = { }
glActiveRefs = { } -- For cType()

----------------------------------------------------------------------------------------------------------------------

require('./include/utils')
require('./include/parser')
require('./include/functions')

----------------------------------------------------------------------------------------------------------------------
-- Scan class.fields for a specific field name.

function findClassField(class, fieldName)
   if (class.fields != nil) then
      for _, f in ipairs(class.fields) do
         if (f.name == fieldName) then
            return f
         end
      end
   end
end

----------------------------------------------------------------------------------------------------------------------

function outputLookup(Name, List)
    local sorted = { }
    for _, v in pairs(List) do
        table.insert(sorted, v)
    end

    table.sort(sorted, function(a,b)
        if (a.value == b.value) then
            return a.name < b.name
        else
            return a.value < b.value
        end
    end)

    local list = ''
    for _, v in ipairs(sorted) do
        if (v.name:upper() != 'PRIVATE') and (v.name:upper() != 'END') then
            -- Note: This unusual formatting solution helps to resolve output problems on 64-bit Linux
            local hash_id = '0x' .. string.format('%08x', v.value):sub(-8)
            if hash_id:match('^0x[8f][%dabcdef]+') != nil then hash_id = '(int)' .. hash_id end
            list = list .. string.format("   { \"%s\", %s },\n", shortName(v.name), hash_id)
        end
    end

    return 'static const struct FieldDef cl' .. Name .. '[] = {\n' .. list .. '   { nullptr, 0 }\n};\n\n'
end

----------------------------------------------------------------------------------------------------------------------
-- Output the CPP compatible class definition

function outputClassHeader(class, Private, Custom)
   local physicalFields = false
   for _, f in ipairs(class.fields) do
      if not f.virtual then physicalFields = true end
   end

   priority('class obj' .. class.name .. ';') -- Forward declaration
   output('class obj' .. class.name ..  ' : public ' .. nz(class.base, 'Object') .. ' {')
   output('   public:')
   output('   static constexpr CLASSID CLASS_ID = CLASSID::' .. class.name:upper() .. ';')
   output("   static constexpr CSTRING CLASS_NAME = \"" .. class.name .. "\";")
   output('')
   output('   using create = pf::Create<obj' .. class.name .. '>;')

   if physicalFields then
      output('')

      local max_len = 3 + class.longestFieldType + 1 + 2

      for _, f in ipairs(class.fields) do
         if not f.virtual then
            local left
            local field_name = cName(f, true)
            if nz(field_name) then
               left = string.format('   %-' .. class.longestType .. 's %s;', f.type, field_name)
            else
               left = string.format('   %-' .. class.longestType .. 's;', f.type)
            end

            if nz(f.comment) then
               local clean_comment = f.comment:gsub('[`!@#]', '')
               output(string.format('%-' .. max_len .. 's // %s', left, clean_comment))
            else
               output(left)
            end
         end
      end

      if (Private != nil) then
         output()
         output('#ifdef PRV_' .. class.name:upper())
         output(Private)
         output('#endif')
      end

      if (Custom != nil) then
         output('   public:')
         output(Custom)
      end
   end

   -- Insert registered actions

   if nz(class.sortedActions) then
      output('')
      output('   // Action stubs\n')
      for _, action in ipairs(class.sortedActions) do
         if glActionStubs[action.name] then
            if (glActionStubs[action.name]:len() != 0) then
               local stub = glActionStubs[action.name]
               stub = string.match(stub,'^()\n*$') and '' or string.match(stub,'^\n*(.*%S)')
               output(stub)
            end
         else
            output('   // ' .. action.name .. '\n')
         end
      end

      if not class.actions['Init'] then
         output(glActionStubs['Init'])
      end
   end

   -- Insert registered methods

   if nz(class.methods) then
      for _, m in ipairs(class.methods) do
         if m.nestedInline then output(m.nestedInline) end
      end
   end

   -- Insert customised set-field functions.  These are intended to be as fast as possible, so
   -- features such as error logging and parameter checking are not included.

   output('')
   output('   // Customised field setting\n')
   local indent = '      '

   for _, f in ipairs(class.fields) do
      local field_name = cName(f, true)
      if nz(field_name) and (f.write != nil) then
         local fid_name = field_name
         local id = fid_name:sub(-3)
         if id:find('^%lID$') then
            fid_name = fid_name:sub(1, -3)
         end

         local field_type = f.type

         if field_type:find('^STRUCT *') then -- Unnamed structs must be converted to PTR
            field_type = 'APTR'
         end

         if not field_type:find('^const ') then
            if (bit.band(f.flags, FD_STRING) != 0) and (bit.band(f.flags, FD_ARRAY) == 0) then
               if field_type:find('^STRING') or field_type:find('^CSTRING') then
                  field_type = 'T &&'
               else
                  field_type = 'const ' .. field_type
               end
            elseif bit.band(f.flags, bit.bor(FD_POINTER, FD_OBJECT)) != 0 then
               -- Applying const to pointers can cause type conversion issues.
            else
               field_type = 'const ' .. field_type
            end
         end

         if (f.write == 'Set') or nz(f.setField) or f.virtual then
            if f.struct then
               if field_type:sub(-1) != '*' then
                  field_type = field_type .. ' *'
               end
            end

            if (field_type:sub(-2) == '[]') then
               field_type = field_type:sub(1,-3) .. '*'
               output(string.format('   inline ERR set%s(%s Value, int Elements) noexcept {', fid_name, field_type))
            elseif (bit.band(f.flags, FD_ARRAY) != 0) then
               if bit.band(f.flags, FD_CPP) != 0 then
                  output(string.format('   inline ERR set%s(%s *Value) noexcept {', fid_name, field_type))
               else
                  output(string.format('   inline ERR set%s(%s Value, int Elements) noexcept {', fid_name, field_type))
               end
            elseif (field_type == 'T &&') then
               output(string.format('   template <class T> inline ERR set%s(%s Value) noexcept {', fid_name, field_type))
            else
               output(string.format('   inline ERR set%s(%s Value) noexcept {', fid_name, field_type))
            end

            if (f.write == 'Init') then
               output(indent .. 'if (this->initialised()) return ERR::NoFieldAccess;')
            end

            local err, fl, target = class.meta.mtFindField(f.name:hash())

            if (err != ERR_Okay) then
               print('Failed to field ' .. f.name .. ' in class ' .. class.name)
            end

            if (err == ERR_Okay) and (target.id == class.meta.id) then
               output(indent .. 'auto target = this;')
               output(indent .. string.format('auto field = &this->Class->Dictionary[%d];', fl.index))
            else
               output(indent .. 'OBJECTPTR target;')
               output(indent .. string.format('auto field = FindField(this, FID_%s, &target);', fid_name))
            end

            if bit.band(f.flags, FD_UNIT) != 0 then
               if bit.band(f.flags, bit.bor(FD_INT,FD_INT64,FD_DOUBLE,FD_FLOAT)) != 0 then
                  output(indent .. 'Unit var(Value);')
                  output(indent .. 'return field->WriteValue(target, field, FD_UNIT, &var, 1);')
               else
                  -- Pass through as pointer; requires further analysis to determine viability
                  output(indent .. 'return field->WriteValue(target, field, FD_POINTER, Value, 1);')
               end
            elseif bit.band(f.flags, FD_ARRAY) != 0 then
               if bit.band(f.flags, FD_CPP) != 0 then
                  local flags = string.format('%08x', f.flags):sub(-8)
                  output(indent .. 'return field->WriteValue(target, field, 0x' .. flags .. ', Value, int(Value->size()));')
               else
                  local flags = string.format('%08x', f.flags):sub(-8)
                  output(indent .. 'return field->WriteValue(target, field, 0x' .. flags .. ', Value, Elements);')
               end
            elseif bit.band(f.flags, FD_FUNCTION) != 0 then
               output(indent .. 'return field->WriteValue(target, field, FD_FUNCTION, &Value, 1);')
            elseif bit.band(f.flags, bit.bor(FD_STRING)) != 0 then
               local flags = string.format('%08x', f.flags):sub(-8)
               output(indent .. 'return field->WriteValue(target, field, 0x' .. flags .. ', to_cstring(Value), 1);')
            elseif bit.band(f.flags, bit.bor(FD_POINTER)) != 0 then
               local flags = string.format('%08x', f.flags):sub(-8)
               output(indent .. 'return field->WriteValue(target, field, 0x' .. flags .. ', Value, 1);')
            elseif bit.band(f.flags, bit.bor(FD_DOUBLE,FD_FLOAT)) != 0 then
               output(indent .. 'return field->WriteValue(target, field, FD_DOUBLE, &Value, 1);')
            elseif bit.band(f.flags, FD_INT64) != 0 then
               output(indent .. 'return field->WriteValue(target, field, FD_INT64, &Value, 1);')
            else
               output(indent .. 'return field->WriteValue(target, field, FD_INT, &Value, 1);')
            end
         else
            if (field_type == 'T &&') then
               output(string.format('   template <class T> inline ERR set%s(%s Value) noexcept {', fid_name, field_type))
            else
               output(string.format('   inline ERR set%s(%s Value) noexcept {', fid_name, field_type))
            end
            if (f.write == 'Init') then
               output(indent .. 'if (this->initialised()) return ERR::NoFieldAccess;')
            end
            output(indent .. string.format('this->%s = Value;', field_name))
            output(indent .. 'return ERR::Okay;')
         end

         output('   }\n')
      end
   end
   output('};')
   output()
end

----------------------------------------------------------------------------------------------------------------------
-- Useful for ensuring strict XML compliance, like
--
-- From: <something>content</>
-- To:   <something>content</something>

function cleanXMLString(str, caller)
   if nz(str) then
      if (str:find('[<>]')) then
         str = '<ROOT>' .. str .. '</ROOT>'

         if cleanXMLString_xml == nil then
            cleanXMLString_xml, err = obj.new('xml', { statement=str, flags=XMF_INCLUDE_WHITESPACE })
         end

         if (cleanXMLString_xml != nil) then
            cleanXMLString_xml.statement = str
            local err, clean_str = cleanXMLString_xml.mtSerialise(0, XMF_INCLUDE_SIBLINGS)
            if (clean_str) then str = clean_str:match('<ROOT>(.-)</ROOT>'):trim() end
         else
            error('Failed to parse XML for ' .. nz(caller, 'undefined') .. '.')
         end
      end
   else
      str = ''
   end
   return str
end

----------------------------------------------------------------------------------------------------------------------
-- Extract information from a compiled class' field definition.

function getMetaFieldDefinition(Field)
   local fl = {
      name  = Field.name,
      flags = Field.flags
   }

   getFieldType(fl, Field.flags, Field.name, Field.arg)
   fl.docType = fl.doc_type

   if (bit.band(Field.flags, FD_SYNONYM) != 0) then
      fl.synonym = true
   end

   if nz(Field.getField) then
      fl.read = 'Get'
      fl.get = Field.getField
   elseif bit.band(Field.flags, FD_READ) != 0 then
      fl.read = 'Read'
   end

   if nz(Field.setField) then
      fl.write = 'Set'
      fl.set = Field.setField
   elseif bit.band(Field.flags, FD_WRITE) != 0 then
      fl.write = 'Write'
   elseif bit.band(Field.flags, FD_INIT) != 0 then
      fl.write = 'Init'
   end

   if (nz(fl.read) and nz(fl.write)) then
      fl.access = fl.read .. '/' .. fl.write
   elseif nz(fl.read) then
      fl.access = fl.read
   elseif nz(fl.write) then
      fl.access = fl.write
   else
      fl.access = 'Private'
   end

   if (bit.band(Field.flags, FD_SYSTEM) != 0) then
      fl.access = 'Private'
      fl.private = true
   end

   return fl
end

----------------------------------------------------------------------------------------------------------------------

require('./include/types')

----------------------------------------------------------------------------------------------------------------------
-- Returns fields as a list returned by cType, featuring { type, name, docType, fullType, comment }

function extractFields(Def, Origin)
   local fields = { }

   if not Def then return fields end

   for line, content in ipairs(Def:split("\n")) do
      -- Extract comment, if specified
      local comment = content:match("^.+#%s-(.+)$")
      if nz(comment) then
         content = content:match("^(.+)#%s-.+$")
      else
         -- Support for alternative comment format where the colon is used.
         comment = content:match("^.+:%s-(.+)$")
         if nz(comment) then
            content = content:match("^(.+):%s-.+$")
         end
      end

      local type, name = content:match("^%s*(.+)%s+([^%s]+)%s-$")
      if (type != nil) then
         local field = cType({ type=type:trim(), name=name:trim(), comment=string.trim(comment) }, Origin)
         table.insert(fields, field)
      elseif not nz(content:trim()) then
         -- Ignore empty line
      else
         error("Unable to process line '" .. nz(content,"NULL") .. "' for '" .. nz(Origin,'NIL') .. "'")
      end
   end

   return fields
end

----------------------------------------------------------------------------------------------------------------------
-- Convert a string such as 'SHOW_IMAGES' to 'ShowImages'

function shortName(Name)
   local result = ""
   for _, n in ipairs(Name:split("_")) do
      if (n=="XY") or (n=="SSL") or (n=="HTML") or (n=="CDATA") or (n=="2D") or (n =="3D") or (n=="DGA") or
         (n=="DPMS") or (n=="GTF") or (n=="SRGB") or (n=="RGB") or (n=="HSV") or (n=="CX") or (n=="CY") or
         (n=="FX") or (n=="FY") then
         result = result .. n
      else
         local cap, word = n:match("^(.)(.+)$")
         if (cap == nil) or (word == nil) then
            result = result .. n:upper()
         else
            result = result .. cap:upper() .. word:lower()
         end
      end
   end
   return result
end

----------------------------------------------------------------------------------------------------------------------

function registerClass(Name)
   if not nz(Name) then error('No Name provided to registerClass()') end
   if (glClasses == nil) then glClasses = { } end
   if (glClasses[Name:lower()] == nil) then
      glClasses[Name:lower()] = { name=Name:cap() }
   end
   return glClasses[Name:lower()]
end

----------------------------------------------------------------------------------------------------------------------

function parseFDLFile(Source)
   local err, full_path = mSys.ResolvePath(Source)

   glFDLFolder = file.splitPath(full_path)

   if (err == ERR_Okay) then
      verbose("Process FDL file " .. full_path)
      loadFile(full_path)
      return ERR_Okay
   else
      error("The specified source '" .. Source .. "' could not be located.")
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Function definitions can be embedded into source code with the idlFunction() routine.

function idlFunction(Name, Category, Comment, Status, Description, Def)
   -- Find the registered function definition that must have been pre-declared in the FDL.

   local func
   for k, f in ipairs(glFunctions) do
      if (f.name == Name) then
         func = f
         break
      end
   end

   if (func == nil) then
      local list = ''
      for k, f in ipairs(glFunctions) do
         list = list .. f.name .. '\n'
      end
      error("Function '" .. Name .. "' is not declared in the FDL.  Known functions are:\n" .. list)
   end

   if (Status) then func.status = Status:lower() end
   func.comment     = Comment
   func.description = Description
   func.category    = Category

   if (Def == nil) then Def = { } end

   if nz(Def.result) then
      func.result = Def.result
   elseif nz(Def.errors) then
      func.result = cType({ type="error", values=Def.errors, isFunction=true }, "Function " .. Name)
   end

   local outValues  = ""
   local argSeq     = ""
   local jumpArgs
   local proto      = ""
   local doc_proto  = ""
   local variadic   = false
   local last_param = nil

   if nz(Def.input) then
      func.input = { }
      for line, content in ipairs(Def.input:split("\n")) do
         local comment = content:match("^.-:%s-(.+)$")
         if nz(comment) then
            content = content:match("^(.-):%s-.+$")
         elseif nz(content) then
            error('No comment found for function parameter in ' .. Name .. '()')
         end
         local type, name = content:match("^%s*(.+)%s+([^%s]+)%s-$")
         if (type != nil) then
            local param = cType({
               type=type:trim(), name=name:trim(), comment=comment:trim(), isFunction=true
            }, "Function " .. Name)
            table.insert(func.input, param)

            if nz(argSeq) then
               argSeq = argSeq .. ", "
               proto = proto .. ", "
               doc_proto = doc_proto .. ", "
               outValues = outValues .. ","
            end

            if (param.type == '...') then
               jumpArgs = argSeq .. "..."
               argSeq = argSeq .. "Args... Tags"
            else
               if param.type:find('*$') then
                  argSeq = argSeq .. param.type .. cName(param)
               else
                  argSeq = argSeq .. param.type .. " " .. cName(param)
               end
            end

            if (param.type == "...") then
               proto = proto .. "..."
               doc_proto = doc_proto .. "..."
               if not nz(outValues) then
                  -- This special case is required when '...' is the first parameter.
                  if (param.fullType.fd == "FD_VARTAGS") then
                     proto = "int64_t," .. proto
                  else
                     proto = "int," .. proto
                  end
               end
               outValues = outValues .. "Tags..."
               variadic = true
            else
               proto = proto .. nz(param.extType, param.type) .. " " .. cName(param)
               doc_proto = doc_proto .. nz(param.docType, param.type) .. " " .. cName(param)
               outValues = outValues .. param.name
            end

            last_param = param
         elseif nz(content:trim()) then
            error("Unable to process line '" .. nz(content,"NULL") .. "' for function '" .. Name .. "'")
         end
      end
   end

   local response = func.result
   if (func.result == nil) then
      response = { type="void" }
   end

   if Def.ext_proto then
      jumpArgs = Def.ext_proto
      argSeq   = Def.ext_proto
      if (string.sub(argSeq, -3) == '...') then
         argSeq = string.sub(argSeq, 1, -4) .. "Args... Tags"
      end
   elseif not jumpArgs then
      jumpArgs = argSeq
   end

   -- The func.def is used for building the jump table
   func.def = "   " .. nz(response.type,"NIL")
   if Def.attrib then func.def = func.def .. " " .. Def.attrib end
   func.def = func.def  .. " (*_" .. func.name .. ")(" .. nz(jumpArgs,"void") .. ");"

   func.c_proto = proto
   func.doc_proto = doc_proto
   func.c_response = response.type
   func.doc_response = response.docType

   if (variadic) then
      func.macro = function()
         return "template<class... Args> " .. nz(response.type,"NIL") .. " " .. func.name ..
            "(" .. nz(argSeq,"void") .. ")" ..
            " { return " .. glModule.name .. "Base->_" .. func.name .. "(" .. nz(outValues,"") .. "); }"
      end

      func.staticMacro = function()
         if nz(glFunctionPrefix) then
            return 'extern ' .. nz(response.type,'NIL') .. ' ' .. func.name .. '(' .. nz(jumpArgs,'void') .. ');'
         else
            return 'extern "C" ' .. nz(response.type,'NIL') .. ' ' .. func.name .. '(' .. nz(jumpArgs,'void') .. ');'
         end
      end
   else
      func.macro = function()
         return 'inline ' .. nz(response.type,'NIL') .. ' ' .. func.name .. '(' .. nz(argSeq,'void') .. ')' ..
            ' { return ' .. glModule.name .. 'Base->_' .. func.name .. '(' .. nz(outValues,'') .. '); }'
      end

      func.staticMacro = function()
         if nz(glFunctionPrefix) then
            return 'extern ' .. nz(response.type,'NIL') .. ' ' .. func.name .. '(' .. nz(jumpArgs,'void') .. ');'
         else
            return 'extern "C" ' .. nz(response.type,'NIL') .. ' ' .. func.name .. '(' .. nz(jumpArgs,'void') .. ');'
         end
      end
   end
end

----------------------------------------------------------------------------------------------------------------------

function saveOutput()
   local tempPath = "temp:" .. nz(glModule.name,"idl-c-" .. math.random(1000000)):lower() .. ".h"
   local outPath = glOutputPath
   if (outPath == nil) then
      if nz(glModule.name) then
         outPath = "sdk:include/parasol/modules/" .. glModule.name:lower() .. ".h"
      else
         error("No output path specified in command-line.")
      end
   end

   verbose("Saving C header to \"" .. outPath .. "\"")

   do
      local file = obj.new("file", { flags="WRITE|NEW", location=tempPath } )

      priority() -- Blank line at the end

      local blank = 0
      for a=1, #glHeader do
         local str = glHeader[a] .. "\n"
         if (str == "\n") then
            blank = blank + 1
         else
            blank = 0
         end

         if (blank < 2) then file.acWrite(str, str:len()) end
      end

      for a=1, #glConstants do
         local str = glConstants[a] .. "\n"
         if (str == "\n") then
            blank = blank + 1
         else
            blank = 0
         end

         if (blank < 2) then file.acWrite(str, str:len()) end
      end

      for a=1, #glOutput do
         if (glOutput[a] == "__FUNCTION_TABLE__") then
            local out = ''
            out = out .. "#ifdef PARASOL_STATIC\n"
            out = out .. "#define JUMPTABLE_" .. glModule.name:upper() .. " [[maybe_unused]] static struct " .. glModule.name .. "Base *" .. glModule.name .. "Base = nullptr;\n"
            out = out .. "#else\n"
            out = out .. "#define JUMPTABLE_" .. glModule.name:upper() .. " struct " .. glModule.name .. "Base *" .. glModule.name .. "Base = nullptr;\n"
            out = out .. "#endif\n\n"

            out = out .. "struct " .. glModule.name .. "Base {\n"
            out = out .. "#ifndef PARASOL_STATIC\n"
            for k, func in ipairs(glFunctions) do
               if nz(func.def) then
                  out = out .. func.def .. "\n"
               end
            end
            out = out .. "#endif // PARASOL_STATIC\n"
            out = out .. "};\n\n"

            out = out .. "#if !defined(PARASOL_STATIC) and !defined(PRV_" .. glModule.name:upper() .. "_MODULE)\n"
            out = out .. "extern struct " .. glModule.name .. "Base *" .. glModule.name .. "Base;\n"
            if nz(glFunctionPrefix) then
               out = out .. "namespace " .. glFunctionPrefix:lower() .. " {\n"
            end
            for k, func in ipairs(glFunctions) do
               if nz(func.macro) then
                  out = out .. func.macro() .. "\n"
               end
            end
            if nz(glFunctionPrefix) then
               out = out .. "} // namespace\n"
            end
            out = out .. "#else\n"
            if nz(glFunctionPrefix) then
               out = out .. "namespace " .. glFunctionPrefix:lower() .. " {\n"
            end
            for k, func in ipairs(glFunctions) do
               if nz(func.staticMacro) and (func.status != 'private') then
                  out = out .. func.staticMacro() .. "\n"
               end
            end
            if nz(glFunctionPrefix) then
               out = out .. "} // namespace\n"
            end
            out = out .. "#endif // PARASOL_STATIC\n\n"
            file.acWrite(out, out:len())
         else
            local str = glOutput[a] .. "\n"
            if (str == "\n") then
               blank = blank + 1
            else
               blank = 0
            end

            if (blank < 2) then file.acWrite(str, str:len()) end
         end
      end
   end

   collectgarbage()

   mSys.MoveFile(tempPath, outPath)
end

----------------------------------------------------------------------------------------------------------------------
-- Generate private C function prototypes for the module.

function buildPrototypes()
   if (glClasses != nil) then
      for className, cl in pairs(glClasses) do
         if nz(cl.methods) then
            for _, method in ipairs(cl.methods) do
               local proto = "OBJECTPTR Object"
               if nz(method.params) then
                  for _, param in ipairs(method.params) do
                     proto = proto .. ", " .. nz(param.extType, param.docType) .. " " .. param.name
                  end
               end
               method.prototype = "ERR " .. cl.methodPrefix:lower() .. '::' .. method.name .. "(" .. proto .. ")"
            end
         end
      end
   end

   if nz(glFunctions) then
      local proto = ''
      local prefix = ''
      if nz(glFunctionPrefix) then
         proto = 'namespace ' .. glFunctionPrefix .. ' {\n'
         prefix = glFunctionPrefix .. '::'
      end

      for k, func in ipairs(glFunctions) do
         local response
         if (func.result != nil) and (func.result.type != nil) then
            response = func.result.fullType.c_type
         else
            response = "void"
         end

         func.prototype = nz(func.c_response,"void") .. " " .. func.name .. "(" .. nz(func.c_proto,"") .. ")"
         func.docPrototype = nz(func.doc_response,"void") .. " " .. prefix .. func.name .. "(" .. nz(func.doc_proto,"") .. ")"

         if nz(glFunctionPrefix) then
            proto = proto .. 'extern ' .. func.prototype .. ";\n"
         else
            proto = proto .. 'extern "C" ' .. func.prototype .. ";\n"
         end
      end

      if nz(glFunctionPrefix) then
         proto = proto .. '\n} // namespace\n'
      end

      return proto
   else
      return ""
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Generate private C definitions that describe the public functions of a module.

function buildDefs()
   if not nz(glFunctions) then return "" end

   local prefix = ''
   if nz(glFunctionPrefix) then prefix = glFunctionPrefix .. '::' end

   local flist = "\nconst struct Function glFunctions[] = {\n"
   for _, func in ipairs(glFunctions) do
      flist = flist .. "   { (APTR)" .. prefix .. func.name .. ", \"" .. func.name .. "\", args" .. func.name .. " },\n"
   end
   flist = flist .. "   { nullptr, nullptr, nullptr }\n"
   flist = flist .. "};\n\n"

   table.sort(glFunctions, function(a,b) return a.name < b.name end)

   local plist = ""
   for _, func in ipairs(glFunctions) do
      plist = plist .."FDEF args" .. func.name .. "[] = {"

      // Process the result type first

      if (func.result != nil) and (func.result.type != nil) then
         local type = func.result.fullType

         if (type != nil) then
            local fd = type.fd
            local result_name = "Result"
            if (fd == "FD_INT|FD_ERROR") then
               result_name = "Error"
            elseif (fd == "FD_OBJECTPTR") then
               result_name = "Object"
            elseif func.result.struct != nil then
               result_name = func.result.struct
            end
            if (func.result.allocated) then fd = fd .. "|FD_ALLOC" end
            plist = plist .. " { \"" .. result_name .. "\", " .. fd .. " }, "
         else
            plist = plist .. " { \"" .. func.result.type .. "\", FD_VOID }, "
         end
      else
         plist = plist .. " { \"Void\", FD_VOID }, "
      end

      plist = plist .. buildInputParameters(func.input) .. " };\n"
   end

   return "#ifndef FDEF\n#define FDEF static const struct FunctionField\n#endif\n\n" .. plist .. flist
end

----------------------------------------------------------------------------------------------------------------------
-- Build C parameter definitions for a function or method

function buildInputParameters(List)
   local plist = ""
   if (List != nil) then
      for _, param in ipairs(List) do
         local fd = param.fullType.fd
         if (param.allocated) then fd = fd .. "|FD_ALLOC" end
         if (param.resultValue) then fd = fd .. "|FD_RESULT" end
         if (param.struct != nil) then
            plist = plist .. "{ \"" .. param.struct .. ":" .. param.name .. "\", " .. fd .. " }, "
         else
            plist = plist .. "{ \"" .. param.name .. "\", " .. fd .. " }, "
         end
      end
   end
   return plist .. "{ 0, 0 }"
end

----------------------------------------------------------------------------------------------------------------------
-- Build a list of all available action names and their parameters.

function loadActions()
   verbose("Loading core actions...")
   glActions = { }
   for id, actions in ipairs(mSys.ActionList()) do
      if nz(actions) and nz(actions.name) then
         glActions[actions.name] = { name=actions.name, input=actions.args, hash=actions.hash, id=id-1 }
      end
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Resolve the location of the Parasol SDK and create an 'sdk:' volume.

function resolveSDKPath(Path)
   local sdk_path
   local err = ERR_Failed
   local search_list = { }
   if not Path then
      local search_path = 'CMakeLists.txt'
      local limit = 5
      while (err != ERR_Okay) and (limit > 0) do
         table.insert(search_list, search_path)
         err, sdk_path = mSys.ResolvePath(search_path)
         search_path = '../' .. search_path
         limit = limit - 1
      end
   else
      table.insert(search_list, Path .. '/CMakeLists.txt')
      err, sdk_path = mSys.ResolvePath(Path .. '/CMakeLists.txt')
   end

   if (err == ERR_Okay) then
      sdk_path = sdk_path:match("(.+)CMakeLists%.txt")
   else
      local msg = ''
      for _, path in ipairs(search_list) do
         msg = msg .. path .. '\n'
      end
      print('Unable to find CMakeLists.txt after searching the following paths:\n' .. msg)
      error('A path to the Parasol SDK could not be determined.')
   end

   mSys.SetVolume('sdk', sdk_path)
end

----------------------------------------------------------------------------------------------------------------------

   glProgram     = 'idl-c' -- FDL's can read this
   glSource      = arg('src')
   glOutputPath  = arg('output')
   glFeedback    = arg('feedback')
   glOutputDefs  = arg('output-defs')
   glOutputProto = arg('output-proto')
   glPrototypes  = arg('prototypes')

   if (glSource == nil) then
      print("This command is used to compile self-documenting source files.  Provide a reference to a")
      print("source '.fdl' file in the src parameter.  The resulting data will be saved to the file")
      print("referenced in the output parameter.")
      print("")
      print("  src          Source FDL file.")
      print("  output       Target file for generated C++ headers.")
      print("  feedback     Set to 'verbose' to print debug messages.")
      print("  output-defs  Target file for generated C++ value definitions.")
      print("  output-proto Target file for generated C++ function prototypes.")
      print("  prototypes   Set to 'static' to output static prototype functions.")
      return
   end

   mSys = mod.load('core')

   glFunctions      = { }
   glFunctionLookup = { }
   glMethods        = { }
   glFields         = { }
   glPaths          = { }
   glCustomTypes    = { }
   glStructures     = { }
   glDocuments      = { }
   glModule         = { }
   glTotalWarnings  = 0
   glCategory       = nil
   glCategories     = { }
   glPrivateNames   = { }

   resolveSDKPath(arg('sdk'))

   loadActions()

   require('./include/doc')

   if (parseFDLFile(glSource) == ERR_Okay) then
      if glAbort then
         print('FDL processing cancelled, reason: ' .. glAbort)
         return
      end

      parseSourceFiles()
      saveOutput()

      local protoDef = buildPrototypes()

      if nz(glOutputDefs) then
         catch(function()
            local file = obj.new('file', { flags='WRITE|NEW', location=glOutputDefs } )
            file.acWrite('// Auto-generated by idl-c.fluid\n\n')
            if (glOutputProto == glOutputDefs) and nz(protoDef) then
               glOutputProto = nil
               file.acWrite(protoDef)
            end
            local defs = buildDefs()
            if nz(defs) then file.acWrite(defs) end
         end,
         function(Exception)
            error('Failed to open or write file "' .. glOutputDefs .. '" ' .. Exception.message)
         end)
      end

      if nz(glOutputProto) then
         catch(function()
            local file = obj.new('file', { flags='WRITE|NEW', location=glOutputProto } )
            file.acWrite('// Auto-generated by idl-c.fluid\n\n')
            if nz(protoDef) then file.acWrite(protoDef) end
         end,
         function(Exception)
            error('Failed to open or write file "' .. glOutputProto .. '" ' .. Exception.message)
         end)
      end

      saveDocuments()
   end
