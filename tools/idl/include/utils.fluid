-- Universal utility functions

----------------------------------------------------------------------------------------------------------------------
-- Print a message to stdout if verbose mode is enabled

function verbose(String)
   if glFeedback is 'verbose' then
      print(String)
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Add a line to the output. If the string ends with a newline character, preserve it, otherwise trim trailing spaces.

function output(String)
   if String?? then
      if String:sub(-1) is '\n' then
         table.insert(glOutput, String)
      else
         table.insert(glOutput, String:rtrim())
      end
   else
      table.insert(glOutput,'')
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Verify that the Options parameter is a table or nil, otherwise throw an error.

function checkOptions(Options)
   if type(Options) != 'table' then
      if Options then
         error('Invalid option type "' .. type(Options) .. '", expected table.')
      else
         return { }
      end
   end
   return Options
end

----------------------------------------------------------------------------------------------------------------------
-- Add a line to the header with high priority. If Input is a function, execute it and add its output lines to the
-- header.

function priority(Input)
   if type(Input) is 'function' then
      local saveOutput = glOutput
      glOutput = { }
      Input()
      for k,v in ipairs(glOutput) do
         table.insert(glHeader, v)
      end
      glOutput = saveOutput
   elseif (type(Input) is 'string') and Input?? then
      table.insert(glHeader, Input:rtrim())
   else
      table.insert(glHeader,'')
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Convert a string such as 'SHOW_IMAGES' to 'ShowImages'

function shortName(Name)
   local result = ""
   for _, n in ipairs(Name:split("_")) do
      if (n is "XY") or (n is "SSL") or (n is "HTML") or (n is "CDATA") or (n is "2D") or (n  is "3D") or (n is "DGA") or
         (n is "DPMS") or (n is "GTF") or (n is "SRGB") or (n is "RGB") or (n is "HSV") or (n is "CX") or (n is "CY") or
         (n is "FX") or (n is "FY") then
         result ..= n
      else
         local cap, word = n:match("^(.)(.+)$")
         if not cap or not word then
            result ..= n:upper()
         else
            result ..= cap:upper() .. word:lower()
         end
      end
   end
   return result
end

----------------------------------------------------------------------------------------------------------------------
-- Scan Class.fields for a specific FieldName.

function findClassField(Class, FieldName)
   assert(Class.fields, 'Class.fields is empty')

   for _, f in ipairs(Class.fields) do
      if f.name is FieldName then
         return f
      end
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Use to ensure strict XML compliance, like
--
-- From: <something>content</>
-- To:   <something>content</something>

function cleanXMLString(str, caller)
   if str?? then
      if str:find('[<>]') then
         str = '<ROOT>' .. str .. '</ROOT>'

         if not cleanXMLString_xml then
            cleanXMLString_xml, err = obj.new('xml', { statement=str, flags=XMF_INCLUDE_WHITESPACE })
         end

         if cleanXMLString_xml then
            cleanXMLString_xml.statement = str
            local err, clean_str = cleanXMLString_xml.mtSerialise(0, XMF_INCLUDE_SIBLINGS)
            if clean_str then str = clean_str:match('<ROOT>(.-)</ROOT>'):trim() end
         else
            error('Failed to parse XML for ' .. (caller ?? 'undefined') .. '.')
         end
      end
   else
      str = ''
   end
   return str
end

----------------------------------------------------------------------------------------------------------------------
-- Register a class by name and return its table. If the class already exists, return the existing table.

function registerClass(Name)
   assert(Name??, 'No Name provided to registerClass()')
   glClasses ?= { }
   glClasses[Name:lower()] ?= { name=Name:cap() }
   return glClasses[Name:lower()]
end

----------------------------------------------------------------------------------------------------------------------
-- Extract information from a compiled class' field definition.

function getMetaFieldDefinition(Field)
   local fl = {
      name  = Field.name,
      flags = Field.flags
   }

   getFieldType(fl, Field.flags, Field.name, Field.arg)
   fl.docType = fl.doc_type

   if (Field.flags & FD_SYNONYM)?? then
      fl.synonym = true
   end

   if Field.getField?? then
      fl.read = 'Get'
      fl.get = Field.getField
   elseif (Field.flags & FD_READ)?? then
      fl.read = 'Read'
   end

   if Field.setField?? then
      fl.write = 'Set'
      fl.set = Field.setField
   elseif (Field.flags & FD_WRITE)?? then
      fl.write = 'Write'
   elseif (Field.flags & FD_INIT)?? then
      fl.write = 'Init'
   end

   if fl.read?? and fl.write?? then
      fl.access = fl.read .. '/' .. fl.write
   elseif fl.read?? then
      fl.access = fl.read
   elseif fl.write?? then
      fl.access = fl.write
   else
      fl.access = 'Private'
   end

   if (Field.flags & FD_SYSTEM)?? then
      fl.access = 'Private'
      fl.private = true
   end

   return fl
end

----------------------------------------------------------------------------------------------------------------------
-- Build a list of all available action names and their parameters.

function loadActions()
   if glActions then return end
   verbose("Loading core actions...")
   glActions = { }
   for id, actions in ipairs(mSys.ActionList()) do
      if not table.empty(actions) and actions.name?? then
         glActions[actions.name] = { name=actions.name, input=actions.args, hash=actions.hash, id=id }
      end
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Resolve the location of the Parasol SDK and create an 'sdk:' volume.

function resolveSDKPath(Path)
   local sdk_path
   local err = ERR_Failed
   local search_list = { }
   if not Path then
      local search_path = 'CMakeLists.txt'
      local limit = 5
      while (err != ERR_Okay) and (limit > 0) do
         table.insert(search_list, search_path)
         err, sdk_path = mSys.ResolvePath(search_path)
         search_path = '../' .. search_path
         limit -= 1
      end
   else
      table.insert(search_list, Path .. '/CMakeLists.txt')
      err, sdk_path = mSys.ResolvePath(Path .. '/CMakeLists.txt')
   end

   if err is ERR_Okay then
      sdk_path = sdk_path:match("(.+)CMakeLists%.txt")
   else
      local msg = ''
      for _, path in ipairs(search_list) do
         msg ..= path .. '\n'
      end
      print('Unable to find CMakeLists.txt after searching the following paths:\n' .. msg)
      error('A path to the Parasol SDK could not be determined.')
   end

   mSys.SetVolume('sdk', sdk_path)
end
