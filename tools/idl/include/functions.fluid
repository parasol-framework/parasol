-- FDL functions such as module(), header(), flags(), c_include(), cpp_include() ...

----------------------------------------------------------------------------------------------------------------------
-- FDL function

global function c_include(...)
   for k,v in ipairs({...}) do
      if v:find('^<(.+)>$') then
         priority('#include ' .. v)
      else
         priority('#include "' .. v .. '"')
      end
   end
   priority()
end

----------------------------------------------------------------------------------------------------------------------
-- FDL function

global function cpp_include(...)
   priority('#ifdef __cplusplus')
   for k,v in ipairs({...}) do
      if v:find('^<(.+)>$') then
         inc = v:match('^<parasol/(.+)>$')

         if inc then inc = inc:gsub('[/%.]', '_') end

         if inc then
            priority('#ifndef ' .. inc:upper())
            priority('#include ' .. v)
            priority('#endif')
            priority()
         else
            priority('#include ' .. v)
         end
      else
         priority('#include "' .. v .. '"')
      end
   end
   priority('#endif')
   priority()
end

----------------------------------------------------------------------------------------------------------------------
-- FDL function
-- Restricts the output of anything declared within the Function.

global function restrict(Function)
   status = glRestrict
   global glRestrict = 'ALL'
   Function()
   glRestrict = status
end

----------------------------------------------------------------------------------------------------------------------
-- FDL function

global function module(Options, Function)
   if (Options['timestamp'] ?? 0) > glIDLTimestamp then
      -- Do nothing if the timestamp is > than the timestamp on this idl-c release
      global glAbort = 'Timestamp on IDL file (' .. Options['timestamp'] .. ') exceeds IDL-C timestamp of ' .. glIDLTimestamp
      return
   end

   global glModule = Options

   if glModule.name?? then
      priority('#pragma once')
      priority()
   else
      error('No "name" field specified in module() call.')
   end

   priority('// Name:      ' .. glModule.name:lower() .. '.h')

   if Options['copyright']?? then
      priority('// Copyright: ' .. Options['copyright'])
   end
   priority('// Generator: idl-c')
   priority()

   priority('#include <parasol/main.h>')
   priority()

   if glModule.version?? then
      priority('#define MODVERSION_' .. glModule.name:upper() .. ' (' .. glModule.version .. ')')
      priority()
   end

   if glModule.src then -- Primary source file
      content = file.readAll(glFDLFolder .. glModule.src)
      content = content:gsub('\r\n', '\n')

      -- Extract possible content from within comments so that we don't get interference from the code while parsing.

      extracted_content = (string.match(content, '^/%*+(.-)%*+/') ?? '') -- The first line might start with a comment.
      for extract in string.gmatch(content, '[^/]/%*+(.-)%*+/') do
         extracted_content ..= '\n' .. extract
      end

      mod_desc = string.match(extracted_content, '%-MODULE%-(.-)%-END%-')

      if mod_desc then
         local name
         name, glModule.comment, glModule.description = mod_desc:match('\n(%w+):%s+(.-)\n\n(.+)')
         if not name then
            error('The -MODULE- header for ' .. tostring(glModule.name) .. ' is incorrectly defined.')
         elseif (name:lower() != glModule.name:lower()) then
            error("The name specified in the -MODULE- header '" .. name .. "' does not match the name specified in the module() call '" .. glModule.name .. "'")
         end
      end
   end

   Function()
end

----------------------------------------------------------------------------------------------------------------------
-- FDL function

global function header(Options, Function)
   global glHeaderPath = Options['path']
   if glHeaderPath?? then
      priority('#pragma once')
      priority()
      priority('// Name:      ' .. glHeaderPath:lower() .. '.h')
   else
      s = ''
      for i=1,10 do
         s = s .. string.char(math.random(65, 90))
      end

      priority('#pragma once')
      priority()
   end

   if Options['copyright']?? then
      priority('// Copyright: ' .. Options['copyright'])
   end
   priority('// Generator: idl-c')
   priority()

   Function()
end

----------------------------------------------------------------------------------------------------------------------
-- FDL function
--
--  flags('KQ', { comment='Special qualifier flags' },
--    'L_SHIFT: Left Shift is held',
--    'R_SHIFT: Right Shift is held',
--    { SHIFT = 'L_SHIFT|R_SHIFT' }
--  )

global function flags(Prefix, Options, ...)
   verbose('Processing ' .. tostring(Prefix) .. ' flags.')
   if glCustomTypes[Prefix] then print('WARN: A "' .. Prefix .. '" constant already exists.') end

   Options = checkOptions(Options)

   out = { }
   sortedFlags = { }
   if Options.comment?? then
      table.insert(out, '// ' .. Options.comment)
      table.insert(out, '')
   end

   function outputFlagDef(Options, Prefix, flag_name, val)
      if not Options.weak then
         if Options.bits is 16 then
            table.insert(sortedFlags, { value = val, define = string.format('   %s = 0x%.4x,', flag_name, val) } )
         else
            hash_id = string.format('%08x', val):sub(-8)
            table.insert(sortedFlags, { value = val, define = string.format('   %s = 0x%s,', flag_name, hash_id) } )
         end
      elseif Options.bits is 16 then
         table.insert(sortedFlags, { value = val, define = string.format('#define %s_%s 0x%.4x', Prefix, flag_name, val) })
      else
         -- Note: This unusual formatting solution helps to resolve output problems on 64-bit Linux
         hash_id = string.format('%08x', val):sub(-8)
         table.insert(sortedFlags, { value = val, define = string.format('#define %s_%s 0x%s', Prefix, flag_name, hash_id) } )
      end
   end

   if not Options.weak then
      type_size = choose Options.bits from
         64 -> 'int64_t'
         16 -> 'uint16_t'
         8  -> 'uint8_t'
         else -> 'uint32_t'
      end
      table.insert(out, string.format('enum class %s : ' .. type_size .. ' {', Prefix))
      table.insert(out, '   NIL = 0,')
   end

   lookup = { }
   local flags = {...}
   f = 0
   for a=0, #flags - 1 do
      local flag_name
      if type(flags[a]) is 'string' then
         key, comment = flags[a]:match('^(.-):%s+(.+)$')
         key ?= flags[a]

         for flag_name in values(key:split('|')) do
            val = 1 << f
            outputFlagDef(Options, Prefix, flag_name, val)
            lookup[flag_name] = { name=flag_name, value=val, comment=comment }
         end
      elseif type(flags[a]) is 'table' then
         for flag_name, ref in pairs(flags[a]) do
            val = 0

            local key, comment
            if type(ref) != 'number' then
               key, comment = ref:match('^(.-):%s+(.+)$')
               if key then
                  if key:find('^0x%d+$') or key:find('^[+-]?%d+$') then
                     key = tonumber(key)
                  end
               end
            end

            key ?= ref

            if type(key) is 'number' then
               val = key
            else -- Process named reference(s) to other flags
               for v in values(key:split('|')) do
                  assert(lookup[v], "Failed to lookup flag reference '" .. v .. "' for " .. Prefix .. "_" .. flag_name)
                  val = val | lookup[v].value
               end
               comment ??= 'Synonym for `' .. key:gsub('|',' | ') .. '`'
            end
            outputFlagDef(Options, Prefix, flag_name, val)
            lookup[flag_name] = { name=flag_name, value=val, comment=comment }
         end
      else
         error("Invalid flag type for '" .. Prefix .. "', expected string, got '" .. type(flags[a]) .. "'")
      end

      f++
   end

   table.sort(sortedFlags, function(a,b) return a.value < b.value end)
   for _, flag in ipairs(sortedFlags) do
      table.insert(out, flag.define)
   end

   if not Options.weak then
      table.insert(out, '};')
      table.insert(out, '')
      table.insert(out, 'DEFINE_ENUM_FLAG_OPERATORS(' .. Prefix .. ')')
   end

   table.insert(out, '')

   if Options.module?? and (Options.module:lower() != glModule.name:lower()) then
     -- Do nothing, module restriction imposed.
   elseif not glRestrict then
      for k,v in pairs(out) do table.insert(glConstants, v) end
   end

   glCustomTypes[Prefix] = {
      prefix=Prefix, grouping='flags', list=lookup, comment=Options.comment,
      restrict=glRestrict
   }

   if not Options.weak then -- Promote strong-typing to other C++ definitions
      glCustomTypes[Prefix].type = 'int'
   end
end

----------------------------------------------------------------------------------------------------------------------
-- FDL function

global function privateNames(List)
   for k,v in pairs(List) do
      glPrivateNames[v] = true
   end
end

----------------------------------------------------------------------------------------------------------------------
-- FDL function

global function hash(Prefix, Format, ...)
   for _, v in ipairs({...}) do
      hash_name = v:gsub('[^%w]', '_')
      -- Note: This unusual formatting solution helps to resolve output problems on 64-bit Linux
      hash_id = string.format('%08x', v:hash()):sub(-8)
      output('#define ' .. Prefix .. '_' .. hash_name .. ' ' .. string.format(Format, hash_id))
   end
   output()
end

global function typedHash(Prefix, Type, ...)
   Type = cType({ type=Type }, Prefix)
   output('enum class ' .. Prefix .. ' : ' .. Type.type .. ' {')
   output('   NIL = 0,')
   for _, v in ipairs({...}) do
      hash_name = v:gsub('[^%w]', '_')
      -- Note: This unusual formatting solution helps to resolve output problems on 64-bit Linux
      hash_id = string.format('%08x', v:hash()):sub(-8)
      output('   ' .. hash_name .. ' = ' .. string.format("0x%sUL", hash_id) .. ',')
   end
   output('};')
   output()
end

----------------------------------------------------------------------------------------------------------------------
-- FDL function

global function const(Prefix, Options, ...)
   verbose('Processing ' .. tostring(Prefix) .. ' constants.')
   if glCustomTypes[Prefix] then print('WARN: A "' .. Prefix .. '" constant already exists.') end

   Options = checkOptions(Options)

   out = { }
   if Options.comment?? then
      table.insert(out, '// ' .. Options.comment)
      table.insert(out, '')
   end

   if Options.type then -- Strong typing enabled, convert via cType()
      Options.type = cType({ type=Options.type }, Prefix)
      table.insert(out, string.format('enum class %s : ' .. Options.type.type .. ' {', Prefix))
      table.insert(out, '   NIL = 0,')
   end

   list = { }
   for k,va in ipairs({...}) do
      if type(va) is 'string' then
         key, comment = va:match('^(.-):%s+(.+)$')
         key ?= va
         for v in values(key:split('|')) do
            table.insert(out, '#define ' .. Prefix .. '_' .. v)
         end
      elseif type(va) is 'table' then
         sorted = { }
         for name, value in pairs(va) do
            table.insert(sorted, { name = name, value = value })
         end
         table.sort(sorted, function(a,b)
            if a.value is b.value then
               return a.name < b.name
            elseif type(a.value) is 'number' and type(b.value) is 'number' then
               return a.value < b.value
            else
               return tostring(a.value) < tostring(b.value)
            end
         end)

         for v in values(sorted) do
            local val, comment
            if type(v.value) is 'string' then
               val, comment = v.value:match('^(.-):%s+(.+)$')
            end
            val ?= v.value

            if Options.type then
               table.insert(out, '   ' .. v.name .. ' = ' .. val .. ',')
            else
               table.insert(out, '#define ' .. Prefix .. '_' .. v.name .. ' ' .. val)
            end

            table.insert(list, { name=v.name, value=val, comment=comment })
         end
      else
         error('Invalid const type for "' .. Prefix .. '", expected string, got "' .. type(va) .. '"')
      end
   end

   if Options.type then
      table.insert(out, '};')
   end

   table.insert(out, '')

   if Options.module?? and (Options.module:lower() != glModule.name:lower()) then
     -- Do nothing, module restriction imposed.
   elseif not glRestrict then
      for k,v in pairs(out) do table.insert(glConstants, v) end
   end

   glCustomTypes[Prefix] = {
      prefix=Prefix, grouping='constants', list=list, comment=Options.comment,
      restrict=(glRestrict ?? Options.restrict),
      type=Options.type -- Promotes strong-typing to other C++ definitions
   }
end

----------------------------------------------------------------------------------------------------------------------
-- FDL function

global function enum(Prefix, Options, ...)
   verbose('Processing ' .. tostring(Prefix) .. ' enum.')
   if glCustomTypes[Prefix] then print('WARN: A "' .. Prefix .. '" constant already exists.') end

   Options = checkOptions(Options)

   out = { }
   if Options.comment?? then
      table.insert(out, '// ' .. Options.comment)
      table.insert(out, '')
   end

   if Options.type then -- Strong typing enabled, convert via cType()
      Options.type = cType({ type=Options.type }, Prefix)
      table.insert(out, string.format('enum class %s : ' .. Options.type.type .. ' {', Prefix))
      table.insert(out, '   NIL = 0,')
   end

   list = { }
   inc = (Options.start ?? 0)
   for k,va in ipairs({...}) do
      if type(va) is 'string' then
         key, comment = va:match('^(.-):%s+(.+)$')
         key ?= va
         synonym = false
         for name in values(key:split('|')) do
            if Options.type then
               table.insert(out, '   ' .. name .. ' = ' .. inc .. ',')
            elseif Options.bits is 64 then
               table.insert(out, '#define ' .. Prefix .. '_' .. name .. ' ' .. inc .. 'LL')
            else
               table.insert(out, '#define ' .. Prefix .. '_' .. name .. ' ' .. inc)
            end

            table.insert(list, { name=name, value=inc, comment=comment, synonym=synonym })
            synonym = true
         end

         inc++
      elseif type(va) is 'table' then -- The client provided a table of fixed values
         for name, client_val in pairs(va) do
            assert(type(client_val) is 'number', 'Client-provided enum values must be numeric, got ' .. tostring(client_val))

            if Options.type then
               table.insert(out, '   ' .. name .. ' = ' .. client_val .. ',')
            elseif Options.bits is 64 then
               table.insert(out, '#define ' .. Prefix .. '_' .. name .. ' ' .. client_val .. 'LL')
            else
               table.insert(out, '#define ' .. Prefix .. '_' .. name .. ' ' .. client_val)
            end

            table.insert(list, { name=name, value=client_val })
         end
      else
         error('Invalid enum type for "' .. Prefix .. '", expected string, got "' .. type(va) .. '"')
      end
   end

   if Options.type then
      table.insert(out, '};')
   end

   table.insert(out, '')

   if Options.module?? and (Options.module:lower() != glModule.name:lower()) then
     -- Do nothing, module restriction imposed.
   elseif not glRestrict then
      for k,v in pairs(out) do table.insert(glConstants, v) end
   end

   glCustomTypes[Prefix] = {
      prefix=Prefix, grouping='constants', list=list, comment=Options.comment,
      restrict=(glRestrict ?? Options.restrict),
      bits=Options.bits,
      type=Options.type -- Promotes strong-typing to other C++ definitions
   }
end

----------------------------------------------------------------------------------------------------------------------
-- FDL function

global function platform(Platform, Function)
   saveHeader = glHeader
   saveOutput = glOutput
   global glHeader = { }
   global glOutput = { }

   local define
   if (Platform:lower() is 'windows') then
      define = '_WIN32'
      Function()
   elseif (Platform:lower() is 'linux') then
      define = '__linux__'
      Function()
   elseif (Platform:lower() is 'x11') then
      define = '__xwindows__'
      Function()
   --elseif (Platform:lower() is 'osx') then
   --   define = '__xwindows__'
   --   Function()
   else
      error('Unrecognised platform "' .. Platform .. '"')
   end

   platformHeader = glHeader
   platformOutput = glOutput
   glHeader = saveHeader
   glOutput = saveOutput

   if #platformHeader > 0 then
      priority('#ifdef ' .. define)
      priority()
      for k,v in ipairs(platformHeader) do
         priority(v)
      end
      priority('#endif')
      priority()
   end

   if #platformOutput > 0 then
      output('#ifdef ' .. define)
      output()
      for k,v in ipairs(platformOutput) do
         output(v)
      end
      output('#endif')
      output()
   end
end

----------------------------------------------------------------------------------------------------------------------
-- FDL function

global function struct(Name, Options, Def, Append)
   verbose('Processing struct ' .. tostring(Name))

   prevStruct = glCurrentStructure
   global glCurrentStructure = Name

   catch(function()
      Options = checkOptions(Options)

      out = { }
      full_name = Name
      if Options.version then
         table.insert(out, '#define VER_' .. Name:upper() .. ' ' .. Options.version)
         table.insert(out, '')
         full_name = Name .. 'V' .. Options.version
      end

      if not Options.type then
         table.insert(out, 'struct ' .. full_name ..  ' {')
      else
         table.insert(out, 'typedef struct ' .. full_name ..  ' {')
      end

      fields = extractFields(Def, full_name)

      type_len = 0
      name_len = 0
      type_max = 0
      for i, f in ipairs(fields) do
         field_name = cName(f, true)
         if field_name:len() > name_len then name_len = field_name:len() end

         if f.type:len() > type_len then
            if f.type:len() < 10 then
               type_len = f.type:len()
            end
         end

         if f.type:len() + field_name:len() > type_max then
            type_max = f.type:len() + 2 + field_name:len()
         end
      end

      max_len = 3 + type_max + 1 + 2

      for i, f in ipairs(fields) do
         field_name = cName(f, true)
         local left
         if field_name?? then -- field_name can be nil if the field describes a function pointer
            left = string.format('   %-' .. type_len .. 's %s;', (f.extType ?? f.type), field_name)
         else
            left = string.format('   %-' .. type_len .. 's;', (f.extType ?? f.type))
         end

         if f.comment?? then
            clean_comment = f.comment:gsub('[`!@#]', '')
            table.insert(out, string.format('%-' .. max_len .. 's // %s', left, clean_comment))
         else
            print('WARN: ' .. full_name .. '.' .. f.name .. ' requires a comment.')
            table.insert(out, left)
         end
      end

      if Append then
         table.insert(out, Append:rtrim())
      end

      if not Options.type then
         table.insert(out, '};')
         table.insert(out, '')
      else
         Options.type = Options.type:upper()
         table.insert(out, '} ' .. Options.type .. ';')
         table.insert(out, '')
      end

      if Options.module?? and (Options.module:lower() != glModule.name:lower()) then
        -- Do nothing, module restriction imposed.
      elseif not glRestrict then
         for k,v in pairs(out) do table.insert(glOutput, v) end
      end

      glStructures[Name] = {
         version = Options.version, type = Options.type, comment = Options.comment, fields = fields,
         restrict = (glRestrict ?? Options.restrict), name = Name
      }
   end,
   function(Exception)
      glCurrentStructure = prevStruct
      error(Exception.message)
   end)

   glCurrentStructure = prevStruct
end

----------------------------------------------------------------------------------------------------------------------
-- Create a C/C++ field name from the definitions in a Field object.

global function cName(Field, CStruct)
   if Field.isFunctionPtr then return '' end -- Functions have their name embedded in the type.

   name = Field.name
   if CStruct then
      if (Field.type is 'OBJECTID') or (Field.type is 'MEMORYID') then
         if name:sub(-2) != 'ID' then
            name ..= 'ID'
         end
      end
   end

   if Field.arraySize and (Field.arraySize > 0) then
      name ..= '[' .. Field.arraySize .. ']'
   end

   if Field.bits then
      name ..= ':1'
   end

   return name
end

----------------------------------------------------------------------------------------------------------------------
-- FDL Function
-- Refer to outputClassHeader() for output of the class structure.

global function class(Name, Options, Spec, Private, Custom)
   verbose('Processing class ' .. tostring(Name))

   Options = checkOptions(Options)

   output('// ' .. Name .. ' class definition')
   output()
   output('#define VER_' .. Name:upper() .. ' (' .. string.format('%f', (Options.version ?? 1.0)) .. ')')
   output()

   local class = registerClass(Name)
   class.name = Name -- The name defined by class() has priority over any name defined by method()
   class.src = Options.src
   if Options.base then
      class.base = "obj" .. Options.base
   end
   class.references = { }

   global glActiveRefs = class.references

   if type(class.src) is 'string' then class.src = { class.src } end -- Convert string to an array of strings

   if mSys.GetResource(RES_STATIC_BUILD) is 0 then
      -- Attempt to load the class into memory.  This introduces a circular reference when the module is not yet
      -- compiled, so the meta information may only be used for phase 2 output (i.e. documentation).

      if mSys.AnalysePath('~modules:' .. glModule.name) is ERR_Okay then
         class.meta = mSys.FindClass(Name:hash(), 0)
      else
         if glFeedback is 'verbose' then
            print('Module ' .. glModule.name .. ' not compiled, class documentation will not be produced.')
         end
      end
   else
      class.meta = mSys.FindClass(Name:hash(), 0)
   end

   -- Process methods and fields defined in the source code (if available)

   cdef = parseClassFields(class, Spec)

   if not table.empty(Options.references) then
      for _, v in pairs(Options.references) do
         if glCustomTypes[v]?? then
            cdef = cdef .. outputLookup(class.name .. v, glCustomTypes[v].list)
            glCustomTypes[v].restrict = nil
         elseif glStructures[v]?? then
            class.references['STRUCT:' .. v] = true
            -- A manual reference to a structure will forcibly turn off any restriction
            glStructures[v].restrict = nil
         else
            print('Reference to lookup ' .. v .. ' not found.')
         end
      end
   end

   class.actions = { }
   if class.src then
      -- Process -METHOD- and -FIELD- definitions

      for _, path in pairs(class.src) do
         if glFeedback is 'verbose' then
            print()
            print('Class file: ' .. glFDLFolder .. path)
         end

         content = file.readAll(glFDLFolder .. path)
         content = content:gsub('\r\n', '\n')

         -- Look for C/C++ action declarations, in the format: ERR CLASS_Action(...).  This will create a series
         -- of dummy action entries that can be overwritten with -ACTION- sections.

         patterns = {
            'ERR%s-' .. Name:upper() .. '_(%a-)%(obj.-%)',
            'ERR%s-' .. Name:upper() .. '_(%a-)%(ext.-%)'
         }

         for _, pattern in pairs(patterns) do
            for actionName in string.gmatch(content, pattern) do
               if glActions[actionName] then
                  verbose('Discovered action ' .. actionName)
                  class.actions[actionName] = { name=actionName }
               else
                  verbose('Ignoring declaration of ' .. actionName)
               end
            end
         end

         -- Extract possible content from within comments so that we don't get interference from the code while parsing.

         extracted_content = (string.match(content, '^/%*+(.-)%*+/') ?? '') -- The first line might start with a comment.
         for extract in string.gmatch(content, '[^/]/%*+(.-)%*+/') do
            extracted_content = extracted_content .. '\n' .. extract
         end

         -- Parse each line individually

         local currentEntry
         local processing
         for line in string.gmatch(extracted_content, '(.-\n)') do
            if line?? then
               line = (line:match('^(.*%S)') ?? '')
               if (line is '-CLASS-') or (line is '-METHOD-') or (line is '-ACTION-') or (line is '-FIELD-') then
                  if currentEntry then parseClassEntry(class, processing, currentEntry) end
                  currentEntry = ''
                  processing = line
               elseif line is '-END-' then
                  if currentEntry then parseClassEntry(class, processing, currentEntry) end
                  currentEntry = nil
                  processing = nil
               elseif line is '-INTERNAL-' then
                  currentEntry = nil
                  processing = nil
               elseif currentEntry then
                  currentEntry ..= line .. '\n'
               end
            elseif currentEntry then
               currentEntry ..= '\n'
            end
         end

         if currentEntry then parseClassEntry(class, processing, currentEntry) end
      end
   end

   -- Export method definitions for a class

   if class.methods then
      pfx  = class.methodPrefix
      lpfx = pfx:lower()

      if glFeedback is 'verbose' then
         print('Generating ' .. #class.methods .. ' methods.')
      end

      for k, method in ipairs(class.methods) do
         if method.input?? then
            t = { }
            i = 1
            for str in string.gmatch(method.input, '([^;]+)') do
               t[i] = str:trim()
               i++
            end

            method.params = { }
            for _, v in ipairs(t) do
               param = { }
               param.type, param.name = v:match('^(.+)%s([^%s]+)$')
               cType(param, 'Method ' .. method.name)
               table.insert(method.params, param)
            end
         end

         -- Generate a modified C method name for the function declaration if the method shares a name with an existing
         -- action.  E.g. 'XML_Sort' will become 'XML_SortXML'

         method.funcName = method.name
         if glActions[method.funcName] then
            method.funcName ..= Name
         end

         function pName(Param)
            name = Param.name
            if (Param.type is 'OBJECTID') or (Param.type is 'MEMORYID') then
               if name:sub(-2) != 'ID' then
                  name ..= 'ID'
               end
            end
            return name
         end

         struct_params = '' -- struct parameter types & names
         values = '' -- Parameter values
         results = false
         params = ''
         if method.params then
            for _, param in ipairs(method.params) do
               struct_params ..= param.basicType .. ' ' .. pName(param) .. '; '

               if params?? then params ..= ', ' end

               if param.type is 'FUNCTION *' then
                  params ..= 'FUNCTION ' .. pName(param)
                  if values?? then values ..= ', ' end
                  values ..= '&' .. pName(param)
               else
                  params ..= param.type .. ' ' .. pName(param)
                  if values?? then values ..= ', ' end

                  if param.resultValue then
                     values ..= '(' .. param.basicType .. ')0'
                     results = true
                  else
                     values ..= pName(param)
                  end
               end
            end
         end

         action_support = 'static const AC id = AC(-' .. method.id .. '); ERR call(OBJECTPTR Object) { return Action(id, Object, this); }'
         if method.params and #method.params > 0 then
            class.methods[k].struct = 'struct ' .. method.name .. ' { ' .. struct_params .. action_support .. ' };'
         else
            class.methods[k].struct = 'struct ' .. method.name .. ' { ' .. action_support .. ' };'
         end

         name = method.name:decap()
         if name is 'delete' then name = 'del' end -- C++ keyword check

         inline = '   inline ERR ' .. name .. '(' .. params .. ') noexcept {\n'
         local args = 'nullptr'

         if method.params and #method.params > 0 then
            inline ..= '      struct ' .. lpfx .. '::' .. method.name .. ' args = { ' .. values .. ' };\n'
            args = '&args'
         end

         if (results) then
            inline ..= '      ERR error = Action(AC(-' .. method.id .. '), this, ' .. args .. ');\n'
            for _, p in pairs(method.params) do
               if p.resultValue then
                  inline ..= '      if (' .. p.name .. ') *' .. p.name .. ' = args.' .. p.name .. ';\n'
               end
            end
            inline ..= '      return(error);\n'
         else
            inline ..= '      return(Action(AC(-' .. method.id .. '), this, ' .. args .. '));\n'
         end

         inline ..= '   }'
         class.methods[k].nestedInline = inline
      end

      output('// ' .. Name:cap() .. ' methods')
      output()

      if lpfx?? then
         output('namespace ' .. lpfx .. ' {')
      end

      for _, method in ipairs(class.methods) do
         if method.struct?? then
            output(method.struct)
         end
      end
      output()

      if lpfx?? then
         output('} // namespace')
      end

      output()
   end

   class.sortedActions = { }
   for _, a in pairs(class.actions) do
      table.insert(class.sortedActions, a)
   end

   if not table.empty(class.sortedActions) then
      table.sort(class.sortedActions, function(a,b) return a.name < b.name end)
   end

   outputClassHeader(class, Private, Custom)

   -- Output internal C definitions for class methods & actions, if an output file has been specified.

   if Options.output?? then
      mdef = ''
      if not table.empty(class.methods) then
         for k, m in ipairs(class.methods) do
            if not table.empty(m.params) then
               mdef ..= 'FDEF ma' .. m.name .. '[] = { ' .. buildInputParameters(m.params) .. ' };\n'
            end
         end
         mdef ..= '\n'

         mdef ..= 'static const struct MethodEntry cl' .. Name .. 'Methods[] = {\n'
         for k, m in ipairs(class.methods) do
            local structSize
            if table.empty(m.params) then
               mdef ..= '   { AC(-' .. m.id .. '), (APTR)' .. Name:upper() .. '_' .. m.funcName .. ', "' .. m.name .. '", 0, 0 },\n'
            else
               structSize = 'sizeof(struct ' .. class.methodPrefix:lower() .. '::' .. m.name .. ')'
               mdef ..= '   { AC(-' .. m.id .. '), (APTR)' .. Name:upper() .. '_' .. m.funcName .. ', "' .. m.name .. '", ma' .. m.name .. ', ' .. structSize .. ' },\n'
            end
         end
         mdef ..= '   { AC::NIL, 0, 0, 0, 0 }\n};\n\n'
      end

      if not table.empty(class.sortedActions) then
         mdef ..= "static const struct ActionArray cl" .. Name .. "Actions[] = {\n"
         for _, action in ipairs(class.sortedActions) do
            mdef ..= "   { AC::" .. action.name .. ", " .. Name:upper() .. "_" .. action.name .. " },\n"
         end
         mdef ..= "   { AC::NIL, nullptr }\n};\n\n"
      end

      file = obj.new("file", { flags="WRITE|NEW", location=glFDLFolder .. Options.output } )
      file.acWrite("// Auto-generated by idl-c.fluid\n\n")
      if cdef?? then file.acWrite(cdef) end
      if mdef?? then file.acWrite(mdef) end
   end
end

----------------------------------------------------------------------------------------------------------------------
-- FDL Function
-- This is a shortened version of functions(), where only the names of the functions need to be specified as a list.
-- Further elaboration on the functions is normally done by embedding -FUNCTION- sections in the module code.

global function functionNames(Prefix, ...)
   global glFunctionPrefix = Prefix ?? ''
   for _, fname in ipairs({...}) do
      if fname:find('[^%w]') then
         error('Invalid function name "' .. fname .. '"')
      end

      func = {
         name  = fname,
         def   = '   void (*_' .. fname .. ')(void);',
         macro = function() -- Default macro, to be overridden by documented function
            return 'template <typename... Args> inline ERR ' .. glFunctionPrefix:lower() .. fname ..
               '(Args... pArgs) noexcept { return ' .. glModule.name .. 'Base->_' .. fname .. '(pArgs...); }'
         end,
         staticMacro = function()
            return 'template <typename... Args> ERR ' .. glFunctionPrefix:lower() .. fname .. '(Args... pArgs);'
         end
      }

      table.insert(glFunctions, func)
      glFunctionLookup[fname] = func
   end

   output('__FUNCTION_TABLE__')
end

----------------------------------------------------------------------------------------------------------------------
-- FDL Function
-- Register methods for a class.  This must be declared prior to the corresponding class() function call.

global function methods(ClassName, Prefix, Methods)
   verbose('Processing ' .. #Methods .. ' methods for class ' .. tostring(ClassName))

   local class = registerClass(ClassName)
   class.methodPrefix = Prefix
   class.methods = Methods

   -- Generate a lookup table by method name
   class.lookupMethods = { }
   for _, m in ipairs(class.methods) do
      class.lookupMethods[m.name] = m
   end
end

----------------------------------------------------------------------------------------------------------------------
-- FDL Function

global function c_insert(Raw)
   output(Raw)
end
