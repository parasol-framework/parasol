-- FDL functions such as module(), header(), flags(), c_include(), cpp_include() ...

----------------------------------------------------------------------------------------------------------------------
-- FDL function

function c_include(...)
   for k,v in ipairs({...}) do
      if (v:find('^<(.+)>$') != nil) then
         priority('#include ' .. v)
      else
         priority('#include "' .. v .. '"')
      end
   end
   priority()
end

----------------------------------------------------------------------------------------------------------------------
-- FDL function

function cpp_include(...)
   priority('#ifdef __cplusplus')
   for k,v in ipairs({...}) do
      if (v:find('^<(.+)>$') != nil) then
         local inc = v:match('^<parasol/(.+)>$')

         if (inc != nil) then inc = inc:gsub('[/%.]', '_') end

         if (inc != nil) then
            priority('#ifndef ' .. inc:upper())
            priority('#include ' .. v)
            priority('#endif')
            priority()
         else
            priority('#include ' .. v)
         end
      else
         priority('#include "' .. v .. '"')
      end
   end
   priority('#endif')
   priority()
end

----------------------------------------------------------------------------------------------------------------------
-- FDL function
-- Restricts the output of anything declared within the Function.

function restrict(Function)
   local status = glRestrict
   glRestrict = 'ALL'
   Function()
   glRestrict = status
end

----------------------------------------------------------------------------------------------------------------------
-- FDL function

function module(Options, Function)
   if (nz(Options['timestamp'],0) > glIDLTimestamp) then
      -- Do nothing if the timestamp is > than the timestamp on this idl-c release
      glAbort = 'Timestamp on IDL file (' .. Options['timestamp'] .. ') exceeds IDL-C timestamp of ' .. glIDLTimestamp
      return
   end

   glModule = Options

   if nz(glModule.name) then
      priority('#pragma once')
      priority()
   else
      error('No "name" field specified in module() call.')
   end

   priority('// Name:      ' .. glModule.name:lower() .. '.h')

   if nz(Options['copyright']) then
      priority('// Copyright: ' .. Options['copyright'])
   end
   priority('// Generator: idl-c')
   priority()

   priority('#include <parasol/main.h>')
   priority()

   if nz(glModule.version) then
      priority('#define MODVERSION_' .. glModule.name:upper() .. ' (' .. glModule.version .. ')')
      priority()
   end

   if (glModule.src != nil) then -- Primary source file
      local content = file.readAll(glFDLFolder .. glModule.src)
      content = content:gsub('\r\n', '\n')

      -- Extract possible content from within comments so that we don't get interference from the code while parsing.

      local extracted_content = nz(string.match(content, '^/%*+(.-)%*+/'),'') -- The first line might start with a comment.
      for extract in string.gmatch(content, '[^/]/%*+(.-)%*+/') do
         extracted_content = extracted_content .. '\n' .. extract
      end

      mod_desc = string.match(extracted_content, '%-MODULE%-(.-)%-END%-')

      if mod_desc then
         local name
         name, glModule.comment, glModule.description = mod_desc:match('\n(%w+):%s+(.-)\n\n(.+)')
         if not name then
            error('The -MODULE- header for ' .. tostring(glModule.name) .. ' is incorrectly defined.')
         elseif (name:lower() != glModule.name:lower()) then
            error("The name specified in the -MODULE- header '" .. name .. "' does not match the name specified in the module() call '" .. glModule.name .. "'")
         end
      end
   end

   Function()
end

----------------------------------------------------------------------------------------------------------------------
-- FDL function

function header(Options, Function)
   glHeaderPath = Options['path']
   if nz(glHeaderPath) then
      priority('#pragma once')
      priority()
      priority('// Name:      ' .. glHeaderPath:lower() .. '.h')
   else
      local s = ''
      for i=1,10 do
         s = s .. string.char(math.random(65, 90))
      end

      priority('#pragma once')
      priority()
   end

   if nz(Options['copyright']) then
      priority('// Copyright: ' .. Options['copyright'])
   end
   priority('// Generator: idl-c')
   priority()

   Function()
end

----------------------------------------------------------------------------------------------------------------------
-- FDL function
--
--  flags('KQ', { comment='Special qualifier flags' },
--    'L_SHIFT: Left Shift is held',
--    'R_SHIFT: Right Shift is held',
--    { SHIFT = 'L_SHIFT|R_SHIFT' }
--  )

function flags(Prefix, Options, ...)
   verbose('Processing ' .. tostring(Prefix) .. ' flags.')
   if (glCustomTypes[Prefix]) then print('WARN: A "' .. Prefix .. '" constant already exists.') end

   Options = checkOptions(Options)

   local out = { }
   local sortedFlags = { }
   if (nz(Options.comment)) then
      table.insert(out, '// ' .. Options.comment)
      table.insert(out, '')
   end

   local function outputFlagDef(Options, Prefix, flag_name, val)
      if (not Options.weak) then
         if (Options.bits == 16) then
            table.insert(sortedFlags, { value = val, define = string.format('   %s = 0x%.4x,', flag_name, val) } )
         else
            local hash_id = string.format('%08x', val):sub(-8)
            table.insert(sortedFlags, { value = val, define = string.format('   %s = 0x%s,', flag_name, hash_id) } )
         end
      elseif (Options.bits == 16) then
         table.insert(sortedFlags, { value = val, define = string.format('#define %s_%s 0x%.4x', Prefix, flag_name, val) })
      else
         -- Note: This unusual formatting solution helps to resolve output problems on 64-bit Linux
         local hash_id = string.format('%08x', val):sub(-8)
         table.insert(sortedFlags, { value = val, define = string.format('#define %s_%s 0x%s', Prefix, flag_name, hash_id) } )
      end
   end

   if (not Options.weak) then
      local type_size = 'uint32_t'
      if (Options.bits == 64) then
         type_size = 'int64_t'
      elseif (Options.bits == 16) then
         type_size = 'uint16_t'
      elseif (Options.bits == 8) then
         type_size = 'uint8_t'
      end
      table.insert(out, string.format('enum class %s : ' .. type_size .. ' {', Prefix))
      table.insert(out, '   NIL = 0,')
   end

   local lookup = { }
   local flags = {...}
   local f = 0
   for a=1,#flags do
      local flag_name
      if (type(flags[a]) == 'string') then
         local key, comment = flags[a]:match('^(.-):%s+(.+)$')
         if (key == nil) then key = flags[a] end

         for _, flag_name in ipairs(key:split('|')) do
            local val = bit.lshift(1, f)
            outputFlagDef(Options, Prefix, flag_name, val)
            lookup[flag_name] = { name=flag_name, value=val, comment=comment }
         end
      elseif (type(flags[a]) == 'table') then
         for flag_name, ref in pairs(flags[a]) do
            local val = 0

            local key, comment
            if (type(ref) != 'number') then
               key, comment = ref:match('^(.-):%s+(.+)$')
               if (key != nil) then
                  if (key:find('^0x%d+$')) or (key:find('^[+-]?%d+$')) then
                     key = tonumber(key)
                  end
               end
            end

            if (key == nil) then key = ref end

            if (type(key) == 'number') then
               val = key
            else -- Process named reference(s) to other flags
               local v
               for _, v in ipairs(key:split('|')) do
                  if (lookup[v] != nil) then
                     val = bit.bor(val, lookup[v].value)
                  else
                     error("Failed to lookup flag reference '" .. v .. "' for " .. Prefix .. "_" .. flag_name)
                  end
               end
               if (comment == nil) then comment = 'Synonym for `' .. key:gsub('|',' | ') .. '`' end
            end
            outputFlagDef(Options, Prefix, flag_name, val)
            lookup[flag_name] = { name=flag_name, value=val, comment=comment }
         end
      else
         error("Invalid flag type for '" .. Prefix .. "', expected string, got '" .. type(flags[a]) .. "'")
      end

      f = f + 1
   end

   table.sort(sortedFlags, function(a,b) return a.value < b.value end)
   for _, flag in ipairs(sortedFlags) do
      table.insert(out, flag.define)
   end

   if (not Options.weak) then
      table.insert(out, '};')
      table.insert(out, '')
      table.insert(out, 'DEFINE_ENUM_FLAG_OPERATORS(' .. Prefix .. ')')
   end

   table.insert(out, '')

   if nz(Options.module) and (Options.module:lower() != glModule.name:lower()) then
     -- Do nothing, module restriction imposed.
   elseif (glRestrict == nil) then
      for k,v in pairs(out) do table.insert(glConstants, v) end
   end

   glCustomTypes[Prefix] = {
      prefix=Prefix, grouping='flags', list=lookup, comment=Options.comment,
      restrict=glRestrict
   }

   if (not Options.weak) then -- Promote strong-typing to other C++ definitions
      glCustomTypes[Prefix].type = 'int'
   end
end

----------------------------------------------------------------------------------------------------------------------
-- FDL function

function privateNames(List)
   for k,v in pairs(List) do
      glPrivateNames[v] = true
   end
end

----------------------------------------------------------------------------------------------------------------------
-- FDL function

function hash(Prefix, Format, ...)
   for _, v in ipairs({...}) do
      local hash_name = v:gsub('[^%w]', '_')
      -- Note: This unusual formatting solution helps to resolve output problems on 64-bit Linux
      local hash_id = string.format('%08x', v:hash()):sub(-8)
      output('#define ' .. Prefix .. '_' .. hash_name .. ' ' .. string.format(Format, hash_id))
   end
   output()
end

function typedHash(Prefix, Type, ...)
   Type = cType({ type=Type }, Prefix)
   output('enum class ' .. Prefix .. ' : ' .. Type.type .. ' {')
   output('   NIL = 0,')
   for _, v in ipairs({...}) do
      local hash_name = v:gsub('[^%w]', '_')
      -- Note: This unusual formatting solution helps to resolve output problems on 64-bit Linux
      local hash_id = string.format('%08x', v:hash()):sub(-8)
      output('   ' .. hash_name .. ' = ' .. string.format("0x%sUL", hash_id) .. ',')
   end
   output('};')
   output()
end

----------------------------------------------------------------------------------------------------------------------
-- FDL function

function const(Prefix, Options, ...)
   verbose('Processing ' .. tostring(Prefix) .. ' constants.')
   if (glCustomTypes[Prefix]) then print('WARN: A "' .. Prefix .. '" constant already exists.') end

   Options = checkOptions(Options)

   local out = { }
   if (nz(Options.comment)) then
      table.insert(out, '// ' .. Options.comment)
      table.insert(out, '')
   end

   if (Options.type) then -- Strong typing enabled, convert via cType()
      Options.type = cType({ type=Options.type }, Prefix)
      table.insert(out, string.format('enum class %s : ' .. Options.type.type .. ' {', Prefix))
      table.insert(out, '   NIL = 0,')
   end

   local list = { }
   for k,va in ipairs({...}) do
      if (type(va) == 'string') then
         local key, comment = va:match('^(.-):%s+(.+)$')
         if (key == nil) then key = va end
         for _, v in ipairs(key:split('|')) do
            table.insert(out, '#define ' .. Prefix .. '_' .. v)
         end
      elseif (type(va) == 'table') then
         local sorted = { }
         for name, value in pairs(va) do
            table.insert(sorted, { name = name, value = value })
         end
         table.sort(sorted, function(a,b)
            if (a.value == b.value) then
               return a.name < b.name
            elseif type(a.value) == 'number' and type(b.value) == 'number' then
               return a.value < b.value
            else
               return tostring(a.value) < tostring(b.value)
            end
         end)

         for _, v in ipairs(sorted) do
            local val, comment
            if (type(v.value) == 'string') then
               val, comment = v.value:match('^(.-):%s+(.+)$')
            end
            if (val == nil) then val = v.value end

            if (Options.type) then
               table.insert(out, '   ' .. v.name .. ' = ' .. val .. ',')
            else
               table.insert(out, '#define ' .. Prefix .. '_' .. v.name .. ' ' .. val)
            end

            table.insert(list, { name=v.name, value=val, comment=comment })
         end
      else
         error('Invalid const type for "' .. Prefix .. '", expected string, got "' .. type(va) .. '"')
      end
   end

   if (Options.type) then
      table.insert(out, '};')
   end

   table.insert(out, '')

   if nz(Options.module) and (Options.module:lower() != glModule.name:lower()) then
     -- Do nothing, module restriction imposed.
   elseif (glRestrict == nil) then //.
      for k,v in pairs(out) do table.insert(glConstants, v) end
   end

   glCustomTypes[Prefix] = {
      prefix=Prefix, grouping='constants', list=list, comment=Options.comment,
      restrict=nz(glRestrict, Options.restrict),
      type=Options.type -- Promotes strong-typing to other C++ definitions
   }
end

----------------------------------------------------------------------------------------------------------------------
-- FDL function

function enum(Prefix, Options, ...)
   verbose('Processing ' .. tostring(Prefix) .. ' enum.')
   if (glCustomTypes[Prefix]) then print('WARN: A "' .. Prefix .. '" constant already exists.') end

   Options = checkOptions(Options)

   local out = { }
   if (nz(Options.comment)) then
      table.insert(out, '// ' .. Options.comment)
      table.insert(out, '')
   end

   if (Options.type) then -- Strong typing enabled, convert via cType()
      Options.type = cType({ type=Options.type }, Prefix)
      table.insert(out, string.format('enum class %s : ' .. Options.type.type .. ' {', Prefix))
      table.insert(out, '   NIL = 0,')
   end

   local list = { }
   local inc = nz(Options.start, 0)
   for k,va in ipairs({...}) do
      if (type(va) == 'string') then
         local key, comment = va:match('^(.-):%s+(.+)$')
         if (key == nil) then key = va end
         local synonym = false
         for _, name in ipairs(key:split('|')) do
            if (Options.type) then
               table.insert(out, '   ' .. name .. ' = ' .. inc .. ',')
            elseif (Options.bits == 64) then
               table.insert(out, '#define ' .. Prefix .. '_' .. name .. ' ' .. inc .. 'LL')
            else
               table.insert(out, '#define ' .. Prefix .. '_' .. name .. ' ' .. inc)
            end

            table.insert(list, { name=name, value=inc, comment=comment, synonym=synonym })
            synonym = true
         end

         inc = inc + 1
      elseif (type(va) == 'table') then -- The client provided a table of fixed values
         for name, client_val in pairs(va) do
            if (type(client_val) != 'number') then
               error('Client-provided enum values must be numeric')
            end

            if (Options.type) then
               table.insert(out, '   ' .. name .. ' = ' .. client_val .. ',')
            elseif (Options.bits == 64) then
               table.insert(out, '#define ' .. Prefix .. '_' .. name .. ' ' .. client_val .. 'LL')
            else
               table.insert(out, '#define ' .. Prefix .. '_' .. name .. ' ' .. client_val)
            end

            table.insert(list, { name=name, value=client_val })
         end
      else
         error('Invalid enum type for "' .. Prefix .. '", expected string, got "' .. type(va) .. '"')
      end
   end

   if (Options.type) then
      table.insert(out, '};')
   end

   table.insert(out, '')

   if nz(Options.module) and (Options.module:lower() != glModule.name:lower()) then
     -- Do nothing, module restriction imposed.
   elseif (glRestrict == nil) then
      for k,v in pairs(out) do table.insert(glConstants, v) end
   end

   glCustomTypes[Prefix] = {
      prefix=Prefix, grouping='constants', list=list, comment=Options.comment,
      restrict=nz(glRestrict, Options.restrict),
      bits=Options.bits,
      type=Options.type -- Promotes strong-typing to other C++ definitions
   }
end

----------------------------------------------------------------------------------------------------------------------
-- FDL function

function platform(Platform, Function)
   local saveHeader = glHeader
   local saveOutput = glOutput
   glHeader = { }
   glOutput = { }

   local define
   if (Platform:lower() == 'windows') then
      define = '_WIN32'
      Function()
   elseif (Platform:lower() == 'linux') then
      define = '__linux__'
      Function()
   elseif (Platform:lower() == 'x11') then
      define = '__xwindows__'
      Function()
   --elseif (Platform:lower() == 'osx') then
   --   define = '__xwindows__'
   --   Function()
   else
      error('Unrecognised platform "' .. Platform .. '"')
   end

   local platformHeader = glHeader
   local platformOutput = glOutput
   glHeader = saveHeader
   glOutput = saveOutput

   if #platformHeader > 0 then
      priority('#ifdef ' .. define)
      priority()
      for k,v in ipairs(platformHeader) do
         priority(v)
      end
      priority('#endif')
      priority()
   end

   if #platformOutput > 0 then
      output('#ifdef ' .. define)
      output()
      for k,v in ipairs(platformOutput) do
         output(v)
      end
      output('#endif')
      output()
   end
end

----------------------------------------------------------------------------------------------------------------------
-- FDL function

function struct(Name, Options, Def, Append)
   verbose('Processing struct ' .. tostring(Name))

   local prevStruct = glCurrentStructure
   glCurrentStructure = Name

   catch(function()
      Options = checkOptions(Options)

      local out = { }
      local full_name = Name
      if (Options.version != nil) then
         table.insert(out, '#define VER_' .. Name:upper() .. ' ' .. Options.version)
         table.insert(out, '')
         full_name = Name .. 'V' .. Options.version
      end

      if Options.type == nil then
         table.insert(out, 'struct ' .. full_name ..  ' {')
      else
         table.insert(out, 'typedef struct ' .. full_name ..  ' {')
      end

      local fields = extractFields(Def, full_name)

      local type_len = 0
      local name_len = 0
      local type_max = 0
      for i, f in ipairs(fields) do
         local field_name = cName(f, true)
         if (field_name:len() > name_len) then name_len = field_name:len() end

         if (f.type:len() > type_len) then
            if (f.type:len() < 10) then
               type_len = f.type:len()
            end
         end

         if (f.type:len() + field_name:len() > type_max) then
            type_max = f.type:len() + 2 + field_name:len()
         end
      end

      local max_len = 3 + type_max + 1 + 2

      for i, f in ipairs(fields) do
         local field_name = cName(f, true)
         local left
         if nz(field_name) then -- field_name can be nil if the field describes a function pointer
            left = string.format('   %-' .. type_len .. 's %s;', nz(f.extType, f.type), field_name)
         else
            left = string.format('   %-' .. type_len .. 's;', nz(f.extType, f.type))
         end

         if nz(f.comment) then
            local clean_comment = f.comment:gsub('[`!@#]', '')
            table.insert(out, string.format('%-' .. max_len .. 's // %s', left, clean_comment))
         else
            print('WARN: ' .. full_name .. '.' .. f.name .. ' requires a comment.')
            table.insert(out, left)
         end
      end

      if (Append != nil) then
         table.insert(out, Append:rtrim())
      end

      if Options.type == nil then
         table.insert(out, '};')
         table.insert(out, '')
      else
         Options.type = Options.type:upper()
         table.insert(out, '} ' .. Options.type .. ';')
         table.insert(out, '')
      end

      if nz(Options.module) and (Options.module:lower() != glModule.name:lower()) then
        -- Do nothing, module restriction imposed.
      elseif (glRestrict == nil) then
         for k,v in pairs(out) do table.insert(glOutput, v) end
      end

      glStructures[Name] = {
         version = Options.version, type = Options.type, comment = Options.comment, fields = fields,
         restrict = nz(glRestrict, Options.restrict), name = Name
      }
   end,
   function(Exception)
      glCurrentStructure = prevStruct
      error(Exception.message)
   end)

   glCurrentStructure = prevStruct
end

----------------------------------------------------------------------------------------------------------------------
-- Create a C/C++ field name from the definitions in a Field object.

function cName(Field, CStruct)
   if (Field.isFunctionPtr) then return '' end // Functions have their name embedded in the type.

   local name = Field.name
   if (CStruct) then
      if (Field.type == 'OBJECTID') or (Field.type == 'MEMORYID') then
         if (name:sub(-2) != 'ID') then
            name = name .. 'ID'
         end
      end
   end

   if (Field.arraySize != nil) and (Field.arraySize > 0) then
      name = name .. '[' .. Field.arraySize .. ']'
   end

   if (Field.bits != nil) then
      name = name .. ':1'
   end

   return name
end

----------------------------------------------------------------------------------------------------------------------
-- FDL Function
-- Refer to outputClassHeader() for output of the class structure.

function class(Name, Options, Spec, Private, Custom)
   verbose('Processing class ' .. tostring(Name))

   Options = checkOptions(Options)

   output('// ' .. Name .. ' class definition')
   output()
   output('#define VER_' .. Name:upper() .. ' (' .. string.format('%f', nz(Options.version,1.0)) .. ')')
   output()

   local class = registerClass(Name)
   class.name = Name -- The name defined by class() has priority over any name defined by method()
   class.src = Options.src
   if Options.base then
      class.base = "obj" .. Options.base
   end
   class.references = { }

   glActiveRefs = class.references

   if (type(class.src) == 'string') then class.src = { class.src } end -- Convert string to an array of strings

   if (mSys.GetResource(RES_STATIC_BUILD) == 0) then
      -- Attempt to load the class into memory.  This introduces a circular reference when the module is not yet
      -- compiled, so the meta information may only be used for phase 2 output (i.e. documentation).

      if (mSys.AnalysePath('~modules:' .. glModule.name) == ERR_Okay) then
         class.meta = mSys.FindClass(Name:hash(), 0)
      else
         if (glFeedback == 'verbose') then
            print('Module ' .. glModule.name .. ' not compiled, class documentation will not be produced.')
         end
      end
   else
      class.meta = mSys.FindClass(Name:hash(), 0)
   end

   -- Process methods and fields defined in the source code (if available)

   local cdef = parseClassFields(class, Spec)

   if nz(Options.references) then
      for _, v in pairs(Options.references) do
         if nz(glCustomTypes[v]) then
            cdef = cdef .. outputLookup(class.name .. v, glCustomTypes[v].list)
            glCustomTypes[v].restrict = nil
         elseif nz(glStructures[v]) then
            class.references['STRUCT:' .. v] = true
            -- A manual reference to a structure will forcibly turn off any restriction
            glStructures[v].restrict = nil
         else
            print('Reference to lookup ' .. v .. ' not found.')
         end
      end
   end

   class.actions = { }
   if (class.src != nil) then
      -- Process -METHOD- and -FIELD- definitions

      local path
      for _, path in pairs(class.src) do
         if (glFeedback == 'verbose') then
            print()
            print('Class file: ' .. glFDLFolder .. path)
         end

         local content = file.readAll(glFDLFolder .. path)
         content = content:gsub('\r\n', '\n')

         -- Look for C/C++ action declarations, in the format: ERR CLASS_Action(...).  This will create a series
         -- of dummy action entries that can be overwritten with -ACTION- sections.

         local patterns = {
            'ERR%s-' .. Name:upper() .. '_(%a-)%(obj.-%)',
            'ERR%s-' .. Name:upper() .. '_(%a-)%(ext.-%)'
         }
         for _, pattern in pairs(patterns) do
            for actionName in string.gmatch(content, pattern) do
               if (glActions[actionName] != nil) then
                  verbose('Discovered action ' .. actionName)
                  class.actions[actionName] = { name=actionName }
               else
                  verbose('Ignoring declaration of ' .. actionName)
               end
            end
         end

         -- Extract possible content from within comments so that we don't get interference from the code while parsing.

         local extracted_content = nz(string.match(content, '^/%*+(.-)%*+/'),'') -- The first line might start with a comment.
         for extract in string.gmatch(content, '[^/]/%*+(.-)%*+/') do
            extracted_content = extracted_content .. '\n' .. extract
         end

         -- Parse each line individually

         local currentEntry = nil
         local processing = nil
         for line in string.gmatch(extracted_content, '(.-\n)') do
            if nz(line) then
               line = nz(line:match('^(.*%S)'),'')
               if (line == '-CLASS-') or (line == '-METHOD-') or (line == '-ACTION-') or (line == '-FIELD-') then
                  if (currentEntry != nil) then parseClassEntry(class, processing, currentEntry) end
                  currentEntry = ''
                  processing = line
               elseif (line == '-END-') then
                  if (currentEntry != nil) then parseClassEntry(class, processing, currentEntry) end
                  currentEntry = nil
                  processing = nil
               elseif (line == '-INTERNAL-') then
                  currentEntry = nil
                  processing = nil
               elseif (currentEntry != nil) then
                  currentEntry = currentEntry .. line .. '\n'
               end
            elseif (currentEntry != nil) then
               currentEntry = currentEntry .. '\n'
            end
         end

         if (currentEntry != nil) then parseClassEntry(class, processing, currentEntry) end
      end
   end

   -- Export method definitions for a class

   if (class.methods != nil) then
      local pfx  = class.methodPrefix
      local lpfx = pfx:lower()

      if (glFeedback == 'verbose') then
         print('Generating ' .. #class.methods .. ' methods.')
      end

      for k, method in ipairs(class.methods) do
         if nz(method.input) then
            local t = { }
            local i = 1
            for str in string.gmatch(method.input, '([^;]+)') do
               t[i] = str:trim()
               i = i + 1
            end

            method.params = { }
            for _, v in ipairs(t) do
               local param = { }
               param.type, param.name = v:match('^(.+)%s([^%s]+)$')
               cType(param, 'Method ' .. method.name)
               table.insert(method.params, param)
            end
         end

         -- Generate a modified C method name for the function declaration if the method shares a name with an existing
         -- action.  E.g. 'XML_Sort' will become 'XML_SortXML'

         method.funcName = method.name
         if (glActions[method.funcName] != nil) then
            method.funcName = method.funcName .. Name
         end

         local function pName(Param)
            local name = Param.name
            if (Param.type == 'OBJECTID') or (Param.type == 'MEMORYID') then
               if (name:sub(-2) != 'ID') then
                  name = name .. 'ID'
               end
            end
            return name
         end

         local struct_params = '' -- struct parameter types & names
         local values = '' -- Parameter values
         local results = false
         local params = ''
         if method.params then
            for _, param in ipairs(method.params) do
               struct_params = struct_params .. param.basicType .. ' ' .. pName(param) .. '; '

               if nz(params) then params = params .. ', ' end

               if (param.type == 'FUNCTION *') then
                  params = params .. 'FUNCTION ' .. pName(param)
                  if nz(values) then values = values .. ', ' end
                  values = values .. '&' .. pName(param)
               else
                  params = params .. param.type .. ' ' .. pName(param)
                  if nz(values) then values = values .. ', ' end

                  if (param.resultValue) then
                     values  = values .. '(' .. param.basicType .. ')0'
                     results = true
                  else
                     values = values .. pName(param)
                  end
               end
            end
         end

         local action_support = 'static const AC id = AC(-' .. method.id .. '); ERR call(OBJECTPTR Object) { return Action(id, Object, this); }'
         if (method.params != nil) and (#method.params > 0) then
            class.methods[k].struct = 'struct ' .. method.name .. ' { ' .. struct_params .. action_support .. ' };'
         else
            class.methods[k].struct = 'struct ' .. method.name .. ' { ' .. action_support .. ' };'
         end

         local name = method.name:decap()
         if name == 'delete' then name = 'del' end -- C++ keyword check

         local inline = '   inline ERR ' .. name .. '(' .. params .. ') noexcept {\n'
         local args = 'nullptr'

         if (method.params != nil) and (#method.params > 0) then
            inline = inline .. '      struct ' .. lpfx .. '::' .. method.name .. ' args = { ' .. values .. ' };\n'
            args = '&args'
         end

         if (results) then
            inline = inline .. '      ERR error = Action(AC(-' .. method.id .. '), this, ' .. args .. ');\n'
            for _, p in pairs(method.params) do
               if (p.resultValue) then
                  inline = inline .. '      if (' .. p.name .. ') *' .. p.name .. ' = args.' .. p.name .. ';\n'
               end
            end
            inline = inline .. '      return(error);\n'
         else
            inline = inline .. '      return(Action(AC(-' .. method.id .. '), this, ' .. args .. '));\n'
         end

         inline = inline .. '   }'
         class.methods[k].nestedInline = inline
      end

      output('// ' .. Name:cap() .. ' methods')
      output()

      if nz(lpfx) then
         output('namespace ' .. lpfx .. ' {')
      end

      for _, method in ipairs(class.methods) do
         if nz(method.struct) then
            output(method.struct)
         end
      end
      output()

      if nz(lpfx) then
         output('} // namespace')
      end

      output()
   end

   class.sortedActions = { }
   for _, a in pairs(class.actions) do
      table.insert(class.sortedActions, a)
   end

   if nz(class.sortedActions) then
      table.sort(class.sortedActions, function(a,b) return a.name < b.name end)
   end

   outputClassHeader(class, Private, Custom)

   -- Output internal C definitions for class methods & actions, if an output file has been specified.

   if nz(Options.output) then
      local mdef = ''
      if (class.methods != nil) then
         for k, m in ipairs(class.methods) do
            if nz(m.params) then
               mdef = mdef .. 'FDEF ma' .. m.name .. '[] = { ' .. buildInputParameters(m.params) .. ' };\n'
            end
         end
         mdef = mdef .. '\n'

         mdef = mdef .. 'static const struct MethodEntry cl' .. Name .. 'Methods[] = {\n'
         for k, m in ipairs(class.methods) do
            local structSize
            if not nz(m.params) then
               mdef = mdef .. '   { AC(-' .. m.id .. '), (APTR)' .. Name:upper() .. '_' .. m.funcName .. ', "' .. m.name .. '", 0, 0 },\n'
            else
               structSize = 'sizeof(struct ' .. class.methodPrefix:lower() .. '::' .. m.name .. ')'
               mdef = mdef .. '   { AC(-' .. m.id .. '), (APTR)' .. Name:upper() .. '_' .. m.funcName .. ', "' .. m.name .. '", ma' .. m.name .. ', ' .. structSize .. ' },\n'
            end
         end
         mdef = mdef .. '   { AC::NIL, 0, 0, 0, 0 }\n};\n\n'
      end

      if nz(class.sortedActions) then
         mdef = mdef .. "static const struct ActionArray cl" .. Name .. "Actions[] = {\n"
         for _, action in ipairs(class.sortedActions) do
            mdef = mdef .. "   { AC::" .. action.name .. ", " .. Name:upper() .. "_" .. action.name .. " },\n"
         end
         mdef = mdef .. "   { AC::NIL, nullptr }\n};\n\n"
      end

      local file = obj.new("file", { flags="WRITE|NEW", location=glFDLFolder .. Options.output } )
      file.acWrite("// Auto-generated by idl-c.fluid\n\n")
      if nz(cdef) then file.acWrite(cdef) end
      if nz(mdef) then file.acWrite(mdef) end
   end
end

----------------------------------------------------------------------------------------------------------------------
-- FDL Function
-- This is a shortened version of functions(), where only the names of the functions need to be specified as a list.
-- Further elaboration on the functions is normally done by embedding -FUNCTION- sections in the module code.

function functionNames(Prefix, ...)
   glFunctionPrefix = nz(Prefix,'')
   for _, fname in ipairs({...}) do
      if (fname:find('[^%w]')) then
         error('Invalid function name "' .. fname .. '"')
      end

      local func = {
         name  = fname,
         def   = '   void (*_' .. fname .. ')(void);',
         macro = function() -- Default macro, to be overridden by documented function
            return 'template <typename... Args> inline ERR ' .. glFunctionPrefix:lower() .. fname ..
               '(Args... pArgs) noexcept { return ' .. glModule.name .. 'Base->_' .. fname .. '(pArgs...); }'
         end,
         staticMacro = function()
            return 'template <typename... Args> ERR ' .. glFunctionPrefix:lower() .. fname .. '(Args... pArgs);'
         end
      }

      table.insert(glFunctions, func)
      glFunctionLookup[fname] = func
   end

   output('__FUNCTION_TABLE__')
end

----------------------------------------------------------------------------------------------------------------------
-- FDL Function
-- Register methods for a class.  This must be declared prior to the corresponding class() function call.

function methods(ClassName, Prefix, Methods)
   verbose('Processing methods for class ' .. tostring(ClassName))

   local class = registerClass(ClassName)
   class.methodPrefix = Prefix
   class.methods = Methods

   -- Generate a lookup table by method name
   class.lookupMethods = { }
   for _, m in ipairs(class.methods) do
      class.lookupMethods[m.name] = m
   end
end

----------------------------------------------------------------------------------------------------------------------
-- FDL Function

function c_insert(Raw)
   output(Raw)
end
