
----------------------------------------------------------------------------------------------------------------------

function parseClassEntry(Class, Type, Extract)
   if Type is '-CLASS-' then
      parseClassHeader(Class, Extract)
   elseif Type is '-METHOD-' then
      parseMethod(Class, Extract)
   elseif Type is '-ACTION-' then
      parseAction(Class, Extract)
   elseif Type is '-FIELD-' then
      parseField(Class, Extract)
   end
end

----------------------------------------------------------------------------------------------------------------------

function parseClassHeader(Class, Extract)
   Extract = '-CLASS-\n' .. Extract:trim() .. '\n-END-\n'
   local name
   name, Class.comment = Extract:match('\n(%w+):%s+(.-)\n')
   Class.status = Extract:match('\n[Ss]tatus:%s+(.-)\n')
   assert(name:lower() is Class.name:lower(), "The name specified in the -CLASS- header '" .. name .. "' does not match the name specified in the class() call '" .. Class.name .. "'")
   Class.description = Extract:match("\n\n(.-)\n%-[A-Z]+%-\n")
end

----------------------------------------------------------------------------------------------------------------------

function parseAction(class, extract)
   extract = '-ACTION-\n' .. extract:trim() .. '\n-END-\n'

   local name    = extract:match('\n[Nn]ame:%s+(.-)\n')
   local comment = extract:match('\n[Cc]omment:%s+(.-)\n')
   if not name then
      name, comment = extract:match('\n(%w+):%s+(.-)\n')
   end

   local action = class.actions[name]
   if not action then action = { } end
   action.name = name
   action.comment = comment
   action.description = extract:match('\n\n(.-)\n%-[A-Z]+%-\n')

   local errors = extract:match('\n%-ERRORS%-\n(.-)%-END%-')
   if errors?? then
      action.results = { }

      for line in string.gmatch(errors, '(.-)\n') do
         if not line?? then break end -- A double line-break forces a premature end to error processing.

         local ecode, comment = line:match('(%a-):%s+(.+)')
         if ecode then
            table.insert(action.results, { code = _G['ERR_' .. ecode], codeName = ecode, msg = comment })
         else
            ecode = line:match('(%a+):?')
            if ecode?? then
               table.insert(action.results, { code = _G['ERR_' .. ecode], codeName = ecode, msg = mSys.GetErrorMsg(_G['ERR_' .. ecode]) })
            end
        end
      end

      table.sort(action.results, function(a,b) return a.code < b.code end)
   end
end

----------------------------------------------------------------------------------------------------------------------

function parseField(class, extract)
   extract = '-FIELD-\n' .. extract:trim() .. '\n-END-\n'
   local lookup  = extract:match('\n[Ll]ookup:%s+(.-)\n')
   local status  = extract:match('\n[Ss]tatus:%s+(.-)\n')
   local name, comment = extract:match('\n(%w+):%s+(.-)\n')

   local description = extract:match('\n\n(.-)\n%-[A-Z]+%-\n')

   if not name then
      print('Name not defined for -FIELD- definition.')
      return
   end

   local f = findClassField(class, name)
   if f then
      if comment?? then f.comment = comment end
      if lookup?? then
         if glCustomTypes[lookup] then
            f.lookup = lookup
            class.references['TYPE:' .. lookup] = 1
         else
            print('Requested lookup "' .. lookup .. '" is not known.')
         end
      end
      if string.match((status ?? ''), '^[Pp]rivate') or string.match((comment ?? ''), '^[Pp]rivate') then
         f.private = true
         f.access = 'Private'
      end
      f.description = description
   elseif class.meta then
      print("Field '" .. class.name .. "." .. tostring(name) .. "' is not defined in the FDL or compiled class spec.")
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Convert a parameter string such as "int width: The width of the image"

function parseParameterString(Parameter)
   local param = { }
   param.comment = Parameter:match('^.+:%s-(.+)$')
   if param.comment?? then Parameter = Parameter:match('^(.+):%s-.+$') end
   param.type, param.name = Parameter:match('^%s*(.+)%s+([^%s]+)%s-$')
   if param.type then
      param.type = param.type:trim()
      param.name = param.name:trim()
      param.comment = param.comment:trim()
      return param
   end
end

----------------------------------------------------------------------------------------------------------------------

function parseMethod(class, extract)
   extract = '-METHOD-\n' .. extract:trim() .. '\n-END-\n'

   local name    = extract:match('\n[Nn]ame:%s+(.-)\n')
   local comment = extract:match('\n[Cc]omment:%s+(.-)\n')
   if not name then
      name, comment = extract:match('\n(%w+):%s+(.-)\n')
   end

   local status      = extract:match('\n[Ss]tatus:%s+(.-)\n')
   local description = extract:match('\n\n(.-)\n%-[A-Z]+%-\n')

   if name:find('%(%)') then
      name = name:match('(%a+)()')
   end

   assert(name??, 'Failed to extract a name tag from -METHOD- definition.')
   assert(comment??, "Failed to extract a comment tag from -METHOD- definition of '" .. name .. "'")
   assert(description??, "Failed to extract a description from -METHOD- definition of '" .. name .. "'")

   if glFeedback is 'verbose' then print('Processing method ' .. name) end

   local method -- Retrieve the definition for this method
   if class.methods then
      method = class.lookupMethods[name]
      assert(method, "Method '" .. name .. "' is not registered in the FDL.")
   else
      error("Methods need to be pre-defined for class '" .. tostring(class.name) .. "' with methods()")
   end

   method.params = { }
   method.description = description
   method.comment = comment
   method.status = status

   local input = extract:match('\n%-INPUT%-\n(.-)\n\n%-[A-Z]+%-\n')

   local errors = extract:match('\n%-ERRORS%-\n(.-)%-END%-')
   if errors?? then
      method.results = { }

      for line in string.gmatch(errors, '(.-)\n') do
         if not line?? then break end -- A double line-break forces a premature end to error processing.

         local ecode, comment = line:match('(%a-):%s+(.+)')
         if ecode then
            table.insert(method.results, { code = _G['ERR_' .. ecode], codeName = ecode, msg = comment })
         else
            ecode = line:match('(%a+):?')
            if ecode?? then
               table.insert(method.results, { code = _G['ERR_' .. ecode], codeName = ecode, msg = mSys.GetErrorMsg(_G['ERR_' .. ecode]) })
            end
         end
      end

      table.sort(method.results, function(a,b) return (a.code ?? -1) < (b.code ?? -1) end)
   end

   if input?? then
      for line, content in ipairs(input:split('\n')) do
         local param = parseParameterString(content)
         if param then
            cType(param, name)
            table.insert(method.params, param)
         elseif content:trim()?? then
            error("Unable to process line '" .. (content ?? "NULL") .. "' for method '" .. name .. "'")
         end
      end
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Process the formal field definitions in a class spec.

function parseClassFields(class, ClientSpec)
   local cdef = ''

   -- Parse fields defined in the FDL

   class.fields = extractFields(ClientSpec, class.name)

   -- Add compiled fields into the field definitions.  NB: Technically this relies on a circular reference, so such
   -- information can only be taken advantage of for phase 2 processing (class documentation).

   if class.meta then
      local newFields = {}

      -- NB: Some classes don't output any fields (which is permissable)

      local metaFields = class.meta.subFields
      if table.empty(metaFields) and (class.meta.classID is class.meta.baseClassID) then
         metaFields = class.meta.fields
      end

      if table.empty(metaFields) then metaFields = { } end

      for k, f in ipairs(metaFields) do
         local def = getMetaFieldDefinition(f)
         if def and (def.synonym != true) then
            local f = findClassField(class, def.name) -- Retrieve field parsed from FDL, if defined
            if f then
               f.write   = def.write
               f.read    = def.read
               f.flags   = def.flags
               f.access  = def.access ?? def.access
               f.private = f.private ?? def.private
               if not f.type then f.type = tostring(def.type) end
            else
               def.virtual = true
               def.fullType = glTypes.void -- Dummy
               table.insert(newFields, def)
            end
         end
      end

      for _, f in ipairs(newFields) do
         table.insert(class.fields, f)
      end
   end

   class.lookupFields = { }
   if class.fields then
      for _, f in ipairs(class.fields) do
         class.lookupFields[f.name] = f
      end
   end

   -- NB: FieldArray is not output because as yet fields (including virtual fields) cannot be accurately
   -- described without the developer writing a custom field configuration in C.

   local fdef = 'static const struct FieldArray cl' .. class.name .. 'Fields[] = {\n'
   class.longestType = 0
   local name_len = 0
   class.longestFieldType = 0  -- Holds the longest field + type string
   for _, f in ipairs(class.fields) do
      if not f.virtual then
         local field_name = cName(f)

         if field_name:len() > name_len then name_len = field_name:len() end

         if f.type:len() > class.longestType then
            if f.type:len() < 10 then
               class.longestType = f.type:len()
            end
         end

         if f.type:len() + field_name:len() > class.longestFieldType then
            class.longestFieldType = f.type:len() + 2 + field_name:len()
         end

         if f.ref then
            cdef ..= outputLookup(class.name .. f.name, f.ref.list)
         end

         assert(f.fullType??, 'The fullType is not defined for field ' .. tostring(f.name))

         fdef ..= "   { \"" .. f.name .. "\", " .. f.fullType.fd .. ", 0, nullptr, nullptr },\n"
      end
   end
   fdef ..= '};\n\n'

   return cdef
end

----------------------------------------------------------------------------------------------------------------------
-- Load and process an FDL file source, then process raw source files containing -FUNCTION- definitions.

function parseSourceFiles()
   if (glFeedback is 'verbose') then print('Processing source files...') end

   local srcFiles = { }

   for i=1, arg('files:size') ?? 0 do
      table.insert(srcFiles, arg('files(' .. (i-1) .. ')'))
   end

   if (#srcFiles < 1) then
      if (glFeedback is 'verbose') then print('No source files were detected.') end
      return
   end

   local path
   for _, path in pairs(srcFiles) do
      -- Process --IDL_BEGIN/END-- sections, which allow the developer to embed FDL functions in the source code.

      local idlExtract, extract
      local content = file.readAll(path)
      content = '\n' .. content:gsub('\r\n', '\n')
      for extract in string.gmatch(content, '%-%-IDL_BEGIN%-%-(.-)%-%-IDL_END%-%-') do
         idlExtract = (idlExtract ?? '') .. extract
      end

      if idlExtract then
         exec(idlExtract)
      end

      -- Process -FUNCTION- definitions

      if glFeedback is 'verbose' then
         print()
         print('File: ' .. path)
      end

      -- Extract possible content from within comments so that we don't get interference from the code while parsing.

      local extracted_content = ''
      for extract in string.gmatch(content, '[^/]/%*+(.-)%*+/') do
         extracted_content = extracted_content .. '\n' .. extract
      end
      content = extracted_content

      -- Parse each line individually

      local currentExtract = nil
      local processing = nil
      for line in string.gmatch(content, '(.-\n)') do
         if line?? then
            line = line:match('^(.*%S)') ?? ''
            if (line is '-CATEGORY-') or (line is '-FUNCTION-') then
               if processing is '-CATEGORY-' then parseCategory(currentExtract) end
               if processing is '-FUNCTION-' then parseFunction(currentExtract) end
               currentExtract = ''
               processing = line
            elseif (line is '-END-') or (line is '-INTERNAL-') then
               if processing is '-CATEGORY-' then parseCategory(currentExtract) end
               if processing is '-FUNCTION-' then parseFunction(currentExtract) end
               currentExtract = nil
               processing = nil
            elseif processing then
               currentExtract ..= line .. '\n'
            end
         elseif processing then
            currentExtract ..= '\n'
         end
      end

      if processing is '-CATEGORY-' then parseCategory(currentExtract) end
      if processing is '-FUNCTION-' then parseFunction(currentExtract) end
   end
end

----------------------------------------------------------------------------------------------------------------------

function parseCategory(extract)
   extract = '-CATEGORY-\n' .. extract:trim() .. '\n-END-\n'
   glCategory = extract:match('\n[Nn]ame:%s+(.-)\n')
   glCategories[glCategory] = { name=glCategory }
end

----------------------------------------------------------------------------------------------------------------------
-- Used by processSourceFiles() to process -FUNCTION- descriptions in self-documenting source code.

function parseFunction(extract)
   if not extract?? then return end

   extract = '-FUNCTION-\n' .. extract:trim() .. '\n-END-\n'

   local name, comment = extract:match('\n(%w+):%s+(.-)\n')
   local status      = extract:match('\n[Ss]tatus:%s+(.-)\n')
   local category    = extract:match('\n[Cc]ategory:%s+(.-)\n')
   local ext_proto   = extract:match('\n[Ee]xtPrototype:%s+(.-)\n')
   local attrib      = extract:match('\n[Aa]ttribute:%s+(.-)\n') -- This value is appended to the jump table name
   local description = extract:match('\n\n(.-)\n%-[A-Z]+%-\n')

   if name:find('%(%)') then
      name = name:match('(%a+)()')
   end

   assert(name??, 'Failed to extract a name tag from -FUNCTION- definition.')
   assert(comment??, "Failed to extract a comment tag from -FUNCTION- definition of '" .. name .. "'")
   assert(description??, "Failed to extract a description from -FUNCTION- definition of '" .. name .. "'")

   if glFeedback is "verbose" then
      print("Processing function " .. name .. "()")
   end

   local def = {
      input     = extract:match("\n%-INPUT%-\n(.-)\n%-[A-Z]+%-\n"),
      ext_proto = ext_proto,
      attrib    = attrib
   }

   local errors = extract:match("\n%-ERRORS%-\n(.-)%-END%-")
   if errors?? then
      def.result = cType({ type="error", values={ }, isFunction=true }, "Function " .. name)

      for line in string.gmatch(errors, "(.-)\n") do
         if not line?? then break end -- A double line-break forces a premature end to error processing.

         local ecode, comment = line:match("(%a-):%s+(.+)")
         if ecode?? and comment?? then
            local codeValue = _G['ERR_' .. ecode]
            if not codeValue then
               print('Error code "' .. ecode .. '" referenced in function ' .. name .. '() is invalid.')
            else
               table.insert(def.result.values, { code = codeValue, codeName = ecode, msg = comment })
            end
         else
            ecode = line:match("(%a+):?")
            if ecode?? then
               local codeValue = _G['ERR_' .. ecode]
               if not codeValue then
                  print('Error code "' .. ecode .. '" referenced in function ' .. name .. '() is invalid.')
               else
                  table.insert(def.result.values, { code = codeValue, codeName = ecode, msg = mSys.GetErrorMsg(codeValue) })
               end
            end
         end
      end

      table.sort(def.result.values, function(a,b) return a.code < b.code end)
   else
      local result = extract:match("\n%-RESULT%-\n(.-)\n%-END%-")
      if result?? then
         local ext_type, comment = result:match("(.-):%s-(.+)$")
         assert(ext_type, "Incorrectly defined result section in function '" .. name .. "'")
         def.result = cType({ type=ext_type, comment=comment:trim(), isFunction=true, isResponse=true }, "Function " .. name)
      end
   end

   idlFunction(name, (category ?? glCategory), comment, status, description, def)
end
