
----------------------------------------------------------------------------------------------------------------------

global function parseClassEntry(Class, Type, Extract)
   if Type is '-CLASS-' then
      parseClassHeader(Class, Extract)
   elseif Type is '-METHOD-' then
      parseMethod(Class, Extract)
   elseif Type is '-ACTION-' then
      parseAction(Class, Extract)
   elseif Type is '-FIELD-' then
      parseField(Class, Extract)
   end
end

----------------------------------------------------------------------------------------------------------------------

global function parseClassHeader(Class, Extract)
   Extract = '-CLASS-\n' .. Extract:trim() .. '\n-END-\n'
   local name
   name, Class.comment = Extract:match('\n(%w+):%s+(.-)\n')
   Class.status = Extract:match('\n[Ss]tatus:%s+(.-)\n')
   assert(name:lower() is Class.name:lower(), "The name specified in the -CLASS- header '" .. name .. "' does not match the name specified in the class() call '" .. Class.name .. "'")
   Class.description = Extract:match("\n\n(.-)\n%-[A-Z]+%-\n")
end

----------------------------------------------------------------------------------------------------------------------

global function parseAction(Class, Extract)
   Extract = '-ACTION-\n' .. Extract:trim() .. '\n-END-\n'

   name    = Extract:match('\n[Nn]ame:%s+(.-)\n')
   comment = Extract:match('\n[Cc]omment:%s+(.-)\n')
   if not name then
      name, comment = Extract:match('\n(%w+):%s+(.-)\n')
   end

   action = Class.actions[name]
   if not action then action = { } end
   action.name = name
   action.comment = comment
   action.description = Extract:match('\n\n(.-)\n%-[A-Z]+%-\n')

   errors = Extract:match('\n%-ERRORS%-\n(.-)%-END%-')
   if errors?? then
      action.results = { }

      for line in string.gmatch(errors, '(.-)\n') do
         if not line?? then break end -- A double line-break forces a premature end to error processing.

         ecode, comment = line:match('(%a-):%s+(.+)')
         if ecode then
            table.insert(action.results, { code = _G['ERR_' .. ecode], codeName = ecode, msg = comment })
         else
            ecode = line:match('(%a+):?')
            if ecode?? then
               table.insert(action.results, { code = _G['ERR_' .. ecode], codeName = ecode, msg = mSys.GetErrorMsg(_G['ERR_' .. ecode]) })
            end
        end
      end

      table.sort(action.results, function(a,b) return a.code < b.code end)
   end
end

----------------------------------------------------------------------------------------------------------------------

global function parseField(class, Extract)
   Extract = '-FIELD-\n' .. Extract:trim() .. '\n-END-\n'
   lookup  = Extract:match('\n[Ll]ookup:%s+(.-)\n')
   status  = Extract:match('\n[Ss]tatus:%s+(.-)\n')
   name, comment = Extract:match('\n(%w+):%s+(.-)\n')

   description = Extract:match('\n\n(.-)\n%-[A-Z]+%-\n')

   if not name then
      print('Name not defined for -FIELD- definition.')
      return
   end

   f = findClassField(class, name)
   if f then
      if comment?? then f.comment = comment end
      if lookup?? then
         if glCustomTypes[lookup] then
            f.lookup = lookup
            class.references['TYPE:' .. lookup] = 1
         else
            print('Requested lookup "' .. lookup .. '" is not known.')
         end
      end
      if string.match((status ?? ''), '^[Pp]rivate') or string.match((comment ?? ''), '^[Pp]rivate') then
         f.private = true
         f.access = 'Private'
      end
      f.description = description
   elseif class.meta then
      print("Field '" .. class.name .. "." .. tostring(name) .. "' is not defined in the FDL or compiled class spec.")
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Convert a parameter string such as "int width: The width of the image"

global function parseParameterString(Parameter)
   param = { }
   param.comment = Parameter:match('^.+:%s-(.+)$')
   if param.comment?? then Parameter = Parameter:match('^(.+):%s-.+$') end
   param.type, param.name = Parameter:match('^%s*(.+)%s+([^%s]+)%s-$')
   if param.type then
      param.type = param.type:trim()
      param.name = param.name:trim()
      param.comment = param.comment:trim()
      return param
   end
end

----------------------------------------------------------------------------------------------------------------------

global function parseMethod(Class, Extract)
   Extract = '-METHOD-\n' .. Extract:trim() .. '\n-END-\n'

   name    = Extract:match('\n[Nn]ame:%s+(.-)\n')
   comment = Extract:match('\n[Cc]omment:%s+(.-)\n')
   if not name then
      name, comment = Extract:match('\n(%w+):%s+(.-)\n')
   end

   status      = Extract:match('\n[Ss]tatus:%s+(.-)\n')
   description = Extract:match('\n\n(.-)\n%-[A-Z]+%-\n')

   if name:find('%(%)') then
      name = name:match('(%a+)()')
   end

   assert(name??, 'Failed to extract a name tag from -METHOD- definition.')
   assert(comment??, "Failed to extract a comment tag from -METHOD- definition of '" .. name .. "'")
   assert(description??, "Failed to extract a description from -METHOD- definition of '" .. name .. "'")

   if glFeedback is 'verbose' then print('Processing method ' .. name) end

   local method -- Retrieve the definition for this method
   if Class.methods then
      method = Class.lookupMethods[name]
      assert(method, "Method '" .. name .. "' is not registered in the FDL.")
   else
      error("Methods need to be pre-defined for class '" .. tostring(Class.name) .. "' with methods()")
   end

   method.params = { }
   method.description = description
   method.comment = comment
   method.status = status

   input = Extract:match('\n%-INPUT%-\n(.-)\n\n%-[A-Z]+%-\n')

   errors = Extract:match('\n%-ERRORS%-\n(.-)%-END%-')
   if errors?? then
      method.results = { }

      for line in string.gmatch(errors, '(.-)\n') do
         if not line?? then break end -- A double line-break forces a premature end to error processing.

         ecode, comment = line:match('(%a-):%s+(.+)')
         if ecode then
            table.insert(method.results, { code = _G['ERR_' .. ecode], codeName = ecode, msg = comment })
         else
            ecode = line:match('(%a+):?')
            if ecode?? then
               table.insert(method.results, { code = _G['ERR_' .. ecode], codeName = ecode, msg = mSys.GetErrorMsg(_G['ERR_' .. ecode]) })
            end
         end
      end

      table.sort(method.results, function(a,b) return (a.code ?? -1) < (b.code ?? -1) end)
   end

   if input?? then
      for line, content in ipairs(input:split('\n')) do
         param = parseParameterString(content)
         if param then
            cType(param, name)
            table.insert(method.params, param)
         elseif content:trim()?? then
            error("Unable to process line '" .. (content ?? "NULL") .. "' for method '" .. name .. "'")
         end
      end
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Process the formal field definitions in a class spec.

global function parseClassFields(Class, ClientSpec)
   cdef = ''

   -- Parse fields defined in the FDL

   Class.fields = extractFields(ClientSpec, Class.name)

   -- Add compiled fields into the field definitions.  NB: Technically this relies on a circular reference, so such
   -- information can only be taken advantage of for phase 2 processing (class documentation).

   if Class.meta then
      newFields = {}

      -- NB: Some classes don't output any fields (which is permissable)

      metaFields = Class.meta.subFields
      if (not metaFields or #metaFields == 0) and (Class.meta.classID is Class.meta.baseClassID) then
         metaFields = Class.meta.fields
      end

      if metaFields then
         for i=0,#metaFields-1 do
            f = metaFields[i]
            def = getMetaFieldDefinition(f)
            if def and def.synonym != true then
               f = findClassField(Class, def.name) -- Retrieve field parsed from FDL, if defined
               if f then
                  f.write   = def.write
                  f.read    = def.read
                  f.flags   = def.flags
                  f.access  = def.access ?? def.access
                  f.private = f.private ?? def.private
                  f.type   ?= tostring(def.type)
               else
                  def.virtual = true
                  def.fullType = glTypes.void -- Dummy
                  table.insert(newFields, def)
               end
            end
         end
      end

      for _, f in ipairs(newFields) do
         table.insert(Class.fields, f)
      end
   end

   Class.lookupFields = { }
   if Class.fields then
      for _, f in ipairs(Class.fields) do
         Class.lookupFields[f.name] = f
      end
   end

   -- NB: FieldArray is not output because as yet fields (including virtual fields) cannot be accurately
   -- described without the developer writing a custom field configuration in C.

   fdef = 'static const struct FieldArray cl' .. Class.name .. 'Fields[] = {\n'
   Class.longestType = 0
   name_len = 0
   Class.longestFieldType = 0  -- Holds the longest field + type string
   for _, f in ipairs(Class.fields) do
      if not f.virtual then
         field_name = cName(f)

         if field_name:len() > name_len then name_len = field_name:len() end

         if f.type:len() > Class.longestType then
            if f.type:len() < 10 then
               Class.longestType = f.type:len()
            end
         end

         if f.type:len() + field_name:len() > Class.longestFieldType then
            Class.longestFieldType = f.type:len() + 2 + field_name:len()
         end

         if f.ref then
            cdef ..= outputLookup(Class.name .. f.name, f.ref.list)
         end

         assert(f.fullType??, 'The fullType is not defined for field ' .. tostring(f.name))

         fdef ..= "   { \"" .. f.name .. "\", " .. f.fullType.fd .. ", 0, nullptr, nullptr },\n"
      end
   end
   fdef ..= '};\n\n'

   return cdef
end

----------------------------------------------------------------------------------------------------------------------
-- Load and process an FDL file source, then process raw source files containing -FUNCTION- definitions.

global function parseSourceFiles()
   if glFeedback is 'verbose' then print('Processing source files...') end

   srcFiles = { }

   for i=1, arg('files:size') ?? 0 do
      table.insert(srcFiles, arg('files(' .. (i-1) .. ')'))
   end

   if #srcFiles < 1 then
      if glFeedback is 'verbose' then print('No source files were detected.') end
      return
   end

   for _, path in pairs(srcFiles) do
      -- Process --IDL_BEGIN/END-- sections, which allow the developer to embed FDL functions in the source code.

      local idlExtract, extract
      content = file.readAll(path)
      content = '\n' .. content:gsub('\r\n', '\n')
      for extract in string.gmatch(content, '%-%-IDL_BEGIN%-%-(.-)%-%-IDL_END%-%-') do
         idlExtract = (idlExtract ?? '') .. extract
      end

      if idlExtract then
         exec(idlExtract)
      end

      -- Process -FUNCTION- definitions

      if glFeedback is 'verbose' then
         print()
         print('File: ' .. path)
      end

      -- Extract possible content from within comments so that we don't get interference from the code while parsing.

      extracted_content = ''
      for extract in string.gmatch(content, '[^/]/%*+(.-)%*+/') do
         extracted_content = extracted_content .. '\n' .. extract
      end
      content = extracted_content

      -- Parse each line individually

      currentExtract = nil
      processing = nil
      for line in string.gmatch(content, '(.-\n)') do
         if line?? then
            line = line:match('^(.*%S)') ?? ''
            if (line is '-CATEGORY-') or (line is '-FUNCTION-') then
               if processing is '-CATEGORY-' then parseCategory(currentExtract) end
               if processing is '-FUNCTION-' then parseFunction(currentExtract) end
               currentExtract = ''
               processing = line
            elseif (line is '-END-') or (line is '-INTERNAL-') then
               if processing is '-CATEGORY-' then parseCategory(currentExtract) end
               if processing is '-FUNCTION-' then parseFunction(currentExtract) end
               currentExtract = nil
               processing = nil
            elseif processing then
               currentExtract ..= line .. '\n'
            end
         elseif processing then
            currentExtract ..= '\n'
         end
      end

      if processing is '-CATEGORY-' then parseCategory(currentExtract) end
      if processing is '-FUNCTION-' then parseFunction(currentExtract) end
   end
end

----------------------------------------------------------------------------------------------------------------------

global function parseCategory(extract)
   extract = '-CATEGORY-\n' .. extract:trim() .. '\n-END-\n'
   global glCategory = extract:match('\n[Nn]ame:%s+(.-)\n')
   glCategories[glCategory] = { name=glCategory }
end

----------------------------------------------------------------------------------------------------------------------
-- Used by processSourceFiles() to process -FUNCTION- descriptions in self-documenting source code.

global function parseFunction(extract)
   if not extract?? then return end

   extract = '-FUNCTION-\n' .. extract:trim() .. '\n-END-\n'

   local name, comment = extract:match('\n(%w+):%s+(.-)\n')
   status      = extract:match('\n[Ss]tatus:%s+(.-)\n')
   category    = extract:match('\n[Cc]ategory:%s+(.-)\n')
   ext_proto   = extract:match('\n[Ee]xtPrototype:%s+(.-)\n')
   attrib      = extract:match('\n[Aa]ttribute:%s+(.-)\n') -- This value is appended to the jump table name
   description = extract:match('\n\n(.-)\n%-[A-Z]+%-\n')

   if name:find('%(%)') then
      name = name:match('(%a+)()')
   end

   assert(name??, 'Failed to extract a name tag from -FUNCTION- definition.')
   assert(comment??, "Failed to extract a comment tag from -FUNCTION- definition of '" .. name .. "'")
   assert(description??, "Failed to extract a description from -FUNCTION- definition of '" .. name .. "'")

   if glFeedback is "verbose" then
      print("Processing function " .. name .. "()")
   end

   def = {
      input     = extract:match("\n%-INPUT%-\n(.-)\n%-[A-Z]+%-\n"),
      ext_proto = ext_proto,
      attrib    = attrib
   }

   errors = extract:match("\n%-ERRORS%-\n(.-)%-END%-")
   if errors?? then
      def.result = cType({ type="error", values={ }, isFunction=true }, "Function " .. name)

      for line in string.gmatch(errors, "(.-)\n") do
         line ?? break -- A double line-break forces a premature end to error processing.

         local ecode, comment = line:match("(%a-):%s+(.+)")
         if ecode?? and comment?? then
            codeValue = _G['ERR_' .. ecode]
            if not codeValue then
               print('Error code "' .. ecode .. '" referenced in function ' .. name .. '() is invalid.')
            else
               table.insert(def.result.values, { code = codeValue, codeName = ecode, msg = comment })
            end
         else
            ecode = line:match("(%a+):?")
            if ecode?? then
               codeValue = _G['ERR_' .. ecode]
               if not codeValue then
                  print('Error code "' .. ecode .. '" referenced in function ' .. name .. '() is invalid.')
               else
                  table.insert(def.result.values, { code = codeValue, codeName = ecode, msg = mSys.GetErrorMsg(codeValue) })
               end
            end
         end
      end

      table.sort(def.result.values, function(a,b) return a.code < b.code end)
   else
      result = extract:match("\n%-RESULT%-\n(.-)\n%-END%-")
      if result?? then
         local ext_type, comment = result:match("(.-):%s-(.+)$")
         assert(ext_type, "Incorrectly defined result section in function '" .. name .. "'")
         def.result = cType({ type=ext_type, comment=comment:trim(), isFunction=true, isResponse=true }, "Function " .. name)
      end
   end

   idlFunction(name, (category ?? glCategory), comment, status, description, def)
end
