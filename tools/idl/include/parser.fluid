
----------------------------------------------------------------------------------------------------------------------

function parseClassEntry(Class, Type, Extract)
   if (Type == '-CLASS-') then
      parseClassHeader(Class, Extract)
   elseif (Type == '-METHOD-') then
      parseMethod(Class, Extract)
   elseif (Type == '-ACTION-') then
      parseAction(Class, Extract)
   elseif (Type == '-FIELD-') then
      parseField(Class, Extract)
   end
end

----------------------------------------------------------------------------------------------------------------------

function parseClassHeader(Class, Extract)
   Extract = '-CLASS-\n' .. Extract:trim() .. '\n-END-\n'
   local name
   name, Class.comment = Extract:match('\n(%w+):%s+(.-)\n')
   Class.status = Extract:match('\n[Ss]tatus:%s+(.-)\n')

   if (name:lower() != Class.name:lower()) then
      error("The name specified in the -CLASS- header '" .. name .. "' does not match the name specified in the class() call '" .. Class.name .. "'")
   end

   Class.description = Extract:match("\n\n(.-)\n%-[A-Z]+%-\n")
end

----------------------------------------------------------------------------------------------------------------------

function parseAction(class, extract)
   extract = '-ACTION-\n' .. extract:trim() .. '\n-END-\n'

   local name    = extract:match('\n[Nn]ame:%s+(.-)\n')
   local comment = extract:match('\n[Cc]omment:%s+(.-)\n')
   if (name == nil) then
      name, comment = extract:match('\n(%w+):%s+(.-)\n')
   end

   local action = class.actions[name]
   if (action == nil) then action = { } end
   action.name = name
   action.comment = comment
   action.description = extract:match('\n\n(.-)\n%-[A-Z]+%-\n')

   local errors = extract:match('\n%-ERRORS%-\n(.-)%-END%-')
   if nz(errors) then
      action.results = { }

      for line in string.gmatch(errors, '(.-)\n') do
         if not nz(line) then break end -- A double line-break forces a premature end to error processing.

         local ecode, comment = line:match('(%a-):%s+(.+)')
         if (ecode != nil) then
            table.insert(action.results, { code = _G['ERR_' .. ecode], codeName = ecode, msg = comment })
         else
            ecode = line:match('(%a+):?')
            if nz(ecode) then
               table.insert(action.results, { code = _G['ERR_' .. ecode], codeName = ecode, msg = mSys.GetErrorMsg(_G['ERR_' .. ecode]) })
            end
        end
      end

      table.sort(action.results, function(a,b) return a.code < b.code end)
   end
end

----------------------------------------------------------------------------------------------------------------------

function parseField(class, extract)
   extract = '-FIELD-\n' .. extract:trim() .. '\n-END-\n'
   local lookup  = extract:match('\n[Ll]ookup:%s+(.-)\n')
   local status  = extract:match('\n[Ss]tatus:%s+(.-)\n')
   local name, comment = extract:match('\n(%w+):%s+(.-)\n')

   local description = extract:match('\n\n(.-)\n%-[A-Z]+%-\n')

   if not name then
      print('Name not defined for -FIELD- definition.')
      return
   end

   local f = findClassField(class, name)
   if (f != nil) then
      if nz(comment) then f.comment = comment end
      if nz(lookup) then
         if (glCustomTypes[lookup]) then
            f.lookup = lookup
            class.references['TYPE:' .. lookup] = 1
         else
            print('Requested lookup "' .. lookup .. '" is not known.')
         end
      end
      if string.match(nz(status,''), '^[Pp]rivate') or string.match(nz(comment,''), '^[Pp]rivate') then
         f.private = true
         f.access = 'Private'
      end
      f.description = description
   elseif (class.meta != nil) then
      print("Field '" .. class.name .. "." .. nz(name,'NIL') .. "' is not defined in the FDL or compiled class spec.")
   end
end

----------------------------------------------------------------------------------------------------------------------

function parseMethod(class, extract)
   extract = '-METHOD-\n' .. extract:trim() .. '\n-END-\n'

   local name    = extract:match('\n[Nn]ame:%s+(.-)\n')
   local comment = extract:match('\n[Cc]omment:%s+(.-)\n')
   if (name == nil) then
      name, comment = extract:match('\n(%w+):%s+(.-)\n')
   end

   local status      = extract:match('\n[Ss]tatus:%s+(.-)\n')
   local description = extract:match('\n\n(.-)\n%-[A-Z]+%-\n')

   if (name:find('%(%)') != nil) then
      name = name:match('(%a+)()')
   end

   if not nz(name) then error('Failed to extract a name tag from -METHOD- definition.') end
   if not nz(comment) then error("Failed to extract a comment tag from -METHOD- definition of '" .. name .. "'")  end
   if not nz(description) then error("Failed to extract a description from -METHOD- definition of '" .. name .. "'") end

   if (glFeedback == 'verbose') then print('Processing method ' .. name) end

   local method -- Retrieve the definition for this method
   if (class.methods != nil) then
      method = class.lookupMethods[name]
      if (method == nil) then error("Method '" .. name .. "' is not registered in the FDL.") end
   else
      error("Methods need to be pre-defined for class '" .. nz(class.name,"NIL") .. "' with methods()")
   end

   method.params = { }
   method.description = description
   method.comment = comment
   method.status = status

   local input = extract:match('\n%-INPUT%-\n(.-)\n\n%-[A-Z]+%-\n')

   local errors = extract:match('\n%-ERRORS%-\n(.-)%-END%-')
   if nz(errors) then
      method.results = { }

      for line in string.gmatch(errors, '(.-)\n') do
         if not nz(line) then break end -- A double line-break forces a premature end to error processing.

         local ecode, comment = line:match('(%a-):%s+(.+)')
         if (ecode != nil) then
            table.insert(method.results, { code = _G['ERR_' .. ecode], codeName = ecode, msg = comment })
         else
            ecode = line:match('(%a+):?')
            if nz(ecode) then
               table.insert(method.results, { code = _G['ERR_' .. ecode], codeName = ecode, msg = mSys.GetErrorMsg(_G['ERR_' .. ecode]) })
            end
         end
      end

      table.sort(method.results, function(a,b) return nz(a.code,-1) < nz(b.code,-1) end)
   end

   if nz(input) then
      for line, content in ipairs(input:split('\n')) do
         local param = { }
         param.comment = content:match('^.+:%s-(.+)$')
         if nz(param.comment) then content = content:match('^(.+):%s-.+$') end
         param.type, param.name = content:match('^%s*(.+)%s+([^%s]+)%s-$')
         if (param.type != nil) then
            param.type = param.type:trim()
            param.name = param.name:trim()
            param.comment = param.comment:trim()
            cType(param, name)
            table.insert(method.params, param)
         elseif nz(content:trim()) then
            error("Unable to process line '" .. nz(content,"NULL") .. "' for method '" .. name .. "'")
         end
      end
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Process the formal field definitions in a class spec.

function parseClassFields(class, ClientSpec)
   local cdef = ''

   -- Parse fields defined in the FDL

   class.fields = extractFields(ClientSpec, class.name)

   -- Add compiled fields into the field definitions.  NB: Technically this relies on a circular reference, so such
   -- information can only be taken advantage of for phase 2 processing (class documentation).

   if (class.meta != nil) then
      local newFields = {}

      -- NB: Some classes don't output any fields (which is permissable)

      local metaFields = class.meta.subFields
      if (not metaFields) and (class.meta.classID == class.meta.baseClassID) then
         metaFields = class.meta.fields
      end

      for k, f in ipairs(nz(metaFields, { })) do
         local def = getMetaFieldDefinition(f)
         if (def != nil) and (def.synonym != true) then
            local f = findClassField(class, def.name) -- Retrieve field parsed from FDL, if defined
            if (f != nil) then
               f.write  = def.write
               f.read   = def.read
               f.flags  = def.flags
               f.access = nz(def.access, def.access)
               f.private = nz(f.private, def.private)
               if (f.type == nil) then f.type = nz(def.type,'NIL') end
            else
               def.virtual = true
               def.fullType = glTypes.void -- Dummy
               table.insert(newFields, def)
            end
         end
      end

      for _, f in ipairs(newFields) do
         table.insert(class.fields, f)
      end
   end

   class.lookupFields = { }
   if (class.fields != nil) then
      for _, f in ipairs(class.fields) do
         class.lookupFields[f.name] = f
      end
   end

   -- NB: FieldArray is not output because as yet fields (including virtual fields) cannot be accurately
   -- described without the developer writing a custom field configuration in C.

   local fdef = 'static const struct FieldArray cl' .. class.name .. 'Fields[] = {\n'
   class.longestType = 0
   local name_len = 0
   class.longestFieldType = 0  -- Holds the longest field + type string
   for _, f in ipairs(class.fields) do
      if not f.virtual then
         local field_name = cName(f)

         if (field_name:len() > name_len) then name_len = field_name:len() end

         if (f.type:len() > class.longestType) then
            if (f.type:len() < 10) then
               class.longestType = f.type:len()
            end
         end

         if (f.type:len() + field_name:len() > class.longestFieldType) then
            class.longestFieldType = f.type:len() + 2 + field_name:len()
         end

         if (f.ref != nil) then
            cdef = cdef .. outputLookup(class.name .. f.name, f.ref.list)
         end

         if not nz(f.fullType) then error('The fullType is not defined for field ' .. nz(f.name,'NIL')) end

         fdef = fdef .. "   { \"" .. f.name .. "\", " .. f.fullType.fd .. ", 0, nullptr, nullptr },\n"
      end
   end
   fdef = fdef .. '};\n\n'

   return cdef
end

----------------------------------------------------------------------------------------------------------------------
-- Load and process an FDL file source, then process raw source files containing -FUNCTION- definitions.

function parseSourceFiles()
   if (glFeedback == 'verbose') then print('Processing source files...') end

   local srcFiles = { }

   for i=1,nz(arg('files:size'), 0) do
      table.insert(srcFiles, arg('files(' .. (i-1) .. ')'))
   end

   if (#srcFiles < 1) then
      if (glFeedback == 'verbose') then print('No source files were detected.') end
      return
   end

   local path
   for _, path in pairs(srcFiles) do
      -- Process --IDL_BEGIN/END-- sections, which allow the developer to embed FDL functions in the source code.

      local idlExtract, extract
      local content = file.readAll(path)
      content = '\n' .. content:gsub('\r\n', '\n')
      for extract in string.gmatch(content, '%-%-IDL_BEGIN%-%-(.-)%-%-IDL_END%-%-') do
         idlExtract = nz(idlExtract,'') .. extract
      end

      if (idlExtract != nil) then
         exec(idlExtract)
      end

      -- Process -FUNCTION- definitions

      if (glFeedback == 'verbose') then
         print()
         print('File: ' .. path)
      end

      -- Extract possible content from within comments so that we don't get interference from the code while parsing.

      local extracted_content = ''
      for extract in string.gmatch(content, '[^/]/%*+(.-)%*+/') do
         extracted_content = extracted_content .. '\n' .. extract
      end
      content = extracted_content

      -- Parse each line individually

      local currentExtract = nil
      local processing = nil
      for line in string.gmatch(content, '(.-\n)') do
         if nz(line) then
            line = nz(line:match('^(.*%S)'),'')
            if (line == '-CATEGORY-') or (line == '-FUNCTION-') then
               if (processing == '-CATEGORY-') then parseCategory(currentExtract) end
               if (processing == '-FUNCTION-') then parseFunction(currentExtract) end
               currentExtract = ''
               processing = line
            elseif (line == '-END-') or (line == '-INTERNAL-') then
               if (processing == '-CATEGORY-') then parseCategory(currentExtract) end
               if (processing == '-FUNCTION-') then parseFunction(currentExtract) end
               currentExtract = nil
               processing = nil
            elseif (processing != nil) then
               currentExtract = currentExtract .. line .. '\n'
            end
         elseif (processing != nil) then
            currentExtract = currentExtract .. '\n'
         end
      end

      if (processing == '-CATEGORY-') then parseCategory(currentExtract) end
      if (processing == '-FUNCTION-') then parseFunction(currentExtract) end
   end
end

----------------------------------------------------------------------------------------------------------------------

function parseCategory(extract)
   extract = '-CATEGORY-\n' .. extract:trim() .. '\n-END-\n'
   glCategory = extract:match('\n[Nn]ame:%s+(.-)\n')
   glCategories[glCategory] = { name=glCategory }
end

----------------------------------------------------------------------------------------------------------------------
-- Used by processSourceFiles() to process -FUNCTION- descriptions in self-documenting source code.

function parseFunction(extract)
   if not nz(extract) then return end

   extract = '-FUNCTION-\n' .. extract:trim() .. '\n-END-\n'

   local name, comment = extract:match('\n(%w+):%s+(.-)\n')
   local status      = extract:match('\n[Ss]tatus:%s+(.-)\n')
   local category    = extract:match('\n[Cc]ategory:%s+(.-)\n')
   local ext_proto   = extract:match('\n[Ee]xtPrototype:%s+(.-)\n')
   local attrib      = extract:match('\n[Aa]ttribute:%s+(.-)\n') -- This value is appended to the jump table name
   local description = extract:match('\n\n(.-)\n%-[A-Z]+%-\n')

   if (name:find('%(%)') != nil) then
      name = name:match('(%a+)()')
   end

   if not nz(name) then
      error('Failed to extract a name tag from -FUNCTION- definition.')
   end

   if not nz(comment) then
      error("Failed to extract a comment tag from -FUNCTION- definition of '" .. name .. "'")
   end

   if not nz(description) then
      error("Failed to extract a description from -FUNCTION- definition of '" .. name .. "'")
   end

   if (glFeedback == "verbose") then
      print("Processing function " .. name .. "()")
   end

   local def = {
      input     = extract:match("\n%-INPUT%-\n(.-)\n%-[A-Z]+%-\n"),
      ext_proto = ext_proto,
      attrib    = attrib
   }

   local errors = extract:match("\n%-ERRORS%-\n(.-)%-END%-")
   if nz(errors) then
      def.result = cType({ type="error", values={ }, isFunction=true }, "Function " .. name)

      for line in string.gmatch(errors, "(.-)\n") do
         if not nz(line) then break end -- A double line-break forces a premature end to error processing.

         local ecode, comment = line:match("(%a-):%s+(.+)")
         if nz(ecode) and nz(comment) then
            local codeValue = _G['ERR_' .. ecode]
            if not codeValue then
               print('Error code "' .. ecode .. '" referenced in function ' .. name .. '() is invalid.')
            else
               table.insert(def.result.values, { code = codeValue, codeName = ecode, msg = comment })
            end
         else
            ecode = line:match("(%a+):?")
            if nz(ecode) then
               codeValue = _G['ERR_' .. ecode]
               if not codeValue then
                  print('Error code "' .. ecode .. '" referenced in function ' .. name .. '() is invalid.')
               else
                  table.insert(def.result.values, { code = codeValue, codeName = ecode, msg = mSys.GetErrorMsg(codeValue) })
               end
            end
         end
      end

      table.sort(def.result.values, function(a,b) return a.code < b.code end)
   else
      local result = extract:match("\n%-RESULT%-\n(.-)\n%-END%-")
      if nz(result) then
         local ext_type, comment = result:match("(.-):%s-(.+)$")
         if (ext_type == nil) then error("Incorrectly defined result section in function '" .. name .. "'") end
         def.result = cType({ type=ext_type, comment=comment:trim(), isFunction=true, isResponse=true }, "Function " .. name)
      end
   end

   idlFunction(name, nz(category, glCategory), comment, status, description, def)
end
