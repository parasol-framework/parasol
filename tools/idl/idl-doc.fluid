-- Extended documentation parsing functionality; included by idl-c

   require 'common'

----------------------------------------------------------------------------------------------------------------------

function ignoreAction(actionID)
   if (actionID == nil) then return nil end
   return glIgnoreList[actionID]
end

glIgnoreList = { }
glIgnoreList[AC_DataFeed] = true
glIgnoreList[AC_Free] = true
glIgnoreList[AC_FreeWarning] = true
glIgnoreList[AC_Init] = true
glIgnoreList[AC_NewChild] = true
glIgnoreList[AC_NewObject] = true
glIgnoreList[AC_NewOwner] = true
glIgnoreList[nz(AC_NewPlacement,0)] = true

function setAction(Action, Options)
   for k, v in pairs(Options) do
      glActions[Action][k] = v
   end
end

----------------------------------------------------------------------------------------------------------------------

setAction('Activate', {
   comment   = 'Performs the native action of the object.',
   prototype = 'ERR acActivate(*Object)'
})

setAction('Clear', {
   comment   = 'Clears an object\'s data.',
   prototype = 'ERR acClear(*Object)'
})

setAction('Clipboard', {
   comment   = 'Copy and paste information to and from clipboard objects.',
   prototype = 'ERR acClipboard(*Object, OBJECTID Clipboard, CLIPMODE Mode)',
   params    = {
      { name='Mode', type='CLIPMODE', lookup='CLIPMODE', comment='The mode that will be used to shift data between the target object and clipboard system.' }
   }
})

setAction('CopyData', {
   comment   = 'Copies one object\'s data to another.',
   prototype = 'ERR acCopyData(*Object, OBJECTID Dest)',
   params    = {
      { name='Dest', type='OBJECTID', comment='The unique ID of the destination object.' }
   }
})

setAction('DataFeed', {
   comment   = 'Provides a mechanism for feeding data to objects.',
   prototype = 'ERR acDataFeed(*Object, OBJECTID Object, DATA Datatype, APTR Buffer, INT Size)',
   params    = {
      { name='Object', type='OBJECTID', comment='Must refer to the unique ID of the object that you represent. If you do not represent an object, set this parameter to the current task ID.' },
      { name='Datatype', type='DATA', lookup='DATA', comment='The type of data being sent.' },
      { name='Buffer', type='APTR', comment='The data being sent to the target object.' },
      { name='Size', type='INT', comment='The size of the data in Buffer.' }
   }
})

setAction('Deactivate', {
   comment   = 'Stops an object from performing its native activities.',
   prototype = 'ERR acDeactivate(*Object)'
})

setAction('Disable', {
   comment   = 'Disables an object.',
   prototype = 'ERR acDisable(*Object)'
})

setAction('DragDrop', {
   comment   = 'Manages drag and drop from one object to another.',
   prototype = 'ERR acDragDrop(*Object, OBJECTID Source, INT Item, DATA Datatype)',
   params    = {
      { name='Source', type='OBJECTID', comment='Refers to the object containing the source data.' },
      { name='Item', type='INT', comment='An item ID, relevant to the source object.' },
      { name='Datatype', type='DATA', lookup='DATA', comment='The type of data represented by the source item.' }
   }
})

setAction('Draw', {
   comment   = 'Draws object graphics to drawable areas.',
   prototype = 'ERR acDraw(*Object, DOUBLE X, DOUBLE Y, DOUBLE Width, DOUBLE Height)',
   params    = {
      { name='X', type='INT', comment='The X position of the region to be drawn.' },
      { name='Y', type='INT', comment='The Y position of the region to be drawn.' },
      { name='Width', type='INT', comment='The width of the region to be drawn.' },
      { name='Height', type='INT', comment='The height of the region to be drawn.' }
   }
})

setAction('Enable', {
   comment   = 'Restore the state of a disabled object.',
   prototype = 'ERR acEnable(*Object)'
})

setAction('Flush', {
   comment   = 'Flush buffered data from an object.',
   prototype = 'ERR acFlush(*Object)'
})

setAction('Focus', {
   comment   = 'Focus on this object in the user interface.',
   prototype = 'ERR acFocus(*Object)'
})

setAction('FreeWarning', {
   comment = 'Used for receiving an early warning before an object is removed.'
})

setAction('Free', {
   comment   = 'Removes the object and its resources.',
   prototype = 'ERR FreeResource(*Object)'
})

setAction('GetKey', {
   comment   = 'Retrieves custom key values that are not defined by an object\'s structure.',
   prototype = 'ERR acGetKey(*Object, CSTRING Key, STRING Value, INT Size)',
   params    = {
      { name='Key', type='CSTRING', comment='The name of a key value.' },
      { name='Value', type='STRING', comment='Pointer to a buffer space large enough to hold the retrieved value.' },
      { name='Size', type='INT', comment='Indicates the byte size of the Buffer.' }
   }
})

setAction('Hide', {
   comment   = 'Hides a visible object from the view of the user.',
   prototype = 'ERR acHide(*Object)'
})

setAction('Init', {
   comment   = 'Initialises an object so that it is ready for active use.',
   prototype = 'ERR InitObject(*Object)'
})

setAction('Lock', {
   comment   = "Lock the underlying data or representation of the object.",
   prototype = 'ERR acLock(*Object)'
})

setAction('LostFocus', {
   comment   = 'This internal action is called when an object loses the user focus.',
   prototype = 'ERR acLostFocus(*Object)'
})

setAction('Move', {
   comment   = 'Moves the physical representation of an object to a new location.',
   prototype = 'ERR acMove(*Object, DOUBLE DeltaX, DOUBLE DeltaY, DOUBLE DeltaZ)',
   params    = {
      { name='DeltaX', type='DOUBLE', comment='The number of units to move along the X axis.' },
      { name='DeltaY', type='DOUBLE', comment='The number of units to move along the Y axis.' },
      { name='DeltaZ', type='DOUBLE', comment='The number of units to move along the Z axis.' }
   }
})

setAction('MoveToBack', {
   comment   = 'Move an object to the back of its current location.',
   prototype = 'ERR acMoveToBack(*Object)'
})

setAction('MoveToFront', {
   comment   = 'Move an object to the front of its current location.',
   prototype = 'ERR acMoveToFront(*Object)'
})

setAction('MoveToPoint', {
   comment   = 'Moves the coordinates of an object to a new position.',
   prototype = 'ERR acMoveToPoint(*Object, DOUBLE X, DOUBLE Y, DOUBLE Z, MTF Flags)',
   params    = {
      { name='X', type='DOUBLE', comment='The new X position to move the object to.' },
      { name='Y', type='DOUBLE', comment='The new Y position to move the object to.' },
      { name='Z', type='DOUBLE', comment='The new Z position to move the object to.' },
      { name='Flags', type='MTF', lookup='MTF', comment='Set the relevant MTF flag for each provided parameter.' }
   }
})

setAction('NewChild', {
   comment = 'Used by classes that need to be alerted when an object receives a new child.'
})

setAction('NewObject', {
   comment = 'Called when a new object has been created from a base class.'
})

setAction('NewOwner', {
   comment = 'Called when the owner of an object is about to change.'
})

setAction('Next', {
   comment   = 'Move to the next record.',
   prototype = 'ERR acNext(*Object)'
})

setAction('Prev', {
   comment   = 'Move to the previous record.',
   prototype = 'ERR acPrev(*Object)'
})

setAction('Query', {
   comment   = 'Retrieves the latest information from an object.',
   prototype = 'ERR acQuery(*Object)'
})

setAction('Read', {
   comment   = 'Reads raw data information from objects.',
   prototype = 'ERR acRead(*Object, APTR Buffer, INT Length, INT *Result)',
   params    = {
      { name='Buffer', type='APTR', comment='Points a buffer that will receive the data.' },
      { name='Length', type='INT', comment='The total number of bytes to read from the object.  This value cannot exceed the size of the Buffer.' },
      { name='Result', type='INT', comment='The Read action will write this parameter with the total number of bytes read into the Buffer.' }
   }
})

setAction('Redimension', {
   comment   = 'Repositions and resizes the target object.',
   prototype = 'ERR acRedimension(*Object, DOUBLE X, DOUBLE Y, DOUBLE Z, DOUBLE Width, DOUBLE Height, DOUBLE Depth)',
   params    = {
      { name='X', type='DOUBLE', comment='The new X position to apply to the target object.' },
      { name='Y', type='DOUBLE', comment='The new Y position to apply to the target object.' },
      { name='Z', type='DOUBLE', comment='The new Z position to apply to the target object.' },
      { name='Width', type='DOUBLE', comment='The new width of the target object.' },
      { name='Height', type='DOUBLE', comment='The new height of the target object.' },
      { name='Depth', type='DOUBLE', comment='The new depth of the target object.' }
   }
})

setAction('Redo', {
   comment   = 'Reverse a previous call to the Undo action.',
   prototype = 'ERR acRedo(*Object)'
})

setAction('Refresh', {
   comment   = 'Refreshes the state of an object.',
   prototype = 'ERR acRefresh(*Object)'
})

setAction('Rename', {
   comment   = 'Renames an object.',
   prototype = 'ERR acRename(*Object, CSTRING Name)',
   params    = {
      { name='Name', type='CSTRING', comment='The new name for the object.' }
   }
})

setAction('Reset', {
   comment   = 'Resets an object to its original state.',
   prototype = 'ERR acRefresh(*Object)'
})

setAction('Resize', {
   comment   = 'Resizes objects that are represented by two or three dimensional graphics.',
   prototype = 'ERR acResize(*Object, DOUBLE Width, DOUBLE Height, DOUBLE Depth)',
   params    = {
      { name='Width', type='DOUBLE', comment='The new width of the object.' },
      { name='Height', type='DOUBLE', comment='The new height of the object.' },
      { name='Depth', type='DOUBLE', comment='The new depth of the object.' }
   }
})

setAction('SaveImage', {
   comment   = 'Saves an object\'s image to a destination object.',
   prototype = 'ERR acSaveImage(*Object, OBJECTID Dest, CLASSID ClassID)',
   params    = {
      { name='Dest', type='OBJECTID', comment='Refers to an object that will receive the encoded image data.' },
      { name='ClassID', type='CLASSID', comment='The Picture class to use for encoding the image data.' }
   }
})

setAction('SaveSettings', {
   comment   = 'Saves object settings to a physical storage location.',
   prototype = 'ERR acSaveSettings(*Object)'
})

setAction('SaveToObject', {
   comment   = 'Saves an object\'s data to a destination object.',
   prototype = 'ERR acSaveToObject(*Object, OBJECTID Dest, CLASSID ClassID)',
   params    = {
      { name='Dest', type='OBJECTID', comment='Refers to an object that will receive the encoded data.' },
      { name='ClassID', type='CLASSID', comment='Can refer to a sub-class that should be used when encoding the data.' }
   }
})

setAction('Seek', {
   comment   = 'Move the read/write marker to a new position.',
   prototype = 'ERR acSeek(*Object, DOUBLE Offset, INT Position)',
   params    = {
      { name='Offset', type='DOUBLE', comment='The desired offset to seek to, relative to the Position parameter.' },
      { name='Position', type='POS', comment='The position that defines the starting point for Offset.' }
   }
})

setAction('SetField', {
   comment = 'Private.  For use by the Core to manage context.'
})

setAction('SetKey', {
   comment   = 'Sets custom key values that are not defined by an object\'s structure.',
   prototype = 'ERR acSetKey(*Object, CSTRING Key, CSTRING Value)',
   params    = {
      { name='Key', type='CSTRING', comment='The name of the target key.' },
      { name='Value', type='CSTRING', comment='The string value to associate with Key.' }
   }
})

setAction('Show', {
   comment   = 'Makes an object visible to the user.',
   prototype = 'ERR acShow(*Object)'
})

setAction('Undo', {
   comment   = 'Reverses the last operation.',
   prototype = 'ERR acUndo(*Object)'
})

setAction('Unlock', {
   comment   = 'Remove a lock from an object.',
   prototype = 'ERR acUnlock(*Object)'
})

setAction('Write', {
   comment   = 'Writes data to objects that provide storage or output services.',
   prototype = 'ERR acWrite(*Object, APTR Buffer, INT Length, INT Result)',
   params    = {
      { name='Buffer', type='APTR', comment='A buffer containing the data that will be written to the object.' },
      { name='Length', type='INT', comment='The total number of bytes to write to the object.' },
      { name='Result', type='INT', comment='This parameter with be updated with the total number of bytes written from the Buffer.' }
   }
})

----------------------------------------------------------------------------------------------------------------------

function saveDocuments()
   -- Save module functions, if any

   local outPath = nz(glDocPath, 'sdk:docs/xml/modules/')
   if (outPath:sub(-1) != '/') then outPath = outPath .. '/' end

   if nz(glFunctions) then
      local out = docModuleHeader()
      for _, func in ipairs(glFunctions) do
         out = out .. docFunction(func)
      end
      out = out .. docTypes()
      out = out .. docStructures()
      out = out .. '</book>\n'

      if nz(glModule.name) then
         local file = obj.new('file', { flags='WRITE|NEW', path=outPath .. glModule.name:lower() .. '.xml' } )
         print("Saving module documentation to \"" .. file.path .. '"')
         file.acWrite(out)
      end
   end

   -- Save classes, if any.  Class documentation is only produced if the meta information could be loaded from
   -- a compiled module.

   if (glClasses != nil) then
      for className, cl in pairs(glClasses) do
         if (glFeedback == 'verbose') then print('Processing documentation for class ' .. nz(className,'NIL')) end

         if (cl.meta) then
            local status, err = pcall(function()
               local out = docClass(cl)
               out = out .. docTypes(cl.references)
               out = out .. docStructures(cl.references)
               out = out .. '</book>\n'
               if nz(out) then
                  local file = obj.new('file', { flags='WRITE|NEW', path=outPath .. 'classes/' .. className:lower() .. '.xml' } )
                  print("Saving XML class documentation to \"" .. file.path .. '"')
                  file.acWrite(out)
               end
            end)

            if not status then
               print('Failed to produce documentation for class ' .. className .. ': ' .. err)
            end
         else
            print('No meta information for class ' .. className)
         end
      end
   else
      print('There are no classes to save.')
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Used for extracting descriptions, notes etc.  NB: <pre> should be used for multi-line preformatting, while <code>
-- should be used for in-place code formatting.

function extractParagraph(Input, Caller, References)
   Input = Input:trim()

   -- Convert dangling XML characters: < > &

   Input = Input:gsub('<([%s\\-])', '&lt;%1') -- Less than signs
   Input = Input:gsub('([%s\\-])>', '%1&gt;') -- Greater than signs
--   Input = Input:gsub('&(%a-[^;])', '&amp;%1')

   -- Eliminate any initial leading whitespace from preformatted sections.

   Input = Input:gsub('<pre>[%c%s]*(.-)</pre>', '<pre>%1</pre>')
   Input = Input:gsub('`(.-)`', '<code>%1</code>')

   -- Wrap each line inside a <p> tag and take into account lines that start with XML tags such as <pre> or otherwise
   -- need special treatment.

   local lines = Input:split('\n')
   Input = ''
   local i = 1
   local currentParagraph = nil

   local function closeParagraph()
      if (currentParagraph != nil) then
         Input = nz(Input,'') .. '<p>' .. currentParagraph .. '</p>\n'
         currentParagraph = nil
      end
   end

   while i <= #lines do
      local line = string.trim(lines[i])
      if nz(line) then
         local action
         if (line:match('^!(%w*)$') != nil) then
            action = 'insert'
            line = line:gsub('!(%w*)', function(Lookup)
               if (glStructures[Lookup]) then
                  if References then
                     References['STRUCT:' .. Lookup] = 1
                  end
                  return '<struct lookup="' .. Lookup .. '"/>'
               elseif (glCustomTypes[Lookup]) then
                  if References then
                     References['TYPE:' .. Lookup] = 1
                  end
                  return '<types lookup="' .. Lookup .. '"/>'
               else
                  print('Unrecognised struct or constant "' .. Lookup .. '"')
                  --print(debug.traceback())
               end
            end)
         elseif (line:match('^<pre>.-') != nil) or (line:match('^<h%d>.-') != nil) or
            (line:match('^<header>.-') != nil) or (line:match('^<list.->')) then
            action = 'balance'
         elseif (line:match('^<%a+(.-)>.-</%a->.-$') != nil) then
            action = 'paragraph'
         elseif (line:match('^<%a+(.-)/>$') != nil) then
            action = 'insert'
         elseif (line:match('^<%a') != nil) then
            action = 'balance'
         else
           action = 'paragraph'
         end

         if (action == 'balance') then
            closeParagraph()
            local balance = 0
            repeat
               string.gsub(lines[i], '<(.-)>', function(key,val)
                  if (key:sub(1,1) == '/') then
                     balance = balance - 1
                  else
                     balance = balance + 1
                  end
               end)
               Input = Input .. lines[i] .. '\n'
               i = i + 1
            until (balance <= 0) or (i > #lines)
         elseif (action == 'paragraph') then
            -- Sanity check for tags that start a line but are part of a paragraph.
            if (currentParagraph == nil) then
               currentParagraph = line
            else
               currentParagraph = currentParagraph .. ' ' .. line
            end
            i = i + 1
         elseif (action == 'insert') then
            closeParagraph()
            Input = Input .. line .. '\n'
            i = i + 1
         end
      else -- Blank line
         closeParagraph()
         i = i + 1
      end
   end

   closeParagraph()

   -- Handle <field>, <method> and <action> references

   if nz(Input) and (Input:len() > 12) then
      if (Caller.meta) then
         Input = substituteReferences(Input, Caller)
      else
         Input = substituteReferences(Input, nil)
      end

      return cleanXMLString(Input, Caller)
   else
      return ''
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Use # to refer to class actions, fields, methods.
-- Use ~ for external function and module references.
-- Use @ to refer to external classes and items.
-- Use ! to refer to constants and struct definitions.  Note that if declared as a single-line paragraph, the entire
--   definition will be pulled in to that section.

function substituteReferences(String, Class)
   -- Substitute struct insertion requests

   String = String:gsub('!([A-Z]%w*)([,\n%s])', function(Lookup, Whitespace)
      if (glStructures[Lookup]) then
         if (glStructures[Lookup].restrict == 'c') then return Lookup .. Whitespace end

         if Class then Class.references['STRUCT:' .. Lookup] = 1 end

         return '<st>' .. Lookup .. '</st>' .. Whitespace
      elseif (glCustomTypes[Lookup]) then
         if Class then Class.references['TYPE:' .. Lookup] = 1 end
         return '<lk>' .. Lookup .. '</lk>' .. Whitespace
      else
         print('Unrecognised struct or constant "!' .. Lookup .. '"')
         --print(debug.traceback())
      end
   end)

   -- Substitute action and method references, identified as #MethodName()

   String = String:gsub('#([A-Z]%w*)%(%)', function(CallName)
      if (Class == nil) then
         return '<action>' .. CallName .. '</action>'
      elseif (Class.lookupMethods) and (Class.lookupMethods[CallName]) then
         return '<method>' .. CallName .. '</method>'
      elseif (glActions[CallName]) then
         return '<action>' .. CallName .. '</action>'
      else
         print('Unrecognised class action or method "' .. CallName .. '"')
      end
   end)

   -- Substitute field references, identified as #Field.

   String = String:gsub('#([A-Z]%w*)', function(Field)
      if (Class == nil) then
         -- Don't print errors regarding hexadecimal colours.
         if (Field:len() == 6) or (Field:len() == 8) then
            if (Field:match('[A-Z0-9]+') != nil) then return end
         end

         return '<fl>' .. Field .. '</fl>'
      elseif (Class.lookupFields) and (Class.lookupFields[Field]) then
         return '<fl>' .. Field .. '</fl>'
      else
         -- Don't print errors regarding hexadecimal colours.
         if (Field:len() == 6) or (Field:len() == 8) then
            if (Field:match('[A-Z0-9]+') != nil) then return end
         end

         print('Unrecognised ' .. Class.name .. ' field "' .. Field .. '"')
      end
   end)

   -- Substitute external function references, identified as ~Module.Function()

   String = String:gsub('~([A-Z]%w+)%.([A-Z]%w+)%(%)', function(ModuleName, FunctionName)
      return '<function module="' .. ModuleName .. '">' .. FunctionName .. '</function>'
   end)

   -- Substitue local function references, identified as ~Function()

   String = String:gsub('~([A-Z]%w+)%(%)', function(FunctionName)
      if (glFunctionLookup[FunctionName] != nil) then
         return '<function>' .. FunctionName .. '</function>'
      else
         print('Unrecognised function reference ~' .. FunctionName .. '()')
      end
   end)

   -- Substitute external method/action references, identified as @File.Init()

   String = String:gsub('@([A-Z]%w+)%.([A-Z]%w+)%(%)', function(ClassName, MethodName)
      if mSys.FindClass(ClassName:hash(), 0) then
         -- TODO: Check that the method name is valid according to the class spec
         return '<class name="' .. ClassName .. '" method="' .. MethodName .. '">' .. ClassName .. '.' .. MethodName .. '()</class>'
      else
         print('Unrecognised method/action reference @' .. ClassName .. '.' .. MethodName .. '()')
      end
   end)

   -- Substitute external field references, identified as @File.Size or #File.Size

   String = String:gsub('[@#]([A-Z]%w+)%.([A-Z]%w+)', function(ClassName, FieldName)
      local meta = mSys.FindClass(ClassName:hash(), 0)
      if (meta) then
         local err, field, src = meta.mtFindField(FieldName:hash())
         if (field != nil) then
            return '<class name="' .. ClassName .. '" field="' .. FieldName .. '">' .. ClassName .. '.' .. FieldName .. '</class>'
         else
            print('Failed to find field ' .. ClassName .. '.' .. FieldName)
            return '<class name="' .. ClassName .. '" field="' .. FieldName .. '">_' .. ClassName .. '.' .. FieldName .. '_</class>'
         end
      else
         print('Unrecognised field reference @' .. ClassName .. '.' .. FieldName)
      end
   end)

   -- Substitute class references, identified as @File

   String = String:gsub('@([A-Z]%w+)', function(ClassName)
      if mSys.FindClass(ClassName:hash(), 0) then
         return '<class name="' .. ClassName .. '">' .. ClassName .. '</class>'
      else
         print('Unrecognised class name reference @' .. ClassName)
      end
   end)

   String = String:gsub('`(.-)`', '<code>%1</code>')

   return String
end

----------------------------------------------------------------------------------------------------------------------
-- Generate a header suitable for class documents.

function docClass(Class)
   if (Class.meta == nil) then
      print('No compiled meta information available for class ' .. Class.name)
      return
   end
   local meta = Class.meta

   local out = '<?xml version="1.0"?>\n'
   out = out .. '<?xml-stylesheet type="text/xsl" href="class.xsl"?>\n\n'
   out = out .. '<book>\n'
   out = out .. '  <info>\n'
   out = out .. '    <name>' .. Class.name .. '</name>\n'
   out = out .. '    <type>class</type>\n'
   if nz(glModule.name)      then out = out .. '    <module>' .. glModule.name .. '</module>\n' end
   if nz(glModule.author)    then out = out .. '    <author>' .. glModule.author:escXML() .. '</author>\n' end
   if nz(Class.comment)      then out = out .. '    <comment>' .. substituteReferences(Class.comment:escXML(), Class) .. '</comment>\n' end
   if nz(Class.keywords)     then out = out .. '    <keywords>' .. Class.keywords:escXML() .. '</keywords>\n' end
   if nz(meta.fileExtension) then out = out .. '    <fileExtension>' .. meta.fileExtension .. '</fileExtension>\n' end
   if nz(meta.fileDescription) then out = out .. '    <fileDescription>' .. meta.fileDescription:escXML() .. '</fileDescription>\n' end
   out = out .. '    <version>' .. nz(meta.classVersion,1) .. '</version>\n'
   local class_hash = string.format('%08x', Class.name:hash()):sub(-8)
   out = out .. '    <id>' .. class_hash .. '</id>\n'
   out = out .. '    <idstring>' .. Class.name:upper() .. '</idstring>\n'
   out = out .. '    <category>' .. nz(meta.get('$category'),'') .. '</category>\n'
   if nz(Class.include)      then out = out .. '    <include>' .. Class.include .. '</include>\n' end
   if nz(Class.date)         then out = out .. '    <date>' .. Class.date .. '</date>\n' end
   if nz(glModule.copyright) then out = out .. '    <copyright>' .. glModule.copyright:escXML() .. '</copyright>\n' end
   if nz(Class.description)  then out = out .. '    <description>\n' .. extractParagraph(Class.description, Class, Class.references) .. '</description>\n' end

   if nz(Class.src) then
      out = out .. '    <source>\n'
      local path
      for _, path in pairs(Class.src) do
         local filename = path:gsub('.*[:/\\](.-)', '%1', 1)
         local path = path:match('(.*[:/\\])(.-)')
         local xpath = ''
         if nz(path) then xpath = " path=\"" .. path:escXML() .. '"' end
         out = out .. "      <file" .. xpath .. ">" .. filename:escXML() .. "</file>\n"
      end
      out = out .. "    </source>\n"
   end

   out = out .. "  </info>\n"

   if nz(Class.sortedActions) then
      out = out .. "\n  <actions>\n"
      for _, a in ipairs(Class.sortedActions) do
         if (ignoreAction(glActions[a.name].id) != true) or nz(a.description) then
            out = out .. '    <action>\n'
            out = out .. '      <name>' .. a.name .. '</name>\n'

            if a.comment == nil then a.comment = glActions[a.name].comment end
            if nz(a.comment) then out = out .. '      <comment>' .. substituteReferences(a.comment:escXML(), Class) .. '</comment>\n' end

            if nz(glActions[a.name].prototype) then
               out = out .. '      <prototype>' .. glActions[a.name].prototype:escXML() .. '</prototype>\n'
            end

            if nz(glActions[a.name].params) then
               out = out .. '      <input>\n'
               for _, param in ipairs(glActions[a.name].params) do
                  local ref = ''
                  if nz(param.lookup) then ref = ' lookup="' .. param.lookup .. '"' end
                  if (param.comment == nil) then error('No comment provided for ' .. Class.name .. '.' .. a.name .. '()\'s parameter "' .. param.name .. '"') end
                  out = out .. "        <param type=\"" .. nz(param.docType,param.type):escXML() .. "\" name=\"" .. param.name .. '"' .. ref .. ">" .. substituteReferences(param.comment:escXML(), Class) .. "</param>\n"
               end
               out = out .. '      </input>\n'
            end

            if nz(a.description) then
               out = out .. '      <description>\n'
               out = out .. extractParagraph(a.description, Class, Class.references)
               out = out .. '\n      </description>\n'
            end

            if nz(a.results) then
               local results = ''
               for _, result in ipairs(a.results) do
                  results = results .. '        <error code="' .. result.codeName .. '">' .. substituteReferences(result.msg:escXML(), Class) .. '</error>\n'
               end

               if nz(results) then
                  out = out .. '      <result>\n' .. results .. '      </result>\n'
               end
            end

            out = out .. '    </action>\n\n'
         end
      end
      out = out .. '  </actions>\n'
   end

   if nz(Class.methods) then
      Class.sortedMethods = { }
      for _, f in pairs(Class.methods) do
         table.insert(Class.sortedMethods, f)
      end

      table.sort(Class.sortedMethods, function(a,b) return a.name < b.name end)

      out = out .. '\n  <methods>\n'
      for _, method in ipairs(Class.sortedMethods) do
         if (nz(method.comment) and (method.comment:find('^Private'))) then
            -- Ignore method
         else
            out = out .. '    <method>\n'
            out = out .. '      <name>' .. method.name .. '</name>\n'
            out = out .. '      <comment>' .. substituteReferences(nz(method.comment,''):escXML(), Class) .. '</comment>\n'
            if nz(method.prototype) then out = out .. '      <prototype>' .. method.prototype:escXML() .. '</prototype>\n' end

            if nz(method.params) then
               out = out .. '      <input>\n'
               for _, param in ipairs(method.params) do
                  local ref = ''
                  if nz(param.ref) then ref = " lookup=\"" .. param.lookup .. '"' end
                  if (param.comment == nil) then error('No comment provided for ' .. Class.name .. '.' .. method.name .. '()\'s parameter "' .. param.name .. '"') end
                  out = out .. "        <param type=\"" .. param.docType:escXML() .. "\" name=\"" .. param.name .. '"' .. ref .. ">" .. substituteReferences(param.comment:escXML(), Class) .. "</param>\n"
               end
               out = out .. '      </input>\n'
            end

            if nz(method.description) then
               out = out .. '      <description>\n'
               out = out .. extractParagraph(method.description, Class, Class.references)
               out = out .. '\n      </description>\n'
            end

            if nz(method.results) then
               local results = ''
               for _, result in ipairs(method.results) do
                  results = results .. "        <error code=\"" .. result.codeName .. "\">" .. substituteReferences(result.msg:escXML(), Class) .. "</error>\n"
               end

               if nz(results) then
                  out = out .. "      <result>\n" .. results .. "      </result>\n"
               end
            end

            out = out .. '    </method>\n\n'
         end
      end
      out = out .. '  </methods>\n'
   end

   if nz(Class.fields) then
      -- Process fields
      Class.sortedFields = { }
      for _, f in pairs(Class.fields) do
         table.insert(Class.sortedFields, f)
      end

      if nz(Class.sortedFields) then
         table.sort(Class.sortedFields, function(a,b) return a.name < b.name end)

         out = out .. '\n  <fields>\n'
         for _, f in ipairs(Class.sortedFields) do
            if (f.private != true) then
               out = out .. '    <field>\n'
               out = out .. '      <name>' .. f.name .. '</name>\n'

               if nz(f.comment) then
                  out = out .. '      <comment>' .. substituteReferences(f.comment:escXML(), Class) .. '</comment>\n'
               else
                  print("No comment for field '" .. Class.name .. "." .. f.name .. "'.")
               end

               out = out .. '      <access'
               if nz(f.read) then out = out .. ' read="' .. f.read:sub(1,1) .. '"' end
               if nz(f.write) then out = out .. ' write="' .. f.write:sub(1,1) .. '"' end
               out = out .. '>' .. nz(f.access,'-/-') .. '</access>\n'

               local lookup = ''
               local prototype = ''
               if (f.lookup != nil) then lookup = ' lookup="' .. f.lookup .. '"' end
               local typeName = nz(f.docType,nz(f.type,'NIL'))
               if (typeName == 'struct RGB8') then
                  typeName = 'RGB8'
               elseif (typeName == 'LONG') or (typeName == 'int') then
                  typeName = 'INT'
               elseif (typeName == 'LARGE') or (typeName == 'int64_t') then
                  typeName = 'INT64'
               elseif (f.className) then
                  typeName = '*' .. f.className
                  lookup = ' class="' .. f.className .. '"'
               elseif (f.isFunctionPtr) then
                  typeName = 'FUNCTION *'
                  prototype = ' prototype="' .. f.docType .. '"'
               end

               out = out .. '      <type' .. lookup .. prototype .. '>' .. typeName:escXML() .. '</type>\n'

               local description = f.description
               if (description) then
                  description = extractParagraph(description, Class, Class.references)
               end

               if (f.lookup != nil) then
                  local lookup = '<types lookup="' .. f.lookup .. '"/>'
                  if (description) then
                     if not (description:find('<types lookup="' .. f.lookup .. '"')) then
                        description = description .. '\n' .. lookup
                     end
                  else
                     description = lookup
                  end
               end

               if (description) then
                  out = out .. '      <description>\n'
                  out = out .. description
                  out = out .. '\n      </description>\n'
               end

               out = out .. '    </field>\n\n'
            end
         end
      end
      out = out .. '  </fields>\n'
   end

   return out
end

----------------------------------------------------------------------------------------------------------------------
-- Generate a header suitable for a module that exports at least one function.

function docModuleHeader()
   local out = '<?xml version="1.0"?>\n'
   out = out .. '<?xml-stylesheet type="text/xsl" href="module.xsl"?>\n\n'
   out = out .. '<book>\n'
   out = out .. '  <info>\n'
   if nz(glModule.name)         then out = out .. '    <name>' .. glModule.name .. '</name>\n' end
   out = out .. '    <type>module</type>\n'
   if nz(glModule.author)       then out = out .. '    <author>' .. glModule.author:escXML() .. '</author>\n' end
   if nz(glModule.comment)      then out = out .. '    <comment>' .. glModule.comment:escXML() .. '</comment>\n' end
   if nz(glModule.keywords)     then out = out .. '    <keywords>' .. glModule.keywords:escXML() .. '</keywords>\n' end
   if nz(glModule.version)      then out = out .. '    <version>' .. glModule.version .. '</version>\n' end
   if nz(glModule.id)           then out = out .. '    <id>' .. string.format('%x',glModule.id) .. '</id>\n' end
   if nz(glModule.idstring)     then out = out .. '    <idstring>' .. glModule.idstring .. '</idstring>\n' end
   if nz(glModule.status)       then out = out .. '    <status>' .. glModule.status .. '</status>\n' end
   if nz(glModule.prefix)       then out = out .. '    <prefix>' .. glModule.prefix .. '</prefix>\n' end
   if nz(glModule.category)     then out = out .. '    <category>' .. glModule.category .. '</category>\n' end
   if nz(glModule.include)      then out = out .. '    <include>modules/' .. glModule.name:lower() .. '.h</include>\n' end
   if nz(glModule.date)         then out = out .. '    <date>' .. glModule.date .. '</date>\n' end
   if nz(glModule.copyright)    then out = out .. '    <copyright>' .. glModule.copyright:escXML() .. '</copyright>\n' end
   if nz(glModule.description)  then out = out .. '    <description>\n' .. glModule.description .. '</description>\n' end
   if nz(glModule.notes)        then out = out .. '    <notes>\n' .. glModule.notes .. '</notes>\n' end
   if nz(glModule.technical)    then out = out .. '    <technical>\n' .. glModule.technical .. '</technical>\n' end

   if nz(srcFiles) then
      out = out .. '    <source>\n'
      local path
      for _, path in pairs(srcFiles) do
         local filename = path:gsub('.*[:/\\](.-)', '%1', 1)
         local path = path:match('(.*[:/\\])(.-)')
         out = out .. "      <file path=\"" .. path:escXML() .. "\">" .. filename:escXML() .. "</file>\n"
      end
      out = out .. '    </source>\n'
   end

   if nz(glClasses) then
      out = out .. '    <classes>\n'
      for className, cl in table.sortByKeys(glClasses) do
         out = out .. '      <class>' .. cl.name .. '</class>\n'
      end
      out = out .. '    </classes>\n'
   end

   if nz(glCategories) then
      out = out .. '    <categories>\n'
      for className, cl in table.sortByKeys(glCategories) do
         out = out .. '      <category>' .. cl.name .. '</category>\n'
      end
      out = out .. '    </categories>\n'
   end

   out = out .. '  </info>\n\n'

   return out
end

function docFunction(Function)
   if string.find(nz(Function.status,''), '^[Pp]rivate') or
      string.find(nz(Function.status,''), '^[Ii]nternal') or
      string.find(nz(Function.comment,''), '^[Pp]rivate') then
      return ''
   end

   local out = '  <function>\n'

   if nz(Function.name)      then out = out .. '    <name>' .. Function.name .. '</name>\n' end
   if nz(Function.category)  then out = out .. '    <category>' .. Function.category .. '</category>\n' end
   if nz(Function.version)   then out = out .. '    <version>' .. Function.version .. '</version>\n' end
   if nz(Function.synonym)   then out = out .. '    <synonym>' .. Function.synonym .. '</synonym>\n' end
   if nz(Function.comment)   then out = out .. '    <comment>' .. substituteReferences(Function.comment:escXML()) .. '</comment>\n' end
   if nz(Function.prototype) then out = out .. '    <prototype>' .. Function.docPrototype:escXML() .. '</prototype>\n' end
   if nz(Function.id)        then out = out .. '    <id>' .. Function.id .. '</id>\n' end

   -- Function arguments

   if nz(Function.input) then
      local args = ''
      for k, fa in ipairs(Function.input) do
         local ref = ''
         if (fa.ref != nil) then
            ref = ' lookup="' .. fa.lookup .. '"'
         end

         if (fa.type == nil) then
            args = args .. string.format("      <param type=\"?\" name=\"%s\"" .. ref .. ">%s</param>\n",
               fa.name, substituteReferences(fa.comment:escXML()))
         else
            args = args .. string.format("      <param type=\"%s\" name=\"%s\"" .. ref .. ">%s</param>\n",
               fa.docType:escXML(), fa.name, substituteReferences(fa.comment:escXML()))
         end

         if (fa.comment == 'Undocumented') then
            error(Function.name .. '() parameter "' .. fa.name .. '" is undocumented.')
         end
      end

      if nz(args) then out = out .. '    <input>\n' .. args .. '    </input>\n' end
   end

   -- Description

   if nz(Function.description) then
      out = out .. '    <description>\n' .. extractParagraph(Function.description, Function) .. '\n    </description>\n'
   else
      error(Function.name .. '() has no description.')
   end

   -- Results

   if nz(Function.result) then
      if nz(Function.result.values) then
         local errors = ''
         for _, result in ipairs(Function.result.values) do
            local comment = nz(result.msg, mSys.GetErrorMsg(code))
            errors = errors .. "      <error code=\"" .. result.codeName .. "\">" .. substituteReferences(comment:escXML()) .. "</error>\n"
         end

         if nz(errors) then
            out = out .. "    <result type=\"ERR\">\n" .. errors .. "    </result>\n"
         end
      elseif nz(Function.result.comment) then
         local ref = ''
         if (Function.result.ref != nil) then
            ref = " lookup=\"" .. Function.result.lookup .. '"'
         end

         out = out .. "    <result type=\"" .. Function.result.docType:escXML() .. '"' .. ref .. ">" .. substituteReferences(Function.result.comment:escXML()) .. "</result>\n"
      end
   end

   return out .. '  </function>\n\n'
end

-- Output custom types - flags, enumerators etc

function docTypes(References)
   local out = ''
   local sortedTypes = { }
   for prefix, ct in pairs(glCustomTypes) do
      table.insert(sortedTypes, ct)
   end

   table.sort(sortedTypes, function(a,b) return a.prefix < b.prefix end)

   for _, ct in ipairs(sortedTypes) do
      local comment = ''
      if (ct.comment) then comment = " comment=\"" .. ct.comment:escXML() .. '"' end

      local typeName
      if (ct.grouping == 'constants') then
         typeName = 'const'
      elseif (ct.grouping == 'flags') then
         typeName = 'flag'
      else
         error("Unknowning grouping for custom type, '" .. ct.grouping .. "'")
      end

      if nz(ct.restrict) then
         -- Ignore private types
      elseif References and (References['TYPE:' .. ct.prefix] == nil) then
         -- Type is not referenced
      else
         out = out .. "    <constants lookup=\"" .. ct.prefix .. '"' .. comment:escXML() .. '>\n'

         local sortedValues = { }
         for _, v in pairs(ct.list) do
            table.insert(sortedValues, v)
         end
         table.sort(sortedValues, function(a,b) return a.name < b.name end)

         for _, v in pairs(sortedValues) do
            if (v.synonym) then
               -- Don't publish synonyms
            elseif nz(v.comment) then
               if (v.comment:find('^Internal')) or (v.comment:find('^Private')) then
                  -- Ignore internal/private types
               else
                  out = out .. "      <const name=\"" .. v.name .. "\">" .. substituteReferences(v.comment:escXML()) .. "</const>\n"
               end
            else
               out = out .. "      <const name=\"" .. v.name .. "\"/>\n"
            end
         end
         out = out .. '    </constants>\n\n'
      end
   end

   if nz(out) then
      out = '  <types>\n' .. out .. '  </types>\n'
   end

   return out
end

-- Output structures.  Modules need to output all the structures; Classes output structures that are referenced.

function docStructures(References)
   local out = '  <structs>\n'

   local sortedStructs = { }
   for _, f in pairs(glStructures) do
      table.insert(sortedStructs, f)
   end

   table.sort(sortedStructs, function(a,b) return a.name < b.name end)

   for _, struct in ipairs(sortedStructs) do
      if nz(struct.restrict) then
         -- Don't output restricted structures.
         --if (glFeedback == 'verbose') then print(struct.name .. ' is restricted.') end
      elseif References and (References['STRUCT:' .. struct.name] == nil) then
         -- Don't output unreferenced structures.
         --if (glFeedback == 'verbose') then print(struct.name .. ' is unreferenced.') end
      else
         local comment = ''
         local typeName = ''
         if (struct.comment) then comment = " comment=\"" .. struct.comment:escXML() .. '"' end
         if (struct.type) then typeName = " typeName=\"" .. struct.type:escXML() .. '"' end

         out = out .. "    <struct name=\"" .. struct.name .. '"' .. comment .. typeName .. '>\n'
         for i, f in ipairs(struct.fields) do
            local ref = ''
            if (f.lookup) then ref = " lookup=\"" .. f.lookup .. '"' end

            local arraySize = ''
            if (f.arraySize) then arraySize = " size=\"" .. f.arraySize .. '"' end

            local type = nz(f.docType, 'NIL')
            local prototype = ''
            if (f.isFunctionPtr) then
               type = 'FUNCTION *'
               prototype = ' prototype="' .. f.docType:escXML() .. '"'
            end

            out = out .. "      <field name=\"" .. f.name .. "\" type=\"" .. type:escXML() .. '"' .. prototype .. ref .. arraySize .. ">"
            if nz(f.comment) then out = out .. substituteReferences(f.comment:escXML()) end
            out = out .. '</field>\n'
         end
         out = out .. '    </struct>\n\n'
      end
   end
   out = out .. '  </structs>\n'
   return out
end
