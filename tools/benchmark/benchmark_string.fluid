----------------------------------------------------------------------------------------------------------------------
-- STRING OPERATIONS
----------------------------------------------------------------------------------------------------------------------
-- Goal: Get the length of strings of varying sizes

@Test function StringGetLength()
   local short_str  = "Hello"
   local medium_str = "The quick brown fox jumps over the lazy dog."
   local long_str   = string.rep("Lorem ipsum dolor sit amet, consectetur adipiscing elit. ", 20)

   for i in {0..100000} do
      local len1 = #short_str
      local len2 = #medium_str
      local len3 = #long_str
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Build a string by concatenating multiple parts

@Test function StringConcatenateMultiple()
   for i in {0..100000} do
      -- Concatenate literals
      local result = "Hello" .. " " .. "World" .. "!"

      -- Concatenate with variables
      local a, b, c = "foo", "bar", "baz"
      result = a .. b .. c

      -- Build a longer string from parts
      local parts = "Part1" .. "-" .. "Part2" .. "-" .. "Part3" .. "-" .. "Part4"

      -- Concatenate numbers converted to strings
      result = "Value: " .. tostring(i) .. ", Next: " .. tostring(i + 1)
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Build a string incrementally using append operations

@Test function StringBuildIncrementally()
   for i in {0..1000} do
      local result = ""
      for j in {0..100} do
         result ..= "x"
      end

      -- Build with varying content
      local sentence = ""
      sentence ..= "The "
      sentence ..= "quick "
      sentence ..= "brown "
      sentence ..= "fox "
      sentence ..= "jumps."
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Format strings with embedded values (string interpolation)

@Test function StringFormatting()
   local name = "Alice"
   local age = 30
   local score = 95.5

   for i in {0..1000} do
      local msg1 = string.format("Name: %s, Age: %d", name, age)
      local msg2 = string.format("Score: %.2f out of 100", score)
      local msg3 = string.format("Item %05d costs $%8.2f", i, i * 1.99)
   end
end

@Test function StringInterp()
   local name = "Alice"
   local age = 30

   for i in {0..10000} do
      local msg4 = f"Name: {name}, Age: {age}"
      local msg5 = f"Iteration {i} of 100000"
      local msg6 = f"Result: {i * 2 + 1}"
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Extract a substring from a larger text

@Test function StringExtractSubstring()
   local text = "The quick brown fox jumps over the lazy dog. Pack my box with five dozen liquor jugs."

   for i in {0..10000} do
      -- Extract from beginning
      local first_word = string.substr(text, 1, 3)

      -- Extract from middle
      local middle = string.substr(text, 16, 19)  -- "fox "

      -- Extract from end
      local last_part = string.substr(text, -10)

      -- Extract with negative indices
      local from_end = string.substr(text, -20, -11)

      -- Variable position extraction
      local pos = (i % 40) + 1
      local chunk = string.substr(text, pos, pos + 10)
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Find the position of a substring within text

@Test function StringFindSubstring()
   local text = "The quick brown fox jumps over the lazy dog. The fox is quick."
   local paragraph = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. " ..
                     "Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua."

   for i in {0..5000000} do
      -- Find word at beginning
      local pos1 = string.find(text, "The")

      -- Find word in middle
      local pos2 = string.find(text, "fox")

      -- Find word at end
      local pos3 = string.find(text, "quick", 20)  -- Start search from position 20

      -- Find substring that doesn't exist
      local pos4 = string.find(text, "xyz")

      -- Find in longer text
      local pos5 = string.find(paragraph, "dolor")
      local pos6 = string.find(paragraph, "magna")
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Simple word replacement in a sentence

@Test function StringReplaceWords()
   local text = "The quick brown fox jumps over the lazy dog."

   for i in {0..100} do
      -- Replace single occurrence
      local result1 = string.replace(text, "fox", "cat")

      -- Replace all occurrences
      local text2 = "the cat sat on the mat with the cat"
      local result2 = string.replace(text2, "cat", "dog")

      -- Replace with pattern
      local result3 = string.replace(text, " ", "_")  -- Replace spaces with underscores

      -- Replace multiple different words
      local result4 = string.replace(text, "quick", "slow")
      result4 = string.replace(result4, "brown", "white")
      result4 = string.replace(result4, "lazy", "energetic")
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Split text into words or tokens

@Test function StringCSV()
   local csv_data = "apple,banana,cherry,date,elderberry,fig,grape"

   for i in {0..100} do
      local items = string.split(csv_data, ",")
   end
end

-- Use regex for more sophisticated splitting

rx_split = regex.new("[^;,:]+")

@Test function RegexSplit()
   local mixed = "one;two,three:four"

   for i in {0..1000} do
      local parts = rx_split.split(mixed)
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Test strings against regex patterns

rx_email    = regex.new("^[\\w.+\\-]+@[\\w\\-]+\\.[a-zA-Z]{2,}$")
rx_ipv4     = regex.new("^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$")
rx_hexcolor = regex.new("^#[0-9a-fA-F]{6}$")
rx_digits   = regex.new("^\\d+$")

@Test function RegexTest()
   local valid_email   = "user@example.com"
   local invalid_email = "not-an-email"
   local valid_ip      = "192.168.1.100"
   local invalid_ip    = "999.999.999.999.999"
   local hex_color     = "#ff00aa"
   local not_hex       = "#xyz123"
   local digits_only   = "1234567890"
   local mixed         = "abc123"

   for i in {0..1000} do
      local r1 = rx_email.test(valid_email)
      local r2 = rx_email.test(invalid_email)
      local r3 = rx_ipv4.test(valid_ip)
      local r4 = rx_ipv4.test(invalid_ip)
      local r5 = rx_hexcolor.test(hex_color)
      local r6 = rx_hexcolor.test(not_hex)
      local r7 = rx_digits.test(digits_only)
      local r8 = rx_digits.test(mixed)
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Replace patterns in strings using regex

rx_whitespace = regex.new("\\s+")
rx_tags       = regex.new("<[^>]+>")
rx_vowels     = regex.new("[aeiou]")
rx_numbers    = regex.new("\\d+")

@Test function RegexReplace()
   local text      = "The  quick   brown    fox"
   local html      = "<b>Hello</b> <i>World</i>!"
   local sentence  = "The quick brown fox jumps over the lazy dog."
   local data      = "item:100 cost:250 qty:3"

   for i in {0..1000} do
      -- Collapse multiple spaces into one
      local r1 = rx_whitespace.replace(text, " ")

      -- Strip HTML tags
      local r2 = rx_tags.replace(html, "")

      -- Remove all vowels
      local r3 = rx_vowels.replace(sentence, "")

      -- Replace numbers with a placeholder
      local r4 = rx_numbers.replace(data, "N")
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Compare two strings for equality and ordering

@Test function StringCompareStrings()
   local str1 = "apple"
   local str2 = "banana"
   local str3 = "apple"
   local str4 = "Apple"
   local long1 = "The quick brown fox jumps over the lazy dog"
   local long2 = "The quick brown fox jumps over the lazy cat"

   for i in {0..4000000} do
      -- Equality comparison
      local eq1 = str1 is str3      -- true
      local eq2 = str1 is str2      -- false
      local eq3 = str1 is str4      -- false (case sensitive)

      -- Inequality
      local neq1 = str1 != str2

      -- Lexicographic ordering
      local lt1 = str1 < str2       -- "apple" < "banana"
      local gt1 = str2 > str1
      local le1 = str1 <= str3
      local ge1 = str1 >= str3

      -- Compare longer strings
      local eq_long = long1 is long2
      local lt_long = long1 < long2
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Convert text to uppercase and lowercase

@Test function StringChangeCase()
   local mixed = "Hello World! This Is A Test."
   local lower = "all lowercase text here"
   local upper = "ALL UPPERCASE TEXT HERE"

   for i in {0..40000} do
      -- Convert to uppercase
      local up1 = string.upper(mixed)
      local up2 = string.upper(lower)

      -- Convert to lowercase
      local lo1 = string.lower(mixed)
      local lo2 = string.lower(upper)

      -- Round-trip conversion
      local round = string.lower(string.upper(mixed))
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Remove whitespace from beginning and end of strings

@Test function StringTrimWhitespace()
   local padded = "   Hello World   "
   local left_pad = "   Left padded"
   local right_pad = "Right padded   "
   local tabs = "\t\tTabbed content\t\t"
   local mixed_ws = "  \t Mixed whitespace \n  "

   for i in {0..1000} do
      local trimmed1 = padded:trim()
      local trimmed2 = left_pad:trim() -- should use ltrim() if available
      local trimmed3 = right_pad:rtrim()
      local trimmed4 = tabs:trim()
      local trimmed5 = mixed_ws:trim()
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Access individual characters in a string

@Test function StringAccessCharacters()
   local text = "Hello, World!"

   for i in {0..100} do
      -- Get character at specific position using string.sub
      local char1 = string.substr(text, 1, 1)   -- 'H'
      local char2 = string.substr(text, 7, 7)   -- ' '
      local char3 = string.substr(text, -1, -1) -- '!'

      -- Get character code (byte value)
      local code1 = string.byte(text, 1)     -- 72 ('H')
      local code2 = string.byte(text, 8)     -- 87 ('W')

      -- Get multiple byte values
      local codes = {string.byte(text, 1, 5)}

      -- Create character from code
      local chr = string.char(65)            -- 'A'
      local str = string.char(72, 105, 33)   -- "Hi!"

      -- Variable position access
      local pos = (i % #text) + 1
      local var_char = string.substr(text, pos, pos)
      local var_code = string.byte(text, pos)
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Match patterns in text and extract captures

@Test function RegexExtracts()
   local email = "user@example.com"
   local date = "2024-01-15"
   local log_line = "[ERROR] 2024-01-15 10:30:45 - Connection failed"
   local url = "https://www.example.com:8080/path/to/page?query=value"

   for i in {0..1000} do
      -- Extract with captures
      local user, domain = rxEmailParts.extract(email)

      -- Match date components
      local year, month, day = rxDateParts.extract(date)

      -- Match log level
      local level = rxLogLevel.extract(log_line)

      -- Match timestamp
      local timestamp = rxTimestamp.extract(log_line)

      -- Complex URL parsing
      local protocol = rxProtocol.extract(url)
      local host = rxUrlHost.extract(url)
      local port = rxUrlPort.extract(url)
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Repeat a string multiple times

@Test function StringRepeatString()
   local char = "x"
   local word = "abc"
   local line = "-"

   for i in {0..100000} do
      -- Repeat single character
      local repeated1 = string.rep(char, 10)
      local repeated2 = string.rep(char, 100)

      -- Repeat word
      local repeated3 = string.rep(word, 5)
      local repeated4 = string.rep(word, 20)

      -- Build separator line
      local separator = string.rep(line, 80)

      -- Repeat with separator
      local with_sep = string.rep("item", 5, ", ")

      -- Variable repetition
      local count = (i % 10) + 1
      local var_rep = string.rep("*", count)
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Reverse a string

@Test function StringReverseString()
   local short = "Hello"
   local medium = "The quick brown fox"
   local long = "Pack my box with five dozen liquor jugs. The quick brown fox jumps over the lazy dog."
   local test = "racecar"

   for i in {0..100000} do
      -- Reverse strings of different lengths
      local rev1 = string.reverse(short)
      local rev2 = string.reverse(medium)
      local rev3 = string.reverse(long)

      -- Double reverse (should equal original)
      local double_rev = string.reverse(string.reverse(medium))

      -- Palindrome check pattern
      local is_palindrome = test is string.reverse(test)
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Check if a string starts or ends with a given prefix/suffix

@Test function StringStartsEndsWith()
   local filename = "document.txt"
   local path = "/home/user/documents/file.pdf"
   local url = "https://www.example.com/page"
   local extensions = array<string> {".txt", ".pdf", ".doc", ".csv"}

   for i in {0..1000} do
      local starts_with_doc = filename:startsWith("doc")
      local starts_with_http = url:startsWith("https")
      local starts_with_slash = path:startsWith("/")

      local ends_with_txt = filename:endsWith(".txt")
      local ends_with_pdf = path:endsWith(".pdf")
      local ends_with_com = url:endsWith(".com")

      -- Variable prefix/suffix checks
      local chk = filename:endsWith(extensions[i % 4])
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Measure overhead of tostring() conversions

@Test function StringConversion()
   local int_val = 12345
   local float_val = 3.14159265358979
   local neg_int = -9876
   local neg_float = -2.71828
   local zero = 0
   local bool_true = true
   local bool_false = false
   local tbl = { a = 1 }

   for i in {0..1000000} do
      -- Convert integers to string
      local s1 = tostring(int_val)
      local s2 = tostring(neg_int)
      local s3 = tostring(zero)
      local s4 = tostring(i)

      -- Convert floats to string
      local s5 = tostring(float_val)
      local s6 = tostring(neg_float)
      local s7 = tostring(i * 0.5)

      -- Convert booleans to string
      local s8 = tostring(bool_true)
      local s9 = tostring(bool_false)

      -- Convert nil to string
      local s10 = tostring(nil)

      -- Convert table to string (gets address)
      local s11 = tostring(tbl)

      -- Convert computed values
      local s12 = tostring(i + 100)
      local s13 = tostring(i * 2)
      local s14 = tostring(i / 3)

      -- Concatenation forcing conversion
      local s15 = "" .. i
      local s16 = "value: " .. i

      -- Scientific notation numbers
      local s17 = tostring(1.23e10)
      local s18 = tostring(4.56e-5)

      -- Large and small numbers
      local s19 = tostring(999999999)
      local s20 = tostring(0.000001)
   end
end
