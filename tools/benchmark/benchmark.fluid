--[[
Fluid Benchmarking Tool

Usage:

  parasol benchmark.fluid [test=Name]

Parameters:

  test=[s]     - Regex defining the test(s) to run.
  duration=[n] - Duration limit for each test, in seconds.
  warmup=[n]   - Warmup cycles per test.
  hotloop=[n]  - Cycles required before performing JIT optimisation.
  calls=[n]    - Limit each test to this many calls.
  save         - Saves the results to the log if specified.  Used for comparison on the next run.
 --]]

   import 'benchmark'
   import 'git'
   import 'json'

rxEmailParts   = <{ regex.new([[([^@]+)@(.+)]]) }>
rxDateParts    = <{ regex.new([[(\d+)-(\d+)-(\d+)]]) }>
rxLogLevel     = <{ regex.new("\\[([A-Z]+)\\]") }>
rxTimestamp    = <{ regex.new([[(\d\d:\d\d:\d\d)]]) }>
rxProtocol     = <{ regex.new([[^(\w+)://]]) }>
rxUrlHost      = <{ regex.new([[:\/\/([^:\/]+)]]) }>
rxUrlPort      = <{ regex.new([[:(\d+)/]]) }>

global glSelf = obj.find('self')
global glPath = glSelf.workingPath
global glLogFile = 'user:benchmark.log'

   import './benchmark_array'
   import './benchmark_func'
   import './benchmark_memory'
   import './benchmark_string'
   import './benchmark_math'
   import './benchmark_table'
   import './benchmark_control'

----------------------------------------------------------------------------------------------------------------------
-- EXCEPTION HANDLING
----------------------------------------------------------------------------------------------------------------------
-- Goal: Measure overhead of try-except exception handling

@Test function ExceptionTryExcept()
   -- Function that may throw an error
   local function mayFail(shouldFail)
      if shouldFail then
         error("Intentional error")
      end
      return 42
   end

   -- Function that always succeeds
   local function alwaysSucceeds(x)
      return x * 2
   end

   for i in {0..10000} do
      -- Try-except with no exception thrown
      try
         local result = alwaysSucceeds(i)
      except ex
         local msg = ex.message
      end

      -- Try-except with exception thrown occasionally
      try
         local result = mayFail(i % 100 is 0)
      except ex
         local msg = ex.message
      end

      -- Nested try-except blocks
      try
         try
            local result = alwaysSucceeds(i)
         except inner
            local msg = inner.message
         end
      except outer
         local msg = outer.message
      end

      -- Try-except with multiple operations
      try
         local a = alwaysSucceeds(i)
         local b = alwaysSucceeds(i + 1)
         local c = alwaysSucceeds(i + 2)
         local sum = a + b + c
      except ex
         local msg = ex.message
      end

      -- Try-except with conditional exception
      try
         if i % 50 is 0 then
            error("Periodic error")
         end
         local result = i * 2
      except ex
         local recovered = 0
      end
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Use try-success pattern for handling successful completion

@Test function ExceptionTrySuccess()
   local function compute(x)
      if x < 0 then
         error("Negative value not allowed")
      end
      return x * x
   end

   local function fetchData(id)
      if id is 0 then
         error("Invalid ID")
      end
      return { id = id, value = id * 10 }
   end

   for i in {0..30000} do
      local result = 0

      -- Basic try-success pattern
      try
         result = compute(i)
      except ex
         result = -1
      success
         result = result + 1
      end

      -- Try-success with data fetching pattern
      local data = nil
      try
         data = fetchData(i % 100)
      except ex
         data = { id = 0, value = 0 }
      success
         data.value = data.value * 2
      end

      -- Chained operations in success block
      local a, b
      try
         a = compute(i)
         b = compute(i + 1)
      except ex
         result = 0
      success
         result = a + b
         result = result * 2
      end

      -- Success block with cleanup-like operations
      local resource_acquired = false
      try
         resource_acquired = true
         result = compute(i)
      except ex
         result = -1
      success
         -- Simulated successful completion handling
         result = result + 100
      end

      -- Nested try with success blocks
      try
         try
            result = compute(i)
         except inner
            result = 0
         success
            result = result + 10
         end
      except outer
         result = -1
      success
         result = result + 20
      end
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Measure overhead of defer statement for cleanup

@Test function ExceptionDefer()
   for i in {0..5000} do
      local cleanup_count = 0

      -- Simple defer
      do
         defer()
            cleanup_count++
         end
         local x = i * 2
      end

      -- Multiple defers (LIFO order)
      do
         defer()
            cleanup_count++
         end
         defer()
            cleanup_count++
         end
         defer()
            cleanup_count++
         end
         local x = i
      end

      -- Defer with captured variables
      local value = i
      do
         local captured = value
         defer()
            local _ = captured
         end
         value = value * 2
      end

      -- Defer in nested scopes
      do
         defer()
            cleanup_count++
         end
         do
            defer()
               cleanup_count++
            end
            local inner = i
         end
         local outer = i * 2
      end

      -- Defer with computation
      local result = 0
      do
         defer()
            result = result + 1
         end
         result = i * 2
      end

      -- Defer simulating resource cleanup pattern
      do
         local resource = { open = true }
         defer()
            resource.open = false
         end
         local data = resource.open and i or 0
      end
   end
end

----------------------------------------------------------------------------------------------------------------------
-- VARIABLE SCOPE
----------------------------------------------------------------------------------------------------------------------
-- These benchmarks perform identical operations to enable direct performance comparison
-- between different variable scoping mechanisms.

@Test function ScopeLocal()
   for i in {0..1000000} do
      -- Declare local variables
      local a = 10
      local b = 20
      local c = 30
      local d = 40
      local e = 50

      -- Read operations
      local r1 = a
      local r2 = b
      local r3 = c
      local r4 = d
      local r5 = e

      -- Arithmetic using locals
      local sum = a + b + c + d + e
      local product = a * b
      local diff = e - a
      local quotient = d / a

      -- Write operations
      a = i
      b = i + 1
      c = i + 2
      d = i + 3
      e = i + 4

      -- Mixed read/write
      a = b + c
      b = a * 2
      c = b - d
      d = c + e
      e = a + d

      -- Compound operations
      a += 1
      b -= 1
      c *= 2
      d /= 2
      e %= 100
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Measure performance of global variable access

-- Declare globals for ScopeGlobal benchmark
global glScopeA = 10
global glScopeB = 20
global glScopeC = 30
global glScopeD = 40
global glScopeE = 50

@Test function ScopeGlobal()
   for i in {0..1000000} do
      -- Reset global variables
      glScopeA = 10
      glScopeB = 20
      glScopeC = 30
      glScopeD = 40
      glScopeE = 50

      -- Read operations
      local r1 = glScopeA
      local r2 = glScopeB
      local r3 = glScopeC
      local r4 = glScopeD
      local r5 = glScopeE

      -- Arithmetic using globals
      local sum = glScopeA + glScopeB + glScopeC + glScopeD + glScopeE
      local product = glScopeA * glScopeB
      local diff = glScopeE - glScopeA
      local quotient = glScopeD / glScopeA

      -- Write operations
      glScopeA = i
      glScopeB = i + 1
      glScopeC = i + 2
      glScopeD = i + 3
      glScopeE = i + 4

      -- Mixed read/write
      glScopeA = glScopeB + glScopeC
      glScopeB = glScopeA * 2
      glScopeC = glScopeB - glScopeD
      glScopeD = glScopeC + glScopeE
      glScopeE = glScopeA + glScopeD

      -- Compound operations
      glScopeA += 1
      glScopeB -= 1
      glScopeC *= 2
      glScopeD /= 2
      glScopeE %= 100
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Measure performance of const-annotated local variable access

@Test function ScopeConstantAccess()
   for i in {0..1000000} do
      -- Declare const local variables
      local a <const> = 10
      local b <const> = 20
      local c <const> = 30
      local d <const> = 40
      local e <const> = 50

      -- Read operations (const can only be read, not written)
      local r1 = a
      local r2 = b
      local r3 = c
      local r4 = d
      local r5 = e

      -- Arithmetic using consts
      local sum = a + b + c + d + e
      local product = a * b
      local diff = e - a
      local quotient = d / a

      -- Write to mutable locals derived from consts
      local ma = i
      local mb = i + 1
      local mc = i + 2
      local md = i + 3
      local me = i + 4

      -- Mixed read (const) / write (mutable)
      ma = b + c
      mb = a * 2
      mc = b - d
      md = c + e
      me = a + d

      -- Compound operations on mutable copies
      ma += 1
      mb -= 1
      mc *= 2
      md /= 2
      me %= 100

      -- Additional const reads to match operation count
      local x1 = a + b
      local x2 = c + d
      local x3 = e + a
      local x4 = b + c
      local x5 = d + e
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Measure performance of upvalue access in closures

@Test function ScopeUpvalueAccess()
   -- Declare upvalues outside the loop
   local a = 10
   local b = 20
   local c = 30
   local d = 40
   local e = 50

   -- Create closure that captures upvalues
   local function accessUpvalues(iter)
      -- Read operations
      local r1 = a
      local r2 = b
      local r3 = c
      local r4 = d
      local r5 = e

      -- Arithmetic using upvalues
      local sum = a + b + c + d + e
      local product = a * b
      local diff = e - a
      local quotient = d / a

      -- Write operations
      a = iter
      b = iter + 1
      c = iter + 2
      d = iter + 3
      e = iter + 4

      -- Mixed read/write
      a = b + c
      b = a * 2
      c = b - d
      d = c + e
      e = a + d

      -- Compound operations
      a += 1
      b -= 1
      c *= 2
      d /= 2
      e %= 100
   end

   for i in {0..1000000} do
      -- Reset upvalues
      a = 10
      b = 20
      c = 30
      d = 40
      e = 50

      -- Call function that accesses upvalues
      accessUpvalues(i)
   end
end

----------------------------------------------------------------------------------------------------------------------
-- TYPE OPERATIONS
----------------------------------------------------------------------------------------------------------------------
-- Goal: Measure overhead of type() function calls

@Test function TypeCheckType()
   -- Create values of different types
   local num_int = 42
   local num_float = 3.14159
   local str = "hello"
   local tbl = { a = 1, b = 2 }
   local arr = array<int> { 1, 2, 3 }
   local func = function() return 1 end
   local bool_true = true
   local bool_false = false
   local nil_val = nil

   for i in {0..500} do
      -- Check type of numbers
      local t1 = type(num_int)
      local t2 = type(num_float)
      local t3 = type(i)

      -- Check type of strings
      local t4 = type(str)
      local t5 = type("literal")

      -- Check type of tables
      local t6 = type(tbl)
      local t7 = type({})

      -- Check type of arrays
      local t8 = type(arr)

      -- Check type of functions
      local t9 = type(func)
      local t10 = type(function() end)

      -- Check type of booleans
      local t11 = type(bool_true)
      local t12 = type(bool_false)

      -- Check type of nil
      local t13 = type(nil_val)
      local t14 = type(nil)

      -- Type comparisons
      local is_num = type(num_int) is "number"
      local is_str = type(str) is "string"
      local is_tbl = type(tbl) is "table"
      local is_func = type(func) is "function"
      local is_bool = type(bool_true) is "boolean"

      -- Conditional based on type
      local val = i % 3 is 0 and str or (i % 3 is 1 and num_int or tbl)
      if type(val) is "string" then
         local _ = #val
      elseif type(val) is "number" then
         local _ = val * 2
      elseif type(val) is "table" then
         local _ = val.a
      end
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Measure overhead of tonumber() conversions

@Test function NumberConversion()
   local str_int = "12345"
   local str_neg = "-9876"
   local str_float = "3.14159"
   local str_neg_float = "-2.71828"
   local str_zero = "0"
   local str_sci = "1.23e5"
   local str_hex = "0xFF"
   local str_invalid = "not_a_number"
   local str_mixed = "123abc"

   for i in {0..1000} do
      -- Convert integer strings
      local n1 = tonumber(str_int)
      local n2 = tonumber(str_neg)
      local n3 = tonumber(str_zero)

      -- Convert float strings
      local n4 = tonumber(str_float)
      local n5 = tonumber(str_neg_float)

      -- Convert scientific notation
      local n6 = tonumber(str_sci)

      -- Convert hex strings
      local n7 = tonumber(str_hex)
      local n8 = tonumber("0x1A2B")

      -- Convert with explicit base
      local n9 = tonumber("1010", 2)    -- Binary
      local n10 = tonumber("777", 8)     -- Octal
      local n11 = tonumber("FF", 16)     -- Hex without prefix

      -- Convert dynamically created strings
      local n12 = tonumber(tostring(i))
      local n13 = tonumber(tostring(i * 2))

      -- Invalid conversions (return nil)
      local n14 = tonumber(str_invalid)
      local n15 = tonumber(str_mixed)
      local n16 = tonumber("")

      -- Numbers passed through (already numbers)
      local n17 = tonumber(42)
      local n18 = tonumber(3.14)
      local n19 = tonumber(i)

      -- Conditional conversion with fallback
      local val = tonumber(str_int) ?? 0
      local val2 = tonumber(str_invalid) ?? -1
   end
end

----------------------------------------------------------------------------------------------------------------------

function logMessage(message)
   print(message)
end

   local tm = obj.new('time')
   tm.acQuery()

   git_info = git.query(glPath)

   logMessage(string.format('%04d-%02d-%02d %02d:%02d:%02d', tm.year, tm.month, tm.day, tm.hour, tm.minute, tm.second))
   logMessage(f'Git branch: {git_info.branch} / {git_info.commit}')
   logMessage('')

   local duration   = tonumber(arg('duration',2))
   local warmup     = tonumber(arg('warmup',10))
   local hotloop    = tonumber(arg('hotloop',5))
   local call_limit = tonumber(arg('calls',1000))
   local save_results = arg('save',false)

   local test_match = arg('test')
   if test_match then
      global rx_test = regex.new(test_match)
      logMessage(f'Filtering benchmarks with pattern: {test_match}')
   end

   report = {
      evals = { },
      config = { },
      timestamp = tm.timeStamp,
      git = { branch=git_info.branch, commit=git_info.commit }
   }

   local anno = debug.anno.list()

   name_list = {}
   longest_name = 0
   for k,v in pairs(anno) do
      local func_name = tostring(k)
      table.insert(name_list, { name = func_name, func = k })
      if #func_name > longest_name then
         longest_name = #func_name
      end
   end

   table.sort(name_list, function(a:table, b:table):bool
      return (a.name < b.name)
   end)

   for entry in values(name_list) do
      func = entry.func
      name = entry.name
      entry = anno[func]

      if rx_test then
         if not rx_test.match(name) then continue end
      end

      local eval
      try<trace>
         eval = bmark.run({
            duration     = duration,
            warmupCalls  = warmup,
            feedbackRate = 100,
            maxCalls     = call_limit,
            hotLoop      = hotloop
         }, nil, func)
      except ex
         logMessage(f'Error in benchmark {name}: {ex.message}')
         logMessage(ex.stackTrace)
      success
         logMessage(string.format('%s() Calls Per Second: %d; Total Calls: %d, Fastest: %.3f ms', name, eval.callsPerSecond, eval.benchmarkCalls, eval.stats.min))
         if eval.memoryLeakRate / eval.callsPerSecond > 512 then
            logMessage(string.format('Leak Rate:  %d bytes per call', eval.memoryLeakRate / eval.callsPerSecond))
         end

         if save_results is 'all' then
            report['evals'][name] = eval
         else
            report['evals'][name] = {
               time    = eval.benchmarkTime,
               cps     = math.floor(eval.callsPerSecond),
               samples = eval.stats.sampleSize,
               fastest = eval.stats.min,
               median  = eval.stats.median,
               p99     = eval.stats.p99
            }
         end
      end
   end

   local last_result
   try
      log_file = io.open(glLogFile, 'r')
      local offset = 1024
      local pos = 1
      local buffer = ''
      local rx = regex.new('(.*)\n(?!\n)')
      while (pos > 0) do
         pos     = log_file:seek('end', offset)
         segment = log_file:read(1024)
         buffer  = segment .. buffer
         while buffer:endsWith('\n') do
            buffer = buffer:rtrim()
         end

         split = buffer:find('\n')
         if split then
            last_result = json.decode(buffer:substr(split))
            break
         end
         offset += 1024
      end
      log_file:close()
   end

   -- Save the results

   if save_results?? then
      report['config'] = {
         duration  = duration,
         warmup    = warmup,
         hotLoop   = hotloop,
         callLimit = call_limit
      }

      log_file = io.open(glLogFile, 'a')
      log_file:write(json.encode(report))
      log_file:write('\n')
      log_file:close()
   end

   if last_result then
      logMessage('')
      logMessage('Comparison to last run (+ve % is better):')
      logMessage('')
      for name, eval in pairs(last_result.evals) do
         if report.evals[name] then
            local cmp = report.evals[name]
            local pad_name = string.format(f'%{longest_name+2}s', name)
            local then_and_now = string.format('%5s -> %5s', string.format('%.2f', eval.p99), string.format('%.2f', cmp.p99))
            local pct = string.format('%8s', string.format("%.2f%%",(eval.p99 - cmp.p99) / cmp.p99 * 100))
            logMessage(f'{pad_name}: {then_and_now} {pct}')
         end
      end
   end
