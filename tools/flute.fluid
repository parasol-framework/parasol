-- $FLUID
--
-- Flute (FLUid TEst) provides a standard framework for the execution of unit tests in Fluid.
--
-- TODO: Support for JSON output of test results.
--       Support for parameterized tests from the command line.
--       Support for test retries on failure.
--       Support for test timeouts (mark as a fail after N seconds is exceeded).

glHelp = [[
Flute provides a standard framework for the execution of unit tests in Fluid.

Example usage:

   parasol flute.fluid file=[file]
]]

   require 'common'

   glFile    = arg('file')
   glTest    = arg('test')?:split(',') ?? { }
   glHotPath = arg('hotPath') -- Force hot-path execution for all tests.
   glSelf    = obj.find('self')
   glLabels  = arg('labels')?:split(',') ?? { }

   jit.opt.start("hotloop=3") -- Lower threshold to trigger JIT sooner, simplifies debugging

----------------------------------------------------------------------------------------------------------------------

glNetworkAvailable = thunk():bool
   global mNet ?= catch(function() return mod.load('network') end)
   return mNet != nil
end

glAudioAvailable = thunk():bool
   global mAudio ?= catch(function() return mod.load('audio') end)
   return mAudio != nil
end

glFontAvailable = thunk():bool
   global mFont ?= catch(function() return mod.load('font') end)
   return mFont != nil
end

glDisplayAvailable = thunk():bool
   global mGfx ?= catch(function() return mod.load('display') end)
   return mGfx != nil
end

global glSSLAvailable = thunk():bool
   glNetworkAvailable ?? return false

   -- Test if SSL support is available by attempting to create SSL socket

   ex, test_socket = catch(function()
      return obj.new('netsocket', { name = 'SSLSupportTest', port = glPort, flags = 'SERVER|SSL' })
   end)

   if test_socket then
      supported = test_socket.error is ERR_Okay
      test_socket = nil
      collectgarbage()
      return supported
   end

   return false
end

----------------------------------------------------------------------------------------------------------------------

function checkAvailable(Requirement:str, Expectation:bool)
   if Requirement is 'network' then
      return glNetworkAvailable is Expectation
   elseif Requirement is 'ssl' then
      return glSSLAvailable is Expectation
   elseif Requirement is 'font' then
      return glFontAvailable is Expectation
   elseif Requirement is 'audio' then
      return glAudioAvailable is Expectation
   elseif Requirement is 'display' then
      return glDisplayAvailable is Expectation
   else
      error('Invalid requirement: ' .. Requirement)
   end
end

----------------------------------------------------------------------------------------------------------------------

function sortTests(Tests:table)
   if #Tests <= 1 then return end

   table.sort(Tests, function(a,b)
      return (a.priority ?? 0) < (b.priority ?? 0)
   end)
end

----------------------------------------------------------------------------------------------------------------------
--[[
_ANNO = {
   [functionRef] = {
      name = 'functionName',
      source = 'path/to/file.fluid',
      annotations = {
         { name = 'Test', args = { key = value, ... } },
         { name = 'Requires', args = { ... } }
      }
   }
}
--]]

function runTests()
   global glTestTotal = 0
   global glTestsPassed = 0

   err, glFile = mSys.ResolvePath(glFile)
   if err != ERR_Okay then
      print("The targeted source file doesn't exist: " .. glFile)
      return
   end

   loadFile(glFile)

   all = debug.anno.list()
   before_each = {}
   after_each  = {}
   before_all  = {}
   after_all   = {}

   if all then
      global body ?= {}
      body.tests ?= {}

      for func, entry in pairs(all) do
         disabled = false
         is_test  = false
         test_name     = nil
         test_timeout  = nil
         test_priority = nil
         test_labels   = nil
         test_hotpath  = nil
         for k,v in pairs(entry.annotations) do
            if v.name is 'Test' then
               -- @Test Arguments: name, timeout, priority, labels
               is_test = true
               for k, v in pairs(v.args) do
                  choose k from
                     'name'     -> test_name     = v
                     'timeout'  -> test_timeout  = v
                     'priority' -> test_priority = v
                     'labels'   -> test_labels   = v
                     'hotpath'  -> test_hotpath  = v
                  end
               end
            elseif v.name is 'Disabled' then
               disabled = true
            elseif v.name is 'BeforeEach' then
               -- BeforeEach can carry arguments that determine the default parameters for all tests.
               table.insert(before_each, { func=func, args=v.args })
            elseif v.name is 'AfterEach' then
               table.insert(after_each, func)
            elseif v.name is 'BeforeAll' then
               table.insert(before_all, func)
            elseif v.name is 'AfterAll' then
               table.insert(after_all, func)
            elseif v.name is 'Requires' then
               for req, expect in pairs(v.args) do
                  if not checkAvailable(req, expect ?? true) then disabled = true end
               end
            end
         end

         if #glLabels > 0 then -- User is filtering on at least one label
            if test_labels is nil then
               disabled = true
            else
               label_present = false
               inverse = false

               for _, label_filter in ipairs(glLabels) do
                  if label_filter:startsWith('~') then
                     inverse = true
                     label_filter = label_filter:sub(1)
                  end

                  for _, test_label in ipairs(test_labels) do
                     if label_filter is test_label then
                        label_present = true
                        break
                     end
                  end
                  if label_present then break end
               end

               if inverse then
                  if label_present then
                     disabled = true
                  end
               else
                  if not label_present then
                     disabled = true
                  end
               end
            end
         end

         if not disabled and is_test then
            table.insert(body.tests, {
               func     = func,
               name     = test_name ?? tostring(func),
               timeout  = test_timeout,
               priority = test_priority,
               labels   = test_labels,
               disabled = disabled,
               is_test  = is_test,
               hotpath  = test_hotpath
            })
         end
      end
   else
      print("The Flute test file did not include annotations.  It is either not a Flute script or is misconfigured.")
      return
   end

   if not body.tests then
      -- Exporting no tests is considered legitimate - a test file may choose to have no tests.
      print("The Flute test file did not return any tests to execute.")
      glSelf.errorString = nil
      return
   end

   glTestTotal += #body.tests

   if #before_all > 0 then
      state = {
         folder = [*_]file.splitPath(glFile)
      }

      for func in values(before_all) do
         func(state)
      end
   end

   sortTests(body.tests)

   i = 0
   for test in values(body.tests) do
      i++
      skip = false
      assert(test.name, 'Test function is missing a name.')
      assert(test.func, 'Test function is missing a function reference.')

      print('-- Test ' .. i .. ': ' .. test.name .. ' --')

      -- Filter by test name if requested

      if #glTest > 0 then
         skip = true
         for v in values(glTest) do
            if test.name is v then
               skip = false
               break
            end
         end
      end

      if not skip and test.func then
         -- Run the test
         startTime = mSys.PreciseTime()

         if #before_each > 0 then
            for entry in values(before_each) do
               if entry.args.hotpath then
                  test.hotpath ?= true
               end
               entry.func()
            end
         end

         local status, error_msg = pcall(test.func)
         hotpath_status = true
         if status and (test.hotpath or glHotPath) then
            -- First test succeeded.  The hot-path test involves calling the test repeatedly to exercise the JIT compiler.
            local count = 0
            hotpath_status, error_msg = pcall(function()
               for {0..5} do
                  test.func()
                  count++
               end
            end)
         end

         totalTime = (mSys.PreciseTime() - startTime) / 1000000

         if #after_each > 0 then
            for f in values(after_each) do
               f()
            end
         end

         collectgarbage()

         if not status then
            not error_msg ?? print(error_msg)
            print(string.format('FAIL: %.6f sec', totalTime))
         else
            if not hotpath_status then
               not error_msg ?? print(error_msg)
               print(string.format('FAIL (HOT-PATH): %.6f sec', totalTime))
            else
               print(string.format('PASS: %.6f sec', totalTime))
               glTestsPassed++
            end
         end
      else
         print('SKIPPED')
         glTestTotal -= 1
      end
   end

   if #after_all > 0 then
      for func in values(after_all) do
         func()
      end
   end

   body?.cleanup()

   if glTestsPassed < glTestTotal then
      -- Setting the errorString will ensure that an error code is returned to the shell.
      glSelf.errorString = 'Ran ' .. glTestTotal .. ' tests, passed ' .. glTestsPassed
   else
      glSelf.errorString = nil
   end

   print('--\nRan ' .. glTestTotal .. ' tests, passed ' .. glTestsPassed)
end

----------------------------------------------------------------------------------------------------------------------
-- Unit tests should call logOutput() for the purpose of formally logging output for the current test.

global function logOutput(Message)
   print(Message)
end

----------------------------------------------------------------------------------------------------------------------

   if not glFile?? then
      print(glHelp)
      return
   end

   -- Setting an error string ensures that ctest will register a failure if the tests do not complete as planned.
   glSelf.errorString = 'Unexpected execution failure - tests not executed as planned.'

   runTests()
