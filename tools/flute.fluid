-- $FLUID
--
-- Flute (FLUid TEst) provides a standard framework for the execution of unit tests in Fluid.
--
-- TODO: Support for JSON output of test results.
--       Support for parameterized tests from the command line.
--       Support for test retries on failure.
--       Support for test timeouts (mark as a fail after N seconds is exceeded).
--       Support for test filtering by annotated labels

glHelp = [[
Flute provides a standard framework for the execution of unit tests in Fluid.

Example usage:

   parasol flute.fluid file=[file]
]]

   require 'common'

   glFile = arg('file')
   glTest = arg('test')
   glHotPath = arg('hotPath') -- Force hot-path execution for all tests.
   glSelf = obj.find('self')

----------------------------------------------------------------------------------------------------------------------

glNetworkAvailable = thunk():bool
   catch(function()
      if not mNet then
         global mNet = mod.load('network')
      end
   end)
   return mNet != nil
end

glAudioAvailable = thunk():bool
   if not mAudio then
      global mAudio = catch(function() return mod.load('audio') end)
   end
   return mAudio != nil
end

glDisplayAvailable = thunk():bool
   if not mGfx then
      global mGfx = catch(function() return mod.load('display') end)
   end
   return mGfx != nil
end

global glSSLAvailable = thunk():bool
   glNetworkAvailable ?? return false

   -- Test if SSL support is available by attempting to create SSL socket

   ex, test_socket = catch(function()
      return obj.new('netsocket', { name = 'SSLSupportTest', port = glPort, flags = 'SERVER|SSL' })
   end)

   if test_socket then
      supported = false
      if test_socket.error is ERR_Okay then
         supported = true
      end
      test_socket = nil
      collectgarbage()
      return supported
   end

   return false
end

----------------------------------------------------------------------------------------------------------------------

function checkAvailable(Requirement:str, Expectation:bool)
   if Requirement is 'network' then
      return glNetworkAvailable is Expectation
   elseif Requirement is 'ssl' then
      return glSSLAvailable is Expectation
   elseif Requirement is 'audio' then
      return glAudioAvailable is Expectation
   elseif Requirement is 'display' then
      return glDisplayAvailable is Expectation
   else
      error('Invalid requirement: ' .. Requirement)
   end
end

----------------------------------------------------------------------------------------------------------------------

function sortTests(Tests:table)
   if (#Tests <= 1) then return end

   table.sort(Tests, function(a,b)
      return (a.priority ?? 0) < (b.priority ?? 0)
   end)
end

----------------------------------------------------------------------------------------------------------------------
--[[
_ANNO = {
   [functionRef] = {
      name = 'functionName',
      source = 'path/to/file.fluid',
      annotations = {
         { name = 'Test', args = { key = value, ... } },
         { name = 'Requires', args = { ... } }
      }
   }
}
--]]

function runTests()
   global glTestTotal = 0
   global glTestsPassed = 0

   err, t = mSys.AnalysePath(glFile)
   if (err != ERR_Okay) or (t != LOC_FILE) then
      print("The targeted source file doesn't exist: " .. glFile)
      return
   end

   loadFile(glFile)

   all = debug.anno.list()
   before_each = {}
   after_each  = {}
   before_all  = {}
   after_all   = {}

   if all then
      global body ?= {}
      body.tests ?= {}

      for func, entry in pairs(all) do
         disabled = false
         is_test  = false
         test_name     = nil
         test_timeout  = nil
         test_priority = nil
         test_labels   = nil
         test_hotpath  = nil
         for k,v in pairs(entry.annotations) do
            if v.name is 'Test' then
               -- @Test Arguments: name, timeout, priority, labels
               is_test = true
               for k, v in pairs(v.args) do
                  if k is 'name' then
                     test_name = v
                  elseif k is 'timeout' then
                     test_timeout = v
                  elseif k is 'priority' then
                     test_priority = v
                  elseif k is 'labels' then
                     test_labels = v
                  elseif k is 'hotpath' then
                     test_hotpath = v
                  end
               end
            elseif v.name is 'Disabled' then
               disabled = true
            elseif v.name is 'BeforeEach' then
               -- BeforeEach can carry arguments that determine the default parameters for all tests.
               table.insert(before_each, { func=func, args=v.args })
            elseif v.name is 'AfterEach' then
               table.insert(after_each, func)
            elseif v.name is 'BeforeAll' then
               table.insert(before_all, func)
            elseif v.name is 'AfterAll' then
               table.insert(after_all, func)
            elseif v.name is 'Requires' then
               for req, expect in pairs(v.args) do
                  if not checkAvailable(req, expect ?? true) then disabled = true end
               end
            end
         end

         if not disabled and is_test then
            table.insert(body.tests, {
               func     = func,
               name     = test_name ?? tostring(func),
               timeout  = test_timeout,
               priority = test_priority,
               labels   = test_labels,
               disabled = disabled,
               is_test  = is_test,
               hotpath  = test_hotpath
            })
         end
      end
   else
      print("The Flute test file did not include annotations.  It is either not a Flute script or is misconfigured.")
      return
   end

   if not body.tests then
      -- Exporting no tests is considered legitimate - a test file may choose to have no tests.
      print("The Flute test file did not return any tests to execute.")
      glSelf.errorString = nil
      return
   end

   glTestTotal += #body.tests

   if #before_all > 0 then
      state = {
         folder = [*_]file.splitPath(glFile)
      }

      for func in values(before_all) do
         func(state)
      end
   end

   sortTests(body.tests)

   i = 0
   for test in values(body.tests) do
      i++
      skip = false
      assert(test.name, 'Test function is missing a name.')
      assert(test.func, 'Test function is missing a function reference.')
      
      print('-- Test ' .. i .. ': ' .. test.name .. ' --')
      if glTest and (test.name != glTest) then
         skip = true
      end

      if not skip and test.func then
         -- Run the test
         startTime = mSys.PreciseTime()

         if #before_each > 0 then
            for entry in values(before_each) do
               if entry.args.hotpath then
                  test.hotpath ?= true
               end
               entry.func()
            end
         end

         local status, error_msg = pcall(test.func)
         local hotpath_status = true
         if status and (test.hotpath or glHotPath) then
            -- First test succeeded.  The hot-path test involves calling the test repeatedly to exercise the JIT compiler.
            local count = 0
            hotpath_status, error_msg = pcall(function()
               for {0..100} do
                  test.func()
                  count++
               end
            end)
         end

         totalTime = (mSys.PreciseTime() - startTime) / 1000000

         if #after_each > 0 then
            for f in values(after_each) do
               f()
            end
         end

         collectgarbage()

         if not status then
            if error_msg then print(error_msg) end
            print(string.format('FAIL: %.6f sec', totalTime))
         else
            if not hotpath_status then
               if error_msg then print(error_msg) end
               print(string.format('FAIL (HOT-PATH): %.6f sec', totalTime))
            else
               print(string.format('PASS: %.6f sec', totalTime))
               glTestsPassed++
            end
         end
      else
         print('SKIPPED')
         glTestTotal -= 1
      end
   end

   if #after_all > 0 then
      for func in values(after_all) do
         func()
      end
   end

   body?.cleanup()

   print('--')

   if glTestsPassed < glTestTotal then
      -- Setting the errorString will ensure that an error code is returned to the shell.
      glSelf.errorString = 'Ran ' .. glTestTotal .. ' tests, passed ' .. glTestsPassed
   else
      glSelf.errorString = nil
   end

   print('Ran ' .. glTestTotal .. ' tests, passed ' .. glTestsPassed)
end

----------------------------------------------------------------------------------------------------------------------
-- Unit tests should call logOutput() for the purpose of formally logging output for the current test.

global function logOutput(Message)
   print(Message)
end

----------------------------------------------------------------------------------------------------------------------

   if not glFile?? then
      print(glHelp)
      return
   end

   -- Setting an error string ensures that ctest will register a failure if the tests do not complete as planned.
   glSelf.errorString = 'Unexpected execution failure - tests not executed as planned.'

   runTests()
