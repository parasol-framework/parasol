--[[
Fluid Benchmarking Tool

Usage:
   parasol benchmark.fluid [test=Name]

Parameters:
  test    - Regex defining the test(s) to run.
 --]]

   import 'benchmark'
   import 'git'

   global glSelf = obj.find('self')
   global glPath = glSelf.workingPath
   global glLogFile = io.open(glPath .. 'benchmark.log', 'a')

----------------------------------------------------------------------------------------------------------------------
-- MATHEMATICAL OPERATIONS
----------------------------------------------------------------------------------------------------------------------
-- Integer Arithmetic: add, sub, mul, div, mod with integer operands

@Test function MathIntegerArithmetic()
   local a, b, c, d, e = 1, 2, 3, 4, 5
   for i in {0..100000} do
      a = i + 17
      b = a - 13
      c = b * 7
      d = c / 3
      e = d % 11

      -- Chain operations
      a = ((i + 100) * 3 - 50) / 2
      b = (a % 97) + (c % 53)
      c = a * b + c * d - e

      -- Nested arithmetic
      d = (a + b) * (c - d) / (e + 1)
      e = ((a * 2) + (b * 3) - (c / 4)) % 1000
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Floating-Point Arithmetic: add, sub, mul, div with double precision

@Test function MathFloatingPoint()
   local a, b, c, d = 1.0, 2.0, 3.0, 4.0
   local pi <const> = 3.14159265358979
   local e <const> = 2.71828182845905
   local phi <const> = 1.61803398874989

   for i in {0..100000} do
      a = i * pi
      b = a / e
      c = b + phi
      d = c - 0.57721566490153  -- Euler-Mascheroni constant

      -- Mixed precision chain
      a = (i + 0.5) * 3.14159
      b = a / 2.71828 + 1.41421  -- sqrt(2)
      c = (a * b) - (b / a)
      d = c * 0.001 + d * 1000.0

      -- Scientific notation
      a = i * 1.23e-5
      b = a + 9.87e6
      c = b * 4.56e-3
      d = c / 7.89e2
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Bitwise Operations: and, or, xor, not, left shift, right shift (Fluid C-style operators)

@Test function MathBitwiseOperations()
   local a, b, c, d = 0xFF, 0xAA, 0x55, 0x0F
   for i in {0..100000} do
      -- Basic bitwise operations
      a = i & 0xFF          -- AND
      b = i | 0xF0          -- OR
      c = i ~ 0xAA          -- XOR (Fluid uses ~ for XOR, not ^)
      d = ~i                -- NOT (bitwise complement)

      -- Shift operations
      a = i << 4            -- Left shift
      b = i >> 2            -- Right shift
      c = (i << 8) | (i >> 8)  -- Byte swap pattern

      -- Combined bitwise expressions
      d = (a & 0x0F) | (b & 0xF0)
      a = ((i & 0xFF) << 8) | ((i >> 8) & 0xFF)
      b = (c ~ d) & 0xFFFF
      c = (~a & b) | (a & ~b)  -- XOR via AND/OR/NOT

      -- Mask and flag operations
      d = i | (1 << (i % 8))   -- Set bit
      a = i & ~(1 << (i % 8))  -- Clear bit
      b = i ~ (1 << (i % 8))   -- Toggle bit
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Math Library Functions: trigonometric, exponential, logarithmic, rounding, random

@Test function MathLibraryFunctions()
   local a, b, c, d = 0.0, 0.0, 0.0, 0.0
   for i in {0..100000} do
      local x = i * 0.001  -- Scale to reasonable range

      -- Trigonometric functions
      a = math.sin(x)
      b = math.cos(x)
      c = math.tan(x % 1.5)  -- Avoid asymptotes
      d = math.asin(a)
      a = math.acos(b)
      b = math.atan(c)
      c = math.atan2(a, b)

      -- Exponential and logarithmic
      d = math.exp(x % 10)   -- Limit to avoid overflow
      a = math.log(i + 1)
      b = math.log10(i + 1)
      c = math.pow(2, x % 20)
      d = math.sqrt(i + 1)

      -- Rounding functions
      a = math.floor(x * 100)
      b = math.ceil(x * 100)
      c = math.abs(x - 50)
      d = math.min(a, b, c)
      a = math.max(a, b, c)

      -- Random number generation
      b = math.random()
      c = math.random(100)
      d = math.random(1, 1000)
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Compound Operators: +=, -=, *=, /=, %=, ++, --

@Test function MathCompoundOperators()
   local a, b, c, d, e = 1.0, 100.0, 1000.0, 10000.0, 50000.0
   for i in {0..100000} do
      -- Compound assignment operators
      a += 1.5
      b -= 0.7
      c *= 1.001
      d /= 1.0001
      e %= 99999

      -- Increment and decrement
      a++
      b--
      c++
      d--

      -- Reset periodically to avoid overflow/underflow
      if i % 1000 is 0 then
         a = 1.0
         b = 100.0
         c = 1000.0
         d = 10000.0
         e = 50000.0
      end

      -- Mixed compound operations
      a += b
      b -= c * 0.001
      c *= 1.0 + (d * 0.00001)
      d /= 1.0 + (a * 0.0001)

      -- String concatenation compound (..=)
      local s = "test"
      s ..= "a"
      s ..= "b"
      s ..= "c"
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Numeric Comparisons: equality, ordering, min/max chains

@Test function MathNumericComparisons()
   local a, b, c, d = 0, 0, 0, 0
   local result = false
   for i in {0..100000} do
      local x = i * 1.1
      local y = i * 1.2
      local z = i * 0.9

      -- Equality comparisons (using 'is' per Fluid convention)
      result = (i % 10) is 0
      result = x is y
      result = (i & 0xFF) is 0

      -- Inequality comparisons
      result = x != y
      result = i != 0

      -- Ordering comparisons
      result = x < y
      result = x <= y
      result = x > z
      result = x >= z

      -- Chained comparisons (evaluated left-to-right)
      result = z < x and x < y
      result = x >= z and x <= y

      -- Conditional assignments based on comparisons
      a = x < y and 1 or 0
      b = x > z and x or z
      c = (i % 2 is 0) and i or -i

      -- Ternary operator
      d = x < y ? x :> y
      a = i % 2 is 0 ? i * 2 :> i * 3
      b = x > 100 ? (x > 1000 ? 2 :> 1) :> 0
   end
end

----------------------------------------------------------------------------------------------------------------------
-- STRING OPERATIONS
----------------------------------------------------------------------------------------------------------------------
-- Goal: Get the length of strings of varying sizes

@Test function StringGetLength()
   local short_str  = "Hello"
   local medium_str = "The quick brown fox jumps over the lazy dog."
   local long_str   = string.rep("Lorem ipsum dolor sit amet, consectetur adipiscing elit. ", 20)

   for i in {0..50000} do
      local len1 = #short_str
      local len2 = #medium_str
      local len3 = #long_str

      -- Also test string.len equivalent
      local len4 = string.len(short_str)
      local len5 = string.len(medium_str)
      local len6 = string.len(long_str)
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Build a string by concatenating multiple parts

@Test function StringConcatenateMultiple()
   for i in {0..100000} do
      -- Concatenate literals
      local result = "Hello" .. " " .. "World" .. "!"

      -- Concatenate with variables
      local a, b, c = "foo", "bar", "baz"
      result = a .. b .. c

      -- Build a longer string from parts
      local parts = "Part1" .. "-" .. "Part2" .. "-" .. "Part3" .. "-" .. "Part4"

      -- Concatenate numbers converted to strings
      result = "Value: " .. tostring(i) .. ", Next: " .. tostring(i + 1)
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Build a string incrementally using append operations

@Test function StringBuildIncrementally()
   for i in {0..1000} do
      local result = ""
      for j in {0..100} do
         result ..= "x"
      end

      -- Build with varying content
      local sentence = ""
      sentence ..= "The "
      sentence ..= "quick "
      sentence ..= "brown "
      sentence ..= "fox "
      sentence ..= "jumps."
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Format strings with embedded values (string interpolation)

@Test function StringFormatWithValues()
   local name = "Alice"
   local age = 30
   local score = 95.5

   for i in {0..1000} do
      -- Using string.format (printf-style)
      local msg1 = string.format("Name: %s, Age: %d", name, age)
      local msg2 = string.format("Score: %.2f out of 100", score)
      local msg3 = string.format("Item %05d costs $%8.2f", i, i * 1.99)

      -- Using Fluid string interpolation
      local msg4 = f"Name: {name}, Age: {age}"
      local msg5 = f"Iteration {i} of 100000"
      local msg6 = f"Result: {i * 2 + 1}"
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Extract a substring from a larger text

@Test function StringExtractSubstring()
   local text = "The quick brown fox jumps over the lazy dog. Pack my box with five dozen liquor jugs."

   for i in {0..10000} do
      -- Extract from beginning
      local first_word = string.sub(text, 1, 3)

      -- Extract from middle
      local middle = string.sub(text, 16, 19)  -- "fox "

      -- Extract from end
      local last_part = string.sub(text, -10)

      -- Extract with negative indices
      local from_end = string.sub(text, -20, -11)

      -- Variable position extraction
      local pos = (i % 40) + 1
      local chunk = string.sub(text, pos, pos + 10)
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Find the position of a substring within text

@Test function StringFindSubstring()
   local text = "The quick brown fox jumps over the lazy dog. The fox is quick."
   local paragraph = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. " ..
                     "Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua."

   for i in {0..5000000} do
      -- Find word at beginning
      local pos1 = string.find(text, "The")

      -- Find word in middle
      local pos2 = string.find(text, "fox")

      -- Find word at end
      local pos3 = string.find(text, "quick", 20)  -- Start search from position 20

      -- Find substring that doesn't exist
      local pos4 = string.find(text, "xyz")

      -- Find in longer text
      local pos5 = string.find(paragraph, "dolor")
      local pos6 = string.find(paragraph, "magna")
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Replace words or patterns in a paragraph

@Test function StringReplaceWords()
   local text = "The quick brown fox jumps over the lazy dog."

   for i in {0..100} do
      -- Replace single occurrence
      local result1 = string.gsub(text, "fox", "cat")

      -- Replace all occurrences
      local text2 = "the cat sat on the mat with the cat"
      local result2 = string.gsub(text2, "cat", "dog")

      -- Replace with pattern
      local result3 = string.gsub(text, "%s+", "_")  -- Replace spaces with underscores

      -- Replace multiple different words
      local result4 = string.gsub(text, "quick", "slow")
      result4 = string.gsub(result4, "brown", "white")
      result4 = string.gsub(result4, "lazy", "energetic")
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Split text into words or tokens

@Test function StringSplitIntoWords()
   local sentence = "The quick brown fox jumps over the lazy dog"
   local csv_data = "apple,banana,cherry,date,elderberry,fig,grape"

   for i in {0..100} do
      -- Split by spaces using gmatch
      local words = {}
      local idx = 0
      for word in string.gmatch(sentence, "%S+") do
         words[idx] = word
         idx++
      end

      -- Split CSV by comma
      local items = {}
      idx = 0
      for item in string.gmatch(csv_data, "[^,]+") do
         items[idx] = item
         idx++
      end

      -- Split by multiple delimiters
      local mixed = "one;two,three:four"
      local parts = {}
      idx = 0
      for part in string.gmatch(mixed, "[^;,:]+") do
         parts[idx] = part
         idx++
      end
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Compare two strings for equality and ordering

@Test function StringCompareStrings()
   local str1 = "apple"
   local str2 = "banana"
   local str3 = "apple"
   local str4 = "Apple"
   local long1 = "The quick brown fox jumps over the lazy dog"
   local long2 = "The quick brown fox jumps over the lazy cat"

   for i in {0..4000000} do
      -- Equality comparison
      local eq1 = str1 is str3      -- true
      local eq2 = str1 is str2      -- false
      local eq3 = str1 is str4      -- false (case sensitive)

      -- Inequality
      local neq1 = str1 != str2

      -- Lexicographic ordering
      local lt1 = str1 < str2       -- "apple" < "banana"
      local gt1 = str2 > str1
      local le1 = str1 <= str3
      local ge1 = str1 >= str3

      -- Compare longer strings
      local eq_long = long1 is long2
      local lt_long = long1 < long2
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Convert text to uppercase and lowercase

@Test function StringChangeCase()
   local mixed = "Hello World! This Is A Test."
   local lower = "all lowercase text here"
   local upper = "ALL UPPERCASE TEXT HERE"

   for i in {0..40000} do
      -- Convert to uppercase
      local up1 = string.upper(mixed)
      local up2 = string.upper(lower)

      -- Convert to lowercase
      local lo1 = string.lower(mixed)
      local lo2 = string.lower(upper)

      -- Round-trip conversion
      local round = string.lower(string.upper(mixed))
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Remove whitespace from beginning and end of strings

@Test function StringTrimWhitespace()
   local padded = "   Hello World   "
   local left_pad = "   Left padded"
   local right_pad = "Right padded   "
   local tabs = "\t\tTabbed content\t\t"
   local mixed_ws = "  \t Mixed whitespace \n  "

   for i in {0..1000} do
      -- Trim both ends using pattern matching
      local trimmed1 = string.match(padded, "^%s*(.-)%s*$")
      local trimmed2 = string.match(left_pad, "^%s*(.-)%s*$")
      local trimmed3 = string.match(right_pad, "^%s*(.-)%s*$")
      local trimmed4 = string.match(tabs, "^%s*(.-)%s*$")
      local trimmed5 = string.match(mixed_ws, "^%s*(.-)%s*$")

      -- Trim left only
      local ltrim = string.match(left_pad, "^%s*(.*)")

      -- Trim right only
      local rtrim = string.match(right_pad, "(.-)%s*$")
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Access individual characters in a string

@Test function StringAccessCharacters()
   local text = "Hello, World!"

   for i in {0..100} do
      -- Get character at specific position using string.sub
      local char1 = string.sub(text, 1, 1)   -- 'H'
      local char2 = string.sub(text, 7, 7)   -- ' '
      local char3 = string.sub(text, -1, -1) -- '!'

      -- Get character code (byte value)
      local code1 = string.byte(text, 1)     -- 72 ('H')
      local code2 = string.byte(text, 8)     -- 87 ('W')

      -- Get multiple byte values
      local codes = {string.byte(text, 1, 5)}

      -- Create character from code
      local chr = string.char(65)            -- 'A'
      local str = string.char(72, 105, 33)   -- "Hi!"

      -- Variable position access
      local pos = (i % #text) + 1
      local var_char = string.sub(text, pos, pos)
      local var_code = string.byte(text, pos)
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Match patterns in text and extract captures

@Test function StringMatchPatterns()
   local email = "user@example.com"
   local date = "2024-01-15"
   local log_line = "[ERROR] 2024-01-15 10:30:45 - Connection failed"
   local url = "https://www.example.com:8080/path/to/page?query=value"

   for i in {0..1000} do
      -- Simple pattern match
      local matched = string.match(email, "@")

      -- Extract with captures
      local user, domain = string.match(email, "([^@]+)@(.+)")

      -- Match date components
      local year, month, day = string.match(date, "(%d+)-(%d+)-(%d+)")

      -- Match log level
      local level = string.match(log_line, "%[(%u+)%]")

      -- Match timestamp
      local timestamp = string.match(log_line, "(%d%d:%d%d:%d%d)")

      -- Complex URL parsing
      local protocol = string.match(url, "^(%w+)://")
      local host = string.match(url, "://([^:/]+)")
      local port = string.match(url, ":(%d+)/")
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Repeat a string multiple times

@Test function StringRepeatString()
   local char = "x"
   local word = "abc"
   local line = "-"

   for i in {0..100000} do
      -- Repeat single character
      local repeated1 = string.rep(char, 10)
      local repeated2 = string.rep(char, 100)

      -- Repeat word
      local repeated3 = string.rep(word, 5)
      local repeated4 = string.rep(word, 20)

      -- Build separator line
      local separator = string.rep(line, 80)

      -- Repeat with separator
      local with_sep = string.rep("item", 5, ", ")

      -- Variable repetition
      local count = (i % 10) + 1
      local var_rep = string.rep("*", count)
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Reverse a string

@Test function StringReverseString()
   local short = "Hello"
   local medium = "The quick brown fox"
   local long = "Pack my box with five dozen liquor jugs. The quick brown fox jumps over the lazy dog."

   for i in {0..100000} do
      -- Reverse strings of different lengths
      local rev1 = string.reverse(short)
      local rev2 = string.reverse(medium)
      local rev3 = string.reverse(long)

      -- Double reverse (should equal original)
      local double_rev = string.reverse(string.reverse(medium))

      -- Palindrome check pattern
      local test = "racecar"
      local is_palindrome = test is string.reverse(test)
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Check if a string starts or ends with a given prefix/suffix

@Test function StringStartsEndsWith()
   local filename = "document.txt"
   local path = "/home/user/documents/file.pdf"
   local url = "https://www.example.com/page"

   for i in {0..1000} do
      -- Check prefix using string.sub
      local starts_with_doc = string.sub(filename, 1, 3) is "doc"
      local starts_with_http = string.sub(url, 1, 5) is "https"
      local starts_with_slash = string.sub(path, 1, 1) is "/"

      -- Check suffix using string.sub with negative index
      local ends_with_txt = string.sub(filename, -4) is ".txt"
      local ends_with_pdf = string.sub(path, -4) is ".pdf"
      local ends_with_com = string.sub(url, -4) is ".com"

      -- Check using pattern match
      local has_prefix = string.match(filename, "^doc") != nil
      local has_suffix = string.match(filename, "%.txt$") != nil

      -- Variable prefix/suffix checks
      local extensions = {".txt", ".pdf", ".doc", ".csv"}
      local ext = extensions[i % 4]
      local chk = string.sub(filename, -#ext) is ext
   end
end

----------------------------------------------------------------------------------------------------------------------
-- ARRAY OPERATIONS
----------------------------------------------------------------------------------------------------------------------
-- Goal: Create arrays of different types with initial values

@Test function ArrayCreateWithValues()
   for i in {0..1000} do
      -- Create integer arrays
      local int_arr1 = array<int> { 1, 2, 3, 4, 5 }
      local int_arr2 = array<int> { 10, 20, 30, 40, 50, 60, 70, 80, 90, 100 }

      -- Create double arrays
      local dbl_arr1 = array<double> { 1.1, 2.2, 3.3, 4.4, 5.5 }
      local dbl_arr2 = array<double> { 3.14159, 2.71828, 1.41421, 1.73205 }

      -- Create string arrays
      local str_arr1 = array<string> { "apple", "banana", "cherry" }
      local str_arr2 = array<string> { "one", "two", "three", "four", "five" }

      -- Create sized arrays
      local sized_int = array<int, 100>
      local sized_dbl = array<double, 50>
      local sized_str = array<string, 20>
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Read and write elements by index

@Test function ArrayAccessByIndex()
   local int_arr = array<int, 1000>
   local dbl_arr = array<double, 1000>
   local str_arr = array<string, 100>

   -- Initialise arrays
   for i = 0, 999 do
      int_arr[i] = i
      dbl_arr[i] = i * 1.5
   end
   for i = 0, 99 do
      str_arr[i] = f"item_{i}"
   end

   for i in {0..1000} do
      -- Read integer elements
      local v1 = int_arr[0]
      local v2 = int_arr[500]
      local v3 = int_arr[999]

      -- Read double elements
      local d1 = dbl_arr[0]
      local d2 = dbl_arr[500]
      local d3 = dbl_arr[999]

      -- Read string elements
      local s1 = str_arr[0]
      local s2 = str_arr[50]
      local s3 = str_arr[99]

      -- Write elements
      local idx = i % 100
      int_arr[idx] = i
      dbl_arr[idx] = i * 2.5
      str_arr[idx] = f"value_{i}"
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Add elements to the end of an array

@Test function ArrayPushElements()
   for i in {0..100} do
      -- Push integers
      local int_arr = array<int>
      for j = 0, 99 do
         int_arr:push(j * 10)
      end

      -- Push doubles
      local dbl_arr = array<double>
      for j = 0, 99 do
         dbl_arr:push(j * 1.5)
      end

      -- Push strings
      local str_arr = array<string>
      for j = 0, 49 do
         str_arr:push(f"item_{j}")
      end
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Remove elements from the end of an array

@Test function ArrayPopElements()
   for i in {0..100} do
      -- Pop integers
      local int_arr = array<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }
      for j = 0, 9 do
         local val = int_arr:pop()
      end

      -- Pop doubles
      local dbl_arr = array<double> { 1.1, 2.2, 3.3, 4.4, 5.5 }
      for j = 0, 4 do
         local val = dbl_arr:pop()
      end

      -- Pop strings
      local str_arr = array<string> { "a", "b", "c", "d", "e" }
      for j = 0, 4 do
         local val = str_arr:pop()
      end
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Find a value in an array

@Test function ArrayFindValue()
   local int_arr = array<int, 1000>
   local dbl_arr = array<double, 1000>
   local str_arr = array<string> { "apple", "banana", "cherry", "date", "elderberry",
      "fig", "grape", "honeydew", "kiwi", "lemon" }

   for i = 0, 999 do
      int_arr[i] = i * 10
      dbl_arr[i] = i * 1.5
   end

   for i in {0..1000} do
      -- Find in integer array
      local idx1 = int_arr:find(0)
      local idx2 = int_arr:find(5000)
      local idx3 = int_arr:find(9990)
      local idx4 = int_arr:find(12345)  -- Not found

      -- Find in double array
      local idx5 = dbl_arr:find(0.0)
      local idx6 = dbl_arr:find(750.0)
      local idx7 = dbl_arr:find(999.999)  -- Not found

      -- Find in string array
      local idx8 = str_arr:find("apple")
      local idx9 = str_arr:find("grape")
      local idx10 = str_arr:find("mango")  -- Not found
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Check if an array contains a specific value

@Test function ArrayContainsValue()
   local int_arr = array<int> { 10, 20, 30, 40, 50, 60, 70, 80, 90, 100 }
   local dbl_arr = array<double> { 1.5, 2.5, 3.5, 4.5, 5.5 }
   local str_arr = array<string> { "red", "green", "blue", "yellow", "purple" }

   for i in {0..1000} do
      -- Check integer array
      local has1 = int_arr:contains(50)
      local has2 = int_arr:contains(100)
      local has3 = int_arr:contains(55)  -- false

      -- Check double array
      local has4 = dbl_arr:contains(3.5)
      local has5 = dbl_arr:contains(2.0)  -- false

      -- Check string array
      local has6 = str_arr:contains("blue")
      local has7 = str_arr:contains("orange")  -- false
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Sort an array in ascending or descending order

@Test function ArraySortElements()
   for i in {0..100} do
      -- Sort integers ascending
      local int_arr = array<int> { 50, 30, 80, 10, 60, 40, 90, 20, 70, 100 }
      int_arr:sort()

      -- Sort integers descending
      local int_arr2 = array<int> { 50, 30, 80, 10, 60, 40, 90, 20, 70, 100 }
      int_arr2:sort(true)

      -- Sort doubles
      local dbl_arr = array<double> { 3.14, 1.41, 2.71, 1.73, 0.57 }
      dbl_arr:sort()

      -- Sort strings alphabetically
      local str_arr = array<string> { "cherry", "apple", "banana", "date", "elderberry" }
      str_arr:sort()
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Reverse the order of elements in an array

@Test function ArrayReverseElements()
   for i in {0..1000} do
      -- Reverse integer array
      local int_arr = array<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }
      int_arr:reverse()

      -- Reverse double array
      local dbl_arr = array<double> { 1.1, 2.2, 3.3, 4.4, 5.5 }
      dbl_arr:reverse()

      -- Reverse string array
      local str_arr = array<string> { "first", "second", "third", "fourth", "fifth" }
      str_arr:reverse()
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Extract a portion of an array (slice)

@Test function ArraySliceRange()
   local int_arr = array<int> { 0, 10, 20, 30, 40, 50, 60, 70, 80, 90 }
   local dbl_arr = array<double> { 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 }
   local str_arr = array<string> { "a", "b", "c", "d", "e", "f", "g", "h" }

   for i in {0..1000} do
      -- Slice integer arrays with different ranges
      local slice1 = int_arr:slice({0..5})      -- First 5 elements
      local slice2 = int_arr:slice({5..10})     -- Last 5 elements
      local slice3 = int_arr:slice({2..8})      -- Middle portion
      local slice4 = int_arr:slice({-3..-1})    -- Last 3 using negative indices

      -- Slice double array
      local slice5 = dbl_arr:slice({0..4})
      local slice6 = dbl_arr:slice({2...5})     -- Inclusive range

      -- Slice string array
      local slice7 = str_arr:slice({1..4})
      local slice8 = str_arr:slice({0..-1})     -- All elements
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Fill an array with a specific value

@Test function ArrayFillWithValue()
   for i in {0..1000} do
      -- Fill entire integer array
      local int_arr = array<int, 100>
      int_arr:fill(42)

      -- Fill portion of array with range
      local int_arr2 = array<int, 100>
      int_arr2:fill(0)
      int_arr2:fill(99, {10..50})

      -- Fill double array
      local dbl_arr = array<double, 50>
      dbl_arr:fill(3.14159)

      -- Fill with stepped range
      local int_arr3 = array<int, 100>
      int_arr3:fill(0)
      int_arr3:fill(1, range.new(0, 100, false, 2))  -- Every other element
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Copy data between arrays

@Test function ArrayCopyData()
   for i in {0..1000} do
      -- Copy from table to integer array
      local int_arr = array<int, 10>
      local table_data = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100}
      int_arr:copy(table_data)

      -- Copy from table to double array
      local dbl_arr = array<double, 5>
      local dbl_data = {1.1, 2.2, 3.3, 4.4, 5.5}
      dbl_arr:copy(dbl_data)

      -- Copy with destination offset
      local int_arr2 = array<int, 10>
      int_arr2:fill(0)
      int_arr2:copy({100, 200, 300}, 3, 0, 3)
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Iterate over all elements in an array

@Test function ArrayIterateElements()
   local int_arr = array<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }
   local dbl_arr = array<double> { 1.1, 2.2, 3.3, 4.4, 5.5 }
   local str_arr = array<string> { "apple", "banana", "cherry", "date", "elderberry" }

   for i in {0..1000} do
      -- Iterate integers with index and value
      local sum = 0
      for idx, val in int_arr do
         sum += val
      end

      -- Iterate doubles using values()
      local dbl_sum = 0.0
      for val in values(dbl_arr) do
         dbl_sum += val
      end

      -- Iterate strings with ipairs
      local concat = ""
      for _, s in ipairs(str_arr) do
         concat ..= s
      end

      -- Iterate with pairs
      local count = 0
      for k, v in pairs(int_arr) do
         count++
      end
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Join array elements into a single string

@Test function ArrayJoinToString()
   local int_arr = array<int> { 1, 2, 3, 4, 5 }
   local dbl_arr = array<double> { 1.5, 2.5, 3.5 }
   local str_arr = array<string> { "apple", "banana", "cherry" }

   for i in {0..1000} do
      -- Join integers with different separators
      local joined1 = int_arr:join("-")
      local joined2 = int_arr:join(", ")
      local joined3 = int_arr:join("")

      -- Join doubles
      local joined4 = dbl_arr:join(" | ")

      -- Join strings
      local joined5 = str_arr:join(" ")
      local joined6 = str_arr:join(", ")
      local joined7 = str_arr:join("")
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Concatenate array elements with formatting

@Test function ArrayConcatFormatted()
   local int_arr = array<int> { 1, 2, 3, 4, 5 }
   local dbl_arr = array<double> { 3.14159, 2.71828, 1.41421 }
   local str_arr = array<string> { "one", "two", "three" }

   for i in {0..1000} do
      -- Concat integers with format
      local result1 = int_arr:concat("%d", ", ")
      local result2 = int_arr:concat("%03d", "-")

      -- Concat doubles with precision
      local result3 = dbl_arr:concat("%.2f", ", ")
      local result4 = dbl_arr:concat("%.4f", " | ")

      -- Concat strings
      local result5 = str_arr:concat("%s", " ")
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Get the first and last elements of an array

@Test function ArrayFirstLastAccess()
   local int_arr = array<int> { 10, 20, 30, 40, 50 }
   local dbl_arr = array<double> { 1.1, 2.2, 3.3, 4.4, 5.5 }
   local str_arr = array<string> { "alpha", "beta", "gamma", "delta" }

   for i in {0..1000} do
      -- Get first element
      local first_int = int_arr:first()
      local first_dbl = dbl_arr:first()
      local first_str = str_arr:first()

      -- Get last element
      local last_int = int_arr:last()
      local last_dbl = dbl_arr:last()
      local last_str = str_arr:last()

      -- Compare with direct indexing
      local first_direct = int_arr[0]
      local last_direct = int_arr[#int_arr - 1]
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Get the length of an array

@Test function ArrayGetLength()
   local empty = array<int>
   local small = array<int> { 1, 2, 3 }
   local medium = array<int, 100>
   local large = array<int, 1000>
   local str_arr = array<string> { "a", "b", "c", "d", "e" }

   -- Fill the sized arrays
   for i = 0, 99 do medium[i] = i end
   for i = 0, 999 do large[i] = i end

   for i in {0..1000} do
      -- Get lengths
      local len1 = #empty
      local len2 = #small
      local len3 = #medium
      local len4 = #large
      local len5 = #str_arr

      -- Use length in calculations
      local total = len1 + len2 + len3 + len4 + len5
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Convert array to a Lua table

@Test function ArrayConvertToTable()
   local int_arr = array<int> { 10, 20, 30, 40, 50 }
   local dbl_arr = array<double> { 1.5, 2.5, 3.5, 4.5, 5.5 }
   local str_arr = array<string> { "one", "two", "three" }

   for i in {0..1000} do
      -- Convert to tables
      local tbl1 = int_arr:table()
      local tbl2 = dbl_arr:table()
      local tbl3 = str_arr:table()

      -- Access converted table elements
      local v1 = tbl1[0]
      local v2 = tbl2[2]
      local v3 = tbl3[1]
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Build and process a large array

@Test function ArrayLargeOperations()
   for i in {0..10} do
      -- Create and fill large array
      local arr = array<int, 10000>
      for j = 0, 9999 do
         arr[j] = j
      end

      -- Find values
      local idx1 = arr:find(5000)
      local idx2 = arr:find(9999)

      -- Check contains
      local has1 = arr:contains(5000)
      local has2 = arr:contains(99999)

      -- Slice
      local slice = arr:slice({1000..2000})

      -- Iterate and sum
      local sum = 0
      for _, v in arr do
         sum += v
      end
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Perform stack operations (push/pop pattern)

@Test function ArrayStackOperations()
   for i in {0..100} do
      local stack = array<int>

      -- Push 100 items
      for j = 0, 99 do
         stack:push(j)
      end

      -- Pop all items
      local sum = 0
      while #stack > 0 do
         sum += stack:pop()
      end

      -- Mixed push/pop operations
      local mixed = array<string>
      mixed:push("first")
      mixed:push("second")
      local top = mixed:pop()
      mixed:push("third")
      mixed:push("fourth")
      top = mixed:pop()
      top = mixed:pop()
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Use arrays as queues (FIFO pattern simulation)

@Test function ArrayQueuePattern()
   for i in {0..100} do
      local queue = array<int>

      -- Enqueue items
      for j = 0, 49 do
         queue:push(j)
      end

      -- De-queue by slicing (simulating queue behaviour)
      while #queue > 0 do
         local front = queue:first()
         queue:remove(0)
      end
   end
end

----------------------------------------------------------------------------------------------------------------------
-- TABLE OPERATIONS
----------------------------------------------------------------------------------------------------------------------
-- Goal: Create empty tables

@Test function TableCreateEmpty()
   for i in {0..1000} do
      -- Create empty tables
      local t1 = {}
      local t2 = {}
      local t3 = {}

      -- Create multiple in sequence
      local tables = {}
      for j = 0, 9 do
         tables[j] = {}
      end
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Create tables with initial key-value pairs

@Test function TableCreateWithValues()
   for i in {0..100000} do
      -- Create with string keys
      local person = { name = "Alice", age = 30, city = "London" }

      -- Create with mixed keys
      local mixed = { [0] = "zero", [1] = "one", key = "value" }

      -- Create nested tables
      local nested = {
         user = { name = "Bob", id = 123 },
         settings = { theme = "dark", language = "en" }
      }

      -- Create with computed values
      local computed = { index = i, doubled = i * 2, squared = i * i }
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Read and write table entries using string keys

@Test function TableAccessByStringKey()
   local t = { alpha = 1, beta = 2, gamma = 3, delta = 4, epsilon = 5 }

   for i in {0..1000000} do
      -- Read by string key
      local v1 = t.alpha
      local v2 = t["beta"]
      local v3 = t.gamma
      local v4 = t["delta"]
      local v5 = t.epsilon

      -- Write by string key
      t.alpha = i
      t["beta"] = i + 1
      t.gamma = i + 2
      t["delta"] = i + 3
      t.epsilon = i + 4
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Read and write table entries using integer keys

@Test function TableAccessByIntegerKey()
   local t = {}
   for i = 0, 99 do
      t[i] = i * 10
   end

   for i in {0..1000000} do
      -- Read by integer key
      local v1 = t[0]
      local v2 = t[50]
      local v3 = t[99]

      -- Write by integer key
      local idx = i % 100
      t[idx] = i
      t[idx + 1] = i * 2
      t[idx + 2] = i * 3
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Access deeply nested table properties

@Test function TableNestedAccess()
   local data = {
      level1 = {
         level2 = {
            level3 = {
               value = 42,
               items = { a = 1, b = 2, c = 3 }
            }
         }
      },
      users = {
         { name = "Alice", scores = { math = 95, science = 88 } },
         { name = "Bob", scores = { math = 82, science = 91 } }
      }
   }

   for i in {0..100000} do
      -- Deep property access
      local v1 = data.level1.level2.level3.value
      local v2 = data.level1.level2.level3.items.a
      local v3 = data.level1.level2.level3.items.b

      -- Access array-like nested data
      local name1 = data.users[0].name
      local score1 = data.users[0].scores.math
      local name2 = data.users[1].name
      local score2 = data.users[1].scores.science

      -- Write to nested properties
      data.level1.level2.level3.value = i
      data.users[0].scores.math = i % 100
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Iterate over all key-value pairs in a table

@Test function TableIteratePairs()
   local small = { a = 1, b = 2, c = 3, d = 4, e = 5 }
   local medium = {}
   for i = 0, 49 do
      medium["key_" .. i] = i * 10
   end

   for i in {0..10000} do
      -- Iterate small table with pairs
      local sum1 = 0
      for k, v in pairs(small) do
         sum1 += v
      end

      -- Iterate medium table
      local sum2 = 0
      local count = 0
      for k, v in pairs(medium) do
         sum2 += v
         count++
      end

      -- Collect keys
      local keys = {}
      local idx = 0
      for k, _ in pairs(small) do
         keys[idx] = k
         idx++
      end
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Iterate over array-like table elements in order

@Test function TableIterateIpairs()
   local arr = { "apple", "banana", "cherry", "date", "elderberry",
                 "fig", "grape", "honeydew", "kiwi", "lemon" }
   local numbers = {}
   for i = 0, 99 do
      numbers[i] = i * 2
   end

   for i in {0..10000} do
      -- Iterate with ipairs (ordered)
      local concat = ""
      for idx, val in ipairs(arr) do
         concat ..= val
      end

      -- Sum numbers with ipairs
      local sum = 0
      for idx, val in ipairs(numbers) do
         sum += val
      end

      -- Count elements
      local count = 0
      for _ in ipairs(arr) do
         count++
      end
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Insert and remove elements from array-like tables

@Test function TableInsertRemove()
   for i in {0..1000} do
      local t = { 1, 2, 3, 4, 5 }

      -- Insert at end
      table.insert(t, 6)
      table.insert(t, 7)
      table.insert(t, 8)

      -- Insert at specific position
      table.insert(t, 0, 0)     -- Insert at beginning
      table.insert(t, 5, 99)    -- Insert in middle

      -- Remove from end
      local last = table.remove(t)

      -- Remove from specific position
      local first = table.remove(t, 0)
      local middle = table.remove(t, 3)

      -- Build table with inserts
      local built = {}
      for j = 0, 19 do
         table.insert(built, j * 10)
      end

      -- Empty table with removes
      while #built > 0 do
         table.remove(built)
      end
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Sort table elements with custom comparator

@Test function TableSort()
   for i in {0..1000} do
      -- Sort numbers ascending (default)
      local nums = { 50, 30, 80, 10, 60, 40, 90, 20, 70, 100 }
      table.sort(nums)

      -- Sort numbers descending
      local nums2 = { 50, 30, 80, 10, 60, 40, 90, 20, 70, 100 }
      table.sort(nums2, function(a, b) return a > b end)

      -- Sort strings
      local words = { "cherry", "apple", "banana", "date", "elderberry" }
      table.sort(words)

      -- Sort by string length
      local words2 = { "cherry", "apple", "banana", "date", "elderberry" }
      table.sort(words2, function(a, b) return #a < #b end)

      -- Sort table of tables by field
      local people = {
         { name = "Charlie", age = 35 },
         { name = "Alice", age = 30 },
         { name = "Bob", age = 25 }
      }
      table.sort(people, function(a, b) return a.age < b.age end)
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Concatenate array-like table elements into a string

@Test function TableConcat()
   local words = { "The", "quick", "brown", "fox", "jumps" }
   local numbers = { "1", "2", "3", "4", "5", "6", "7", "8", "9", "10" }
   local single = { "alone" }

   for i in {0..10000} do
      -- Concat with different separators
      local joined1 = table.concat(words, " ")
      local joined2 = table.concat(words, "-")
      local joined3 = table.concat(words, ", ")
      local joined4 = table.concat(words, "")

      -- Concat numbers
      local joined5 = table.concat(numbers, ",")
      local joined6 = table.concat(numbers, " | ")

      -- Concat single element
      local joined7 = table.concat(single, ",")

      -- Concat with range
      local partial = table.concat(words, " ", 1, 3)
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Get the length of array-like tables

@Test function TableLength()
   local empty = {}
   local small = { 1, 2, 3 }
   local medium = {}
   for i = 0, 99 do medium[i] = i end
   local large = {}
   for i = 0, 999 do large[i] = i end
   local mixed = { a = 1, b = 2, [0] = "zero", [1] = "one", [2] = "two" }

   for i in {0..1000000} do
      -- Get lengths using # operator
      local len1 = #empty
      local len2 = #small
      local len3 = #medium
      local len4 = #large
      local len5 = #mixed  -- Only counts array part

      -- Use length in calculations
      local total = len1 + len2 + len3 + len4 + len5
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Merge two tables into one

@Test function TableMerge()
   local t1 = { a = 1, b = 2, c = 3 }
   local t2 = { d = 4, e = 5, f = 6 }
   local arr1 = { 1, 2, 3 }
   local arr2 = { 4, 5, 6 }

   for i in {0..10000} do
      -- Merge key-value tables (manual)
      local merged = {}
      for k, v in pairs(t1) do
         merged[k] = v
      end
      for k, v in pairs(t2) do
         merged[k] = v
      end

      -- Merge with overwrite
      local base = { a = 1, b = 2, c = 3 }
      local override = { b = 20, d = 40 }
      for k, v in pairs(override) do
         base[k] = v
      end

      -- Concatenate arrays
      local combined = {}
      local idx = 0
      for _, v in ipairs(arr1) do
         combined[idx] = v
         idx++
      end
      for _, v in ipairs(arr2) do
         combined[idx] = v
         idx++
      end
   end
end

----------------------------------------------------------------------------------------------------------------------
-- CONTROL FLOW
----------------------------------------------------------------------------------------------------------------------
-- Goal: Execute branching logic with if/elseif/else chains

@Test function ControlIfElseChains()
   for i in {0..1000000} do
      local result = 0
      local x = i % 100

      -- Simple if-else
      if x < 50 then
         result = 1
      else
         result = 2
      end

      -- Multiple elseif branches
      if x < 10 then
         result = 0
      elseif x < 20 then
         result = 1
      elseif x < 30 then
         result = 2
      elseif x < 40 then
         result = 3
      elseif x < 50 then
         result = 4
      elseif x < 60 then
         result = 5
      elseif x < 70 then
         result = 6
      elseif x < 80 then
         result = 7
      elseif x < 90 then
         result = 8
      else
         result = 9
      end

      -- Nested if statements
      if x < 50 then
         if x < 25 then
            result = x * 2
         else
            result = x * 3
         end
      else
         if x < 75 then
            result = x + 10
         else
            result = x + 20
         end
      end

      -- Compound conditions
      if x >= 20 and x < 40 then
         result = 100
      elseif x >= 40 and x < 60 then
         result = 200
      elseif x >= 60 or x < 10 then
         result = 300
      end
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Use ternary conditional operator for inline branching

@Test function ControlTernaryOperator()
   for i in {0..100000} do
      local x = i % 100
      local result = 0

      -- Simple ternary
      result = x < 50 ? 1 :> 0

      -- Ternary with expressions
      result = x % 2 is 0 ? x * 2 :> x * 3

      -- Chained ternary (nested)
      result = x < 25 ? 1 :> (x < 50 ? 2 :> (x < 75 ? 3 :> 4))

      -- Ternary in expressions
      local a = 10 + (x < 50 ? 5 :> 15)
      local b = (x > 30 ? x :> 30) * 2

      -- Ternary with function-like usage
      local min_val = x < 50 ? x :> 50
      local max_val = x > 25 ? x :> 25
      local clamped = x < 20 ? 20 :> (x > 80 ? 80 :> x)

      -- Ternary with boolean results
      local is_even = x % 2 is 0 ? true :> false
      local in_range = (x >= 25 and x <= 75) ? true :> false
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Use nil coalescing operators for default values

@Test function ControlNilCoalescing()
   for i in {0..100000} do
      local result = 0

      -- Basic ?? operator (nil coalescing)
      local maybe_nil = i % 3 is 0 ? nil :> i
      result = maybe_nil ?? 42

      -- Chain of ?? operators
      local a = i % 5 is 0 ? nil :> nil
      local b = i % 3 is 0 ? nil :> i
      local c = 100
      result = a ?? b ?? c

      -- ??= compound assignment
      local value = i % 2 is 0 ? nil :> i
      value ??= 99
      result = value

      -- ?? with expressions
      local x = i % 7 is 0 ? nil :> i * 2
      result = (x ?? 0) + 10

      -- Nested nil coalescing
      local outer = i % 4 is 0 ? nil :> { inner = i % 2 is 0 ? nil :> i }
      local safe_val = outer ?? { inner = 0 }
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Execute numeric for loops with start, end, step

@Test function ControlForNumericLoop()
   for i in {0..10000} do
      local sum = 0

      -- Simple ascending loop
      for j = 0, 99 do
         sum += j
      end

      -- Loop with step
      for j = 0, 99, 2 do
         sum += j
      end

      -- Descending loop
      for j = 99, 0, -1 do
         sum += j
      end

      -- Descending with step
      for j = 100, 0, -5 do
         sum += j
      end

      -- Nested numeric loops
      for x = 0, 9 do
         for y = 0, 9 do
            sum += x * y
         end
      end

      -- Loop with computed bounds
      local start = i % 10
      local finish = start + 50
      for j = start, finish do
         sum += 1
      end
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Execute range-based for loops

@Test function ControlForRangeLoop()
   for i in {0..100} do
      local sum = 0

      -- Simple range loop (exclusive end)
      for j in {0..100} do
         sum += j
      end

      -- Inclusive range loop
      for j in {0...99} do
         sum += j
      end

      -- Range with step (using range.new)
      nr = range.new(0, 100, false, 2)
      for j in nr() do
         sum += j
      end

      -- Nested range loops
      for x in {0..10} do
         for y in {0..10} do
            sum += x + y
         end
      end

      -- Range with negative indices
      for j in {-10..10} do
         sum += j
      end

      -- Short ranges
      for j in {0..5} do
         sum += j
      end
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Execute while loops with varying conditions

@Test function ControlWhileLoop()
   for i in {0..10000} do
      local sum = 0
      local count = 0

      -- Simple counting while
      count = 0
      while count < 100 do
         sum += count
         count++
      end

      -- While with compound condition
      count = 0
      local limit = 50
      while count < limit and sum < 10000 do
         sum += count
         count++
      end

      -- While with boolean flag
      local running = true
      count = 0
      while running do
         count++
         if count >= 20 then
            running = false
         end
      end

      -- Nested while loops
      local x = 0
      while x < 10 do
         local y = 0
         while y < 10 do
            sum += 1
            y++
         end
         x++
      end

      -- While with modifying condition variable
      local n = 100
      while n > 0 do
         sum += n
         n = n - 3
      end
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Execute repeat-until loops

@Test function ControlRepeatUntil()
   for i in {0..10000} do
      local sum = 0
      local count = 0

      -- Simple repeat-until
      count = 0
      repeat
         sum += count
         count++
      until count >= 100

      -- Repeat with compound condition
      count = 0
      repeat
         sum += count
         count++
      until count >= 50 or sum > 5000

      -- Repeat at least once pattern
      local value = 100
      repeat
         value = value - 10
      until value <= 0

      -- Nested repeat-until
      local x = 0
      repeat
         local y = 0
         repeat
            sum += 1
            y++
         until y >= 10
         x++
      until x >= 10

      -- Repeat with early exit condition
      count = 0
      local found = false
      repeat
         count++
         if count is 42 then
            found = true
         end
      until found or count >= 100
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Use break and continue statements in loops

@Test function ControlBreakContinue()
   for i in {0..1000} do
      local sum = 0
      local count = 0

      -- Break from for loop
      for j = 0, 999 do
         if j >= 100 then
            break
         end
         sum += j
      end

      -- Continue in for loop (skip even numbers)
      for j = 0, 99 do
         if j % 2 is 0 then
            continue
         end
         sum += j
      end

      -- Break from while loop
      count = 0
      while true do
         count++
         if count >= 50 then
            break
         end
      end

      -- Continue in while loop
      count = 0
      while count < 100 do
         count++
         if count % 3 is 0 then
            continue
         end
         sum += count
      end

      -- Break from nested loop (inner only)
      for x = 0, 9 do
         for y = 0, 99 do
            if y >= 10 then
               break
            end
            sum += 1
         end
      end

      -- Continue in nested loop
      for x = 0, 9 do
         for y = 0, 9 do
            if y % 2 is 0 then
               continue
            end
            sum += x + y
         end
      end

      -- Break in range loop
      for j in {0..1000} do
         if j >= 50 then
            break
         end
         sum += j
      end

      -- Continue in range loop
      for j in {0..100} do
         if j % 5 is 0 then
            continue
         end
         sum += j
      end
   end
end

----------------------------------------------------------------------------------------------------------------------
-- FUNCTION CALLS
----------------------------------------------------------------------------------------------------------------------
-- Goal: Call local functions with various argument counts

@Test function FunctionLocalCalls()
   -- Define local functions with varying argument counts
   local function noArgs()
      return 42
   end

   local function oneArg(a)
      return a * 2
   end

   local function twoArgs(a, b)
      return a + b
   end

   local function threeArgs(a, b, c)
      return a + b + c
   end

   local function fiveArgs(a, b, c, d, e)
      return a + b + c + d + e
   end

   local function returnsMultiple(x)
      return x, x * 2, x * 3
   end

   for i in {0..1000000} do
      -- Call with no arguments
      local r0 = noArgs()

      -- Call with one argument
      local r1 = oneArg(i)

      -- Call with two arguments
      local r2 = twoArgs(i, i + 1)

      -- Call with three arguments
      local r3 = threeArgs(i, i + 1, i + 2)

      -- Call with five arguments
      local r5 = fiveArgs(i, i + 1, i + 2, i + 3, i + 4)

      -- Multiple return values
      local a, b, c = returnsMultiple(i)

      -- Chain function calls
      local chained = oneArg(oneArg(oneArg(i)))
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Call functions with variadic arguments

@Test function FunctionVariadic()
   -- Variadic function that sums all arguments
   local function sumAll(...)
      local args = {...}
      local total = 0
      for _, v in ipairs(args) do
         total += v
      end
      return total
   end

   -- Variadic function with fixed first argument
   local function formatArgs(prefix, ...)
      local args = {...}
      return prefix .. #args
   end

   -- Function that forwards variadic arguments
   local function forwardArgs(...)
      return sumAll(...)
   end

   for i in {0..1000} do
      -- Call with varying argument counts
      local s1 = sumAll(1)
      local s2 = sumAll(1, 2)
      local s3 = sumAll(1, 2, 3)
      local s5 = sumAll(1, 2, 3, 4, 5)
      local s10 = sumAll(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

      -- Mixed fixed and variadic
      local f1 = formatArgs("test", 1, 2, 3)
      local f2 = formatArgs("data", 1, 2, 3, 4, 5)

      -- Forward variadic arguments
      local fwd = forwardArgs(i, i + 1, i + 2)
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Create and call closures that capture upvalues

@Test function FunctionClosures()
   for i in {0..1000} do
      -- Simple closure capturing one variable
      local x = i
      local getX = function()
         return x
      end
      local v1 = getX()

      -- Closure capturing multiple variables
      local a, b, c = i, i + 1, i + 2
      local getSum = function()
         return a + b + c
      end
      local v2 = getSum()

      -- Closure that modifies captured variable
      local counter = 0
      local increment = function()
         counter++
         return counter
      end
      for j = 0, 9 do
         increment()
      end

      -- Nested closures
      local outer = i
      local makeInner = function()
         local inner = outer * 2
         return function()
            return inner + outer
         end
      end
      local innerFn = makeInner()
      local v3 = innerFn()

      -- Closure factory pattern
      local makeAdder = function(n)
         return function(x)
            return x + n
         end
      end
      local add5 = makeAdder(5)
      local add10 = makeAdder(10)
      local v4 = add5(i)
      local v5 = add10(i)

      -- Multiple closures sharing upvalue
      local shared = 0
      local inc = function() shared++ end
      local get = function() return shared end
      inc()
      inc()
      local v6 = get()
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Use anonymous function expressions with arrow syntax

@Test function FunctionAnonymous()
   for i in {0..1000} do
      -- Simple arrow function
      local double = (x => x * 2)
      local v1 = double(i)

      -- Arrow function with expression body
      local sum = ((a, b) => a + b)
      local v2 = sum(i, i + 1)

      -- Arrow function in higher-order context
      local numbers = { 1, 2, 3, 4, 5 }
      local mapped = {}
      for idx, n in ipairs(numbers) do
         mapped[idx] = (x => x * 2)(n)
      end

      -- Immediately invoked arrow function
      local result = (x => x * x)(i)

      -- Arrow functions as callbacks (simulated)
      local apply = function(fn, val)
         return fn(val)
      end
      local v3 = apply((x => x + 10), i)
      local v4 = apply((x => x * 3), i)

      -- Nested arrow functions
      local compose = function(f, g)
         return (x => f(g(x)))
      end
      local addOne = (x => x + 1)
      local timesTwo = (x => x * 2)
      local composed = compose(addOne, timesTwo)
      local v5 = composed(i)

      -- Arrow function capturing upvalue
      local multiplier = i % 10 + 1
      local multiply = (x => x * multiplier)
      local v6 = multiply(5)
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Execute recursive function calls

@Test function FunctionRecursive()
   -- Recursive factorial (limited depth)
   local function factorial(n:num):num
      if n <= 1 then return 1 end
      return n * factorial(n - 1)
   end

   -- Recursive fibonacci (limited depth)
   local function fibonacci(n:num):num
      if n <= 1 then return n end
      return fibonacci(n - 1) + fibonacci(n - 2)
   end

   -- Tail-recursive sum
   local function sumTo(n:num, acc:num):num
      acc = acc ?? 0
      if n <= 0 then return acc end
      return sumTo(n - 1, acc + n)
   end

   -- Recursive tree traversal simulation
   local function countDown(n:num):num
      if n <= 0 then return 0 end
      return 1 + countDown(n - 1)
   end

   -- Mutual recursion
   local isEven, isOdd
   isEven = function(n:num):bool
      if n is 0 then return true end
      return isOdd(n - 1)
   end

   isOdd = function(n:num):bool
      if n is 0 then return false end
      return isEven(n - 1)
   end

   for i in {0..500} do
      -- Call recursive functions with safe depths
      local f1 = factorial(10)
      local f2 = factorial(12)

      -- Fibonacci (small values to avoid exponential blowup)
      local fib1 = fibonacci(10)
      local fib2 = fibonacci(12)

      -- Tail-recursive
      local s1 = sumTo(50)
      local s2 = sumTo(100)

      -- Simple recursion
      local c1 = countDown(50)
      local c2 = countDown(100)

      -- Mutual recursion
      local e1 = isEven(20)
      local o1 = isOdd(21)
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Call methods on tables using colon syntax

@Test function FunctionMethodCalls()
   -- Create object-like tables with methods
   local Counter = {
      value = 0,
      increment = function(self)
         self.value++
         return self.value
      end,
      decrement = function(self)
         self.value--
         return self.value
      end,
      add = function(self, n)
         self.value += n
         return self.value
      end,
      getValue = function(self)
         return self.value
      end,
      reset = function(self)
         self.value = 0
      end
   }

   local Point = {
      x = 0,
      y = 0,
      set = function(self, x, y)
         self.x = x
         self.y = y
      end,
      translate = function(self, dx, dy)
         self.x += dx
         self.y += dy
      end,
      distance = function(self)
         return math.sqrt(self.x * self.x + self.y * self.y)
      end
   }

   for i in {0..10000} do
      -- Method calls with colon syntax
      Counter:reset()
      Counter:increment()
      Counter:increment()
      Counter:add(5)
      local v1 = Counter:getValue()
      Counter:decrement()

      -- Multiple method calls in sequence
      Point:set(i % 100, i % 50)
      Point:translate(1, 2)
      Point:translate(-1, 1)
      local d = Point:distance()

      -- Create new instances
      local obj = { value = 0 }
      setmetatable(obj, { __index = Counter })
      obj:increment()
      obj:add(10)
      local v2 = obj:getValue()

      -- Chain-like method usage
      Counter:reset()
      for j = 0, 9 do
         Counter:increment()
      end
      local final = Counter:getValue()
   end
end

----------------------------------------------------------------------------------------------------------------------
-- MEMORY & ALLOCATION
----------------------------------------------------------------------------------------------------------------------
-- Goal: Measure overhead of creating many small tables

@Test function MemoryTableAllocation()
   for i in {0..100} do
      -- Create empty tables
      local tables = {}
      for j = 0, 99 do
         tables[j] = {}
      end

      -- Create tables with initial values
      for j = 0, 99 do
         tables[j] = { a = 1, b = 2, c = 3 }
      end

      -- Create nested table structures
      for j = 0, 49 do
         tables[j] = {
            inner = {
               value = j,
               data = { x = 1, y = 2 }
            }
         }
      end

      -- Create tables with varying sizes
      for j = 0, 19 do
         local t = {}
         for k = 0, j do
            t[k] = k
         end
         tables[j] = t
      end

      -- Create and immediately discard tables
      for j = 0, 99 do
         local temp = { value = j, name = "temp" }
         local _ = temp.value
      end
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Measure overhead of creating many strings

@Test function MemoryStringAllocation()
   for i in {0..500} do
      -- Create short strings
      local strings = {}
      for j = 0, 99 do
         strings[j] = "str"
      end

      -- Create strings via concatenation
      for j = 0, 49 do
         strings[j] = "prefix_" .. tostring(j) .. "_suffix"
      end

      -- Create strings via string.format
      for j = 0, 49 do
         strings[j] = string.format("item_%03d", j)
      end

      -- Create strings via interpolation
      for j = 0, 49 do
         strings[j] = f"value_{j}_data"
      end

      -- Create strings of varying lengths
      for j = 0, 19 do
         strings[j] = string.rep("x", j + 1)
      end

      -- Create and immediately discard strings
      for j = 0, 99 do
         local temp = "temporary_" .. tostring(j)
         local _ = #temp
      end

      -- Substring operations creating new strings
      local source = "The quick brown fox jumps over the lazy dog"
      for j = 0, 19 do
         local sub = string.sub(source, j + 1, j + 10)
      end
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Allocate large numbers of arrays

@Test function MemoryTypedArrayAllocation()
   for i in {0..10} do
      -- Create typed integer arrays
      local int_arrays = array<array>
      for j = 0, 49 do
         int_arrays:push(array<int, 100>)
      end

      -- Create typed double arrays
      local dbl_arrays = array<array>
      for j = 0, 49 do
         dbl_arrays:push(array<double, 100>)
      end

      -- Create typed string arrays
      local str_arrays = {}
      for j = 0, 49 do
         str_arrays[j] = array<string, 50>
      end
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Compare typed and untyped array fills

@Test function MemoryTypedArrayFilled()
   for i in {0..100} do
      local int_arrays = array<array>
      for j = 0, 100 do
         int_arrays:push(array<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 })
      end
   end
end

@Test function MemoryUntypedArrayFilled()
   for i in {0..100} do
      local any_arrays = array<array>
      for j = 0, 100 do
         any_arrays:push(array<any> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 })
      end
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Stress test garbage collector with allocation-heavy workload

@Test function MemoryGCPressure()
   for i in {0..100} do
      -- Rapid allocation and discard of tables
      for j = 0, 199 do
         local t = { a = j, b = j * 2, c = j * 3 }
         local sum = t.a + t.b + t.c
      end

      -- Rapid allocation and discard of strings
      for j = 0, 199 do
         local s = "item_" .. tostring(j) .. "_value"
         local len = #s
      end

      -- Nested allocations
      for j = 0, 49 do
         local outer = {
            inner1 = { value = j },
            inner2 = { value = j * 2 },
            inner3 = { value = j * 3 }
         }
         local sum = outer.inner1.value + outer.inner2.value
      end

      -- Mixed type allocations
      for j = 0, 49 do
         local mixed = {
            num = j,
            str = f"string_{j}",
            tbl = { x = 1, y = 2 },
            arr = { 1, 2, 3, 4, 5 }
         }
      end

      -- Array allocation pressure
      for j = 0, 49 do
         local arr = array<int> { j, j+1, j+2, j+3, j+4 }
         local sum = arr[0] + arr[4]
      end

      -- String building pressure
      for j = 0, 19 do
         local result = ""
         for k = 0, 9 do
            result ..= tostring(k)
         end
      end

      -- Closure allocation pressure
      for j = 0, 49 do
         local captured = j
         local fn = function()
            return captured * 2
         end
         local result = fn()
      end
   end
end

----------------------------------------------------------------------------------------------------------------------
-- EXCEPTION HANDLING
----------------------------------------------------------------------------------------------------------------------
-- Goal: Measure overhead of try-except exception handling

@Test function ExceptionTryExcept()
   -- Function that may throw an error
   local function mayFail(shouldFail)
      if shouldFail then
         error("Intentional error")
      end
      return 42
   end

   -- Function that always succeeds
   local function alwaysSucceeds(x)
      return x * 2
   end

   for i in {0..10000} do
      -- Try-except with no exception thrown
      try
         local result = alwaysSucceeds(i)
      except ex
         local msg = ex.message
      end

      -- Try-except with exception thrown occasionally
      try
         local result = mayFail(i % 100 is 0)
      except ex
         local msg = ex.message
      end

      -- Nested try-except blocks
      try
         try
            local result = alwaysSucceeds(i)
         except inner
            local msg = inner.message
         end
      except outer
         local msg = outer.message
      end

      -- Try-except with multiple operations
      try
         local a = alwaysSucceeds(i)
         local b = alwaysSucceeds(i + 1)
         local c = alwaysSucceeds(i + 2)
         local sum = a + b + c
      except ex
         local msg = ex.message
      end

      -- Try-except with conditional exception
      try
         if i % 50 is 0 then
            error("Periodic error")
         end
         local result = i * 2
      except ex
         local recovered = 0
      end
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Use try-success pattern for handling successful completion

@Test function ExceptionTrySuccess()
   local function compute(x)
      if x < 0 then
         error("Negative value not allowed")
      end
      return x * x
   end

   local function fetchData(id)
      if id is 0 then
         error("Invalid ID")
      end
      return { id = id, value = id * 10 }
   end

   for i in {0..30000} do
      local result = 0

      -- Basic try-success pattern
      try
         result = compute(i)
      except ex
         result = -1
      success
         result = result + 1
      end

      -- Try-success with data fetching pattern
      local data = nil
      try
         data = fetchData(i % 100)
      except ex
         data = { id = 0, value = 0 }
      success
         data.value = data.value * 2
      end

      -- Chained operations in success block
      local a, b
      try
         a = compute(i)
         b = compute(i + 1)
      except ex
         result = 0
      success
         result = a + b
         result = result * 2
      end

      -- Success block with cleanup-like operations
      local resource_acquired = false
      try
         resource_acquired = true
         result = compute(i)
      except ex
         result = -1
      success
         -- Simulated successful completion handling
         result = result + 100
      end

      -- Nested try with success blocks
      try
         try
            result = compute(i)
         except inner
            result = 0
         success
            result = result + 10
         end
      except outer
         result = -1
      success
         result = result + 20
      end
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Measure overhead of defer statement for cleanup

@Test function ExceptionDefer()
   for i in {0..5000} do
      local cleanup_count = 0

      -- Simple defer
      do
         defer()
            cleanup_count++
         end
         local x = i * 2
      end

      -- Multiple defers (LIFO order)
      do
         defer()
            cleanup_count++
         end
         defer()
            cleanup_count++
         end
         defer()
            cleanup_count++
         end
         local x = i
      end

      -- Defer with captured variables
      local value = i
      do
         local captured = value
         defer()
            local _ = captured
         end
         value = value * 2
      end

      -- Defer in nested scopes
      do
         defer()
            cleanup_count++
         end
         do
            defer()
               cleanup_count++
            end
            local inner = i
         end
         local outer = i * 2
      end

      -- Defer with computation
      local result = 0
      do
         defer()
            result = result + 1
         end
         result = i * 2
      end

      -- Defer simulating resource cleanup pattern
      do
         local resource = { open = true }
         defer()
            resource.open = false
         end
         local data = resource.open and i or 0
      end
   end
end

----------------------------------------------------------------------------------------------------------------------
-- VARIABLE SCOPE
----------------------------------------------------------------------------------------------------------------------
-- These benchmarks perform identical operations to enable direct performance comparison
-- between different variable scoping mechanisms.

@Test function ScopeLocal()
   for i in {0..1000000} do
      -- Declare local variables
      local a = 10
      local b = 20
      local c = 30
      local d = 40
      local e = 50

      -- Read operations
      local r1 = a
      local r2 = b
      local r3 = c
      local r4 = d
      local r5 = e

      -- Arithmetic using locals
      local sum = a + b + c + d + e
      local product = a * b
      local diff = e - a
      local quotient = d / a

      -- Write operations
      a = i
      b = i + 1
      c = i + 2
      d = i + 3
      e = i + 4

      -- Mixed read/write
      a = b + c
      b = a * 2
      c = b - d
      d = c + e
      e = a + d

      -- Compound operations
      a += 1
      b -= 1
      c *= 2
      d /= 2
      e %= 100
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Measure performance of global variable access

-- Declare globals for ScopeGlobal benchmark
global glScopeA = 10
global glScopeB = 20
global glScopeC = 30
global glScopeD = 40
global glScopeE = 50

@Test function ScopeGlobal()
   for i in {0..1000000} do
      -- Reset global variables
      glScopeA = 10
      glScopeB = 20
      glScopeC = 30
      glScopeD = 40
      glScopeE = 50

      -- Read operations
      local r1 = glScopeA
      local r2 = glScopeB
      local r3 = glScopeC
      local r4 = glScopeD
      local r5 = glScopeE

      -- Arithmetic using globals
      local sum = glScopeA + glScopeB + glScopeC + glScopeD + glScopeE
      local product = glScopeA * glScopeB
      local diff = glScopeE - glScopeA
      local quotient = glScopeD / glScopeA

      -- Write operations
      glScopeA = i
      glScopeB = i + 1
      glScopeC = i + 2
      glScopeD = i + 3
      glScopeE = i + 4

      -- Mixed read/write
      glScopeA = glScopeB + glScopeC
      glScopeB = glScopeA * 2
      glScopeC = glScopeB - glScopeD
      glScopeD = glScopeC + glScopeE
      glScopeE = glScopeA + glScopeD

      -- Compound operations
      glScopeA += 1
      glScopeB -= 1
      glScopeC *= 2
      glScopeD /= 2
      glScopeE %= 100
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Measure performance of const-annotated local variable access

@Test function ScopeConstantAccess()
   for i in {0..1000000} do
      -- Declare const local variables
      local a <const> = 10
      local b <const> = 20
      local c <const> = 30
      local d <const> = 40
      local e <const> = 50

      -- Read operations (const can only be read, not written)
      local r1 = a
      local r2 = b
      local r3 = c
      local r4 = d
      local r5 = e

      -- Arithmetic using consts
      local sum = a + b + c + d + e
      local product = a * b
      local diff = e - a
      local quotient = d / a

      -- Write to mutable locals derived from consts
      local ma = i
      local mb = i + 1
      local mc = i + 2
      local md = i + 3
      local me = i + 4

      -- Mixed read (const) / write (mutable)
      ma = b + c
      mb = a * 2
      mc = b - d
      md = c + e
      me = a + d

      -- Compound operations on mutable copies
      ma += 1
      mb -= 1
      mc *= 2
      md /= 2
      me %= 100

      -- Additional const reads to match operation count
      local x1 = a + b
      local x2 = c + d
      local x3 = e + a
      local x4 = b + c
      local x5 = d + e
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Measure performance of upvalue access in closures

@Test function ScopeUpvalueAccess()
   -- Declare upvalues outside the loop
   local a = 10
   local b = 20
   local c = 30
   local d = 40
   local e = 50

   -- Create closure that captures upvalues
   local function accessUpvalues(iter)
      -- Read operations
      local r1 = a
      local r2 = b
      local r3 = c
      local r4 = d
      local r5 = e

      -- Arithmetic using upvalues
      local sum = a + b + c + d + e
      local product = a * b
      local diff = e - a
      local quotient = d / a

      -- Write operations
      a = iter
      b = iter + 1
      c = iter + 2
      d = iter + 3
      e = iter + 4

      -- Mixed read/write
      a = b + c
      b = a * 2
      c = b - d
      d = c + e
      e = a + d

      -- Compound operations
      a += 1
      b -= 1
      c *= 2
      d /= 2
      e %= 100
   end

   for i in {0..1000000} do
      -- Reset upvalues
      a = 10
      b = 20
      c = 30
      d = 40
      e = 50

      -- Call function that accesses upvalues
      accessUpvalues(i)
   end
end

----------------------------------------------------------------------------------------------------------------------
-- TYPE OPERATIONS
----------------------------------------------------------------------------------------------------------------------
-- Goal: Measure overhead of type() function calls

@Test function TypeCheckType()
   -- Create values of different types
   local num_int = 42
   local num_float = 3.14159
   local str = "hello"
   local tbl = { a = 1, b = 2 }
   local arr = array<int> { 1, 2, 3 }
   local func = function() return 1 end
   local bool_true = true
   local bool_false = false
   local nil_val = nil

   for i in {0..500} do
      -- Check type of numbers
      local t1 = type(num_int)
      local t2 = type(num_float)
      local t3 = type(i)

      -- Check type of strings
      local t4 = type(str)
      local t5 = type("literal")

      -- Check type of tables
      local t6 = type(tbl)
      local t7 = type({})

      -- Check type of arrays
      local t8 = type(arr)

      -- Check type of functions
      local t9 = type(func)
      local t10 = type(function() end)

      -- Check type of booleans
      local t11 = type(bool_true)
      local t12 = type(bool_false)

      -- Check type of nil
      local t13 = type(nil_val)
      local t14 = type(nil)

      -- Type comparisons
      local is_num = type(num_int) is "number"
      local is_str = type(str) is "string"
      local is_tbl = type(tbl) is "table"
      local is_func = type(func) is "function"
      local is_bool = type(bool_true) is "boolean"

      -- Conditional based on type
      local val = i % 3 is 0 and str or (i % 3 is 1 and num_int or tbl)
      if type(val) is "string" then
         local _ = #val
      elseif type(val) is "number" then
         local _ = val * 2
      elseif type(val) is "table" then
         local _ = val.a
      end
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Measure overhead of tostring() conversions

@Test function StringConversion()
   local int_val = 12345
   local float_val = 3.14159265358979
   local neg_int = -9876
   local neg_float = -2.71828
   local zero = 0
   local bool_true = true
   local bool_false = false
   local tbl = { a = 1 }

   for i in {0..1000000} do
      -- Convert integers to string
      local s1 = tostring(int_val)
      local s2 = tostring(neg_int)
      local s3 = tostring(zero)
      local s4 = tostring(i)

      -- Convert floats to string
      local s5 = tostring(float_val)
      local s6 = tostring(neg_float)
      local s7 = tostring(i * 0.5)

      -- Convert booleans to string
      local s8 = tostring(bool_true)
      local s9 = tostring(bool_false)

      -- Convert nil to string
      local s10 = tostring(nil)

      -- Convert table to string (gets address)
      local s11 = tostring(tbl)

      -- Convert computed values
      local s12 = tostring(i + 100)
      local s13 = tostring(i * 2)
      local s14 = tostring(i / 3)

      -- Concatenation forcing conversion
      local s15 = "" .. i
      local s16 = "value: " .. i

      -- Scientific notation numbers
      local s17 = tostring(1.23e10)
      local s18 = tostring(4.56e-5)

      -- Large and small numbers
      local s19 = tostring(999999999)
      local s20 = tostring(0.000001)
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Goal: Measure overhead of tonumber() conversions

@Test function NumberConversion()
   local str_int = "12345"
   local str_neg = "-9876"
   local str_float = "3.14159"
   local str_neg_float = "-2.71828"
   local str_zero = "0"
   local str_sci = "1.23e5"
   local str_hex = "0xFF"
   local str_invalid = "not_a_number"
   local str_mixed = "123abc"

   for i in {0..1000} do
      -- Convert integer strings
      local n1 = tonumber(str_int)
      local n2 = tonumber(str_neg)
      local n3 = tonumber(str_zero)

      -- Convert float strings
      local n4 = tonumber(str_float)
      local n5 = tonumber(str_neg_float)

      -- Convert scientific notation
      local n6 = tonumber(str_sci)

      -- Convert hex strings
      local n7 = tonumber(str_hex)
      local n8 = tonumber("0x1A2B")

      -- Convert with explicit base
      local n9 = tonumber("1010", 2)    -- Binary
      local n10 = tonumber("777", 8)     -- Octal
      local n11 = tonumber("FF", 16)     -- Hex without prefix

      -- Convert dynamically created strings
      local n12 = tonumber(tostring(i))
      local n13 = tonumber(tostring(i * 2))

      -- Invalid conversions (return nil)
      local n14 = tonumber(str_invalid)
      local n15 = tonumber(str_mixed)
      local n16 = tonumber("")

      -- Numbers passed through (already numbers)
      local n17 = tonumber(42)
      local n18 = tonumber(3.14)
      local n19 = tonumber(i)

      -- Conditional conversion with fallback
      local val = tonumber(str_int) ?? 0
      local val2 = tonumber(str_invalid) ?? -1
   end
end

----------------------------------------------------------------------------------------------------------------------

function logMessage(message)
   print(message)
end

function saveMessage(message:any)
   if type(message) is 'string' then
      logMessage(message)
      glLogFile:write(message .. '\n')
   elseif type(message) is 'array' then
      for s in values(message) do
         logMessage(s)
         glLogFile:write(s .. '\n')
      end
   end
end

   do
      local tm = obj.new('time')
      tm.acQuery()

      local git_info = git.query(glPath)

      saveMessage(string.format('%04d-%02d-%02d %02d:%02d:%02d', tm.year, tm.month, tm.day, tm.hour, tm.minute, tm.second))
      saveMessage(f'Git branch: {git_info.branch} / {git_info.commit}')
      saveMessage('')
   end

   local duration = tonumber(arg('duration',2))
   local warmup = tonumber(arg('warmup',10))
   local hotloop = tonumber(arg('hotloop',5))
   local call_limit =tonumber(arg('calls',1000))

   local test_match = arg('test')
   if test_match then
      global rx_test = regex.new(test_match)
      logMessage(f'Filtering benchmarks with pattern: {test_match}')
   end

   local anno = debug.anno.list()
   all_results = array<table>
   for func, entry in pairs(anno) do
      local results

      if rx_test then
         if not rx_test.match(tostring(func)) then
            --logMessage(f'Skipping {func}')
            continue
         end
      end

      try<trace>
         results = bmark.run({ duration=duration, warmupCalls=warmup, feedbackRate=100, maxCalls=call_limit, hotLoop=hotloop }, nil, func)
      except ex
         logMessage(f'Error in benchmark {func}: {ex.message}')
         logMessage(ex.stackTrace)
      success
         saveMessage(string.format('%s() Calls Per Second: %d; Total Calls: %d, Fastest: %.3f ms', tostring(func), results.callsPerSecond, results.benchmarkCalls, results.stats.min))
         if results.memoryLeakRate/results.callsPerSecond > 512 then
            saveMessage(string.format('Leak Rate:  %d bytes per call', results.memoryLeakRate / results.callsPerSecond))
         end
         all_results:push(results)
      end
   end
