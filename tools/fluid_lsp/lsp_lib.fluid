-- Fluid Language Server Protocol (LSP) Server Library
--
-- Provides a TCP-based LSP server for IDE integration with Fluid scripts.
-- Implements the JSON-RPC 2.0 protocol with LSP wire format (Content-Length framing).
--
-- The server supports handler registration for extending LSP functionality:
--    server.registerHandler('textDocument/hover', function(msg, state) ... end)

   include 'network'
   global json = import 'json'
   import 'common'
   import 'io/filesearch'

   global CACHE_PATH = 'user:config/lsp_doc_cache.fluid'
   global HTML_URI = 'https://parasol.ws/modules/'

   self = { }

   global glTime = obj.new('time')
   global glSelf = obj.find('self')

   -- Document storage for open files.  URI indexed
   global glDocuments = { }

   -- Documentation cache and static definitions for hover
   global glDocCache = nil
   global glDefs = nil

----------------------------------------------------------------------------------------------------------------------
-- Document Line Index
-- Lazily computes and caches an array of line byte offsets. Invalidate by setting doc.lineIndex = nil on changes.
-- Format: array<int> with pairs of (start, stop) for each line, so line N is at indices N*2 and N*2+1.

function rebuildLineIndex(Doc:table, FromLine:num)
   if Doc.lineIndex then return end

   content = Doc.content
   len = #content
   pos = 0

   if not FromLine or not Doc.lineIndex or FromLine is 0 then
      -- Full rebuild
      Doc.lineIndex = array<int>
   else
      -- Incremental rebuild from FromLine onwards
      -- Truncate the array to keep lines 0..FromLine-1
      keep_count = FromLine * 2
      if keep_count > #Doc.lineIndex then
         keep_count = #Doc.lineIndex
      end

      -- Remove entries from FromLine onwards
      Doc.lineIndex:resize(keep_count)

      -- Start scanning from where FromLine begins
      if keep_count >= 2 then
         -- Position after the previous line's newline
         pos = Doc.lineIndex[keep_count - 1] + 1  -- After stop of previous line + newline
         if pos > len then pos = len end
      else
         pos = 0
      end
   end

   while pos < len do
      -- Find end of line (newline or end of content)
      newline_pos = content:find('\n', pos)
      if newline_pos then
         Doc.lineIndex:push(pos, newline_pos - 1)
         pos = newline_pos + 1  -- Skip past the newline
      else
         Doc.lineIndex:push(pos, len - 1)
         break
      end
   end

   -- Handle empty document or trailing newline
   if #Doc.lineIndex is 0 or (len > 0 and content:sub(len - 1, len) is '\n') then
      Doc.lineIndex:push(len, len)  -- start, stop
   end
end

global function getTotalLines(Doc:table):num
   rebuildLineIndex(Doc)
   return #Doc.lineIndex / 2
end

global function getLine(Doc:table, LineNo:num):str
   rebuildLineIndex(Doc)
   total_lines = #Doc.lineIndex / 2
   if LineNo < 0 or LineNo >= total_lines then return '' end

   idx = LineNo * 2
   return Doc.content:sub(Doc.lineIndex[idx], Doc.lineIndex[idx + 1])
end

-- Mark line N and subsequent lines for recomputation.  Currently we are very lazy about this...

global function markLineIndex(Doc:table, LineNo:num)
   Doc.lineIndex = nil
end

----------------------------------------------------------------------------------------------------------------------
-- LSP Symbol Kinds (subset used for Fluid)

global SYMBOL_KIND = {
   FILE = 1,
   MODULE = 2,
   NAMESPACE = 3,
   PACKAGE = 4,
   CLASS = 5,
   METHOD = 6,
   PROPERTY = 7,
   FIELD = 8,
   CONSTRUCTOR = 9,
   ENUM = 10,
   INTERFACE = 11,
   FUNCTION = 12,
   VARIABLE = 13,
   CONSTANT = 14,
   STRING = 15,
   NUMBER = 16,
   BOOLEAN = 17,
   ARRAY = 18,
   OBJECT = 19,
   KEY = 20,
   NULL = 21,
   ENUM_MEMBER = 22,
   STRUCT = 23,
   EVENT = 24,
   OPERATOR = 25,
   TYPE_PARAMETER = 26
}

-- LSP Folding Range Kinds

global FOLDING_KIND = {
   COMMENT = 'comment',
   IMPORTS = 'imports',
   REGION = 'region'
}

-- LSP Error Codes

global LSP_ERROR = {
   PARSE_ERROR      = -32700,
   INVALID_REQUEST  = -32600,
   METHOD_NOT_FOUND = -32601,
   INVALID_PARAMS   = -32602,
   INTERNAL_ERROR   = -32603
}

----------------------------------------------------------------------------------------------------------------------
-- Semantic Token Types and Modifiers (LSP standard)

-- Token types - order matters, index is used in the protocol

global TOKEN_TYPES = array<string> {
   'keyword',        -- 0: if, while, for, etc.
   'operator',       -- 1: and, or, not, is
   'variable',       -- 2: regular variables
   'function',       -- 3: function names
   'string',         -- 4: string literals
   'number',         -- 5: numeric literals
   'comment',        -- 6: comments
   'type',           -- 7: type names
   'parameter',      -- 8: function parameters
   'property',       -- 9: object properties
   'namespace',      -- 10: module/namespace
   'class',          -- 11: class names
   'macro'           -- 12: constants like ERR_Okay
}

-- Token modifiers (bitfield)
global TOKEN_MODIFIERS = array<string> {
   'declaration',    -- 0: variable/function declaration
   'definition',     -- 1: definition site
   'readonly',       -- 2: constants
   'static',         -- 3: static members
   'deprecated',     -- 4: deprecated items
   'modification',   -- 5: modified variable
   'documentation',  -- 6: documentation strings
   'defaultLibrary'  -- 7: built-in functions
}

-- Fluid reserved keywords
global FLUID_KEYWORDS = {
   -- Control flow
   ['if'] = true, ['then'] = true, ['else'] = true, ['elseif'] = true,
   ['for'] = true, ['in'] = true, ['while'] = true, ['do'] = true,
   ['repeat'] = true, ['until'] = true, ['break'] = true, ['continue'] = true,
   ['return'] = true, ['end'] = true, ['try'] = true, ['except'] = true, ['success'] = true,

   -- Pattern matching
   ['choose'] = true, ['from'] = true, ['when'] = true,

   -- Declarations
   ['function'] = true, ['local'] = true, ['global'] = true, ['thunk'] = true, ['import'] = true,

   -- Special
   ['defer'] = true, ['catch'] = true, ['raise'] = true, ['check'] = true
}

-- Logical/comparison operators (highlighted as operators)
global FLUID_OPERATORS = {
   ['and'] = true, ['or'] = true, ['not'] = true, ['is'] = true
}

-- Built-in constants
global FLUID_CONSTANTS = {
   ['true'] = true, ['false'] = true, ['nil'] = true
}

-- Built-in functions (default library)
global FLUID_BUILTINS = {
   -- Output
   ['print'] = true, ['msg'] = true, ['error'] = true, ['assert'] = true,

   -- Type conversion/introspection
   ['type'] = true, ['tonumber'] = true, ['tostring'] = true,

   -- Iteration
   ['pairs'] = true, ['ipairs'] = true, ['next'] = true, ['values'] = true,

   -- Result handling
   ['unpack'] = true,

   -- Protected calls
   ['pcall'] = true, ['xpcall'] = true,

   -- Metatable access
   ['setmetatable'] = true, ['getmetatable'] = true,
   ['rawget'] = true, ['rawset'] = true, ['rawequal'] = true,

   -- Script/module loading
   ['collectgarbage'] = true, ['require'] = true, ['include'] = true,
   ['loadFile'] = true, ['load'] = true, ['exec'] = true,

   -- Script parameters
   ['arg'] = true,

   -- Deferred expressions
   ['resolve'] = true,

   -- Range constructor
   ['range'] = true,

   -- Events
   ['subscribeEvent'] = true, ['unsubscribeEvent'] = true,

   -- Structures
   ['MAKESTRUCT'] = true
}

-- Parasol modules/namespaces
global FLUID_MODULES = {
   -- Core interfaces
   ['obj'] = true, ['struct'] = true, ['array'] = true, ['regex'] = true,
   ['mod'] = true, ['thread'] = true, ['processing'] = true,

   -- Parasol API modules (loaded via mod.load())
   ['mSys'] = true, ['mVec'] = true, ['mGfx'] = true,
   ['mAudio'] = true, ['mFont'] = true, ['mNet'] = true, ['mXML'] = true,

   -- Standard libraries
   ['string'] = true, ['table'] = true, ['math'] = true, ['bit'] = true,
   ['io'] = true, ['debug'] = true,

   -- Fluid script libraries
   ['json'] = true, ['gui'] = true, ['file'] = true
}

----------------------------------------------------------------------------------------------------------------------
-- Utility Functions

global function timestamp():str
   glTime.acQuery()
   return string.format('%04d-%02d-%02d %02d:%02d:%02d',
      glTime.year, glTime.month, glTime.day, glTime.hour, glTime.minute, glTime.second)
end

global function logMessage(Self:table, Message:str)
   Self?.logMessage('[' .. timestamp() .. '] ' .. Message)
end

global function logVerbose(Self:table, Message:str)
   if Self.verbose then
      Self?.logMessage('[' .. timestamp() .. '] [DEBUG] ' .. Message)
   end
end

global function logWarning(Self:table, Message:str)
   Self?.logMessage('[' .. timestamp() .. '] [WARN] ' .. Message)
end

   import './lsp_protocol'

----------------------------------------------------------------------------------------------------------------------
-- Compute diagnostics for a document using debug.validate()

-- Helper to check if character is alphanumeric or underscore

function isIdentChar(C)
   return (C >= 'a' and C <= 'z') or (C >= 'A' and C <= 'Z') or (C >= '0' and C <= '9') or C is '_'
end

-- Compute start and end columns for an error range based on context
-- Returns: start_col, end_col

global function computeErrorRange(Doc:table, Line:num, Column:num)
   -- Find the target line
   if Line >= getTotalLines(Doc) then return Column, Column + 1 end

   line_text = getLine(Doc, Line)
   if Column >= #line_text then return Column, Column + 1 end

   c = line_text:sub(Column, Column + 1)

   -- If starting on an identifier/number character, extend both directions
   if isIdentChar(c) or (c >= '0' and c <= '9') then
      -- Extend backwards to find start of token

      start_col = Column
      while start_col > 0 do
         prev_c = line_text:sub(start_col - 1, start_col)
         if isIdentChar(prev_c) or (prev_c >= '0' and prev_c <= '9') then
            start_col -= 1
         else
            break
         end
      end

      -- Extend forwards to find end of token

      end_col = Column + 1
      while end_col < #line_text do
         next_c = line_text:sub(end_col, end_col + 1)
         if isIdentChar(next_c) or (next_c >= '0' and next_c <= '9') then
            end_col++
         else
            break
         end
      end
      return start_col, end_col
   end

   -- For operators and punctuation, try to capture multi-character operators

   if c is '=' or c is '!' or c is '<' or c is '>' or c is '~' or c is ':' or c is '.' then
      next_c = (Column + 1 < #line_text) and line_text:sub(Column + 1, Column + 2) or ''
      if next_c is '=' or next_c is '>' then
         return Column, Column + 2
      end
   end

   -- For string delimiters, try to find matching end

   if c is '"' or c is "'" then
      end_col = Column + 1
      while end_col < #line_text do
         sc = line_text:sub(end_col, end_col + 1)
         if sc is c then
            return Column, end_col + 1
         elseif sc is '\\' then
            end_col += 2  -- Skip escaped character
         else
            end_col++
         end
      end
      return Column, #line_text  -- Unterminated string - highlight to end of line
   end

   -- Default: single character
   return Column, Column + 1
end

global function computeDiagnostics(Doc:table)
   result = debug.validate(Doc.content)

   lsp_diags = array<table>

   if result.diagnostics then
      rebuildLineIndex(Doc)

      for diag in values(result.diagnostics) do
         -- Map severity: C++ (0=Info,1=Warn,2=Error) -> LSP (1=Error,2=Warn,3=Info)
         lsp_severity = 3  -- Default to Info
         if diag.severity is 2 then lsp_severity = 1      -- Error
         elseif diag.severity is 1 then lsp_severity = 2  -- Warning
         end

         -- Compute a meaningful range if not provided by the parser
         start_col = diag.column
         end_col = diag.endColumn
         if end_col <= start_col+1 then
            start_col, end_col = computeErrorRange(Doc, diag.line, diag.column)
         end

         lsp_diags:push({
            range = {
               start = { line = diag.line, character = start_col },
               ['end'] = { line = diag.line, character = end_col }
            },
            severity = lsp_severity,
            source = 'fluid',
            code = diag.code,
            message = diag.message
         })
      end
   end

   -- Add tips as LSP Hint diagnostics (severity 4)
   if result.tips then
      for tip in values(result.tips) do
         start_col = tip.column
         end_col = tip.endColumn
         if end_col <= start_col+1 then
            start_col, end_col = computeErrorRange(Doc, tip.line, tip.column)
         end

         lsp_diags:push({
            range = {
               start = { line = tip.line, character = start_col },
               ['end'] = { line = tip.line, character = end_col }
            },
            severity = 4,  -- LSP Hint
            source = 'fluid',
            code = tip.category,
            message = tip.message
         })
      end
   end

   return { uri = Doc.uri, version = Doc.version, diagnostics = lsp_diags }
end

   import './lsp_parsing'
   import './lsp_handlers'
   import './lsp_cache'
   import './lsp_hover'

----------------------------------------------------------------------------------------------------------------------
-- Public API

-- Initialize the documentation system for hover support
-- DocPath: Path to the XML document folder (e.g., 'sdk:docs/xml/')
-- Returns true if successful

global function lspInitDocs(DocPath)
   DocPath ?? return false

   if not DocPath:match('[/\\]$') then -- Ensure path ends with separator
      DocPath ..= '/'
   end

   -- Load static definitions (builtins, keywords)
   defsPath = glSelf.workingPath .. 'lsp_defs.fluid'
   local result
   try
      result = loadFile(defsPath)
   except ex
      print('Failed to load static definitions from ' .. defsPath)
   success
      glDefs = result
      print('Loaded static definitions')
   end

   -- Try to load cached documentation
   glDocCache = loadDocCache(DocPath)

   if glDocCache then
      print('Loaded documentation cache')
   else
      -- Build cache if not found or invalid
      glDocCache = buildDocCache(DocPath)
      if glDocCache then
         saveDocCache(CACHE_PATH, glDocCache)
         print('Documentation cache built and saved')
      else
         print('Failed to build documentation cache')
      end
   end

   return glDocCache != nil
end

global function lspStart(Options)
   Options ?= {}

   self.port       = Options.port or 5007
   self.verbose    = Options.verbose or false
   self.logMessage = Options.logMessage or function(msg) print(msg) end
   self.requestLog = Options.requestLog  -- Optional request/response logging callback
   self._socket    = nil
   self._handlers  = {}

   registerCoreHandlers(self)

   logMessage(self, 'Starting Fluid LSP Server on port ' .. self.port)

   -- Create TCP server socket
   self._socket = obj.new('netsocket', {
      port = self.port,
      flags = 'SERVER|MULTI_CONNECT',
      feedback = function(Server, ClientSocket, State)
         if State is NTC_CONNECTED then
            logMessage(self, 'LSP client connected')
         elseif State is NTC_DISCONNECTED then
            logMessage(self, 'LSP client disconnected')
         end
      end,
      incoming = function(Server, ClientSocket)
         processIncoming(self, ClientSocket)
      end
   })

   logMessage(self, 'Fluid LSP Server listening on port ' .. self.port)
   if self.verbose then
      logMessage(self, 'Verbose logging enabled')
   end

   -- Public methods

   self.stop = function()
      if self._socket then
         logMessage(self, 'Stopping LSP server')
         self._socket = nil
         processing.collect()
      end
   end

   self.registerHandler = function(Method, Handler)
      assert(type(Handler) is 'function', 'Handler must be a function')
      self._handlers[Method] = Handler
      logVerbose(self, 'Registered handler for: ' .. Method)
   end

   return self
end
